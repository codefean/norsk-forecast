function fC(e, t) {
    for (var i = 0; i < t.length; i++) {
        const s = t[i];
        if (typeof s != "string" && !Array.isArray(s)) {
            for (const u in s)
                if (u !== "default" && !(u in e)) {
                    const d = Object.getOwnPropertyDescriptor(s, u);
                    d && Object.defineProperty(e, u, d.get ? d : {
                        enumerable: !0,
                        get: () => s[u]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload"))
        return;
    for (const u of document.querySelectorAll('link[rel="modulepreload"]'))
        s(u);
    new MutationObserver(u => {
        for (const d of u)
            if (d.type === "childList")
                for (const f of d.addedNodes)
                    f.tagName === "LINK" && f.rel === "modulepreload" && s(f)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function i(u) {
        const d = {};
        return u.integrity && (d.integrity = u.integrity),
        u.referrerPolicy && (d.referrerPolicy = u.referrerPolicy),
        u.crossOrigin === "use-credentials" ? d.credentials = "include" : u.crossOrigin === "anonymous" ? d.credentials = "omit" : d.credentials = "same-origin",
        d
    }
    function s(u) {
        if (u.ep)
            return;
        u.ep = !0;
        const d = i(u);
        fetch(u.href, d)
    }
}
)();
function Ni(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
function ou(e) {
    if (Object.prototype.hasOwnProperty.call(e, "__esModule"))
        return e;
    var t = e.default;
    if (typeof t == "function") {
        var i = function s() {
            var u = !1;
            try {
                u = this instanceof s
            } catch {}
            return u ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
        };
        i.prototype = t.prototype
    } else
        i = {};
    return Object.defineProperty(i, "__esModule", {
        value: !0
    }),
    Object.keys(e).forEach(function(s) {
        var u = Object.getOwnPropertyDescriptor(e, s);
        Object.defineProperty(i, s, u.get ? u : {
            enumerable: !0,
            get: function() {
                return e[s]
            }
        })
    }),
    i
}
var o0 = {
    exports: {}
}
  , jm = {}
  , s0 = {
    exports: {}
}
  , un = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var d1;
function sk() {
    if (d1)
        return un;
    d1 = 1;
    var e = Symbol.for("react.element")
      , t = Symbol.for("react.portal")
      , i = Symbol.for("react.fragment")
      , s = Symbol.for("react.strict_mode")
      , u = Symbol.for("react.profiler")
      , d = Symbol.for("react.provider")
      , f = Symbol.for("react.context")
      , o = Symbol.for("react.forward_ref")
      , w = Symbol.for("react.suspense")
      , T = Symbol.for("react.memo")
      , k = Symbol.for("react.lazy")
      , L = Symbol.iterator;
    function z(We) {
        return We === null || typeof We != "object" ? null : (We = L && We[L] || We["@@iterator"],
        typeof We == "function" ? We : null)
    }
    var D = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
      , N = Object.assign
      , U = {};
    function V(We, st, Nt) {
        this.props = We,
        this.context = st,
        this.refs = U,
        this.updater = Nt || D
    }
    V.prototype.isReactComponent = {},
    V.prototype.setState = function(We, st) {
        if (typeof We != "object" && typeof We != "function" && We != null)
            throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, We, st, "setState")
    }
    ,
    V.prototype.forceUpdate = function(We) {
        this.updater.enqueueForceUpdate(this, We, "forceUpdate")
    }
    ;
    function re() {}
    re.prototype = V.prototype;
    function ie(We, st, Nt) {
        this.props = We,
        this.context = st,
        this.refs = U,
        this.updater = Nt || D
    }
    var ue = ie.prototype = new re;
    ue.constructor = ie,
    N(ue, V.prototype),
    ue.isPureReactComponent = !0;
    var ce = Array.isArray
      , X = Object.prototype.hasOwnProperty
      , me = {
        current: null
    }
      , K = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function be(We, st, Nt) {
        var zt, Qt = {}, Wt = null, tr = null;
        if (st != null)
            for (zt in st.ref !== void 0 && (tr = st.ref),
            st.key !== void 0 && (Wt = "" + st.key),
            st)
                X.call(st, zt) && !K.hasOwnProperty(zt) && (Qt[zt] = st[zt]);
        var cr = arguments.length - 2;
        if (cr === 1)
            Qt.children = Nt;
        else if (1 < cr) {
            for (var Yt = Array(cr), Gr = 0; Gr < cr; Gr++)
                Yt[Gr] = arguments[Gr + 2];
            Qt.children = Yt
        }
        if (We && We.defaultProps)
            for (zt in cr = We.defaultProps,
            cr)
                Qt[zt] === void 0 && (Qt[zt] = cr[zt]);
        return {
            $$typeof: e,
            type: We,
            key: Wt,
            ref: tr,
            props: Qt,
            _owner: me.current
        }
    }
    function Ee(We, st) {
        return {
            $$typeof: e,
            type: We.type,
            key: st,
            ref: We.ref,
            props: We.props,
            _owner: We._owner
        }
    }
    function Ce(We) {
        return typeof We == "object" && We !== null && We.$$typeof === e
    }
    function He(We) {
        var st = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + We.replace(/[=:]/g, function(Nt) {
            return st[Nt]
        })
    }
    var ct = /\/+/g;
    function nt(We, st) {
        return typeof We == "object" && We !== null && We.key != null ? He("" + We.key) : st.toString(36)
    }
    function J(We, st, Nt, zt, Qt) {
        var Wt = typeof We;
        (Wt === "undefined" || Wt === "boolean") && (We = null);
        var tr = !1;
        if (We === null)
            tr = !0;
        else
            switch (Wt) {
            case "string":
            case "number":
                tr = !0;
                break;
            case "object":
                switch (We.$$typeof) {
                case e:
                case t:
                    tr = !0
                }
            }
        if (tr)
            return tr = We,
            Qt = Qt(tr),
            We = zt === "" ? "." + nt(tr, 0) : zt,
            ce(Qt) ? (Nt = "",
            We != null && (Nt = We.replace(ct, "$&/") + "/"),
            J(Qt, st, Nt, "", function(Gr) {
                return Gr
            })) : Qt != null && (Ce(Qt) && (Qt = Ee(Qt, Nt + (!Qt.key || tr && tr.key === Qt.key ? "" : ("" + Qt.key).replace(ct, "$&/") + "/") + We)),
            st.push(Qt)),
            1;
        if (tr = 0,
        zt = zt === "" ? "." : zt + ":",
        ce(We))
            for (var cr = 0; cr < We.length; cr++) {
                Wt = We[cr];
                var Yt = zt + nt(Wt, cr);
                tr += J(Wt, st, Nt, Yt, Qt)
            }
        else if (Yt = z(We),
        typeof Yt == "function")
            for (We = Yt.call(We),
            cr = 0; !(Wt = We.next()).done; )
                Wt = Wt.value,
                Yt = zt + nt(Wt, cr++),
                tr += J(Wt, st, Nt, Yt, Qt);
        else if (Wt === "object")
            throw st = String(We),
            Error("Objects are not valid as a React child (found: " + (st === "[object Object]" ? "object with keys {" + Object.keys(We).join(", ") + "}" : st) + "). If you meant to render a collection of children, use an array instead.");
        return tr
    }
    function he(We, st, Nt) {
        if (We == null)
            return We;
        var zt = []
          , Qt = 0;
        return J(We, zt, "", "", function(Wt) {
            return st.call(Nt, Wt, Qt++)
        }),
        zt
    }
    function ve(We) {
        if (We._status === -1) {
            var st = We._result;
            st = st(),
            st.then(function(Nt) {
                (We._status === 0 || We._status === -1) && (We._status = 1,
                We._result = Nt)
            }, function(Nt) {
                (We._status === 0 || We._status === -1) && (We._status = 2,
                We._result = Nt)
            }),
            We._status === -1 && (We._status = 0,
            We._result = st)
        }
        if (We._status === 1)
            return We._result.default;
        throw We._result
    }
    var Ne = {
        current: null
    }
      , je = {
        transition: null
    }
      , lt = {
        ReactCurrentDispatcher: Ne,
        ReactCurrentBatchConfig: je,
        ReactCurrentOwner: me
    };
    function Pt() {
        throw Error("act(...) is not supported in production builds of React.")
    }
    return un.Children = {
        map: he,
        forEach: function(We, st, Nt) {
            he(We, function() {
                st.apply(this, arguments)
            }, Nt)
        },
        count: function(We) {
            var st = 0;
            return he(We, function() {
                st++
            }),
            st
        },
        toArray: function(We) {
            return he(We, function(st) {
                return st
            }) || []
        },
        only: function(We) {
            if (!Ce(We))
                throw Error("React.Children.only expected to receive a single React element child.");
            return We
        }
    },
    un.Component = V,
    un.Fragment = i,
    un.Profiler = u,
    un.PureComponent = ie,
    un.StrictMode = s,
    un.Suspense = w,
    un.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = lt,
    un.act = Pt,
    un.cloneElement = function(We, st, Nt) {
        if (We == null)
            throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + We + ".");
        var zt = N({}, We.props)
          , Qt = We.key
          , Wt = We.ref
          , tr = We._owner;
        if (st != null) {
            if (st.ref !== void 0 && (Wt = st.ref,
            tr = me.current),
            st.key !== void 0 && (Qt = "" + st.key),
            We.type && We.type.defaultProps)
                var cr = We.type.defaultProps;
            for (Yt in st)
                X.call(st, Yt) && !K.hasOwnProperty(Yt) && (zt[Yt] = st[Yt] === void 0 && cr !== void 0 ? cr[Yt] : st[Yt])
        }
        var Yt = arguments.length - 2;
        if (Yt === 1)
            zt.children = Nt;
        else if (1 < Yt) {
            cr = Array(Yt);
            for (var Gr = 0; Gr < Yt; Gr++)
                cr[Gr] = arguments[Gr + 2];
            zt.children = cr
        }
        return {
            $$typeof: e,
            type: We.type,
            key: Qt,
            ref: Wt,
            props: zt,
            _owner: tr
        }
    }
    ,
    un.createContext = function(We) {
        return We = {
            $$typeof: f,
            _currentValue: We,
            _currentValue2: We,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
        },
        We.Provider = {
            $$typeof: d,
            _context: We
        },
        We.Consumer = We
    }
    ,
    un.createElement = be,
    un.createFactory = function(We) {
        var st = be.bind(null, We);
        return st.type = We,
        st
    }
    ,
    un.createRef = function() {
        return {
            current: null
        }
    }
    ,
    un.forwardRef = function(We) {
        return {
            $$typeof: o,
            render: We
        }
    }
    ,
    un.isValidElement = Ce,
    un.lazy = function(We) {
        return {
            $$typeof: k,
            _payload: {
                _status: -1,
                _result: We
            },
            _init: ve
        }
    }
    ,
    un.memo = function(We, st) {
        return {
            $$typeof: T,
            type: We,
            compare: st === void 0 ? null : st
        }
    }
    ,
    un.startTransition = function(We) {
        var st = je.transition;
        je.transition = {};
        try {
            We()
        } finally {
            je.transition = st
        }
    }
    ,
    un.unstable_act = Pt,
    un.useCallback = function(We, st) {
        return Ne.current.useCallback(We, st)
    }
    ,
    un.useContext = function(We) {
        return Ne.current.useContext(We)
    }
    ,
    un.useDebugValue = function() {}
    ,
    un.useDeferredValue = function(We) {
        return Ne.current.useDeferredValue(We)
    }
    ,
    un.useEffect = function(We, st) {
        return Ne.current.useEffect(We, st)
    }
    ,
    un.useId = function() {
        return Ne.current.useId()
    }
    ,
    un.useImperativeHandle = function(We, st, Nt) {
        return Ne.current.useImperativeHandle(We, st, Nt)
    }
    ,
    un.useInsertionEffect = function(We, st) {
        return Ne.current.useInsertionEffect(We, st)
    }
    ,
    un.useLayoutEffect = function(We, st) {
        return Ne.current.useLayoutEffect(We, st)
    }
    ,
    un.useMemo = function(We, st) {
        return Ne.current.useMemo(We, st)
    }
    ,
    un.useReducer = function(We, st, Nt) {
        return Ne.current.useReducer(We, st, Nt)
    }
    ,
    un.useRef = function(We) {
        return Ne.current.useRef(We)
    }
    ,
    un.useState = function(We) {
        return Ne.current.useState(We)
    }
    ,
    un.useSyncExternalStore = function(We, st, Nt) {
        return Ne.current.useSyncExternalStore(We, st, Nt)
    }
    ,
    un.useTransition = function() {
        return Ne.current.useTransition()
    }
    ,
    un.version = "18.3.1",
    un
}
var f1;
function iy() {
    return f1 || (f1 = 1,
    s0.exports = sk()),
    s0.exports
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var p1;
function ak() {
    if (p1)
        return jm;
    p1 = 1;
    var e = iy()
      , t = Symbol.for("react.element")
      , i = Symbol.for("react.fragment")
      , s = Object.prototype.hasOwnProperty
      , u = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
      , d = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function f(o, w, T) {
        var k, L = {}, z = null, D = null;
        T !== void 0 && (z = "" + T),
        w.key !== void 0 && (z = "" + w.key),
        w.ref !== void 0 && (D = w.ref);
        for (k in w)
            s.call(w, k) && !d.hasOwnProperty(k) && (L[k] = w[k]);
        if (o && o.defaultProps)
            for (k in w = o.defaultProps,
            w)
                L[k] === void 0 && (L[k] = w[k]);
        return {
            $$typeof: t,
            type: o,
            key: z,
            ref: D,
            props: L,
            _owner: u.current
        }
    }
    return jm.Fragment = i,
    jm.jsx = f,
    jm.jsxs = f,
    jm
}
var m1;
function Uo() {
    return m1 || (m1 = 1,
    o0.exports = ak()),
    o0.exports
}
var G = Uo()
  , R_ = {
    exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.6.1/LICENSE.txt
 */
var lk = R_.exports, g1;
function ck() {
    return g1 || (g1 = 1,
    function(e, t) {
        (function(i, s) {
            e.exports = s()
        }
        )(lk, function() {
            var i = {}
              , s = {};
            function u(f, o, w) {
                if (s[f] = w,
                f === "index") {
                    var T = "var sharedModule = {}; (" + s.shared + ")(sharedModule); (" + s.worker + ")(sharedModule);"
                      , k = {};
                    return s.shared(k),
                    s.index(i, k),
                    typeof window < "u" && i.setWorkerUrl(window.URL.createObjectURL(new Blob([T],{
                        type: "text/javascript"
                    }))),
                    i
                }
            }
            u("shared", ["exports"], function(f) {
                function o(c, n, l, p) {
                    return new (l || (l = Promise))(function(_, b) {
                        function C(O) {
                            try {
                                R(p.next(O))
                            } catch (j) {
                                b(j)
                            }
                        }
                        function M(O) {
                            try {
                                R(p.throw(O))
                            } catch (j) {
                                b(j)
                            }
                        }
                        function R(O) {
                            var j;
                            O.done ? _(O.value) : (j = O.value,
                            j instanceof l ? j : new l(function(q) {
                                q(j)
                            }
                            )).then(C, M)
                        }
                        R((p = p.apply(c, n || [])).next())
                    }
                    )
                }
                function w(c) {
                    return c && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c
                }
                var T, k;
                function L() {
                    if (k)
                        return T;
                    function c(n, l) {
                        this.x = n,
                        this.y = l
                    }
                    return k = 1,
                    T = c,
                    c.prototype = {
                        clone: function() {
                            return new c(this.x,this.y)
                        },
                        add: function(n) {
                            return this.clone()._add(n)
                        },
                        sub: function(n) {
                            return this.clone()._sub(n)
                        },
                        multByPoint: function(n) {
                            return this.clone()._multByPoint(n)
                        },
                        divByPoint: function(n) {
                            return this.clone()._divByPoint(n)
                        },
                        mult: function(n) {
                            return this.clone()._mult(n)
                        },
                        div: function(n) {
                            return this.clone()._div(n)
                        },
                        rotate: function(n) {
                            return this.clone()._rotate(n)
                        },
                        rotateAround: function(n, l) {
                            return this.clone()._rotateAround(n, l)
                        },
                        matMult: function(n) {
                            return this.clone()._matMult(n)
                        },
                        unit: function() {
                            return this.clone()._unit()
                        },
                        perp: function() {
                            return this.clone()._perp()
                        },
                        round: function() {
                            return this.clone()._round()
                        },
                        mag: function() {
                            return Math.sqrt(this.x * this.x + this.y * this.y)
                        },
                        equals: function(n) {
                            return this.x === n.x && this.y === n.y
                        },
                        dist: function(n) {
                            return Math.sqrt(this.distSqr(n))
                        },
                        distSqr: function(n) {
                            var l = n.x - this.x
                              , p = n.y - this.y;
                            return l * l + p * p
                        },
                        angle: function() {
                            return Math.atan2(this.y, this.x)
                        },
                        angleTo: function(n) {
                            return Math.atan2(this.y - n.y, this.x - n.x)
                        },
                        angleWith: function(n) {
                            return this.angleWithSep(n.x, n.y)
                        },
                        angleWithSep: function(n, l) {
                            return Math.atan2(this.x * l - this.y * n, this.x * n + this.y * l)
                        },
                        _matMult: function(n) {
                            var l = n[2] * this.x + n[3] * this.y;
                            return this.x = n[0] * this.x + n[1] * this.y,
                            this.y = l,
                            this
                        },
                        _add: function(n) {
                            return this.x += n.x,
                            this.y += n.y,
                            this
                        },
                        _sub: function(n) {
                            return this.x -= n.x,
                            this.y -= n.y,
                            this
                        },
                        _mult: function(n) {
                            return this.x *= n,
                            this.y *= n,
                            this
                        },
                        _div: function(n) {
                            return this.x /= n,
                            this.y /= n,
                            this
                        },
                        _multByPoint: function(n) {
                            return this.x *= n.x,
                            this.y *= n.y,
                            this
                        },
                        _divByPoint: function(n) {
                            return this.x /= n.x,
                            this.y /= n.y,
                            this
                        },
                        _unit: function() {
                            return this._div(this.mag()),
                            this
                        },
                        _perp: function() {
                            var n = this.y;
                            return this.y = this.x,
                            this.x = -n,
                            this
                        },
                        _rotate: function(n) {
                            var l = Math.cos(n)
                              , p = Math.sin(n)
                              , _ = p * this.x + l * this.y;
                            return this.x = l * this.x - p * this.y,
                            this.y = _,
                            this
                        },
                        _rotateAround: function(n, l) {
                            var p = Math.cos(n)
                              , _ = Math.sin(n)
                              , b = l.y + _ * (this.x - l.x) + p * (this.y - l.y);
                            return this.x = l.x + p * (this.x - l.x) - _ * (this.y - l.y),
                            this.y = b,
                            this
                        },
                        _round: function() {
                            return this.x = Math.round(this.x),
                            this.y = Math.round(this.y),
                            this
                        }
                    },
                    c.convert = function(n) {
                        return n instanceof c ? n : Array.isArray(n) ? new c(n[0],n[1]) : n
                    }
                    ,
                    T
                }
                typeof SuppressedError == "function" && SuppressedError;
                var z, D, N = w(L()), U = function() {
                    if (D)
                        return z;
                    function c(n, l, p, _) {
                        this.cx = 3 * n,
                        this.bx = 3 * (p - n) - this.cx,
                        this.ax = 1 - this.cx - this.bx,
                        this.cy = 3 * l,
                        this.by = 3 * (_ - l) - this.cy,
                        this.ay = 1 - this.cy - this.by,
                        this.p1x = n,
                        this.p1y = l,
                        this.p2x = p,
                        this.p2y = _
                    }
                    return D = 1,
                    z = c,
                    c.prototype = {
                        sampleCurveX: function(n) {
                            return ((this.ax * n + this.bx) * n + this.cx) * n
                        },
                        sampleCurveY: function(n) {
                            return ((this.ay * n + this.by) * n + this.cy) * n
                        },
                        sampleCurveDerivativeX: function(n) {
                            return (3 * this.ax * n + 2 * this.bx) * n + this.cx
                        },
                        solveCurveX: function(n, l) {
                            if (l === void 0 && (l = 1e-6),
                            n < 0)
                                return 0;
                            if (n > 1)
                                return 1;
                            for (var p = n, _ = 0; _ < 8; _++) {
                                var b = this.sampleCurveX(p) - n;
                                if (Math.abs(b) < l)
                                    return p;
                                var C = this.sampleCurveDerivativeX(p);
                                if (Math.abs(C) < 1e-6)
                                    break;
                                p -= b / C
                            }
                            var M = 0
                              , R = 1;
                            for (p = n,
                            _ = 0; _ < 20 && (b = this.sampleCurveX(p),
                            !(Math.abs(b - n) < l)); _++)
                                n > b ? M = p : R = p,
                                p = .5 * (R - M) + M;
                            return p
                        },
                        solve: function(n, l) {
                            return this.sampleCurveY(this.solveCurveX(n, l))
                        }
                    },
                    z
                }(), V = w(U);
                let re, ie;
                function ue() {
                    return re == null && (re = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") && typeof createImageBitmap == "function"),
                    re
                }
                function ce() {
                    if (ie == null && (ie = !1,
                    ue())) {
                        const n = new OffscreenCanvas(5,5).getContext("2d", {
                            willReadFrequently: !0
                        });
                        if (n) {
                            for (let p = 0; p < 25; p++) {
                                const _ = 4 * p;
                                n.fillStyle = `rgb(${_},${_ + 1},${_ + 2})`,
                                n.fillRect(p % 5, Math.floor(p / 5), 1, 1)
                            }
                            const l = n.getImageData(0, 0, 5, 5).data;
                            for (let p = 0; p < 100; p++)
                                if (p % 4 != 3 && l[p] !== p) {
                                    ie = !0;
                                    break
                                }
                        }
                    }
                    return ie || !1
                }
                var X = 1e-6
                  , me = typeof Float32Array < "u" ? Float32Array : Array;
                function K() {
                    var c = new me(9);
                    return me != Float32Array && (c[1] = 0,
                    c[2] = 0,
                    c[3] = 0,
                    c[5] = 0,
                    c[6] = 0,
                    c[7] = 0),
                    c[0] = 1,
                    c[4] = 1,
                    c[8] = 1,
                    c
                }
                function be(c) {
                    return c[0] = 1,
                    c[1] = 0,
                    c[2] = 0,
                    c[3] = 0,
                    c[4] = 0,
                    c[5] = 1,
                    c[6] = 0,
                    c[7] = 0,
                    c[8] = 0,
                    c[9] = 0,
                    c[10] = 1,
                    c[11] = 0,
                    c[12] = 0,
                    c[13] = 0,
                    c[14] = 0,
                    c[15] = 1,
                    c
                }
                function Ee() {
                    var c = new me(3);
                    return me != Float32Array && (c[0] = 0,
                    c[1] = 0,
                    c[2] = 0),
                    c
                }
                function Ce(c) {
                    return Math.hypot(c[0], c[1], c[2])
                }
                function He(c, n, l) {
                    var p = new me(3);
                    return p[0] = c,
                    p[1] = n,
                    p[2] = l,
                    p
                }
                function ct(c, n, l) {
                    return c[0] = n[0] + l[0],
                    c[1] = n[1] + l[1],
                    c[2] = n[2] + l[2],
                    c
                }
                function nt(c, n, l) {
                    return c[0] = n[0] * l,
                    c[1] = n[1] * l,
                    c[2] = n[2] * l,
                    c
                }
                function J(c, n, l) {
                    var p = n[0]
                      , _ = n[1]
                      , b = n[2]
                      , C = l[0]
                      , M = l[1]
                      , R = l[2];
                    return c[0] = _ * R - b * M,
                    c[1] = b * C - p * R,
                    c[2] = p * M - _ * C,
                    c
                }
                Math.hypot || (Math.hypot = function() {
                    for (var c = 0, n = arguments.length; n--; )
                        c += arguments[n] * arguments[n];
                    return Math.sqrt(c)
                }
                );
                var he, ve = Ce;
                function Ne(c, n, l) {
                    var p = n[0]
                      , _ = n[1]
                      , b = n[2]
                      , C = n[3];
                    return c[0] = l[0] * p + l[4] * _ + l[8] * b + l[12] * C,
                    c[1] = l[1] * p + l[5] * _ + l[9] * b + l[13] * C,
                    c[2] = l[2] * p + l[6] * _ + l[10] * b + l[14] * C,
                    c[3] = l[3] * p + l[7] * _ + l[11] * b + l[15] * C,
                    c
                }
                function je() {
                    var c = new me(4);
                    return me != Float32Array && (c[0] = 0,
                    c[1] = 0,
                    c[2] = 0),
                    c[3] = 1,
                    c
                }
                function lt(c, n, l, p) {
                    var _ = .5 * Math.PI / 180;
                    n *= _,
                    l *= _,
                    p *= _;
                    var b = Math.sin(n)
                      , C = Math.cos(n)
                      , M = Math.sin(l)
                      , R = Math.cos(l)
                      , O = Math.sin(p)
                      , j = Math.cos(p);
                    return c[0] = b * R * j - C * M * O,
                    c[1] = C * M * j + b * R * O,
                    c[2] = C * R * O - b * M * j,
                    c[3] = C * R * j + b * M * O,
                    c
                }
                function Pt() {
                    var c = new me(2);
                    return me != Float32Array && (c[0] = 0,
                    c[1] = 0),
                    c
                }
                function We(c, n) {
                    var l = new me(2);
                    return l[0] = c,
                    l[1] = n,
                    l
                }
                Ee(),
                he = new me(4),
                me != Float32Array && (he[0] = 0,
                he[1] = 0,
                he[2] = 0,
                he[3] = 0),
                Ee(),
                He(1, 0, 0),
                He(0, 1, 0),
                je(),
                je(),
                K(),
                Pt();
                const st = 8192;
                function Nt(c, n, l) {
                    return n * (st / (c.tileSize * Math.pow(2, l - c.tileID.overscaledZ)))
                }
                function zt(c, n) {
                    return (c % n + n) % n
                }
                function Qt(c, n, l) {
                    return c * (1 - l) + n * l
                }
                function Wt(c) {
                    if (c <= 0)
                        return 0;
                    if (c >= 1)
                        return 1;
                    const n = c * c
                      , l = n * c;
                    return 4 * (c < .5 ? l : 3 * (c - n) + l - .75)
                }
                function tr(c, n, l, p) {
                    const _ = new V(c,n,l,p);
                    return b => _.solve(b)
                }
                const cr = tr(.25, .1, .25, 1);
                function Yt(c, n, l) {
                    return Math.min(l, Math.max(n, c))
                }
                function Gr(c, n, l) {
                    const p = l - n
                      , _ = ((c - n) % p + p) % p + n;
                    return _ === n ? l : _
                }
                function xr(c, ...n) {
                    for (const l of n)
                        for (const p in l)
                            c[p] = l[p];
                    return c
                }
                let Nr = 1;
                function ur(c, n, l) {
                    const p = {};
                    for (const _ in c)
                        p[_] = n.call(this, c[_], _, c);
                    return p
                }
                function vr(c, n, l) {
                    const p = {};
                    for (const _ in c)
                        n.call(this, c[_], _, c) && (p[_] = c[_]);
                    return p
                }
                function gr(c) {
                    return Array.isArray(c) ? c.map(gr) : typeof c == "object" && c ? ur(c, gr) : c
                }
                const hn = {};
                function Zr(c) {
                    hn[c] || (typeof console < "u" && console.warn(c),
                    hn[c] = !0)
                }
                function $r(c, n, l) {
                    return (l.y - c.y) * (n.x - c.x) > (n.y - c.y) * (l.x - c.x)
                }
                function gn(c) {
                    return typeof WorkerGlobalScope < "u" && c !== void 0 && c instanceof WorkerGlobalScope
                }
                let zr = null;
                function Wr(c) {
                    return typeof ImageBitmap < "u" && c instanceof ImageBitmap
                }
                const $n = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
                function Dn(c, n, l, p, _) {
                    return o(this, void 0, void 0, function*() {
                        if (typeof VideoFrame > "u")
                            throw new Error("VideoFrame not supported");
                        const b = new VideoFrame(c,{
                            timestamp: 0
                        });
                        try {
                            const C = b?.format;
                            if (!C || !C.startsWith("BGR") && !C.startsWith("RGB"))
                                throw new Error(`Unrecognized format ${C}`);
                            const M = C.startsWith("BGR")
                              , R = new Uint8ClampedArray(p * _ * 4);
                            if (yield b.copyTo(R, function(O, j, q, Q, ne) {
                                const oe = 4 * Math.max(-j, 0)
                                  , de = (Math.max(0, q) - q) * Q * 4 + oe
                                  , we = 4 * Q
                                  , Ie = Math.max(0, j)
                                  , Ye = Math.max(0, q);
                                return {
                                    rect: {
                                        x: Ie,
                                        y: Ye,
                                        width: Math.min(O.width, j + Q) - Ie,
                                        height: Math.min(O.height, q + ne) - Ye
                                    },
                                    layout: [{
                                        offset: de,
                                        stride: we
                                    }]
                                }
                            }(c, n, l, p, _)),
                            M)
                                for (let O = 0; O < R.length; O += 4) {
                                    const j = R[O];
                                    R[O] = R[O + 2],
                                    R[O + 2] = j
                                }
                            return R
                        } finally {
                            b.close()
                        }
                    })
                }
                let yn, Tn;
                function bn(c, n, l, p) {
                    return c.addEventListener(n, l, p),
                    {
                        unsubscribe: () => {
                            c.removeEventListener(n, l, p)
                        }
                    }
                }
                function sn(c) {
                    return c * Math.PI / 180
                }
                function Mt(c) {
                    return c / Math.PI * 180
                }
                const kt = {
                    touchstart: !0,
                    touchmove: !0,
                    touchmoveWindow: !0,
                    touchend: !0,
                    touchcancel: !0
                }
                  , er = {
                    dblclick: !0,
                    click: !0,
                    mouseover: !0,
                    mouseout: !0,
                    mousedown: !0,
                    mousemove: !0,
                    mousemoveWindow: !0,
                    mouseup: !0,
                    mouseupWindow: !0,
                    contextmenu: !0,
                    wheel: !0
                }
                  , Er = "AbortError";
                function Ue() {
                    return new Error(Er)
                }
                const se = {
                    MAX_PARALLEL_IMAGE_REQUESTS: 16,
                    MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
                    MAX_TILE_CACHE_ZOOM_LEVELS: 5,
                    REGISTERED_PROTOCOLS: {},
                    WORKER_URL: ""
                };
                function fe(c) {
                    return se.REGISTERED_PROTOCOLS[c.substring(0, c.indexOf("://"))]
                }
                const ge = "global-dispatcher";
                class Me extends Error {
                    constructor(n, l, p, _) {
                        super(`AJAXError: ${l} (${n}): ${p}`),
                        this.status = n,
                        this.statusText = l,
                        this.url = p,
                        this.body = _
                    }
                }
                const $e = () => gn(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href
                  , et = function(c, n) {
                    if (/:\/\//.test(c.url) && !/^https?:|^file:/.test(c.url)) {
                        const p = fe(c.url);
                        if (p)
                            return p(c, n);
                        if (gn(self) && self.worker && self.worker.actor)
                            return self.worker.actor.sendAsync({
                                type: "GR",
                                data: c,
                                targetMapId: ge
                            }, n)
                    }
                    if (!(/^file:/.test(l = c.url) || /^file:/.test($e()) && !/^\w+:/.test(l))) {
                        if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
                            return function(p, _) {
                                return o(this, void 0, void 0, function*() {
                                    const b = new Request(p.url,{
                                        method: p.method || "GET",
                                        body: p.body,
                                        credentials: p.credentials,
                                        headers: p.headers,
                                        cache: p.cache,
                                        referrer: $e(),
                                        signal: _.signal
                                    });
                                    let C, M;
                                    p.type !== "json" || b.headers.has("Accept") || b.headers.set("Accept", "application/json");
                                    try {
                                        C = yield fetch(b)
                                    } catch (O) {
                                        throw new Me(0,O.message,p.url,new Blob)
                                    }
                                    if (!C.ok) {
                                        const O = yield C.blob();
                                        throw new Me(C.status,C.statusText,p.url,O)
                                    }
                                    M = p.type === "arrayBuffer" || p.type === "image" ? C.arrayBuffer() : p.type === "json" ? C.json() : C.text();
                                    const R = yield M;
                                    if (_.signal.aborted)
                                        throw Ue();
                                    return {
                                        data: R,
                                        cacheControl: C.headers.get("Cache-Control"),
                                        expires: C.headers.get("Expires")
                                    }
                                })
                            }(c, n);
                        if (gn(self) && self.worker && self.worker.actor)
                            return self.worker.actor.sendAsync({
                                type: "GR",
                                data: c,
                                mustQueue: !0,
                                targetMapId: ge
                            }, n)
                    }
                    var l;
                    return function(p, _) {
                        return new Promise( (b, C) => {
                            var M;
                            const R = new XMLHttpRequest;
                            R.open(p.method || "GET", p.url, !0),
                            p.type !== "arrayBuffer" && p.type !== "image" || (R.responseType = "arraybuffer");
                            for (const O in p.headers)
                                R.setRequestHeader(O, p.headers[O]);
                            p.type === "json" && (R.responseType = "text",
                            !((M = p.headers) === null || M === void 0) && M.Accept || R.setRequestHeader("Accept", "application/json")),
                            R.withCredentials = p.credentials === "include",
                            R.onerror = () => {
                                C(new Error(R.statusText))
                            }
                            ,
                            R.onload = () => {
                                if (!_.signal.aborted)
                                    if ((R.status >= 200 && R.status < 300 || R.status === 0) && R.response !== null) {
                                        let O = R.response;
                                        if (p.type === "json")
                                            try {
                                                O = JSON.parse(R.response)
                                            } catch (j) {
                                                return void C(j)
                                            }
                                        b({
                                            data: O,
                                            cacheControl: R.getResponseHeader("Cache-Control"),
                                            expires: R.getResponseHeader("Expires")
                                        })
                                    } else {
                                        const O = new Blob([R.response],{
                                            type: R.getResponseHeader("Content-Type")
                                        });
                                        C(new Me(R.status,R.statusText,p.url,O))
                                    }
                            }
                            ,
                            _.signal.addEventListener("abort", () => {
                                R.abort(),
                                C(Ue())
                            }
                            ),
                            R.send(p.body)
                        }
                        )
                    }(c, n)
                };
                function at(c) {
                    if (!c || c.indexOf("://") <= 0 || c.indexOf("data:image/") === 0 || c.indexOf("blob:") === 0)
                        return !0;
                    const n = new URL(c)
                      , l = window.location;
                    return n.protocol === l.protocol && n.host === l.host
                }
                function Qe(c, n, l) {
                    l[c] && l[c].indexOf(n) !== -1 || (l[c] = l[c] || [],
                    l[c].push(n))
                }
                function _t(c, n, l) {
                    if (l && l[c]) {
                        const p = l[c].indexOf(n);
                        p !== -1 && l[c].splice(p, 1)
                    }
                }
                class dt {
                    constructor(n, l={}) {
                        xr(this, l),
                        this.type = n
                    }
                }
                class tt extends dt {
                    constructor(n, l={}) {
                        super("error", xr({
                            error: n
                        }, l))
                    }
                }
                class St {
                    on(n, l) {
                        return this._listeners = this._listeners || {},
                        Qe(n, l, this._listeners),
                        {
                            unsubscribe: () => {
                                this.off(n, l)
                            }
                        }
                    }
                    off(n, l) {
                        return _t(n, l, this._listeners),
                        _t(n, l, this._oneTimeListeners),
                        this
                    }
                    once(n, l) {
                        return l ? (this._oneTimeListeners = this._oneTimeListeners || {},
                        Qe(n, l, this._oneTimeListeners),
                        this) : new Promise(p => this.once(n, p))
                    }
                    fire(n, l) {
                        typeof n == "string" && (n = new dt(n,l || {}));
                        const p = n.type;
                        if (this.listens(p)) {
                            n.target = this;
                            const _ = this._listeners && this._listeners[p] ? this._listeners[p].slice() : [];
                            for (const M of _)
                                M.call(this, n);
                            const b = this._oneTimeListeners && this._oneTimeListeners[p] ? this._oneTimeListeners[p].slice() : [];
                            for (const M of b)
                                _t(p, M, this._oneTimeListeners),
                                M.call(this, n);
                            const C = this._eventedParent;
                            C && (xr(n, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData),
                            C.fire(n))
                        } else
                            n instanceof tt && console.error(n.error);
                        return this
                    }
                    listens(n) {
                        return this._listeners && this._listeners[n] && this._listeners[n].length > 0 || this._oneTimeListeners && this._oneTimeListeners[n] && this._oneTimeListeners[n].length > 0 || this._eventedParent && this._eventedParent.listens(n)
                    }
                    setEventedParent(n, l) {
                        return this._eventedParent = n,
                        this._eventedParentData = l,
                        this
                    }
                }
                var Ve = {
                    $version: 8,
                    $root: {
                        version: {
                            required: !0,
                            type: "enum",
                            values: [8]
                        },
                        name: {
                            type: "string"
                        },
                        metadata: {
                            type: "*"
                        },
                        center: {
                            type: "array",
                            value: "number"
                        },
                        centerAltitude: {
                            type: "number"
                        },
                        zoom: {
                            type: "number"
                        },
                        bearing: {
                            type: "number",
                            default: 0,
                            period: 360,
                            units: "degrees"
                        },
                        pitch: {
                            type: "number",
                            default: 0,
                            units: "degrees"
                        },
                        roll: {
                            type: "number",
                            default: 0,
                            units: "degrees"
                        },
                        state: {
                            type: "state",
                            default: {}
                        },
                        light: {
                            type: "light"
                        },
                        sky: {
                            type: "sky"
                        },
                        projection: {
                            type: "projection"
                        },
                        terrain: {
                            type: "terrain"
                        },
                        sources: {
                            required: !0,
                            type: "sources"
                        },
                        sprite: {
                            type: "sprite"
                        },
                        glyphs: {
                            type: "string"
                        },
                        transition: {
                            type: "transition"
                        },
                        layers: {
                            required: !0,
                            type: "array",
                            value: "layer"
                        }
                    },
                    sources: {
                        "*": {
                            type: "source"
                        }
                    },
                    source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
                    source_vector: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                vector: {}
                            }
                        },
                        url: {
                            type: "string"
                        },
                        tiles: {
                            type: "array",
                            value: "string"
                        },
                        bounds: {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [-180, -85.051129, 180, 85.051129]
                        },
                        scheme: {
                            type: "enum",
                            values: {
                                xyz: {},
                                tms: {}
                            },
                            default: "xyz"
                        },
                        minzoom: {
                            type: "number",
                            default: 0
                        },
                        maxzoom: {
                            type: "number",
                            default: 22
                        },
                        attribution: {
                            type: "string"
                        },
                        promoteId: {
                            type: "promoteId"
                        },
                        volatile: {
                            type: "boolean",
                            default: !1
                        },
                        "*": {
                            type: "*"
                        }
                    },
                    source_raster: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                raster: {}
                            }
                        },
                        url: {
                            type: "string"
                        },
                        tiles: {
                            type: "array",
                            value: "string"
                        },
                        bounds: {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [-180, -85.051129, 180, 85.051129]
                        },
                        minzoom: {
                            type: "number",
                            default: 0
                        },
                        maxzoom: {
                            type: "number",
                            default: 22
                        },
                        tileSize: {
                            type: "number",
                            default: 512,
                            units: "pixels"
                        },
                        scheme: {
                            type: "enum",
                            values: {
                                xyz: {},
                                tms: {}
                            },
                            default: "xyz"
                        },
                        attribution: {
                            type: "string"
                        },
                        volatile: {
                            type: "boolean",
                            default: !1
                        },
                        "*": {
                            type: "*"
                        }
                    },
                    source_raster_dem: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                "raster-dem": {}
                            }
                        },
                        url: {
                            type: "string"
                        },
                        tiles: {
                            type: "array",
                            value: "string"
                        },
                        bounds: {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [-180, -85.051129, 180, 85.051129]
                        },
                        minzoom: {
                            type: "number",
                            default: 0
                        },
                        maxzoom: {
                            type: "number",
                            default: 22
                        },
                        tileSize: {
                            type: "number",
                            default: 512,
                            units: "pixels"
                        },
                        attribution: {
                            type: "string"
                        },
                        encoding: {
                            type: "enum",
                            values: {
                                terrarium: {},
                                mapbox: {},
                                custom: {}
                            },
                            default: "mapbox"
                        },
                        redFactor: {
                            type: "number",
                            default: 1
                        },
                        blueFactor: {
                            type: "number",
                            default: 1
                        },
                        greenFactor: {
                            type: "number",
                            default: 1
                        },
                        baseShift: {
                            type: "number",
                            default: 0
                        },
                        volatile: {
                            type: "boolean",
                            default: !1
                        },
                        "*": {
                            type: "*"
                        }
                    },
                    source_geojson: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                geojson: {}
                            }
                        },
                        data: {
                            required: !0,
                            type: "*"
                        },
                        maxzoom: {
                            type: "number",
                            default: 18
                        },
                        attribution: {
                            type: "string"
                        },
                        buffer: {
                            type: "number",
                            default: 128,
                            maximum: 512,
                            minimum: 0
                        },
                        filter: {
                            type: "*"
                        },
                        tolerance: {
                            type: "number",
                            default: .375
                        },
                        cluster: {
                            type: "boolean",
                            default: !1
                        },
                        clusterRadius: {
                            type: "number",
                            default: 50,
                            minimum: 0
                        },
                        clusterMaxZoom: {
                            type: "number"
                        },
                        clusterMinPoints: {
                            type: "number"
                        },
                        clusterProperties: {
                            type: "*"
                        },
                        lineMetrics: {
                            type: "boolean",
                            default: !1
                        },
                        generateId: {
                            type: "boolean",
                            default: !1
                        },
                        promoteId: {
                            type: "promoteId"
                        }
                    },
                    source_video: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                video: {}
                            }
                        },
                        urls: {
                            required: !0,
                            type: "array",
                            value: "string"
                        },
                        coordinates: {
                            required: !0,
                            type: "array",
                            length: 4,
                            value: {
                                type: "array",
                                length: 2,
                                value: "number"
                            }
                        }
                    },
                    source_image: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                image: {}
                            }
                        },
                        url: {
                            required: !0,
                            type: "string"
                        },
                        coordinates: {
                            required: !0,
                            type: "array",
                            length: 4,
                            value: {
                                type: "array",
                                length: 2,
                                value: "number"
                            }
                        }
                    },
                    layer: {
                        id: {
                            type: "string",
                            required: !0
                        },
                        type: {
                            type: "enum",
                            values: {
                                fill: {},
                                line: {},
                                symbol: {},
                                circle: {},
                                heatmap: {},
                                "fill-extrusion": {},
                                raster: {},
                                hillshade: {},
                                "color-relief": {},
                                background: {}
                            },
                            required: !0
                        },
                        metadata: {
                            type: "*"
                        },
                        source: {
                            type: "string"
                        },
                        "source-layer": {
                            type: "string"
                        },
                        minzoom: {
                            type: "number",
                            minimum: 0,
                            maximum: 24
                        },
                        maxzoom: {
                            type: "number",
                            minimum: 0,
                            maximum: 24
                        },
                        filter: {
                            type: "filter"
                        },
                        layout: {
                            type: "layout"
                        },
                        paint: {
                            type: "paint"
                        }
                    },
                    layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
                    layout_background: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_fill: {
                        "fill-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_circle: {
                        "circle-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_heatmap: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    "layout_fill-extrusion": {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_line: {
                        "line-cap": {
                            type: "enum",
                            values: {
                                butt: {},
                                round: {},
                                square: {}
                            },
                            default: "butt",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-join": {
                            type: "enum",
                            values: {
                                bevel: {},
                                round: {},
                                miter: {}
                            },
                            default: "miter",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-miter-limit": {
                            type: "number",
                            default: 2,
                            requires: [{
                                "line-join": "miter"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-round-limit": {
                            type: "number",
                            default: 1.05,
                            requires: [{
                                "line-join": "round"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_symbol: {
                        "symbol-placement": {
                            type: "enum",
                            values: {
                                point: {},
                                line: {},
                                "line-center": {}
                            },
                            default: "point",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "symbol-spacing": {
                            type: "number",
                            default: 250,
                            minimum: 1,
                            units: "pixels",
                            requires: [{
                                "symbol-placement": "line"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "symbol-avoid-edges": {
                            type: "boolean",
                            default: !1,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "symbol-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "symbol-z-order": {
                            type: "enum",
                            values: {
                                auto: {},
                                "viewport-y": {},
                                source: {}
                            },
                            default: "auto",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-allow-overlap": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image", {
                                "!": "icon-overlap"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-overlap": {
                            type: "enum",
                            values: {
                                never: {},
                                always: {},
                                cooperative: {}
                            },
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-ignore-placement": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-optional": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image", "text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-rotation-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-size": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            units: "factor of the original icon size",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-text-fit": {
                            type: "enum",
                            values: {
                                none: {},
                                width: {},
                                height: {},
                                both: {}
                            },
                            default: "none",
                            requires: ["icon-image", "text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-text-fit-padding": {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [0, 0, 0, 0],
                            units: "pixels",
                            requires: ["icon-image", "text-field", {
                                "icon-text-fit": ["both", "width", "height"]
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-image": {
                            type: "resolvedImage",
                            tokens: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-rotate": {
                            type: "number",
                            default: 0,
                            period: 360,
                            units: "degrees",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-padding": {
                            type: "padding",
                            default: [2],
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-keep-upright": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image", {
                                "icon-rotation-alignment": "map"
                            }, {
                                "symbol-placement": ["line", "line-center"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-offset": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-anchor": {
                            type: "enum",
                            values: {
                                center: {},
                                left: {},
                                right: {},
                                top: {},
                                bottom: {},
                                "top-left": {},
                                "top-right": {},
                                "bottom-left": {},
                                "bottom-right": {}
                            },
                            default: "center",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-pitch-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-pitch-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-rotation-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                "viewport-glyph": {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-field": {
                            type: "formatted",
                            default: "",
                            tokens: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-font": {
                            type: "array",
                            value: "string",
                            default: ["Open Sans Regular", "Arial Unicode MS Regular"],
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-size": {
                            type: "number",
                            default: 16,
                            minimum: 0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-max-width": {
                            type: "number",
                            default: 10,
                            minimum: 0,
                            units: "ems",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-line-height": {
                            type: "number",
                            default: 1.2,
                            units: "ems",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-letter-spacing": {
                            type: "number",
                            default: 0,
                            units: "ems",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-justify": {
                            type: "enum",
                            values: {
                                auto: {},
                                left: {},
                                center: {},
                                right: {}
                            },
                            default: "center",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-radial-offset": {
                            type: "number",
                            units: "ems",
                            default: 0,
                            requires: ["text-field"],
                            "property-type": "data-driven",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            }
                        },
                        "text-variable-anchor": {
                            type: "array",
                            value: "enum",
                            values: {
                                center: {},
                                left: {},
                                right: {},
                                top: {},
                                bottom: {},
                                "top-left": {},
                                "top-right": {},
                                "bottom-left": {},
                                "bottom-right": {}
                            },
                            requires: ["text-field", {
                                "symbol-placement": ["point"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-variable-anchor-offset": {
                            type: "variableAnchorOffsetCollection",
                            requires: ["text-field", {
                                "symbol-placement": ["point"]
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-anchor": {
                            type: "enum",
                            values: {
                                center: {},
                                left: {},
                                right: {},
                                top: {},
                                bottom: {},
                                "top-left": {},
                                "top-right": {},
                                "bottom-left": {},
                                "bottom-right": {}
                            },
                            default: "center",
                            requires: ["text-field", {
                                "!": "text-variable-anchor"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-max-angle": {
                            type: "number",
                            default: 45,
                            units: "degrees",
                            requires: ["text-field", {
                                "symbol-placement": ["line", "line-center"]
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-writing-mode": {
                            type: "array",
                            value: "enum",
                            values: {
                                horizontal: {},
                                vertical: {}
                            },
                            requires: ["text-field", {
                                "symbol-placement": ["point"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-rotate": {
                            type: "number",
                            default: 0,
                            period: 360,
                            units: "degrees",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-padding": {
                            type: "number",
                            default: 2,
                            minimum: 0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-keep-upright": {
                            type: "boolean",
                            default: !0,
                            requires: ["text-field", {
                                "text-rotation-alignment": "map"
                            }, {
                                "symbol-placement": ["line", "line-center"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-transform": {
                            type: "enum",
                            values: {
                                none: {},
                                uppercase: {},
                                lowercase: {}
                            },
                            default: "none",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-offset": {
                            type: "array",
                            value: "number",
                            units: "ems",
                            length: 2,
                            default: [0, 0],
                            requires: ["text-field", {
                                "!": "text-radial-offset"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-allow-overlap": {
                            type: "boolean",
                            default: !1,
                            requires: ["text-field", {
                                "!": "text-overlap"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-overlap": {
                            type: "enum",
                            values: {
                                never: {},
                                always: {},
                                cooperative: {}
                            },
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-ignore-placement": {
                            type: "boolean",
                            default: !1,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-optional": {
                            type: "boolean",
                            default: !1,
                            requires: ["text-field", "icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_raster: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_hillshade: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    "layout_color-relief": {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    filter: {
                        type: "array",
                        value: "*"
                    },
                    filter_operator: {
                        type: "enum",
                        values: {
                            "==": {},
                            "!=": {},
                            ">": {},
                            ">=": {},
                            "<": {},
                            "<=": {},
                            in: {},
                            "!in": {},
                            all: {},
                            any: {},
                            none: {},
                            has: {},
                            "!has": {}
                        }
                    },
                    geometry_type: {
                        type: "enum",
                        values: {
                            Point: {},
                            LineString: {},
                            Polygon: {}
                        }
                    },
                    function: {
                        expression: {
                            type: "expression"
                        },
                        stops: {
                            type: "array",
                            value: "function_stop"
                        },
                        base: {
                            type: "number",
                            default: 1,
                            minimum: 0
                        },
                        property: {
                            type: "string",
                            default: "$zoom"
                        },
                        type: {
                            type: "enum",
                            values: {
                                identity: {},
                                exponential: {},
                                interval: {},
                                categorical: {}
                            },
                            default: "exponential"
                        },
                        colorSpace: {
                            type: "enum",
                            values: {
                                rgb: {},
                                lab: {},
                                hcl: {}
                            },
                            default: "rgb"
                        },
                        default: {
                            type: "*",
                            required: !1
                        }
                    },
                    function_stop: {
                        type: "array",
                        minimum: 0,
                        maximum: 24,
                        value: ["number", "color"],
                        length: 2
                    },
                    expression: {
                        type: "array",
                        value: "*",
                        minimum: 1
                    },
                    light: {
                        anchor: {
                            type: "enum",
                            default: "viewport",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            "property-type": "data-constant",
                            transition: !1,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            }
                        },
                        position: {
                            type: "array",
                            default: [1.15, 210, 30],
                            length: 3,
                            value: "number",
                            "property-type": "data-constant",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            }
                        },
                        color: {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#ffffff",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        intensity: {
                            type: "number",
                            "property-type": "data-constant",
                            default: .5,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        }
                    },
                    sky: {
                        "sky-color": {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#88C6FC",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "horizon-color": {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#ffffff",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "fog-color": {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#ffffff",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "fog-ground-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .5,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "horizon-fog-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .8,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "sky-horizon-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .8,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "atmosphere-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .8,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        }
                    },
                    terrain: {
                        source: {
                            type: "string",
                            required: !0
                        },
                        exaggeration: {
                            type: "number",
                            minimum: 0,
                            default: 1
                        }
                    },
                    projection: {
                        type: {
                            type: "projectionDefinition",
                            default: "mercator",
                            "property-type": "data-constant",
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            }
                        }
                    },
                    paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
                    paint_fill: {
                        "fill-antialias": {
                            type: "boolean",
                            default: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "fill-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-outline-color": {
                            type: "color",
                            transition: !0,
                            requires: [{
                                "!": "fill-pattern"
                            }, {
                                "fill-antialias": !0
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["fill-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "cross-faded-data-driven"
                        }
                    },
                    "paint_fill-extrusion": {
                        "fill-extrusion-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-extrusion-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "fill-extrusion-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-extrusion-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-extrusion-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["fill-extrusion-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-extrusion-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "cross-faded-data-driven"
                        },
                        "fill-extrusion-height": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            units: "meters",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-extrusion-base": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            units: "meters",
                            transition: !0,
                            requires: ["fill-extrusion-height"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-extrusion-vertical-gradient": {
                            type: "boolean",
                            default: !0,
                            transition: !1,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_line: {
                        "line-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "line-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["line-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-width": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-gap-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-offset": {
                            type: "number",
                            default: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-blur": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-dasharray": {
                            type: "array",
                            value: "number",
                            minimum: 0,
                            transition: !0,
                            units: "line widths",
                            requires: [{
                                "!": "line-pattern"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "cross-faded"
                        },
                        "line-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "cross-faded-data-driven"
                        },
                        "line-gradient": {
                            type: "color",
                            transition: !1,
                            requires: [{
                                "!": "line-dasharray"
                            }, {
                                "!": "line-pattern"
                            }, {
                                source: "geojson",
                                has: {
                                    lineMetrics: !0
                                }
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["line-progress"]
                            },
                            "property-type": "color-ramp"
                        }
                    },
                    paint_circle: {
                        "circle-radius": {
                            type: "number",
                            default: 5,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-blur": {
                            type: "number",
                            default: 0,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["circle-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-pitch-scale": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-pitch-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "viewport",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-stroke-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-stroke-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-stroke-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        }
                    },
                    paint_heatmap: {
                        "heatmap-radius": {
                            type: "number",
                            default: 30,
                            minimum: 1,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "heatmap-weight": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "heatmap-intensity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "heatmap-color": {
                            type: "color",
                            default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"],
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["heatmap-density"]
                            },
                            "property-type": "color-ramp"
                        },
                        "heatmap-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_symbol: {
                        "icon-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-halo-color": {
                            type: "color",
                            default: "rgba(0, 0, 0, 0)",
                            transition: !0,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-halo-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-halo-blur": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["icon-image", "icon-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            overridable: !0,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-halo-color": {
                            type: "color",
                            default: "rgba(0, 0, 0, 0)",
                            transition: !0,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-halo-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-halo-blur": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["text-field", "text-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_raster: {
                        "raster-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-hue-rotate": {
                            type: "number",
                            default: 0,
                            period: 360,
                            transition: !0,
                            units: "degrees",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-brightness-min": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-brightness-max": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-saturation": {
                            type: "number",
                            default: 0,
                            minimum: -1,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-contrast": {
                            type: "number",
                            default: 0,
                            minimum: -1,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-resampling": {
                            type: "enum",
                            values: {
                                linear: {},
                                nearest: {}
                            },
                            default: "linear",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-fade-duration": {
                            type: "number",
                            default: 300,
                            minimum: 0,
                            transition: !1,
                            units: "milliseconds",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_hillshade: {
                        "hillshade-illumination-direction": {
                            type: "numberArray",
                            default: 335,
                            minimum: 0,
                            maximum: 359,
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-illumination-altitude": {
                            type: "numberArray",
                            default: 45,
                            minimum: 0,
                            maximum: 90,
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-illumination-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "viewport",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-exaggeration": {
                            type: "number",
                            default: .5,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-shadow-color": {
                            type: "colorArray",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-highlight-color": {
                            type: "colorArray",
                            default: "#FFFFFF",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-accent-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-method": {
                            type: "enum",
                            values: {
                                standard: {},
                                basic: {},
                                combined: {},
                                igor: {},
                                multidirectional: {}
                            },
                            default: "standard",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    "paint_color-relief": {
                        "color-relief-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "color-relief-color": {
                            type: "color",
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["elevation"]
                            },
                            "property-type": "color-ramp"
                        }
                    },
                    paint_background: {
                        "background-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "background-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "background-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "cross-faded"
                        },
                        "background-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    transition: {
                        duration: {
                            type: "number",
                            default: 300,
                            minimum: 0,
                            units: "milliseconds"
                        },
                        delay: {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            units: "milliseconds"
                        }
                    },
                    "property-type": {
                        "data-driven": {
                            type: "property-type"
                        },
                        "cross-faded": {
                            type: "property-type"
                        },
                        "cross-faded-data-driven": {
                            type: "property-type"
                        },
                        "color-ramp": {
                            type: "property-type"
                        },
                        "data-constant": {
                            type: "property-type"
                        },
                        constant: {
                            type: "property-type"
                        }
                    },
                    promoteId: {
                        "*": {
                            type: "string"
                        }
                    }
                };
                const Ut = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
                function yr(c, n) {
                    const l = {};
                    for (const p in c)
                        p !== "ref" && (l[p] = c[p]);
                    return Ut.forEach(p => {
                        p in n && (l[p] = n[p])
                    }
                    ),
                    l
                }
                function Ht(c, n) {
                    if (Array.isArray(c)) {
                        if (!Array.isArray(n) || c.length !== n.length)
                            return !1;
                        for (let l = 0; l < c.length; l++)
                            if (!Ht(c[l], n[l]))
                                return !1;
                        return !0
                    }
                    if (typeof c == "object" && c !== null && n !== null) {
                        if (typeof n != "object" || Object.keys(c).length !== Object.keys(n).length)
                            return !1;
                        for (const l in c)
                            if (!Ht(c[l], n[l]))
                                return !1;
                        return !0
                    }
                    return c === n
                }
                function sr(c, n) {
                    c.push(n)
                }
                function br(c, n, l) {
                    sr(l, {
                        command: "addSource",
                        args: [c, n[c]]
                    })
                }
                function en(c, n, l) {
                    sr(n, {
                        command: "removeSource",
                        args: [c]
                    }),
                    l[c] = !0
                }
                function qr(c, n, l, p) {
                    en(c, l, p),
                    br(c, n, l)
                }
                function Dr(c, n, l) {
                    let p;
                    for (p in c[l])
                        if (Object.prototype.hasOwnProperty.call(c[l], p) && p !== "data" && !Ht(c[l][p], n[l][p]))
                            return !1;
                    for (p in n[l])
                        if (Object.prototype.hasOwnProperty.call(n[l], p) && p !== "data" && !Ht(c[l][p], n[l][p]))
                            return !1;
                    return !0
                }
                function fr(c, n, l, p, _, b) {
                    c = c || {},
                    n = n || {};
                    for (const C in c)
                        Object.prototype.hasOwnProperty.call(c, C) && (Ht(c[C], n[C]) || l.push({
                            command: b,
                            args: [p, C, n[C], _]
                        }));
                    for (const C in n)
                        Object.prototype.hasOwnProperty.call(n, C) && !Object.prototype.hasOwnProperty.call(c, C) && (Ht(c[C], n[C]) || l.push({
                            command: b,
                            args: [p, C, n[C], _]
                        }))
                }
                function ke(c) {
                    return c.id
                }
                function le(c, n) {
                    return c[n.id] = n,
                    c
                }
                class ee {
                    constructor(n, l, p, _) {
                        this.message = (n ? `${n}: ` : "") + p,
                        _ && (this.identifier = _),
                        l != null && l.__line__ && (this.line = l.__line__)
                    }
                }
                function Ze(c, ...n) {
                    for (const l of n)
                        for (const p in l)
                            c[p] = l[p];
                    return c
                }
                class Ge extends Error {
                    constructor(n, l) {
                        super(l),
                        this.message = l,
                        this.key = n
                    }
                }
                class vt {
                    constructor(n, l=[]) {
                        this.parent = n,
                        this.bindings = {};
                        for (const [p,_] of l)
                            this.bindings[p] = _
                    }
                    concat(n) {
                        return new vt(this,n)
                    }
                    get(n) {
                        if (this.bindings[n])
                            return this.bindings[n];
                        if (this.parent)
                            return this.parent.get(n);
                        throw new Error(`${n} not found in scope.`)
                    }
                    has(n) {
                        return !!this.bindings[n] || !!this.parent && this.parent.has(n)
                    }
                }
                const it = {
                    kind: "null"
                }
                  , Xe = {
                    kind: "number"
                }
                  , wt = {
                    kind: "string"
                }
                  , Ct = {
                    kind: "boolean"
                }
                  , Gt = {
                    kind: "color"
                }
                  , Xt = {
                    kind: "projectionDefinition"
                }
                  , lr = {
                    kind: "object"
                }
                  , _r = {
                    kind: "value"
                }
                  , ri = {
                    kind: "collator"
                }
                  , ni = {
                    kind: "formatted"
                }
                  , kr = {
                    kind: "padding"
                }
                  , ci = {
                    kind: "colorArray"
                }
                  , Si = {
                    kind: "numberArray"
                }
                  , $i = {
                    kind: "resolvedImage"
                }
                  , Ro = {
                    kind: "variableAnchorOffsetCollection"
                };
                function Ln(c, n) {
                    return {
                        kind: "array",
                        itemType: c,
                        N: n
                    }
                }
                function an(c) {
                    if (c.kind === "array") {
                        const n = an(c.itemType);
                        return typeof c.N == "number" ? `array<${n}, ${c.N}>` : c.itemType.kind === "value" ? "array" : `array<${n}>`
                    }
                    return c.kind
                }
                const qn = [it, Xe, wt, Ct, Gt, Xt, ni, lr, Ln(_r), kr, Si, ci, $i, Ro];
                function Ei(c, n) {
                    if (n.kind === "error")
                        return null;
                    if (c.kind === "array") {
                        if (n.kind === "array" && (n.N === 0 && n.itemType.kind === "value" || !Ei(c.itemType, n.itemType)) && (typeof c.N != "number" || c.N === n.N))
                            return null
                    } else {
                        if (c.kind === n.kind)
                            return null;
                        if (c.kind === "value") {
                            for (const l of qn)
                                if (!Ei(l, n))
                                    return null
                        }
                    }
                    return `Expected ${an(c)} but found ${an(n)} instead.`
                }
                function Ao(c, n) {
                    return n.some(l => l.kind === c.kind)
                }
                function Hn(c, n) {
                    return n.some(l => l === "null" ? c === null : l === "array" ? Array.isArray(c) : l === "object" ? c && !Array.isArray(c) && typeof c == "object" : l === typeof c)
                }
                function Go(c, n) {
                    return c.kind === "array" && n.kind === "array" ? c.itemType.kind === n.itemType.kind && typeof c.N == "number" : c.kind === n.kind
                }
                const xl = .96422
                  , Wo = .82521
                  , qo = 4 / 29
                  , Ho = 6 / 29
                  , xs = 3 * Ho * Ho
                  , bs = Ho * Ho * Ho
                  , Zo = Math.PI / 180
                  , Vi = 180 / Math.PI;
                function oa(c) {
                    return (c %= 360) < 0 && (c += 360),
                    c
                }
                function Ki([c,n,l,p]) {
                    let _, b;
                    const C = bl((.2225045 * (c = su(c)) + .7168786 * (n = su(n)) + .0606169 * (l = su(l))) / 1);
                    c === n && n === l ? _ = b = C : (_ = bl((.4360747 * c + .3850649 * n + .1430804 * l) / xl),
                    b = bl((.0139322 * c + .0971045 * n + .7141733 * l) / Wo));
                    const M = 116 * C - 16;
                    return [M < 0 ? 0 : M, 500 * (_ - C), 200 * (C - b), p]
                }
                function su(c) {
                    return c <= .04045 ? c / 12.92 : Math.pow((c + .055) / 1.055, 2.4)
                }
                function bl(c) {
                    return c > bs ? Math.pow(c, 1 / 3) : c / xs + qo
                }
                function wf([c,n,l,p]) {
                    let _ = (c + 16) / 116
                      , b = isNaN(n) ? _ : _ + n / 500
                      , C = isNaN(l) ? _ : _ - l / 200;
                    return _ = 1 * dn(_),
                    b = xl * dn(b),
                    C = Wo * dn(C),
                    [ic(3.1338561 * b - 1.6168667 * _ - .4906146 * C), ic(-.9787684 * b + 1.9161415 * _ + .033454 * C), ic(.0719453 * b - .2289914 * _ + 1.4052427 * C), p]
                }
                function ic(c) {
                    return (c = c <= .00304 ? 12.92 * c : 1.055 * Math.pow(c, 1 / 2.4) - .055) < 0 ? 0 : c > 1 ? 1 : c
                }
                function dn(c) {
                    return c > Ho ? c * c * c : xs * (c - qo)
                }
                const ws = Object.hasOwn || function(c, n) {
                    return Object.prototype.hasOwnProperty.call(c, n)
                }
                ;
                function Xr(c, n) {
                    return ws(c, n) ? c[n] : void 0
                }
                function Ss(c) {
                    return parseInt(c.padEnd(2, c), 16) / 255
                }
                function Ns(c, n) {
                    return Da(n ? c / 100 : c, 0, 1)
                }
                function Da(c, n, l) {
                    return Math.min(Math.max(n, c), l)
                }
                function ch(c) {
                    return !c.some(Number.isNaN)
                }
                const au = {
                    aliceblue: [240, 248, 255],
                    antiquewhite: [250, 235, 215],
                    aqua: [0, 255, 255],
                    aquamarine: [127, 255, 212],
                    azure: [240, 255, 255],
                    beige: [245, 245, 220],
                    bisque: [255, 228, 196],
                    black: [0, 0, 0],
                    blanchedalmond: [255, 235, 205],
                    blue: [0, 0, 255],
                    blueviolet: [138, 43, 226],
                    brown: [165, 42, 42],
                    burlywood: [222, 184, 135],
                    cadetblue: [95, 158, 160],
                    chartreuse: [127, 255, 0],
                    chocolate: [210, 105, 30],
                    coral: [255, 127, 80],
                    cornflowerblue: [100, 149, 237],
                    cornsilk: [255, 248, 220],
                    crimson: [220, 20, 60],
                    cyan: [0, 255, 255],
                    darkblue: [0, 0, 139],
                    darkcyan: [0, 139, 139],
                    darkgoldenrod: [184, 134, 11],
                    darkgray: [169, 169, 169],
                    darkgreen: [0, 100, 0],
                    darkgrey: [169, 169, 169],
                    darkkhaki: [189, 183, 107],
                    darkmagenta: [139, 0, 139],
                    darkolivegreen: [85, 107, 47],
                    darkorange: [255, 140, 0],
                    darkorchid: [153, 50, 204],
                    darkred: [139, 0, 0],
                    darksalmon: [233, 150, 122],
                    darkseagreen: [143, 188, 143],
                    darkslateblue: [72, 61, 139],
                    darkslategray: [47, 79, 79],
                    darkslategrey: [47, 79, 79],
                    darkturquoise: [0, 206, 209],
                    darkviolet: [148, 0, 211],
                    deeppink: [255, 20, 147],
                    deepskyblue: [0, 191, 255],
                    dimgray: [105, 105, 105],
                    dimgrey: [105, 105, 105],
                    dodgerblue: [30, 144, 255],
                    firebrick: [178, 34, 34],
                    floralwhite: [255, 250, 240],
                    forestgreen: [34, 139, 34],
                    fuchsia: [255, 0, 255],
                    gainsboro: [220, 220, 220],
                    ghostwhite: [248, 248, 255],
                    gold: [255, 215, 0],
                    goldenrod: [218, 165, 32],
                    gray: [128, 128, 128],
                    green: [0, 128, 0],
                    greenyellow: [173, 255, 47],
                    grey: [128, 128, 128],
                    honeydew: [240, 255, 240],
                    hotpink: [255, 105, 180],
                    indianred: [205, 92, 92],
                    indigo: [75, 0, 130],
                    ivory: [255, 255, 240],
                    khaki: [240, 230, 140],
                    lavender: [230, 230, 250],
                    lavenderblush: [255, 240, 245],
                    lawngreen: [124, 252, 0],
                    lemonchiffon: [255, 250, 205],
                    lightblue: [173, 216, 230],
                    lightcoral: [240, 128, 128],
                    lightcyan: [224, 255, 255],
                    lightgoldenrodyellow: [250, 250, 210],
                    lightgray: [211, 211, 211],
                    lightgreen: [144, 238, 144],
                    lightgrey: [211, 211, 211],
                    lightpink: [255, 182, 193],
                    lightsalmon: [255, 160, 122],
                    lightseagreen: [32, 178, 170],
                    lightskyblue: [135, 206, 250],
                    lightslategray: [119, 136, 153],
                    lightslategrey: [119, 136, 153],
                    lightsteelblue: [176, 196, 222],
                    lightyellow: [255, 255, 224],
                    lime: [0, 255, 0],
                    limegreen: [50, 205, 50],
                    linen: [250, 240, 230],
                    magenta: [255, 0, 255],
                    maroon: [128, 0, 0],
                    mediumaquamarine: [102, 205, 170],
                    mediumblue: [0, 0, 205],
                    mediumorchid: [186, 85, 211],
                    mediumpurple: [147, 112, 219],
                    mediumseagreen: [60, 179, 113],
                    mediumslateblue: [123, 104, 238],
                    mediumspringgreen: [0, 250, 154],
                    mediumturquoise: [72, 209, 204],
                    mediumvioletred: [199, 21, 133],
                    midnightblue: [25, 25, 112],
                    mintcream: [245, 255, 250],
                    mistyrose: [255, 228, 225],
                    moccasin: [255, 228, 181],
                    navajowhite: [255, 222, 173],
                    navy: [0, 0, 128],
                    oldlace: [253, 245, 230],
                    olive: [128, 128, 0],
                    olivedrab: [107, 142, 35],
                    orange: [255, 165, 0],
                    orangered: [255, 69, 0],
                    orchid: [218, 112, 214],
                    palegoldenrod: [238, 232, 170],
                    palegreen: [152, 251, 152],
                    paleturquoise: [175, 238, 238],
                    palevioletred: [219, 112, 147],
                    papayawhip: [255, 239, 213],
                    peachpuff: [255, 218, 185],
                    peru: [205, 133, 63],
                    pink: [255, 192, 203],
                    plum: [221, 160, 221],
                    powderblue: [176, 224, 230],
                    purple: [128, 0, 128],
                    rebeccapurple: [102, 51, 153],
                    red: [255, 0, 0],
                    rosybrown: [188, 143, 143],
                    royalblue: [65, 105, 225],
                    saddlebrown: [139, 69, 19],
                    salmon: [250, 128, 114],
                    sandybrown: [244, 164, 96],
                    seagreen: [46, 139, 87],
                    seashell: [255, 245, 238],
                    sienna: [160, 82, 45],
                    silver: [192, 192, 192],
                    skyblue: [135, 206, 235],
                    slateblue: [106, 90, 205],
                    slategray: [112, 128, 144],
                    slategrey: [112, 128, 144],
                    snow: [255, 250, 250],
                    springgreen: [0, 255, 127],
                    steelblue: [70, 130, 180],
                    tan: [210, 180, 140],
                    teal: [0, 128, 128],
                    thistle: [216, 191, 216],
                    tomato: [255, 99, 71],
                    turquoise: [64, 224, 208],
                    violet: [238, 130, 238],
                    wheat: [245, 222, 179],
                    white: [255, 255, 255],
                    whitesmoke: [245, 245, 245],
                    yellow: [255, 255, 0],
                    yellowgreen: [154, 205, 50]
                };
                function po(c, n, l) {
                    return c + l * (n - c)
                }
                function Qi(c, n, l) {
                    return c.map( (p, _) => po(p, n[_], l))
                }
                class Br {
                    constructor(n, l, p, _=1, b=!0) {
                        this.r = n,
                        this.g = l,
                        this.b = p,
                        this.a = _,
                        b || (this.r *= _,
                        this.g *= _,
                        this.b *= _,
                        _ || this.overwriteGetter("rgb", [n, l, p, _]))
                    }
                    static parse(n) {
                        if (n instanceof Br)
                            return n;
                        if (typeof n != "string")
                            return;
                        const l = function(p) {
                            if ((p = p.toLowerCase().trim()) === "transparent")
                                return [0, 0, 0, 0];
                            const _ = Xr(au, p);
                            if (_) {
                                const [C,M,R] = _;
                                return [C / 255, M / 255, R / 255, 1]
                            }
                            if (p.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(p)) {
                                const C = p.length < 6 ? 1 : 2;
                                let M = 1;
                                return [Ss(p.slice(M, M += C)), Ss(p.slice(M, M += C)), Ss(p.slice(M, M += C)), Ss(p.slice(M, M + C) || "ff")]
                            }
                            if (p.startsWith("rgb")) {
                                const C = p.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                                if (C) {
                                    const [M,R,O,j,q,Q,ne,oe,de,we,Ie,Ye] = C
                                      , Le = [j || " ", ne || " ", we].join("");
                                    if (Le === "  " || Le === "  /" || Le === ",," || Le === ",,,") {
                                        const te = [O, Q, de].join("")
                                          , _e = te === "%%%" ? 100 : te === "" ? 255 : 0;
                                        if (_e) {
                                            const Oe = [Da(+R / _e, 0, 1), Da(+q / _e, 0, 1), Da(+oe / _e, 0, 1), Ie ? Ns(+Ie, Ye) : 1];
                                            if (ch(Oe))
                                                return Oe
                                        }
                                    }
                                    return
                                }
                            }
                            const b = p.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                            if (b) {
                                const [C,M,R,O,j,q,Q,ne,oe] = b
                                  , de = [R || " ", j || " ", Q].join("");
                                if (de === "  " || de === "  /" || de === ",," || de === ",,,") {
                                    const we = [+M, Da(+O, 0, 100), Da(+q, 0, 100), ne ? Ns(+ne, oe) : 1];
                                    if (ch(we))
                                        return function([Ie,Ye,Le,te]) {
                                            function _e(Oe) {
                                                const ft = (Oe + Ie / 30) % 12
                                                  , Rt = Ye * Math.min(Le, 1 - Le);
                                                return Le - Rt * Math.max(-1, Math.min(ft - 3, 9 - ft, 1))
                                            }
                                            return Ie = oa(Ie),
                                            Ye /= 100,
                                            Le /= 100,
                                            [_e(0), _e(8), _e(4), te]
                                        }(we)
                                }
                            }
                        }(n);
                        return l ? new Br(...l,!1) : void 0
                    }
                    get rgb() {
                        const {r: n, g: l, b: p, a: _} = this
                          , b = _ || 1 / 0;
                        return this.overwriteGetter("rgb", [n / b, l / b, p / b, _])
                    }
                    get hcl() {
                        return this.overwriteGetter("hcl", function(n) {
                            const [l,p,_,b] = Ki(n)
                              , C = Math.sqrt(p * p + _ * _);
                            return [Math.round(1e4 * C) ? oa(Math.atan2(_, p) * Vi) : NaN, C, l, b]
                        }(this.rgb))
                    }
                    get lab() {
                        return this.overwriteGetter("lab", Ki(this.rgb))
                    }
                    overwriteGetter(n, l) {
                        return Object.defineProperty(this, n, {
                            value: l
                        }),
                        l
                    }
                    toString() {
                        const [n,l,p,_] = this.rgb;
                        return `rgba(${[n, l, p].map(b => Math.round(255 * b)).join(",")},${_})`
                    }
                    static interpolate(n, l, p, _="rgb") {
                        switch (_) {
                        case "rgb":
                            {
                                const [b,C,M,R] = Qi(n.rgb, l.rgb, p);
                                return new Br(b,C,M,R,!1)
                            }
                        case "hcl":
                            {
                                const [b,C,M,R] = n.hcl
                                  , [O,j,q,Q] = l.hcl;
                                let ne, oe;
                                if (isNaN(b) || isNaN(O))
                                    isNaN(b) ? isNaN(O) ? ne = NaN : (ne = O,
                                    M !== 1 && M !== 0 || (oe = j)) : (ne = b,
                                    q !== 1 && q !== 0 || (oe = C));
                                else {
                                    let Le = O - b;
                                    O > b && Le > 180 ? Le -= 360 : O < b && b - O > 180 && (Le += 360),
                                    ne = b + p * Le
                                }
                                const [de,we,Ie,Ye] = function([Le,te,_e,Oe]) {
                                    return Le = isNaN(Le) ? 0 : Le * Zo,
                                    wf([_e, Math.cos(Le) * te, Math.sin(Le) * te, Oe])
                                }([ne, oe ?? po(C, j, p), po(M, q, p), po(R, Q, p)]);
                                return new Br(de,we,Ie,Ye,!1)
                            }
                        case "lab":
                            {
                                const [b,C,M,R] = wf(Qi(n.lab, l.lab, p));
                                return new Br(b,C,M,R,!1)
                            }
                        }
                    }
                }
                Br.black = new Br(0,0,0,1),
                Br.white = new Br(1,1,1,1),
                Br.transparent = new Br(0,0,0,0),
                Br.red = new Br(1,0,0,1);
                class cs {
                    constructor(n, l, p) {
                        this.sensitivity = n ? l ? "variant" : "case" : l ? "accent" : "base",
                        this.locale = p,
                        this.collator = new Intl.Collator(this.locale ? this.locale : [],{
                            sensitivity: this.sensitivity,
                            usage: "search"
                        })
                    }
                    compare(n, l) {
                        return this.collator.compare(n, l)
                    }
                    resolvedLocale() {
                        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
                    }
                }
                const La = ["bottom", "center", "top"];
                class wl {
                    constructor(n, l, p, _, b, C) {
                        this.text = n,
                        this.image = l,
                        this.scale = p,
                        this.fontStack = _,
                        this.textColor = b,
                        this.verticalAlign = C
                    }
                }
                class ei {
                    constructor(n) {
                        this.sections = n
                    }
                    static fromString(n) {
                        return new ei([new wl(n,null,null,null,null,null)])
                    }
                    isEmpty() {
                        return this.sections.length === 0 || !this.sections.some(n => n.text.length !== 0 || n.image && n.image.name.length !== 0)
                    }
                    static factory(n) {
                        return n instanceof ei ? n : ei.fromString(n)
                    }
                    toString() {
                        return this.sections.length === 0 ? "" : this.sections.map(n => n.text).join("")
                    }
                }
                class mi {
                    constructor(n) {
                        this.values = n.slice()
                    }
                    static parse(n) {
                        if (n instanceof mi)
                            return n;
                        if (typeof n == "number")
                            return new mi([n, n, n, n]);
                        if (Array.isArray(n) && !(n.length < 1 || n.length > 4)) {
                            for (const l of n)
                                if (typeof l != "number")
                                    return;
                            switch (n.length) {
                            case 1:
                                n = [n[0], n[0], n[0], n[0]];
                                break;
                            case 2:
                                n = [n[0], n[1], n[0], n[1]];
                                break;
                            case 3:
                                n = [n[0], n[1], n[2], n[1]]
                            }
                            return new mi(n)
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(n, l, p) {
                        return new mi(Qi(n.values, l.values, p))
                    }
                }
                class Ui {
                    constructor(n) {
                        this.values = n.slice()
                    }
                    static parse(n) {
                        if (n instanceof Ui)
                            return n;
                        if (typeof n == "number")
                            return new Ui([n]);
                        if (Array.isArray(n)) {
                            for (const l of n)
                                if (typeof l != "number")
                                    return;
                            return new Ui(n)
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(n, l, p) {
                        return new Ui(Qi(n.values, l.values, p))
                    }
                }
                class ii {
                    constructor(n) {
                        this.values = n.slice()
                    }
                    static parse(n) {
                        if (n instanceof ii)
                            return n;
                        if (typeof n == "string") {
                            const p = Br.parse(n);
                            return p ? new ii([p]) : void 0
                        }
                        if (!Array.isArray(n))
                            return;
                        const l = [];
                        for (const p of n) {
                            if (typeof p != "string")
                                return;
                            const _ = Br.parse(p);
                            if (!_)
                                return;
                            l.push(_)
                        }
                        return new ii(l)
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(n, l, p, _="rgb") {
                        const b = [];
                        if (n.values.length != l.values.length)
                            throw new Error(`colorArray: Arrays have mismatched length (${n.values.length} vs. ${l.values.length}), cannot interpolate.`);
                        for (let C = 0; C < n.values.length; C++)
                            b.push(Br.interpolate(n.values[C], l.values[C], p, _));
                        return new ii(b)
                    }
                }
                class Qn extends Error {
                    constructor(n) {
                        super(n),
                        this.name = "RuntimeError"
                    }
                    toJSON() {
                        return this.message
                    }
                }
                const lu = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
                class Yr {
                    constructor(n) {
                        this.values = n.slice()
                    }
                    static parse(n) {
                        if (n instanceof Yr)
                            return n;
                        if (Array.isArray(n) && !(n.length < 1) && n.length % 2 == 0) {
                            for (let l = 0; l < n.length; l += 2) {
                                const p = n[l]
                                  , _ = n[l + 1];
                                if (typeof p != "string" || !lu.has(p) || !Array.isArray(_) || _.length !== 2 || typeof _[0] != "number" || typeof _[1] != "number")
                                    return
                            }
                            return new Yr(n)
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(n, l, p) {
                        const _ = n.values
                          , b = l.values;
                        if (_.length !== b.length)
                            throw new Qn(`Cannot interpolate values of different length. from: ${n.toString()}, to: ${l.toString()}`);
                        const C = [];
                        for (let M = 0; M < _.length; M += 2) {
                            if (_[M] !== b[M])
                                throw new Qn(`Cannot interpolate values containing mismatched anchors. from[${M}]: ${_[M]}, to[${M}]: ${b[M]}`);
                            C.push(_[M]);
                            const [R,O] = _[M + 1]
                              , [j,q] = b[M + 1];
                            C.push([po(R, j, p), po(O, q, p)])
                        }
                        return new Yr(C)
                    }
                }
                class mo {
                    constructor(n) {
                        this.name = n.name,
                        this.available = n.available
                    }
                    toString() {
                        return this.name
                    }
                    static fromString(n) {
                        return n ? new mo({
                            name: n,
                            available: !1
                        }) : null
                    }
                }
                class jr {
                    constructor(n, l, p) {
                        this.from = n,
                        this.to = l,
                        this.transition = p
                    }
                    static interpolate(n, l, p) {
                        return new jr(n,l,p)
                    }
                    static parse(n) {
                        return n instanceof jr ? n : Array.isArray(n) && n.length === 3 && typeof n[0] == "string" && typeof n[1] == "string" && typeof n[2] == "number" ? new jr(n[0],n[1],n[2]) : typeof n == "object" && typeof n.from == "string" && typeof n.to == "string" && typeof n.transition == "number" ? new jr(n.from,n.to,n.transition) : typeof n == "string" ? new jr(n,n,1) : void 0
                    }
                }
                function Fr(c, n, l, p) {
                    return typeof c == "number" && c >= 0 && c <= 255 && typeof n == "number" && n >= 0 && n <= 255 && typeof l == "number" && l >= 0 && l <= 255 ? p === void 0 || typeof p == "number" && p >= 0 && p <= 1 ? null : `Invalid rgba value [${[c, n, l, p].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof p == "number" ? [c, n, l, p] : [c, n, l]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
                }
                function Cs(c) {
                    if (c === null || typeof c == "string" || typeof c == "boolean" || typeof c == "number" || c instanceof jr || c instanceof Br || c instanceof cs || c instanceof ei || c instanceof mi || c instanceof Ui || c instanceof ii || c instanceof Yr || c instanceof mo)
                        return !0;
                    if (Array.isArray(c)) {
                        for (const n of c)
                            if (!Cs(n))
                                return !1;
                        return !0
                    }
                    if (typeof c == "object") {
                        for (const n in c)
                            if (!Cs(c[n]))
                                return !1;
                        return !0
                    }
                    return !1
                }
                function Sr(c) {
                    if (c === null)
                        return it;
                    if (typeof c == "string")
                        return wt;
                    if (typeof c == "boolean")
                        return Ct;
                    if (typeof c == "number")
                        return Xe;
                    if (c instanceof Br)
                        return Gt;
                    if (c instanceof jr)
                        return Xt;
                    if (c instanceof cs)
                        return ri;
                    if (c instanceof ei)
                        return ni;
                    if (c instanceof mi)
                        return kr;
                    if (c instanceof Ui)
                        return Si;
                    if (c instanceof ii)
                        return ci;
                    if (c instanceof Yr)
                        return Ro;
                    if (c instanceof mo)
                        return $i;
                    if (Array.isArray(c)) {
                        const n = c.length;
                        let l;
                        for (const p of c) {
                            const _ = Sr(p);
                            if (l) {
                                if (l === _)
                                    continue;
                                l = _r;
                                break
                            }
                            l = _
                        }
                        return Ln(l || _r, n)
                    }
                    return lr
                }
                function $s(c) {
                    const n = typeof c;
                    return c === null ? "" : n === "string" || n === "number" || n === "boolean" ? String(c) : c instanceof Br || c instanceof jr || c instanceof ei || c instanceof mi || c instanceof Ui || c instanceof ii || c instanceof Yr || c instanceof mo ? c.toString() : JSON.stringify(c)
                }
                class go {
                    constructor(n, l) {
                        this.type = n,
                        this.value = l
                    }
                    static parse(n, l) {
                        if (n.length !== 2)
                            return l.error(`'literal' expression requires exactly one argument, but found ${n.length - 1} instead.`);
                        if (!Cs(n[1]))
                            return l.error("invalid value");
                        const p = n[1];
                        let _ = Sr(p);
                        const b = l.expectedType;
                        return _.kind !== "array" || _.N !== 0 || !b || b.kind !== "array" || typeof b.N == "number" && b.N !== 0 || (_ = b),
                        new go(_,p)
                    }
                    evaluate() {
                        return this.value
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                }
                const oc = {
                    string: wt,
                    number: Xe,
                    boolean: Ct,
                    object: lr
                };
                class Ji {
                    constructor(n, l) {
                        this.type = n,
                        this.args = l
                    }
                    static parse(n, l) {
                        if (n.length < 2)
                            return l.error("Expected at least one argument.");
                        let p, _ = 1;
                        const b = n[0];
                        if (b === "array") {
                            let M, R;
                            if (n.length > 2) {
                                const O = n[1];
                                if (typeof O != "string" || !(O in oc) || O === "object")
                                    return l.error('The item type argument of "array" must be one of string, number, boolean', 1);
                                M = oc[O],
                                _++
                            } else
                                M = _r;
                            if (n.length > 3) {
                                if (n[2] !== null && (typeof n[2] != "number" || n[2] < 0 || n[2] !== Math.floor(n[2])))
                                    return l.error('The length argument to "array" must be a positive integer literal', 2);
                                R = n[2],
                                _++
                            }
                            p = Ln(M, R)
                        } else {
                            if (!oc[b])
                                throw new Error(`Types doesn't contain name = ${b}`);
                            p = oc[b]
                        }
                        const C = [];
                        for (; _ < n.length; _++) {
                            const M = l.parse(n[_], _, _r);
                            if (!M)
                                return null;
                            C.push(M)
                        }
                        return new Ji(p,C)
                    }
                    evaluate(n) {
                        for (let l = 0; l < this.args.length; l++) {
                            const p = this.args[l].evaluate(n);
                            if (!Ei(this.type, Sr(p)))
                                return p;
                            if (l === this.args.length - 1)
                                throw new Qn(`Expected value to be of type ${an(this.type)}, but found ${an(Sr(p))} instead.`)
                        }
                        throw new Error
                    }
                    eachChild(n) {
                        this.args.forEach(n)
                    }
                    outputDefined() {
                        return this.args.every(n => n.outputDefined())
                    }
                }
                const sc = {
                    "to-boolean": Ct,
                    "to-color": Gt,
                    "to-number": Xe,
                    "to-string": wt
                };
                class us {
                    constructor(n, l) {
                        this.type = n,
                        this.args = l
                    }
                    static parse(n, l) {
                        if (n.length < 2)
                            return l.error("Expected at least one argument.");
                        const p = n[0];
                        if (!sc[p])
                            throw new Error(`Can't parse ${p} as it is not part of the known types`);
                        if ((p === "to-boolean" || p === "to-string") && n.length !== 2)
                            return l.error("Expected one argument.");
                        const _ = sc[p]
                          , b = [];
                        for (let C = 1; C < n.length; C++) {
                            const M = l.parse(n[C], C, _r);
                            if (!M)
                                return null;
                            b.push(M)
                        }
                        return new us(_,b)
                    }
                    evaluate(n) {
                        switch (this.type.kind) {
                        case "boolean":
                            return !!this.args[0].evaluate(n);
                        case "color":
                            {
                                let l, p;
                                for (const _ of this.args) {
                                    if (l = _.evaluate(n),
                                    p = null,
                                    l instanceof Br)
                                        return l;
                                    if (typeof l == "string") {
                                        const b = n.parseColor(l);
                                        if (b)
                                            return b
                                    } else if (Array.isArray(l) && (p = l.length < 3 || l.length > 4 ? `Invalid rgba value ${JSON.stringify(l)}: expected an array containing either three or four numeric values.` : Fr(l[0], l[1], l[2], l[3]),
                                    !p))
                                        return new Br(l[0] / 255,l[1] / 255,l[2] / 255,l[3])
                                }
                                throw new Qn(p || `Could not parse color from value '${typeof l == "string" ? l : JSON.stringify(l)}'`)
                            }
                        case "padding":
                            {
                                let l;
                                for (const p of this.args) {
                                    l = p.evaluate(n);
                                    const _ = mi.parse(l);
                                    if (_)
                                        return _
                                }
                                throw new Qn(`Could not parse padding from value '${typeof l == "string" ? l : JSON.stringify(l)}'`)
                            }
                        case "numberArray":
                            {
                                let l;
                                for (const p of this.args) {
                                    l = p.evaluate(n);
                                    const _ = Ui.parse(l);
                                    if (_)
                                        return _
                                }
                                throw new Qn(`Could not parse numberArray from value '${typeof l == "string" ? l : JSON.stringify(l)}'`)
                            }
                        case "colorArray":
                            {
                                let l;
                                for (const p of this.args) {
                                    l = p.evaluate(n);
                                    const _ = ii.parse(l);
                                    if (_)
                                        return _
                                }
                                throw new Qn(`Could not parse colorArray from value '${typeof l == "string" ? l : JSON.stringify(l)}'`)
                            }
                        case "variableAnchorOffsetCollection":
                            {
                                let l;
                                for (const p of this.args) {
                                    l = p.evaluate(n);
                                    const _ = Yr.parse(l);
                                    if (_)
                                        return _
                                }
                                throw new Qn(`Could not parse variableAnchorOffsetCollection from value '${typeof l == "string" ? l : JSON.stringify(l)}'`)
                            }
                        case "number":
                            {
                                let l = null;
                                for (const p of this.args) {
                                    if (l = p.evaluate(n),
                                    l === null)
                                        return 0;
                                    const _ = Number(l);
                                    if (!isNaN(_))
                                        return _
                                }
                                throw new Qn(`Could not convert ${JSON.stringify(l)} to number.`)
                            }
                        case "formatted":
                            return ei.fromString($s(this.args[0].evaluate(n)));
                        case "resolvedImage":
                            return mo.fromString($s(this.args[0].evaluate(n)));
                        case "projectionDefinition":
                            return this.args[0].evaluate(n);
                        default:
                            return $s(this.args[0].evaluate(n))
                        }
                    }
                    eachChild(n) {
                        this.args.forEach(n)
                    }
                    outputDefined() {
                        return this.args.every(n => n.outputDefined())
                    }
                }
                const od = ["Unknown", "Point", "LineString", "Polygon"];
                class sa {
                    constructor() {
                        this.globals = null,
                        this.feature = null,
                        this.featureState = null,
                        this.formattedSection = null,
                        this._parseColorCache = new Map,
                        this.availableImages = null,
                        this.canonical = null
                    }
                    id() {
                        return this.feature && "id"in this.feature ? this.feature.id : null
                    }
                    geometryType() {
                        return this.feature ? typeof this.feature.type == "number" ? od[this.feature.type] : this.feature.type : null
                    }
                    geometry() {
                        return this.feature && "geometry"in this.feature ? this.feature.geometry : null
                    }
                    canonicalID() {
                        return this.canonical
                    }
                    properties() {
                        return this.feature && this.feature.properties || {}
                    }
                    parseColor(n) {
                        let l = this._parseColorCache.get(n);
                        return l || (l = Br.parse(n),
                        this._parseColorCache.set(n, l)),
                        l
                    }
                }
                class Sl {
                    constructor(n, l, p=[], _, b=new vt, C=[]) {
                        this.registry = n,
                        this.path = p,
                        this.key = p.map(M => `[${M}]`).join(""),
                        this.scope = b,
                        this.errors = C,
                        this.expectedType = _,
                        this._isConstant = l
                    }
                    parse(n, l, p, _, b={}) {
                        return l ? this.concat(l, p, _)._parse(n, b) : this._parse(n, b)
                    }
                    _parse(n, l) {
                        function p(_, b, C) {
                            return C === "assert" ? new Ji(b,[_]) : C === "coerce" ? new us(b,[_]) : _
                        }
                        if (n !== null && typeof n != "string" && typeof n != "boolean" && typeof n != "number" || (n = ["literal", n]),
                        Array.isArray(n)) {
                            if (n.length === 0)
                                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                            const _ = n[0];
                            if (typeof _ != "string")
                                return this.error(`Expression name must be a string, but found ${typeof _} instead. If you wanted a literal array, use ["literal", [...]].`, 0),
                                null;
                            const b = this.registry[_];
                            if (b) {
                                let C = b.parse(n, this);
                                if (!C)
                                    return null;
                                if (this.expectedType) {
                                    const M = this.expectedType
                                      , R = C.type;
                                    if (M.kind !== "string" && M.kind !== "number" && M.kind !== "boolean" && M.kind !== "object" && M.kind !== "array" || R.kind !== "value") {
                                        if (M.kind === "projectionDefinition" && ["string", "array"].includes(R.kind) || ["color", "formatted", "resolvedImage"].includes(M.kind) && ["value", "string"].includes(R.kind) || ["padding", "numberArray"].includes(M.kind) && ["value", "number", "array"].includes(R.kind) || M.kind === "colorArray" && ["value", "string", "array"].includes(R.kind) || M.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(R.kind))
                                            C = p(C, M, l.typeAnnotation || "coerce");
                                        else if (this.checkSubtype(M, R))
                                            return null
                                    } else
                                        C = p(C, M, l.typeAnnotation || "assert")
                                }
                                if (!(C instanceof go) && C.type.kind !== "resolvedImage" && this._isConstant(C)) {
                                    const M = new sa;
                                    try {
                                        C = new go(C.type,C.evaluate(M))
                                    } catch (R) {
                                        return this.error(R.message),
                                        null
                                    }
                                }
                                return C
                            }
                            return this.error(`Unknown expression "${_}". If you wanted a literal array, use ["literal", [...]].`, 0)
                        }
                        return this.error(n === void 0 ? "'undefined' value invalid. Use null instead." : typeof n == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof n} instead.`)
                    }
                    concat(n, l, p) {
                        const _ = typeof n == "number" ? this.path.concat(n) : this.path
                          , b = p ? this.scope.concat(p) : this.scope;
                        return new Sl(this.registry,this._isConstant,_,l || null,b,this.errors)
                    }
                    error(n, ...l) {
                        const p = `${this.key}${l.map(_ => `[${_}]`).join("")}`;
                        this.errors.push(new Ge(p,n))
                    }
                    checkSubtype(n, l) {
                        const p = Ei(n, l);
                        return p && this.error(p),
                        p
                    }
                }
                class Oa {
                    constructor(n, l) {
                        this.type = l.type,
                        this.bindings = [].concat(n),
                        this.result = l
                    }
                    evaluate(n) {
                        return this.result.evaluate(n)
                    }
                    eachChild(n) {
                        for (const l of this.bindings)
                            n(l[1]);
                        n(this.result)
                    }
                    static parse(n, l) {
                        if (n.length < 4)
                            return l.error(`Expected at least 3 arguments, but found ${n.length - 1} instead.`);
                        const p = [];
                        for (let b = 1; b < n.length - 1; b += 2) {
                            const C = n[b];
                            if (typeof C != "string")
                                return l.error(`Expected string, but found ${typeof C} instead.`, b);
                            if (/[^a-zA-Z0-9_]/.test(C))
                                return l.error("Variable names must contain only alphanumeric characters or '_'.", b);
                            const M = l.parse(n[b + 1], b + 1);
                            if (!M)
                                return null;
                            p.push([C, M])
                        }
                        const _ = l.parse(n[n.length - 1], n.length - 1, l.expectedType, p);
                        return _ ? new Oa(p,_) : null
                    }
                    outputDefined() {
                        return this.result.outputDefined()
                    }
                }
                class hs {
                    constructor(n, l) {
                        this.type = l.type,
                        this.name = n,
                        this.boundExpression = l
                    }
                    static parse(n, l) {
                        if (n.length !== 2 || typeof n[1] != "string")
                            return l.error("'var' expression requires exactly one string literal argument.");
                        const p = n[1];
                        return l.scope.has(p) ? new hs(p,l.scope.get(p)) : l.error(`Unknown variable "${p}". Make sure "${p}" has been bound in an enclosing "let" expression before using it.`, 1)
                    }
                    evaluate(n) {
                        return this.boundExpression.evaluate(n)
                    }
                    eachChild() {}
                    outputDefined() {
                        return !1
                    }
                }
                class ui {
                    constructor(n, l, p) {
                        this.type = n,
                        this.index = l,
                        this.input = p
                    }
                    static parse(n, l) {
                        if (n.length !== 3)
                            return l.error(`Expected 2 arguments, but found ${n.length - 1} instead.`);
                        const p = l.parse(n[1], 1, Xe)
                          , _ = l.parse(n[2], 2, Ln(l.expectedType || _r));
                        return p && _ ? new ui(_.type.itemType,p,_) : null
                    }
                    evaluate(n) {
                        const l = this.index.evaluate(n)
                          , p = this.input.evaluate(n);
                        if (l < 0)
                            throw new Qn(`Array index out of bounds: ${l} < 0.`);
                        if (l >= p.length)
                            throw new Qn(`Array index out of bounds: ${l} > ${p.length - 1}.`);
                        if (l !== Math.floor(l))
                            throw new Qn(`Array index must be an integer, but found ${l} instead.`);
                        return p[l]
                    }
                    eachChild(n) {
                        n(this.index),
                        n(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class aa {
                    constructor(n, l) {
                        this.type = Ct,
                        this.needle = n,
                        this.haystack = l
                    }
                    static parse(n, l) {
                        if (n.length !== 3)
                            return l.error(`Expected 2 arguments, but found ${n.length - 1} instead.`);
                        const p = l.parse(n[1], 1, _r)
                          , _ = l.parse(n[2], 2, _r);
                        return p && _ ? Ao(p.type, [Ct, wt, Xe, it, _r]) ? new aa(p,_) : l.error(`Expected first argument to be of type boolean, string, number or null, but found ${an(p.type)} instead`) : null
                    }
                    evaluate(n) {
                        const l = this.needle.evaluate(n)
                          , p = this.haystack.evaluate(n);
                        if (!p)
                            return !1;
                        if (!Hn(l, ["boolean", "string", "number", "null"]))
                            throw new Qn(`Expected first argument to be of type boolean, string, number or null, but found ${an(Sr(l))} instead.`);
                        if (!Hn(p, ["string", "array"]))
                            throw new Qn(`Expected second argument to be of type array or string, but found ${an(Sr(p))} instead.`);
                        return p.indexOf(l) >= 0
                    }
                    eachChild(n) {
                        n(this.needle),
                        n(this.haystack)
                    }
                    outputDefined() {
                        return !0
                    }
                }
                class ac {
                    constructor(n, l, p) {
                        this.type = Xe,
                        this.needle = n,
                        this.haystack = l,
                        this.fromIndex = p
                    }
                    static parse(n, l) {
                        if (n.length <= 2 || n.length >= 5)
                            return l.error(`Expected 3 or 4 arguments, but found ${n.length - 1} instead.`);
                        const p = l.parse(n[1], 1, _r)
                          , _ = l.parse(n[2], 2, _r);
                        if (!p || !_)
                            return null;
                        if (!Ao(p.type, [Ct, wt, Xe, it, _r]))
                            return l.error(`Expected first argument to be of type boolean, string, number or null, but found ${an(p.type)} instead`);
                        if (n.length === 4) {
                            const b = l.parse(n[3], 3, Xe);
                            return b ? new ac(p,_,b) : null
                        }
                        return new ac(p,_)
                    }
                    evaluate(n) {
                        const l = this.needle.evaluate(n)
                          , p = this.haystack.evaluate(n);
                        if (!Hn(l, ["boolean", "string", "number", "null"]))
                            throw new Qn(`Expected first argument to be of type boolean, string, number or null, but found ${an(Sr(l))} instead.`);
                        let _;
                        if (this.fromIndex && (_ = this.fromIndex.evaluate(n)),
                        Hn(p, ["string"])) {
                            const b = p.indexOf(l, _);
                            return b === -1 ? -1 : [...p.slice(0, b)].length
                        }
                        if (Hn(p, ["array"]))
                            return p.indexOf(l, _);
                        throw new Qn(`Expected second argument to be of type array or string, but found ${an(Sr(p))} instead.`)
                    }
                    eachChild(n) {
                        n(this.needle),
                        n(this.haystack),
                        this.fromIndex && n(this.fromIndex)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class Ii {
                    constructor(n, l, p, _, b, C) {
                        this.inputType = n,
                        this.type = l,
                        this.input = p,
                        this.cases = _,
                        this.outputs = b,
                        this.otherwise = C
                    }
                    static parse(n, l) {
                        if (n.length < 5)
                            return l.error(`Expected at least 4 arguments, but found only ${n.length - 1}.`);
                        if (n.length % 2 != 1)
                            return l.error("Expected an even number of arguments.");
                        let p, _;
                        l.expectedType && l.expectedType.kind !== "value" && (_ = l.expectedType);
                        const b = {}
                          , C = [];
                        for (let O = 2; O < n.length - 1; O += 2) {
                            let j = n[O];
                            const q = n[O + 1];
                            Array.isArray(j) || (j = [j]);
                            const Q = l.concat(O);
                            if (j.length === 0)
                                return Q.error("Expected at least one branch label.");
                            for (const oe of j) {
                                if (typeof oe != "number" && typeof oe != "string")
                                    return Q.error("Branch labels must be numbers or strings.");
                                if (typeof oe == "number" && Math.abs(oe) > Number.MAX_SAFE_INTEGER)
                                    return Q.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                                if (typeof oe == "number" && Math.floor(oe) !== oe)
                                    return Q.error("Numeric branch labels must be integer values.");
                                if (p) {
                                    if (Q.checkSubtype(p, Sr(oe)))
                                        return null
                                } else
                                    p = Sr(oe);
                                if (b[String(oe)] !== void 0)
                                    return Q.error("Branch labels must be unique.");
                                b[String(oe)] = C.length
                            }
                            const ne = l.parse(q, O, _);
                            if (!ne)
                                return null;
                            _ = _ || ne.type,
                            C.push(ne)
                        }
                        const M = l.parse(n[1], 1, _r);
                        if (!M)
                            return null;
                        const R = l.parse(n[n.length - 1], n.length - 1, _);
                        return R ? M.type.kind !== "value" && l.concat(1).checkSubtype(p, M.type) ? null : new Ii(p,_,M,b,C,R) : null
                    }
                    evaluate(n) {
                        const l = this.input.evaluate(n);
                        return (Sr(l) === this.inputType && this.outputs[this.cases[l]] || this.otherwise).evaluate(n)
                    }
                    eachChild(n) {
                        n(this.input),
                        this.outputs.forEach(n),
                        n(this.otherwise)
                    }
                    outputDefined() {
                        return this.outputs.every(n => n.outputDefined()) && this.otherwise.outputDefined()
                    }
                }
                class Zn {
                    constructor(n, l, p) {
                        this.type = n,
                        this.branches = l,
                        this.otherwise = p
                    }
                    static parse(n, l) {
                        if (n.length < 4)
                            return l.error(`Expected at least 3 arguments, but found only ${n.length - 1}.`);
                        if (n.length % 2 != 0)
                            return l.error("Expected an odd number of arguments.");
                        let p;
                        l.expectedType && l.expectedType.kind !== "value" && (p = l.expectedType);
                        const _ = [];
                        for (let C = 1; C < n.length - 1; C += 2) {
                            const M = l.parse(n[C], C, Ct);
                            if (!M)
                                return null;
                            const R = l.parse(n[C + 1], C + 1, p);
                            if (!R)
                                return null;
                            _.push([M, R]),
                            p = p || R.type
                        }
                        const b = l.parse(n[n.length - 1], n.length - 1, p);
                        if (!b)
                            return null;
                        if (!p)
                            throw new Error("Can't infer output type");
                        return new Zn(p,_,b)
                    }
                    evaluate(n) {
                        for (const [l,p] of this.branches)
                            if (l.evaluate(n))
                                return p.evaluate(n);
                        return this.otherwise.evaluate(n)
                    }
                    eachChild(n) {
                        for (const [l,p] of this.branches)
                            n(l),
                            n(p);
                        n(this.otherwise)
                    }
                    outputDefined() {
                        return this.branches.every( ([n,l]) => l.outputDefined()) && this.otherwise.outputDefined()
                    }
                }
                class Cl {
                    constructor(n, l, p, _) {
                        this.type = n,
                        this.input = l,
                        this.beginIndex = p,
                        this.endIndex = _
                    }
                    static parse(n, l) {
                        if (n.length <= 2 || n.length >= 5)
                            return l.error(`Expected 3 or 4 arguments, but found ${n.length - 1} instead.`);
                        const p = l.parse(n[1], 1, _r)
                          , _ = l.parse(n[2], 2, Xe);
                        if (!p || !_)
                            return null;
                        if (!Ao(p.type, [Ln(_r), wt, _r]))
                            return l.error(`Expected first argument to be of type array or string, but found ${an(p.type)} instead`);
                        if (n.length === 4) {
                            const b = l.parse(n[3], 3, Xe);
                            return b ? new Cl(p.type,p,_,b) : null
                        }
                        return new Cl(p.type,p,_)
                    }
                    evaluate(n) {
                        const l = this.input.evaluate(n)
                          , p = this.beginIndex.evaluate(n);
                        let _;
                        if (this.endIndex && (_ = this.endIndex.evaluate(n)),
                        Hn(l, ["string"]))
                            return [...l].slice(p, _).join("");
                        if (Hn(l, ["array"]))
                            return l.slice(p, _);
                        throw new Qn(`Expected first argument to be of type array or string, but found ${an(Sr(l))} instead.`)
                    }
                    eachChild(n) {
                        n(this.input),
                        n(this.beginIndex),
                        this.endIndex && n(this.endIndex)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                function Vs(c, n) {
                    const l = c.length - 1;
                    let p, _, b = 0, C = l, M = 0;
                    for (; b <= C; )
                        if (M = Math.floor((b + C) / 2),
                        p = c[M],
                        _ = c[M + 1],
                        p <= n) {
                            if (M === l || n < _)
                                return M;
                            b = M + 1
                        } else {
                            if (!(p > n))
                                throw new Qn("Input is not a number.");
                            C = M - 1
                        }
                    return 0
                }
                class lc {
                    constructor(n, l, p) {
                        this.type = n,
                        this.input = l,
                        this.labels = [],
                        this.outputs = [];
                        for (const [_,b] of p)
                            this.labels.push(_),
                            this.outputs.push(b)
                    }
                    static parse(n, l) {
                        if (n.length - 1 < 4)
                            return l.error(`Expected at least 4 arguments, but found only ${n.length - 1}.`);
                        if ((n.length - 1) % 2 != 0)
                            return l.error("Expected an even number of arguments.");
                        const p = l.parse(n[1], 1, Xe);
                        if (!p)
                            return null;
                        const _ = [];
                        let b = null;
                        l.expectedType && l.expectedType.kind !== "value" && (b = l.expectedType);
                        for (let C = 1; C < n.length; C += 2) {
                            const M = C === 1 ? -1 / 0 : n[C]
                              , R = n[C + 1]
                              , O = C
                              , j = C + 1;
                            if (typeof M != "number")
                                return l.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', O);
                            if (_.length && _[_.length - 1][0] >= M)
                                return l.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', O);
                            const q = l.parse(R, j, b);
                            if (!q)
                                return null;
                            b = b || q.type,
                            _.push([M, q])
                        }
                        return new lc(b,p,_)
                    }
                    evaluate(n) {
                        const l = this.labels
                          , p = this.outputs;
                        if (l.length === 1)
                            return p[0].evaluate(n);
                        const _ = this.input.evaluate(n);
                        if (_ <= l[0])
                            return p[0].evaluate(n);
                        const b = l.length;
                        return _ >= l[b - 1] ? p[b - 1].evaluate(n) : p[Vs(l, _)].evaluate(n)
                    }
                    eachChild(n) {
                        n(this.input);
                        for (const l of this.outputs)
                            n(l)
                    }
                    outputDefined() {
                        return this.outputs.every(n => n.outputDefined())
                    }
                }
                function sd(c) {
                    return c && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c
                }
                var Us, la, cc = function() {
                    if (la)
                        return Us;
                    function c(n, l, p, _) {
                        this.cx = 3 * n,
                        this.bx = 3 * (p - n) - this.cx,
                        this.ax = 1 - this.cx - this.bx,
                        this.cy = 3 * l,
                        this.by = 3 * (_ - l) - this.cy,
                        this.ay = 1 - this.cy - this.by,
                        this.p1x = n,
                        this.p1y = l,
                        this.p2x = p,
                        this.p2y = _
                    }
                    return la = 1,
                    Us = c,
                    c.prototype = {
                        sampleCurveX: function(n) {
                            return ((this.ax * n + this.bx) * n + this.cx) * n
                        },
                        sampleCurveY: function(n) {
                            return ((this.ay * n + this.by) * n + this.cy) * n
                        },
                        sampleCurveDerivativeX: function(n) {
                            return (3 * this.ax * n + 2 * this.bx) * n + this.cx
                        },
                        solveCurveX: function(n, l) {
                            if (l === void 0 && (l = 1e-6),
                            n < 0)
                                return 0;
                            if (n > 1)
                                return 1;
                            for (var p = n, _ = 0; _ < 8; _++) {
                                var b = this.sampleCurveX(p) - n;
                                if (Math.abs(b) < l)
                                    return p;
                                var C = this.sampleCurveDerivativeX(p);
                                if (Math.abs(C) < 1e-6)
                                    break;
                                p -= b / C
                            }
                            var M = 0
                              , R = 1;
                            for (p = n,
                            _ = 0; _ < 20 && (b = this.sampleCurveX(p),
                            !(Math.abs(b - n) < l)); _++)
                                n > b ? M = p : R = p,
                                p = .5 * (R - M) + M;
                            return p
                        },
                        solve: function(n, l) {
                            return this.sampleCurveY(this.solveCurveX(n, l))
                        }
                    },
                    Us
                }(), Sf = sd(cc);
                class yo {
                    constructor(n, l, p, _, b) {
                        this.type = n,
                        this.operator = l,
                        this.interpolation = p,
                        this.input = _,
                        this.labels = [],
                        this.outputs = [];
                        for (const [C,M] of b)
                            this.labels.push(C),
                            this.outputs.push(M)
                    }
                    static interpolationFactor(n, l, p, _) {
                        let b = 0;
                        if (n.name === "exponential")
                            b = uc(l, n.base, p, _);
                        else if (n.name === "linear")
                            b = uc(l, 1, p, _);
                        else if (n.name === "cubic-bezier") {
                            const C = n.controlPoints;
                            b = new Sf(C[0],C[1],C[2],C[3]).solve(uc(l, 1, p, _))
                        }
                        return b
                    }
                    static parse(n, l) {
                        let[p,_,b,...C] = n;
                        if (!Array.isArray(_) || _.length === 0)
                            return l.error("Expected an interpolation type expression.", 1);
                        if (_[0] === "linear")
                            _ = {
                                name: "linear"
                            };
                        else if (_[0] === "exponential") {
                            const O = _[1];
                            if (typeof O != "number")
                                return l.error("Exponential interpolation requires a numeric base.", 1, 1);
                            _ = {
                                name: "exponential",
                                base: O
                            }
                        } else {
                            if (_[0] !== "cubic-bezier")
                                return l.error(`Unknown interpolation type ${String(_[0])}`, 1, 0);
                            {
                                const O = _.slice(1);
                                if (O.length !== 4 || O.some(j => typeof j != "number" || j < 0 || j > 1))
                                    return l.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                                _ = {
                                    name: "cubic-bezier",
                                    controlPoints: O
                                }
                            }
                        }
                        if (n.length - 1 < 4)
                            return l.error(`Expected at least 4 arguments, but found only ${n.length - 1}.`);
                        if ((n.length - 1) % 2 != 0)
                            return l.error("Expected an even number of arguments.");
                        if (b = l.parse(b, 2, Xe),
                        !b)
                            return null;
                        const M = [];
                        let R = null;
                        p !== "interpolate-hcl" && p !== "interpolate-lab" || l.expectedType == ci ? l.expectedType && l.expectedType.kind !== "value" && (R = l.expectedType) : R = Gt;
                        for (let O = 0; O < C.length; O += 2) {
                            const j = C[O]
                              , q = C[O + 1]
                              , Q = O + 3
                              , ne = O + 4;
                            if (typeof j != "number")
                                return l.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', Q);
                            if (M.length && M[M.length - 1][0] >= j)
                                return l.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', Q);
                            const oe = l.parse(q, ne, R);
                            if (!oe)
                                return null;
                            R = R || oe.type,
                            M.push([j, oe])
                        }
                        return Go(R, Xe) || Go(R, Xt) || Go(R, Gt) || Go(R, kr) || Go(R, Si) || Go(R, ci) || Go(R, Ro) || Go(R, Ln(Xe)) ? new yo(R,p,_,b,M) : l.error(`Type ${an(R)} is not interpolatable.`)
                    }
                    evaluate(n) {
                        const l = this.labels
                          , p = this.outputs;
                        if (l.length === 1)
                            return p[0].evaluate(n);
                        const _ = this.input.evaluate(n);
                        if (_ <= l[0])
                            return p[0].evaluate(n);
                        const b = l.length;
                        if (_ >= l[b - 1])
                            return p[b - 1].evaluate(n);
                        const C = Vs(l, _)
                          , M = yo.interpolationFactor(this.interpolation, _, l[C], l[C + 1])
                          , R = p[C].evaluate(n)
                          , O = p[C + 1].evaluate(n);
                        switch (this.operator) {
                        case "interpolate":
                            switch (this.type.kind) {
                            case "number":
                                return po(R, O, M);
                            case "color":
                                return Br.interpolate(R, O, M);
                            case "padding":
                                return mi.interpolate(R, O, M);
                            case "colorArray":
                                return ii.interpolate(R, O, M);
                            case "numberArray":
                                return Ui.interpolate(R, O, M);
                            case "variableAnchorOffsetCollection":
                                return Yr.interpolate(R, O, M);
                            case "array":
                                return Qi(R, O, M);
                            case "projectionDefinition":
                                return jr.interpolate(R, O, M)
                            }
                        case "interpolate-hcl":
                            switch (this.type.kind) {
                            case "color":
                                return Br.interpolate(R, O, M, "hcl");
                            case "colorArray":
                                return ii.interpolate(R, O, M, "hcl")
                            }
                        case "interpolate-lab":
                            switch (this.type.kind) {
                            case "color":
                                return Br.interpolate(R, O, M, "lab");
                            case "colorArray":
                                return ii.interpolate(R, O, M, "lab")
                            }
                        }
                    }
                    eachChild(n) {
                        n(this.input);
                        for (const l of this.outputs)
                            n(l)
                    }
                    outputDefined() {
                        return this.outputs.every(n => n.outputDefined())
                    }
                }
                function uc(c, n, l, p) {
                    const _ = p - l
                      , b = c - l;
                    return _ === 0 ? 0 : n === 1 ? b / _ : (Math.pow(n, b) - 1) / (Math.pow(n, _) - 1)
                }
                const Xo = {
                    color: Br.interpolate,
                    number: po,
                    padding: mi.interpolate,
                    numberArray: Ui.interpolate,
                    colorArray: ii.interpolate,
                    variableAnchorOffsetCollection: Yr.interpolate,
                    array: Qi
                };
                class eo {
                    constructor(n, l) {
                        this.type = n,
                        this.args = l
                    }
                    static parse(n, l) {
                        if (n.length < 2)
                            return l.error("Expected at least one argument.");
                        let p = null;
                        const _ = l.expectedType;
                        _ && _.kind !== "value" && (p = _);
                        const b = [];
                        for (const M of n.slice(1)) {
                            const R = l.parse(M, 1 + b.length, p, void 0, {
                                typeAnnotation: "omit"
                            });
                            if (!R)
                                return null;
                            p = p || R.type,
                            b.push(R)
                        }
                        if (!p)
                            throw new Error("No output type");
                        const C = _ && b.some(M => Ei(_, M.type));
                        return new eo(C ? _r : p,b)
                    }
                    evaluate(n) {
                        let l, p = null, _ = 0;
                        for (const b of this.args)
                            if (_++,
                            p = b.evaluate(n),
                            p && p instanceof mo && !p.available && (l || (l = p.name),
                            p = null,
                            _ === this.args.length && (p = l)),
                            p !== null)
                                break;
                        return p
                    }
                    eachChild(n) {
                        this.args.forEach(n)
                    }
                    outputDefined() {
                        return this.args.every(n => n.outputDefined())
                    }
                }
                function ad(c, n) {
                    return c === "==" || c === "!=" ? n.kind === "boolean" || n.kind === "string" || n.kind === "number" || n.kind === "null" || n.kind === "value" : n.kind === "string" || n.kind === "number" || n.kind === "value"
                }
                function cu(c, n, l, p) {
                    return p.compare(n, l) === 0
                }
                function hc(c, n, l) {
                    const p = c !== "==" && c !== "!=";
                    return class pC {
                        constructor(b, C, M) {
                            this.type = Ct,
                            this.lhs = b,
                            this.rhs = C,
                            this.collator = M,
                            this.hasUntypedArgument = b.type.kind === "value" || C.type.kind === "value"
                        }
                        static parse(b, C) {
                            if (b.length !== 3 && b.length !== 4)
                                return C.error("Expected two or three arguments.");
                            const M = b[0];
                            let R = C.parse(b[1], 1, _r);
                            if (!R)
                                return null;
                            if (!ad(M, R.type))
                                return C.concat(1).error(`"${M}" comparisons are not supported for type '${an(R.type)}'.`);
                            let O = C.parse(b[2], 2, _r);
                            if (!O)
                                return null;
                            if (!ad(M, O.type))
                                return C.concat(2).error(`"${M}" comparisons are not supported for type '${an(O.type)}'.`);
                            if (R.type.kind !== O.type.kind && R.type.kind !== "value" && O.type.kind !== "value")
                                return C.error(`Cannot compare types '${an(R.type)}' and '${an(O.type)}'.`);
                            p && (R.type.kind === "value" && O.type.kind !== "value" ? R = new Ji(O.type,[R]) : R.type.kind !== "value" && O.type.kind === "value" && (O = new Ji(R.type,[O])));
                            let j = null;
                            if (b.length === 4) {
                                if (R.type.kind !== "string" && O.type.kind !== "string" && R.type.kind !== "value" && O.type.kind !== "value")
                                    return C.error("Cannot use collator to compare non-string types.");
                                if (j = C.parse(b[3], 3, ri),
                                !j)
                                    return null
                            }
                            return new pC(R,O,j)
                        }
                        evaluate(b) {
                            const C = this.lhs.evaluate(b)
                              , M = this.rhs.evaluate(b);
                            if (p && this.hasUntypedArgument) {
                                const R = Sr(C)
                                  , O = Sr(M);
                                if (R.kind !== O.kind || R.kind !== "string" && R.kind !== "number")
                                    throw new Qn(`Expected arguments for "${c}" to be (string, string) or (number, number), but found (${R.kind}, ${O.kind}) instead.`)
                            }
                            if (this.collator && !p && this.hasUntypedArgument) {
                                const R = Sr(C)
                                  , O = Sr(M);
                                if (R.kind !== "string" || O.kind !== "string")
                                    return n(b, C, M)
                            }
                            return this.collator ? l(b, C, M, this.collator.evaluate(b)) : n(b, C, M)
                        }
                        eachChild(b) {
                            b(this.lhs),
                            b(this.rhs),
                            this.collator && b(this.collator)
                        }
                        outputDefined() {
                            return !0
                        }
                    }
                }
                const ld = hc("==", function(c, n, l) {
                    return n === l
                }, cu)
                  , nm = hc("!=", function(c, n, l) {
                    return n !== l
                }, function(c, n, l, p) {
                    return !cu(0, n, l, p)
                })
                  , Cf = hc("<", function(c, n, l) {
                    return n < l
                }, function(c, n, l, p) {
                    return p.compare(n, l) < 0
                })
                  , im = hc(">", function(c, n, l) {
                    return n > l
                }, function(c, n, l, p) {
                    return p.compare(n, l) > 0
                })
                  , om = hc("<=", function(c, n, l) {
                    return n <= l
                }, function(c, n, l, p) {
                    return p.compare(n, l) <= 0
                })
                  , uh = hc(">=", function(c, n, l) {
                    return n >= l
                }, function(c, n, l, p) {
                    return p.compare(n, l) >= 0
                });
                class hh {
                    constructor(n, l, p) {
                        this.type = ri,
                        this.locale = p,
                        this.caseSensitive = n,
                        this.diacriticSensitive = l
                    }
                    static parse(n, l) {
                        if (n.length !== 2)
                            return l.error("Expected one argument.");
                        const p = n[1];
                        if (typeof p != "object" || Array.isArray(p))
                            return l.error("Collator options argument must be an object.");
                        const _ = l.parse(p["case-sensitive"] !== void 0 && p["case-sensitive"], 1, Ct);
                        if (!_)
                            return null;
                        const b = l.parse(p["diacritic-sensitive"] !== void 0 && p["diacritic-sensitive"], 1, Ct);
                        if (!b)
                            return null;
                        let C = null;
                        return p.locale && (C = l.parse(p.locale, 1, wt),
                        !C) ? null : new hh(_,b,C)
                    }
                    evaluate(n) {
                        return new cs(this.caseSensitive.evaluate(n),this.diacriticSensitive.evaluate(n),this.locale ? this.locale.evaluate(n) : null)
                    }
                    eachChild(n) {
                        n(this.caseSensitive),
                        n(this.diacriticSensitive),
                        this.locale && n(this.locale)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class dc {
                    constructor(n, l, p, _, b) {
                        this.type = wt,
                        this.number = n,
                        this.locale = l,
                        this.currency = p,
                        this.minFractionDigits = _,
                        this.maxFractionDigits = b
                    }
                    static parse(n, l) {
                        if (n.length !== 3)
                            return l.error("Expected two arguments.");
                        const p = l.parse(n[1], 1, Xe);
                        if (!p)
                            return null;
                        const _ = n[2];
                        if (typeof _ != "object" || Array.isArray(_))
                            return l.error("NumberFormat options argument must be an object.");
                        let b = null;
                        if (_.locale && (b = l.parse(_.locale, 1, wt),
                        !b))
                            return null;
                        let C = null;
                        if (_.currency && (C = l.parse(_.currency, 1, wt),
                        !C))
                            return null;
                        let M = null;
                        if (_["min-fraction-digits"] && (M = l.parse(_["min-fraction-digits"], 1, Xe),
                        !M))
                            return null;
                        let R = null;
                        return _["max-fraction-digits"] && (R = l.parse(_["max-fraction-digits"], 1, Xe),
                        !R) ? null : new dc(p,b,C,M,R)
                    }
                    evaluate(n) {
                        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(n) : [],{
                            style: this.currency ? "currency" : "decimal",
                            currency: this.currency ? this.currency.evaluate(n) : void 0,
                            minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(n) : void 0,
                            maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(n) : void 0
                        }).format(this.number.evaluate(n))
                    }
                    eachChild(n) {
                        n(this.number),
                        this.locale && n(this.locale),
                        this.currency && n(this.currency),
                        this.minFractionDigits && n(this.minFractionDigits),
                        this.maxFractionDigits && n(this.maxFractionDigits)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class uu {
                    constructor(n) {
                        this.type = ni,
                        this.sections = n
                    }
                    static parse(n, l) {
                        if (n.length < 2)
                            return l.error("Expected at least one argument.");
                        const p = n[1];
                        if (!Array.isArray(p) && typeof p == "object")
                            return l.error("First argument must be an image or text section.");
                        const _ = [];
                        let b = !1;
                        for (let C = 1; C <= n.length - 1; ++C) {
                            const M = n[C];
                            if (b && typeof M == "object" && !Array.isArray(M)) {
                                b = !1;
                                let R = null;
                                if (M["font-scale"] && (R = l.parse(M["font-scale"], 1, Xe),
                                !R))
                                    return null;
                                let O = null;
                                if (M["text-font"] && (O = l.parse(M["text-font"], 1, Ln(wt)),
                                !O))
                                    return null;
                                let j = null;
                                if (M["text-color"] && (j = l.parse(M["text-color"], 1, Gt),
                                !j))
                                    return null;
                                let q = null;
                                if (M["vertical-align"]) {
                                    if (typeof M["vertical-align"] == "string" && !La.includes(M["vertical-align"]))
                                        return l.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${M["vertical-align"]}' instead.`);
                                    if (q = l.parse(M["vertical-align"], 1, wt),
                                    !q)
                                        return null
                                }
                                const Q = _[_.length - 1];
                                Q.scale = R,
                                Q.font = O,
                                Q.textColor = j,
                                Q.verticalAlign = q
                            } else {
                                const R = l.parse(n[C], 1, _r);
                                if (!R)
                                    return null;
                                const O = R.type.kind;
                                if (O !== "string" && O !== "value" && O !== "null" && O !== "resolvedImage")
                                    return l.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                                b = !0,
                                _.push({
                                    content: R,
                                    scale: null,
                                    font: null,
                                    textColor: null,
                                    verticalAlign: null
                                })
                            }
                        }
                        return new uu(_)
                    }
                    evaluate(n) {
                        return new ei(this.sections.map(l => {
                            const p = l.content.evaluate(n);
                            return Sr(p) === $i ? new wl("",p,null,null,null,l.verticalAlign ? l.verticalAlign.evaluate(n) : null) : new wl($s(p),null,l.scale ? l.scale.evaluate(n) : null,l.font ? l.font.evaluate(n).join(",") : null,l.textColor ? l.textColor.evaluate(n) : null,l.verticalAlign ? l.verticalAlign.evaluate(n) : null)
                        }
                        ))
                    }
                    eachChild(n) {
                        for (const l of this.sections)
                            n(l.content),
                            l.scale && n(l.scale),
                            l.font && n(l.font),
                            l.textColor && n(l.textColor),
                            l.verticalAlign && n(l.verticalAlign)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class cd {
                    constructor(n) {
                        this.type = $i,
                        this.input = n
                    }
                    static parse(n, l) {
                        if (n.length !== 2)
                            return l.error("Expected two arguments.");
                        const p = l.parse(n[1], 1, wt);
                        return p ? new cd(p) : l.error("No image name provided.")
                    }
                    evaluate(n) {
                        const l = this.input.evaluate(n)
                          , p = mo.fromString(l);
                        return p && n.availableImages && (p.available = n.availableImages.indexOf(l) > -1),
                        p
                    }
                    eachChild(n) {
                        n(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class dh {
                    constructor(n) {
                        this.type = Xe,
                        this.input = n
                    }
                    static parse(n, l) {
                        if (n.length !== 2)
                            return l.error(`Expected 1 argument, but found ${n.length - 1} instead.`);
                        const p = l.parse(n[1], 1);
                        return p ? p.type.kind !== "array" && p.type.kind !== "string" && p.type.kind !== "value" ? l.error(`Expected argument of type string or array, but found ${an(p.type)} instead.`) : new dh(p) : null
                    }
                    evaluate(n) {
                        const l = this.input.evaluate(n);
                        if (typeof l == "string")
                            return [...l].length;
                        if (Array.isArray(l))
                            return l.length;
                        throw new Qn(`Expected value to be of type string or array, but found ${an(Sr(l))} instead.`)
                    }
                    eachChild(n) {
                        n(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                const Ts = 8192;
                function sm(c, n) {
                    const l = (180 + c[0]) / 360
                      , p = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + c[1] * Math.PI / 360))) / 360
                      , _ = Math.pow(2, n.z);
                    return [Math.round(l * _ * Ts), Math.round(p * _ * Ts)]
                }
                function ud(c, n) {
                    const l = Math.pow(2, n.z);
                    return [(_ = (c[0] / Ts + n.x) / l,
                    360 * _ - 180), (p = (c[1] / Ts + n.y) / l,
                    360 / Math.PI * Math.atan(Math.exp((180 - 360 * p) * Math.PI / 180)) - 90)];
                    var p, _
                }
                function hu(c, n) {
                    c[0] = Math.min(c[0], n[0]),
                    c[1] = Math.min(c[1], n[1]),
                    c[2] = Math.max(c[2], n[0]),
                    c[3] = Math.max(c[3], n[1])
                }
                function du(c, n) {
                    return !(c[0] <= n[0] || c[2] >= n[2] || c[1] <= n[1] || c[3] >= n[3])
                }
                function Tf(c, n, l) {
                    const p = c[0] - n[0]
                      , _ = c[1] - n[1]
                      , b = c[0] - l[0]
                      , C = c[1] - l[1];
                    return p * C - b * _ == 0 && p * b <= 0 && _ * C <= 0
                }
                function fu(c, n, l, p) {
                    return (_ = [p[0] - l[0], p[1] - l[1]])[0] * (b = [n[0] - c[0], n[1] - c[1]])[1] - _[1] * b[0] != 0 && !(!mu(c, n, l, p) || !mu(l, p, c, n));
                    var _, b
                }
                function Pf(c, n, l) {
                    for (const p of l)
                        for (let _ = 0; _ < p.length - 1; ++_)
                            if (fu(c, n, p[_], p[_ + 1]))
                                return !0;
                    return !1
                }
                function Fa(c, n, l=!1) {
                    let p = !1;
                    for (const M of n)
                        for (let R = 0; R < M.length - 1; R++) {
                            if (Tf(c, M[R], M[R + 1]))
                                return l;
                            (b = M[R])[1] > (_ = c)[1] != (C = M[R + 1])[1] > _[1] && _[0] < (C[0] - b[0]) * (_[1] - b[1]) / (C[1] - b[1]) + b[0] && (p = !p)
                        }
                    var _, b, C;
                    return p
                }
                function pu(c, n) {
                    for (const l of n)
                        if (Fa(c, l))
                            return !0;
                    return !1
                }
                function Mf(c, n) {
                    for (const l of c)
                        if (!Fa(l, n))
                            return !1;
                    for (let l = 0; l < c.length - 1; ++l)
                        if (Pf(c[l], c[l + 1], n))
                            return !1;
                    return !0
                }
                function kf(c, n) {
                    for (const l of n)
                        if (Mf(c, l))
                            return !0;
                    return !1
                }
                function mu(c, n, l, p) {
                    const _ = p[0] - l[0]
                      , b = p[1] - l[1]
                      , C = (c[0] - l[0]) * b - _ * (c[1] - l[1])
                      , M = (n[0] - l[0]) * b - _ * (n[1] - l[1]);
                    return C > 0 && M < 0 || C < 0 && M > 0
                }
                function fh(c, n, l) {
                    const p = [];
                    for (let _ = 0; _ < c.length; _++) {
                        const b = [];
                        for (let C = 0; C < c[_].length; C++) {
                            const M = sm(c[_][C], l);
                            hu(n, M),
                            b.push(M)
                        }
                        p.push(b)
                    }
                    return p
                }
                function hd(c, n, l) {
                    const p = [];
                    for (let _ = 0; _ < c.length; _++) {
                        const b = fh(c[_], n, l);
                        p.push(b)
                    }
                    return p
                }
                function dd(c, n, l, p) {
                    if (c[0] < l[0] || c[0] > l[2]) {
                        const _ = .5 * p;
                        let b = c[0] - l[0] > _ ? -p : l[0] - c[0] > _ ? p : 0;
                        b === 0 && (b = c[0] - l[2] > _ ? -p : l[2] - c[0] > _ ? p : 0),
                        c[0] += b
                    }
                    hu(n, c)
                }
                function Ba(c, n, l, p) {
                    const _ = Math.pow(2, p.z) * Ts
                      , b = [p.x * Ts, p.y * Ts]
                      , C = [];
                    for (const M of c)
                        for (const R of M) {
                            const O = [R.x + b[0], R.y + b[1]];
                            dd(O, n, l, _),
                            C.push(O)
                        }
                    return C
                }
                function fd(c, n, l, p) {
                    const _ = Math.pow(2, p.z) * Ts
                      , b = [p.x * Ts, p.y * Ts]
                      , C = [];
                    for (const R of c) {
                        const O = [];
                        for (const j of R) {
                            const q = [j.x + b[0], j.y + b[1]];
                            hu(n, q),
                            O.push(q)
                        }
                        C.push(O)
                    }
                    if (n[2] - n[0] <= _ / 2) {
                        (M = n)[0] = M[1] = 1 / 0,
                        M[2] = M[3] = -1 / 0;
                        for (const R of C)
                            for (const O of R)
                                dd(O, n, l, _)
                    }
                    var M;
                    return C
                }
                class Tl {
                    constructor(n, l) {
                        this.type = Ct,
                        this.geojson = n,
                        this.geometries = l
                    }
                    static parse(n, l) {
                        if (n.length !== 2)
                            return l.error(`'within' expression requires exactly one argument, but found ${n.length - 1} instead.`);
                        if (Cs(n[1])) {
                            const p = n[1];
                            if (p.type === "FeatureCollection") {
                                const _ = [];
                                for (const b of p.features) {
                                    const {type: C, coordinates: M} = b.geometry;
                                    C === "Polygon" && _.push(M),
                                    C === "MultiPolygon" && _.push(...M)
                                }
                                if (_.length)
                                    return new Tl(p,{
                                        type: "MultiPolygon",
                                        coordinates: _
                                    })
                            } else if (p.type === "Feature") {
                                const _ = p.geometry.type;
                                if (_ === "Polygon" || _ === "MultiPolygon")
                                    return new Tl(p,p.geometry)
                            } else if (p.type === "Polygon" || p.type === "MultiPolygon")
                                return new Tl(p,p)
                        }
                        return l.error("'within' expression requires valid geojson object that contains polygon geometry type.")
                    }
                    evaluate(n) {
                        if (n.geometry() != null && n.canonicalID() != null) {
                            if (n.geometryType() === "Point")
                                return function(l, p) {
                                    const _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , b = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , C = l.canonicalID();
                                    if (p.type === "Polygon") {
                                        const M = fh(p.coordinates, b, C)
                                          , R = Ba(l.geometry(), _, b, C);
                                        if (!du(_, b))
                                            return !1;
                                        for (const O of R)
                                            if (!Fa(O, M))
                                                return !1
                                    }
                                    if (p.type === "MultiPolygon") {
                                        const M = hd(p.coordinates, b, C)
                                          , R = Ba(l.geometry(), _, b, C);
                                        if (!du(_, b))
                                            return !1;
                                        for (const O of R)
                                            if (!pu(O, M))
                                                return !1
                                    }
                                    return !0
                                }(n, this.geometries);
                            if (n.geometryType() === "LineString")
                                return function(l, p) {
                                    const _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , b = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , C = l.canonicalID();
                                    if (p.type === "Polygon") {
                                        const M = fh(p.coordinates, b, C)
                                          , R = fd(l.geometry(), _, b, C);
                                        if (!du(_, b))
                                            return !1;
                                        for (const O of R)
                                            if (!Mf(O, M))
                                                return !1
                                    }
                                    if (p.type === "MultiPolygon") {
                                        const M = hd(p.coordinates, b, C)
                                          , R = fd(l.geometry(), _, b, C);
                                        if (!du(_, b))
                                            return !1;
                                        for (const O of R)
                                            if (!kf(O, M))
                                                return !1
                                    }
                                    return !0
                                }(n, this.geometries)
                        }
                        return !1
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                }
                let Ef = class {
                    constructor(c=[], n= (l, p) => l < p ? -1 : l > p ? 1 : 0) {
                        if (this.data = c,
                        this.length = this.data.length,
                        this.compare = n,
                        this.length > 0)
                            for (let l = (this.length >> 1) - 1; l >= 0; l--)
                                this._down(l)
                    }
                    push(c) {
                        this.data.push(c),
                        this._up(this.length++)
                    }
                    pop() {
                        if (this.length === 0)
                            return;
                        const c = this.data[0]
                          , n = this.data.pop();
                        return --this.length > 0 && (this.data[0] = n,
                        this._down(0)),
                        c
                    }
                    peek() {
                        return this.data[0]
                    }
                    _up(c) {
                        const {data: n, compare: l} = this
                          , p = n[c];
                        for (; c > 0; ) {
                            const _ = c - 1 >> 1
                              , b = n[_];
                            if (l(p, b) >= 0)
                                break;
                            n[c] = b,
                            c = _
                        }
                        n[c] = p
                    }
                    _down(c) {
                        const {data: n, compare: l} = this
                          , p = this.length >> 1
                          , _ = n[c];
                        for (; c < p; ) {
                            let b = 1 + (c << 1);
                            const C = b + 1;
                            if (C < this.length && l(n[C], n[b]) < 0 && (b = C),
                            l(n[b], _) >= 0)
                                break;
                            n[c] = n[b],
                            c = b
                        }
                        n[c] = _
                    }
                }
                ;
                function ph(c, n, l=0, p=c.length - 1, _=gu) {
                    for (; p > l; ) {
                        if (p - l > 600) {
                            const R = p - l + 1
                              , O = n - l + 1
                              , j = Math.log(R)
                              , q = .5 * Math.exp(2 * j / 3)
                              , Q = .5 * Math.sqrt(j * q * (R - q) / R) * (O - R / 2 < 0 ? -1 : 1);
                            ph(c, n, Math.max(l, Math.floor(n - O * q / R + Q)), Math.min(p, Math.floor(n + (R - O) * q / R + Q)), _)
                        }
                        const b = c[n];
                        let C = l
                          , M = p;
                        for (Pl(c, l, n),
                        _(c[p], b) > 0 && Pl(c, l, p); C < M; ) {
                            for (Pl(c, C, M),
                            C++,
                            M--; _(c[C], b) < 0; )
                                C++;
                            for (; _(c[M], b) > 0; )
                                M--
                        }
                        _(c[l], b) === 0 ? Pl(c, l, M) : (M++,
                        Pl(c, M, p)),
                        M <= n && (l = M + 1),
                        n <= M && (p = M - 1)
                    }
                }
                function Pl(c, n, l) {
                    const p = c[n];
                    c[n] = c[l],
                    c[l] = p
                }
                function gu(c, n) {
                    return c < n ? -1 : c > n ? 1 : 0
                }
                function ja(c, n) {
                    if (c.length <= 1)
                        return [c];
                    const l = [];
                    let p, _;
                    for (const b of c) {
                        const C = yu(b);
                        C !== 0 && (b.area = Math.abs(C),
                        _ === void 0 && (_ = C < 0),
                        _ === C < 0 ? (p && l.push(p),
                        p = [b]) : p.push(b))
                    }
                    if (p && l.push(p),
                    n > 1)
                        for (let b = 0; b < l.length; b++)
                            l[b].length <= n || (ph(l[b], n, 1, l[b].length - 1, am),
                            l[b] = l[b].slice(0, n));
                    return l
                }
                function am(c, n) {
                    return n.area - c.area
                }
                function yu(c) {
                    let n = 0;
                    for (let l, p, _ = 0, b = c.length, C = b - 1; _ < b; C = _++)
                        l = c[_],
                        p = c[C],
                        n += (p.x - l.x) * (l.y + p.y);
                    return n
                }
                const If = 1 / 298.257223563
                  , pd = If * (2 - If)
                  , mh = Math.PI / 180;
                class _u {
                    constructor(n) {
                        const l = 6378.137 * mh * 1e3
                          , p = Math.cos(n * mh)
                          , _ = 1 / (1 - pd * (1 - p * p))
                          , b = Math.sqrt(_);
                        this.kx = l * b * p,
                        this.ky = l * b * _ * (1 - pd)
                    }
                    distance(n, l) {
                        const p = this.wrap(n[0] - l[0]) * this.kx
                          , _ = (n[1] - l[1]) * this.ky;
                        return Math.sqrt(p * p + _ * _)
                    }
                    pointOnLine(n, l) {
                        let p, _, b, C, M = 1 / 0;
                        for (let R = 0; R < n.length - 1; R++) {
                            let O = n[R][0]
                              , j = n[R][1]
                              , q = this.wrap(n[R + 1][0] - O) * this.kx
                              , Q = (n[R + 1][1] - j) * this.ky
                              , ne = 0;
                            q === 0 && Q === 0 || (ne = (this.wrap(l[0] - O) * this.kx * q + (l[1] - j) * this.ky * Q) / (q * q + Q * Q),
                            ne > 1 ? (O = n[R + 1][0],
                            j = n[R + 1][1]) : ne > 0 && (O += q / this.kx * ne,
                            j += Q / this.ky * ne)),
                            q = this.wrap(l[0] - O) * this.kx,
                            Q = (l[1] - j) * this.ky;
                            const oe = q * q + Q * Q;
                            oe < M && (M = oe,
                            p = O,
                            _ = j,
                            b = R,
                            C = ne)
                        }
                        return {
                            point: [p, _],
                            index: b,
                            t: Math.max(0, Math.min(1, C))
                        }
                    }
                    wrap(n) {
                        for (; n < -180; )
                            n += 360;
                        for (; n > 180; )
                            n -= 360;
                        return n
                    }
                }
                function ln(c, n) {
                    return n[0] - c[0]
                }
                function vu(c) {
                    return c[1] - c[0] + 1
                }
                function Gs(c, n) {
                    return c[1] >= c[0] && c[1] < n
                }
                function md(c, n) {
                    if (c[0] > c[1])
                        return [null, null];
                    const l = vu(c);
                    if (n) {
                        if (l === 2)
                            return [c, null];
                        const _ = Math.floor(l / 2);
                        return [[c[0], c[0] + _], [c[0] + _, c[1]]]
                    }
                    if (l === 1)
                        return [c, null];
                    const p = Math.floor(l / 2) - 1;
                    return [[c[0], c[0] + p], [c[0] + p + 1, c[1]]]
                }
                function gd(c, n) {
                    if (!Gs(n, c.length))
                        return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (let p = n[0]; p <= n[1]; ++p)
                        hu(l, c[p]);
                    return l
                }
                function yd(c) {
                    const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (const l of c)
                        for (const p of l)
                            hu(n, p);
                    return n
                }
                function Rf(c) {
                    return c[0] !== -1 / 0 && c[1] !== -1 / 0 && c[2] !== 1 / 0 && c[3] !== 1 / 0
                }
                function _d(c, n, l) {
                    if (!Rf(c) || !Rf(n))
                        return NaN;
                    let p = 0
                      , _ = 0;
                    return c[2] < n[0] && (p = n[0] - c[2]),
                    c[0] > n[2] && (p = c[0] - n[2]),
                    c[1] > n[3] && (_ = c[1] - n[3]),
                    c[3] < n[1] && (_ = n[1] - c[3]),
                    l.distance([0, 0], [p, _])
                }
                function Gi(c, n, l) {
                    const p = l.pointOnLine(n, c);
                    return l.distance(c, p.point)
                }
                function Ml(c, n, l, p, _) {
                    const b = Math.min(Gi(c, [l, p], _), Gi(n, [l, p], _))
                      , C = Math.min(Gi(l, [c, n], _), Gi(p, [c, n], _));
                    return Math.min(b, C)
                }
                function Af(c, n, l, p, _) {
                    if (!Gs(n, c.length) || !Gs(p, l.length))
                        return 1 / 0;
                    let b = 1 / 0;
                    for (let C = n[0]; C < n[1]; ++C) {
                        const M = c[C]
                          , R = c[C + 1];
                        for (let O = p[0]; O < p[1]; ++O) {
                            const j = l[O]
                              , q = l[O + 1];
                            if (fu(M, R, j, q))
                                return 0;
                            b = Math.min(b, Ml(M, R, j, q, _))
                        }
                    }
                    return b
                }
                function zf(c, n, l, p, _) {
                    if (!Gs(n, c.length) || !Gs(p, l.length))
                        return NaN;
                    let b = 1 / 0;
                    for (let C = n[0]; C <= n[1]; ++C)
                        for (let M = p[0]; M <= p[1]; ++M)
                            if (b = Math.min(b, _.distance(c[C], l[M])),
                            b === 0)
                                return b;
                    return b
                }
                function Df(c, n, l) {
                    if (Fa(c, n, !0))
                        return 0;
                    let p = 1 / 0;
                    for (const _ of n) {
                        const b = _[0]
                          , C = _[_.length - 1];
                        if (b !== C && (p = Math.min(p, Gi(c, [C, b], l)),
                        p === 0))
                            return p;
                        const M = l.pointOnLine(_, c);
                        if (p = Math.min(p, l.distance(c, M.point)),
                        p === 0)
                            return p
                    }
                    return p
                }
                function Lf(c, n, l, p) {
                    if (!Gs(n, c.length))
                        return NaN;
                    for (let b = n[0]; b <= n[1]; ++b)
                        if (Fa(c[b], l, !0))
                            return 0;
                    let _ = 1 / 0;
                    for (let b = n[0]; b < n[1]; ++b) {
                        const C = c[b]
                          , M = c[b + 1];
                        for (const R of l)
                            for (let O = 0, j = R.length, q = j - 1; O < j; q = O++) {
                                const Q = R[q]
                                  , ne = R[O];
                                if (fu(C, M, Q, ne))
                                    return 0;
                                _ = Math.min(_, Ml(C, M, Q, ne, p))
                            }
                    }
                    return _
                }
                function gh(c, n) {
                    for (const l of c)
                        for (const p of l)
                            if (Fa(p, n, !0))
                                return !0;
                    return !1
                }
                function lm(c, n, l, p=1 / 0) {
                    const _ = yd(c)
                      , b = yd(n);
                    if (p !== 1 / 0 && _d(_, b, l) >= p)
                        return p;
                    if (du(_, b)) {
                        if (gh(c, n))
                            return 0
                    } else if (gh(n, c))
                        return 0;
                    let C = 1 / 0;
                    for (const M of c)
                        for (let R = 0, O = M.length, j = O - 1; R < O; j = R++) {
                            const q = M[j]
                              , Q = M[R];
                            for (const ne of n)
                                for (let oe = 0, de = ne.length, we = de - 1; oe < de; we = oe++) {
                                    const Ie = ne[we]
                                      , Ye = ne[oe];
                                    if (fu(q, Q, Ie, Ye))
                                        return 0;
                                    C = Math.min(C, Ml(q, Q, Ie, Ye, l))
                                }
                        }
                    return C
                }
                function Of(c, n, l, p, _, b) {
                    if (!b)
                        return;
                    const C = _d(gd(p, b), _, l);
                    C < n && c.push([C, b, [0, 0]])
                }
                function ca(c, n, l, p, _, b, C) {
                    if (!b || !C)
                        return;
                    const M = _d(gd(p, b), gd(_, C), l);
                    M < n && c.push([M, b, C])
                }
                function fc(c, n, l, p, _=1 / 0) {
                    let b = Math.min(p.distance(c[0], l[0][0]), _);
                    if (b === 0)
                        return b;
                    const C = new Ef([[0, [0, c.length - 1], [0, 0]]],ln)
                      , M = yd(l);
                    for (; C.length > 0; ) {
                        const R = C.pop();
                        if (R[0] >= b)
                            continue;
                        const O = R[1]
                          , j = n ? 50 : 100;
                        if (vu(O) <= j) {
                            if (!Gs(O, c.length))
                                return NaN;
                            if (n) {
                                const q = Lf(c, O, l, p);
                                if (isNaN(q) || q === 0)
                                    return q;
                                b = Math.min(b, q)
                            } else
                                for (let q = O[0]; q <= O[1]; ++q) {
                                    const Q = Df(c[q], l, p);
                                    if (b = Math.min(b, Q),
                                    b === 0)
                                        return 0
                                }
                        } else {
                            const q = md(O, n);
                            Of(C, b, p, c, M, q[0]),
                            Of(C, b, p, c, M, q[1])
                        }
                    }
                    return b
                }
                function Na(c, n, l, p, _, b=1 / 0) {
                    let C = Math.min(b, _.distance(c[0], l[0]));
                    if (C === 0)
                        return C;
                    const M = new Ef([[0, [0, c.length - 1], [0, l.length - 1]]],ln);
                    for (; M.length > 0; ) {
                        const R = M.pop();
                        if (R[0] >= C)
                            continue;
                        const O = R[1]
                          , j = R[2]
                          , q = n ? 50 : 100
                          , Q = p ? 50 : 100;
                        if (vu(O) <= q && vu(j) <= Q) {
                            if (!Gs(O, c.length) && Gs(j, l.length))
                                return NaN;
                            let ne;
                            if (n && p)
                                ne = Af(c, O, l, j, _),
                                C = Math.min(C, ne);
                            else if (n && !p) {
                                const oe = c.slice(O[0], O[1] + 1);
                                for (let de = j[0]; de <= j[1]; ++de)
                                    if (ne = Gi(l[de], oe, _),
                                    C = Math.min(C, ne),
                                    C === 0)
                                        return C
                            } else if (!n && p) {
                                const oe = l.slice(j[0], j[1] + 1);
                                for (let de = O[0]; de <= O[1]; ++de)
                                    if (ne = Gi(c[de], oe, _),
                                    C = Math.min(C, ne),
                                    C === 0)
                                        return C
                            } else
                                ne = zf(c, O, l, j, _),
                                C = Math.min(C, ne)
                        } else {
                            const ne = md(O, n)
                              , oe = md(j, p);
                            ca(M, C, _, c, l, ne[0], oe[0]),
                            ca(M, C, _, c, l, ne[0], oe[1]),
                            ca(M, C, _, c, l, ne[1], oe[0]),
                            ca(M, C, _, c, l, ne[1], oe[1])
                        }
                    }
                    return C
                }
                function xu(c) {
                    return c.type === "MultiPolygon" ? c.coordinates.map(n => ({
                        type: "Polygon",
                        coordinates: n
                    })) : c.type === "MultiLineString" ? c.coordinates.map(n => ({
                        type: "LineString",
                        coordinates: n
                    })) : c.type === "MultiPoint" ? c.coordinates.map(n => ({
                        type: "Point",
                        coordinates: n
                    })) : [c]
                }
                class $a {
                    constructor(n, l) {
                        this.type = Xe,
                        this.geojson = n,
                        this.geometries = l
                    }
                    static parse(n, l) {
                        if (n.length !== 2)
                            return l.error(`'distance' expression requires exactly one argument, but found ${n.length - 1} instead.`);
                        if (Cs(n[1])) {
                            const p = n[1];
                            if (p.type === "FeatureCollection")
                                return new $a(p,p.features.map(_ => xu(_.geometry)).flat());
                            if (p.type === "Feature")
                                return new $a(p,xu(p.geometry));
                            if ("type"in p && "coordinates"in p)
                                return new $a(p,xu(p))
                        }
                        return l.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
                    }
                    evaluate(n) {
                        if (n.geometry() != null && n.canonicalID() != null) {
                            if (n.geometryType() === "Point")
                                return function(l, p) {
                                    const _ = l.geometry()
                                      , b = _.flat().map(R => ud([R.x, R.y], l.canonical));
                                    if (_.length === 0)
                                        return NaN;
                                    const C = new _u(b[0][1]);
                                    let M = 1 / 0;
                                    for (const R of p) {
                                        switch (R.type) {
                                        case "Point":
                                            M = Math.min(M, Na(b, !1, [R.coordinates], !1, C, M));
                                            break;
                                        case "LineString":
                                            M = Math.min(M, Na(b, !1, R.coordinates, !0, C, M));
                                            break;
                                        case "Polygon":
                                            M = Math.min(M, fc(b, !1, R.coordinates, C, M))
                                        }
                                        if (M === 0)
                                            return M
                                    }
                                    return M
                                }(n, this.geometries);
                            if (n.geometryType() === "LineString")
                                return function(l, p) {
                                    const _ = l.geometry()
                                      , b = _.flat().map(R => ud([R.x, R.y], l.canonical));
                                    if (_.length === 0)
                                        return NaN;
                                    const C = new _u(b[0][1]);
                                    let M = 1 / 0;
                                    for (const R of p) {
                                        switch (R.type) {
                                        case "Point":
                                            M = Math.min(M, Na(b, !0, [R.coordinates], !1, C, M));
                                            break;
                                        case "LineString":
                                            M = Math.min(M, Na(b, !0, R.coordinates, !0, C, M));
                                            break;
                                        case "Polygon":
                                            M = Math.min(M, fc(b, !0, R.coordinates, C, M))
                                        }
                                        if (M === 0)
                                            return M
                                    }
                                    return M
                                }(n, this.geometries);
                            if (n.geometryType() === "Polygon")
                                return function(l, p) {
                                    const _ = l.geometry();
                                    if (_.length === 0 || _[0].length === 0)
                                        return NaN;
                                    const b = ja(_, 0).map(R => R.map(O => O.map(j => ud([j.x, j.y], l.canonical))))
                                      , C = new _u(b[0][0][0][1]);
                                    let M = 1 / 0;
                                    for (const R of p)
                                        for (const O of b) {
                                            switch (R.type) {
                                            case "Point":
                                                M = Math.min(M, fc([R.coordinates], !1, O, C, M));
                                                break;
                                            case "LineString":
                                                M = Math.min(M, fc(R.coordinates, !0, O, C, M));
                                                break;
                                            case "Polygon":
                                                M = Math.min(M, lm(O, R.coordinates, C, M))
                                            }
                                            if (M === 0)
                                                return M
                                        }
                                    return M
                                }(n, this.geometries)
                        }
                        return NaN
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                }
                class Va {
                    constructor(n) {
                        this.type = _r,
                        this.key = n
                    }
                    static parse(n, l) {
                        if (n.length !== 2)
                            return l.error(`Expected 1 argument, but found ${n.length - 1} instead.`);
                        const p = n[1];
                        return p == null ? l.error("Global state property must be defined.") : typeof p != "string" ? l.error(`Global state property must be string, but found ${typeof n[1]} instead.`) : new Va(p)
                    }
                    evaluate(n) {
                        var l;
                        const p = (l = n.globals) === null || l === void 0 ? void 0 : l.globalState;
                        return p && Object.keys(p).length !== 0 ? Xr(p, this.key) : null
                    }
                    eachChild() {}
                    outputDefined() {
                        return !1
                    }
                }
                const Ps = {
                    "==": ld,
                    "!=": nm,
                    ">": im,
                    "<": Cf,
                    ">=": uh,
                    "<=": om,
                    array: Ji,
                    at: ui,
                    boolean: Ji,
                    case: Zn,
                    coalesce: eo,
                    collator: hh,
                    format: uu,
                    image: cd,
                    in: aa,
                    "index-of": ac,
                    interpolate: yo,
                    "interpolate-hcl": yo,
                    "interpolate-lab": yo,
                    length: dh,
                    let: Oa,
                    literal: go,
                    match: Ii,
                    number: Ji,
                    "number-format": dc,
                    object: Ji,
                    slice: Cl,
                    step: lc,
                    string: Ji,
                    "to-boolean": us,
                    "to-color": us,
                    "to-number": us,
                    "to-string": us,
                    var: hs,
                    within: Tl,
                    distance: $a,
                    "global-state": Va
                };
                class zo {
                    constructor(n, l, p, _) {
                        this.name = n,
                        this.type = l,
                        this._evaluate = p,
                        this.args = _
                    }
                    evaluate(n) {
                        return this._evaluate(n, this.args)
                    }
                    eachChild(n) {
                        this.args.forEach(n)
                    }
                    outputDefined() {
                        return !1
                    }
                    static parse(n, l) {
                        const p = n[0]
                          , _ = zo.definitions[p];
                        if (!_)
                            return l.error(`Unknown expression "${p}". If you wanted a literal array, use ["literal", [...]].`, 0);
                        const b = Array.isArray(_) ? _[0] : _.type
                          , C = Array.isArray(_) ? [[_[1], _[2]]] : _.overloads
                          , M = C.filter( ([O]) => !Array.isArray(O) || O.length === n.length - 1);
                        let R = null;
                        for (const [O,j] of M) {
                            R = new Sl(l.registry,wu,l.path,null,l.scope);
                            const q = [];
                            let Q = !1;
                            for (let ne = 1; ne < n.length; ne++) {
                                const oe = n[ne]
                                  , de = Array.isArray(O) ? O[ne - 1] : O.type
                                  , we = R.parse(oe, 1 + q.length, de);
                                if (!we) {
                                    Q = !0;
                                    break
                                }
                                q.push(we)
                            }
                            if (!Q)
                                if (Array.isArray(O) && O.length !== q.length)
                                    R.error(`Expected ${O.length} arguments, but found ${q.length} instead.`);
                                else {
                                    for (let ne = 0; ne < q.length; ne++) {
                                        const oe = Array.isArray(O) ? O[ne] : O.type
                                          , de = q[ne];
                                        R.concat(ne + 1).checkSubtype(oe, de.type)
                                    }
                                    if (R.errors.length === 0)
                                        return new zo(p,b,j,q)
                                }
                        }
                        if (M.length === 1)
                            l.errors.push(...R.errors);
                        else {
                            const O = (M.length ? M : C).map( ([q]) => {
                                return Q = q,
                                Array.isArray(Q) ? `(${Q.map(an).join(", ")})` : `(${an(Q.type)}...)`;
                                var Q
                            }
                            ).join(" | ")
                              , j = [];
                            for (let q = 1; q < n.length; q++) {
                                const Q = l.parse(n[q], 1 + j.length);
                                if (!Q)
                                    return null;
                                j.push(an(Q.type))
                            }
                            l.error(`Expected arguments of type ${O}, but found (${j.join(", ")}) instead.`)
                        }
                        return null
                    }
                    static register(n, l) {
                        zo.definitions = l;
                        for (const p in l)
                            n[p] = zo
                    }
                }
                function vd(c, [n,l,p,_]) {
                    n = n.evaluate(c),
                    l = l.evaluate(c),
                    p = p.evaluate(c);
                    const b = _ ? _.evaluate(c) : 1
                      , C = Fr(n, l, p, b);
                    if (C)
                        throw new Qn(C);
                    return new Br(n / 255,l / 255,p / 255,b,!1)
                }
                function bu(c, n) {
                    return c in n
                }
                function yh(c, n) {
                    const l = n[c];
                    return l === void 0 ? null : l
                }
                function Ua(c) {
                    return {
                        type: c
                    }
                }
                function wu(c) {
                    if (c instanceof hs)
                        return wu(c.boundExpression);
                    if (c instanceof zo && c.name === "error" || c instanceof hh || c instanceof Tl || c instanceof $a || c instanceof Va)
                        return !1;
                    const n = c instanceof us || c instanceof Ji;
                    let l = !0;
                    return c.eachChild(p => {
                        l = n ? l && wu(p) : l && p instanceof go
                    }
                    ),
                    !!l && Su(c) && kl(c, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
                }
                function Su(c) {
                    if (c instanceof zo && (c.name === "get" && c.args.length === 1 || c.name === "feature-state" || c.name === "has" && c.args.length === 1 || c.name === "properties" || c.name === "geometry-type" || c.name === "id" || /^filter-/.test(c.name)) || c instanceof Tl || c instanceof $a)
                        return !1;
                    let n = !0;
                    return c.eachChild(l => {
                        n && !Su(l) && (n = !1)
                    }
                    ),
                    n
                }
                function pc(c) {
                    if (c instanceof zo && c.name === "feature-state")
                        return !1;
                    let n = !0;
                    return c.eachChild(l => {
                        n && !pc(l) && (n = !1)
                    }
                    ),
                    n
                }
                function kl(c, n) {
                    if (c instanceof zo && n.indexOf(c.name) >= 0)
                        return !1;
                    let l = !0;
                    return c.eachChild(p => {
                        l && !kl(p, n) && (l = !1)
                    }
                    ),
                    l
                }
                function ua(c) {
                    return {
                        result: "success",
                        value: c
                    }
                }
                function Ga(c) {
                    return {
                        result: "error",
                        value: c
                    }
                }
                function Wa(c) {
                    return c["property-type"] === "data-driven" || c["property-type"] === "cross-faded-data-driven"
                }
                function xd(c) {
                    return !!c.expression && c.expression.parameters.indexOf("zoom") > -1
                }
                function bd(c) {
                    return !!c.expression && c.expression.interpolated
                }
                function Ur(c) {
                    return c instanceof Number ? "number" : c instanceof String ? "string" : c instanceof Boolean ? "boolean" : Array.isArray(c) ? "array" : c === null ? "null" : typeof c
                }
                function El(c) {
                    return typeof c == "object" && c !== null && !Array.isArray(c) && Sr(c) === lr
                }
                function wd(c) {
                    return c
                }
                function Sd(c, n) {
                    const l = c.stops && typeof c.stops[0][0] == "object"
                      , p = l || !(l || c.property !== void 0)
                      , _ = c.type || (bd(n) ? "exponential" : "interval")
                      , b = function(j) {
                        switch (j.type) {
                        case "color":
                            return Br.parse;
                        case "padding":
                            return mi.parse;
                        case "numberArray":
                            return Ui.parse;
                        case "colorArray":
                            return ii.parse;
                        default:
                            return null
                        }
                    }(n);
                    if (b && ((c = Ze({}, c)).stops && (c.stops = c.stops.map(j => [j[0], b(j[1])])),
                    c.default = b(c.default ? c.default : n.default)),
                    c.colorSpace && (C = c.colorSpace) !== "rgb" && C !== "hcl" && C !== "lab")
                        throw new Error(`Unknown color space: "${c.colorSpace}"`);
                    var C;
                    const M = function(j) {
                        switch (j) {
                        case "exponential":
                            return mc;
                        case "interval":
                            return _h;
                        case "categorical":
                            return Cd;
                        case "identity":
                            return Td;
                        default:
                            throw new Error(`Unknown function type "${j}"`)
                        }
                    }(_);
                    let R, O;
                    if (_ === "categorical") {
                        R = Object.create(null);
                        for (const j of c.stops)
                            R[j[0]] = j[1];
                        O = typeof c.stops[0][0]
                    }
                    if (l) {
                        const j = {}
                          , q = [];
                        for (let oe = 0; oe < c.stops.length; oe++) {
                            const de = c.stops[oe]
                              , we = de[0].zoom;
                            j[we] === void 0 && (j[we] = {
                                zoom: we,
                                type: c.type,
                                property: c.property,
                                default: c.default,
                                stops: []
                            },
                            q.push(we)),
                            j[we].stops.push([de[0].value, de[1]])
                        }
                        const Q = [];
                        for (const oe of q)
                            Q.push([j[oe].zoom, Sd(j[oe], n)]);
                        const ne = {
                            name: "linear"
                        };
                        return {
                            kind: "composite",
                            interpolationType: ne,
                            interpolationFactor: yo.interpolationFactor.bind(void 0, ne),
                            zoomStops: Q.map(oe => oe[0]),
                            evaluate: ({zoom: oe}, de) => mc({
                                stops: Q,
                                base: c.base
                            }, n, oe).evaluate(oe, de)
                        }
                    }
                    if (p) {
                        const j = _ === "exponential" ? {
                            name: "exponential",
                            base: c.base !== void 0 ? c.base : 1
                        } : null;
                        return {
                            kind: "camera",
                            interpolationType: j,
                            interpolationFactor: yo.interpolationFactor.bind(void 0, j),
                            zoomStops: c.stops.map(q => q[0]),
                            evaluate: ({zoom: q}) => M(c, n, q, R, O)
                        }
                    }
                    return {
                        kind: "source",
                        evaluate(j, q) {
                            const Q = q && q.properties ? q.properties[c.property] : void 0;
                            return Q === void 0 ? Pn(c.default, n.default) : M(c, n, Q, R, O)
                        }
                    }
                }
                function Pn(c, n, l) {
                    return c !== void 0 ? c : n !== void 0 ? n : l !== void 0 ? l : void 0
                }
                function Cd(c, n, l, p, _) {
                    return Pn(typeof l === _ ? p[l] : void 0, c.default, n.default)
                }
                function _h(c, n, l) {
                    if (Ur(l) !== "number")
                        return Pn(c.default, n.default);
                    const p = c.stops.length;
                    if (p === 1 || l <= c.stops[0][0])
                        return c.stops[0][1];
                    if (l >= c.stops[p - 1][0])
                        return c.stops[p - 1][1];
                    const _ = Vs(c.stops.map(b => b[0]), l);
                    return c.stops[_][1]
                }
                function mc(c, n, l) {
                    const p = c.base !== void 0 ? c.base : 1;
                    if (Ur(l) !== "number")
                        return Pn(c.default, n.default);
                    const _ = c.stops.length;
                    if (_ === 1 || l <= c.stops[0][0])
                        return c.stops[0][1];
                    if (l >= c.stops[_ - 1][0])
                        return c.stops[_ - 1][1];
                    const b = Vs(c.stops.map(j => j[0]), l)
                      , C = function(j, q, Q, ne) {
                        const oe = ne - Q
                          , de = j - Q;
                        return oe === 0 ? 0 : q === 1 ? de / oe : (Math.pow(q, de) - 1) / (Math.pow(q, oe) - 1)
                    }(l, p, c.stops[b][0], c.stops[b + 1][0])
                      , M = c.stops[b][1]
                      , R = c.stops[b + 1][1]
                      , O = Xo[n.type] || wd;
                    return typeof M.evaluate == "function" ? {
                        evaluate(...j) {
                            const q = M.evaluate.apply(void 0, j)
                              , Q = R.evaluate.apply(void 0, j);
                            if (q !== void 0 && Q !== void 0)
                                return O(q, Q, C, c.colorSpace)
                        }
                    } : O(M, R, C, c.colorSpace)
                }
                function Td(c, n, l) {
                    switch (n.type) {
                    case "color":
                        l = Br.parse(l);
                        break;
                    case "formatted":
                        l = ei.fromString(l.toString());
                        break;
                    case "resolvedImage":
                        l = mo.fromString(l.toString());
                        break;
                    case "padding":
                        l = mi.parse(l);
                        break;
                    case "colorArray":
                        l = ii.parse(l);
                        break;
                    case "numberArray":
                        l = Ui.parse(l);
                        break;
                    default:
                        Ur(l) === n.type || n.type === "enum" && n.values[l] || (l = void 0)
                    }
                    return Pn(l, c.default, n.default)
                }
                zo.register(Ps, {
                    error: [{
                        kind: "error"
                    }, [wt], (c, [n]) => {
                        throw new Qn(n.evaluate(c))
                    }
                    ],
                    typeof: [wt, [_r], (c, [n]) => an(Sr(n.evaluate(c)))],
                    "to-rgba": [Ln(Xe, 4), [Gt], (c, [n]) => {
                        const [l,p,_,b] = n.evaluate(c).rgb;
                        return [255 * l, 255 * p, 255 * _, b]
                    }
                    ],
                    rgb: [Gt, [Xe, Xe, Xe], vd],
                    rgba: [Gt, [Xe, Xe, Xe, Xe], vd],
                    has: {
                        type: Ct,
                        overloads: [[[wt], (c, [n]) => bu(n.evaluate(c), c.properties())], [[wt, lr], (c, [n,l]) => bu(n.evaluate(c), l.evaluate(c))]]
                    },
                    get: {
                        type: _r,
                        overloads: [[[wt], (c, [n]) => yh(n.evaluate(c), c.properties())], [[wt, lr], (c, [n,l]) => yh(n.evaluate(c), l.evaluate(c))]]
                    },
                    "feature-state": [_r, [wt], (c, [n]) => yh(n.evaluate(c), c.featureState || {})],
                    properties: [lr, [], c => c.properties()],
                    "geometry-type": [wt, [], c => c.geometryType()],
                    id: [_r, [], c => c.id()],
                    zoom: [Xe, [], c => c.globals.zoom],
                    "heatmap-density": [Xe, [], c => c.globals.heatmapDensity || 0],
                    elevation: [Xe, [], c => c.globals.elevation || 0],
                    "line-progress": [Xe, [], c => c.globals.lineProgress || 0],
                    accumulated: [_r, [], c => c.globals.accumulated === void 0 ? null : c.globals.accumulated],
                    "+": [Xe, Ua(Xe), (c, n) => {
                        let l = 0;
                        for (const p of n)
                            l += p.evaluate(c);
                        return l
                    }
                    ],
                    "*": [Xe, Ua(Xe), (c, n) => {
                        let l = 1;
                        for (const p of n)
                            l *= p.evaluate(c);
                        return l
                    }
                    ],
                    "-": {
                        type: Xe,
                        overloads: [[[Xe, Xe], (c, [n,l]) => n.evaluate(c) - l.evaluate(c)], [[Xe], (c, [n]) => -n.evaluate(c)]]
                    },
                    "/": [Xe, [Xe, Xe], (c, [n,l]) => n.evaluate(c) / l.evaluate(c)],
                    "%": [Xe, [Xe, Xe], (c, [n,l]) => n.evaluate(c) % l.evaluate(c)],
                    ln2: [Xe, [], () => Math.LN2],
                    pi: [Xe, [], () => Math.PI],
                    e: [Xe, [], () => Math.E],
                    "^": [Xe, [Xe, Xe], (c, [n,l]) => Math.pow(n.evaluate(c), l.evaluate(c))],
                    sqrt: [Xe, [Xe], (c, [n]) => Math.sqrt(n.evaluate(c))],
                    log10: [Xe, [Xe], (c, [n]) => Math.log(n.evaluate(c)) / Math.LN10],
                    ln: [Xe, [Xe], (c, [n]) => Math.log(n.evaluate(c))],
                    log2: [Xe, [Xe], (c, [n]) => Math.log(n.evaluate(c)) / Math.LN2],
                    sin: [Xe, [Xe], (c, [n]) => Math.sin(n.evaluate(c))],
                    cos: [Xe, [Xe], (c, [n]) => Math.cos(n.evaluate(c))],
                    tan: [Xe, [Xe], (c, [n]) => Math.tan(n.evaluate(c))],
                    asin: [Xe, [Xe], (c, [n]) => Math.asin(n.evaluate(c))],
                    acos: [Xe, [Xe], (c, [n]) => Math.acos(n.evaluate(c))],
                    atan: [Xe, [Xe], (c, [n]) => Math.atan(n.evaluate(c))],
                    min: [Xe, Ua(Xe), (c, n) => Math.min(...n.map(l => l.evaluate(c)))],
                    max: [Xe, Ua(Xe), (c, n) => Math.max(...n.map(l => l.evaluate(c)))],
                    abs: [Xe, [Xe], (c, [n]) => Math.abs(n.evaluate(c))],
                    round: [Xe, [Xe], (c, [n]) => {
                        const l = n.evaluate(c);
                        return l < 0 ? -Math.round(-l) : Math.round(l)
                    }
                    ],
                    floor: [Xe, [Xe], (c, [n]) => Math.floor(n.evaluate(c))],
                    ceil: [Xe, [Xe], (c, [n]) => Math.ceil(n.evaluate(c))],
                    "filter-==": [Ct, [wt, _r], (c, [n,l]) => c.properties()[n.value] === l.value],
                    "filter-id-==": [Ct, [_r], (c, [n]) => c.id() === n.value],
                    "filter-type-==": [Ct, [wt], (c, [n]) => c.geometryType() === n.value],
                    "filter-<": [Ct, [wt, _r], (c, [n,l]) => {
                        const p = c.properties()[n.value]
                          , _ = l.value;
                        return typeof p == typeof _ && p < _
                    }
                    ],
                    "filter-id-<": [Ct, [_r], (c, [n]) => {
                        const l = c.id()
                          , p = n.value;
                        return typeof l == typeof p && l < p
                    }
                    ],
                    "filter->": [Ct, [wt, _r], (c, [n,l]) => {
                        const p = c.properties()[n.value]
                          , _ = l.value;
                        return typeof p == typeof _ && p > _
                    }
                    ],
                    "filter-id->": [Ct, [_r], (c, [n]) => {
                        const l = c.id()
                          , p = n.value;
                        return typeof l == typeof p && l > p
                    }
                    ],
                    "filter-<=": [Ct, [wt, _r], (c, [n,l]) => {
                        const p = c.properties()[n.value]
                          , _ = l.value;
                        return typeof p == typeof _ && p <= _
                    }
                    ],
                    "filter-id-<=": [Ct, [_r], (c, [n]) => {
                        const l = c.id()
                          , p = n.value;
                        return typeof l == typeof p && l <= p
                    }
                    ],
                    "filter->=": [Ct, [wt, _r], (c, [n,l]) => {
                        const p = c.properties()[n.value]
                          , _ = l.value;
                        return typeof p == typeof _ && p >= _
                    }
                    ],
                    "filter-id->=": [Ct, [_r], (c, [n]) => {
                        const l = c.id()
                          , p = n.value;
                        return typeof l == typeof p && l >= p
                    }
                    ],
                    "filter-has": [Ct, [_r], (c, [n]) => n.value in c.properties()],
                    "filter-has-id": [Ct, [], c => c.id() !== null && c.id() !== void 0],
                    "filter-type-in": [Ct, [Ln(wt)], (c, [n]) => n.value.indexOf(c.geometryType()) >= 0],
                    "filter-id-in": [Ct, [Ln(_r)], (c, [n]) => n.value.indexOf(c.id()) >= 0],
                    "filter-in-small": [Ct, [wt, Ln(_r)], (c, [n,l]) => l.value.indexOf(c.properties()[n.value]) >= 0],
                    "filter-in-large": [Ct, [wt, Ln(_r)], (c, [n,l]) => function(p, _, b, C) {
                        for (; b <= C; ) {
                            const M = b + C >> 1;
                            if (_[M] === p)
                                return !0;
                            _[M] > p ? C = M - 1 : b = M + 1
                        }
                        return !1
                    }(c.properties()[n.value], l.value, 0, l.value.length - 1)],
                    all: {
                        type: Ct,
                        overloads: [[[Ct, Ct], (c, [n,l]) => n.evaluate(c) && l.evaluate(c)], [Ua(Ct), (c, n) => {
                            for (const l of n)
                                if (!l.evaluate(c))
                                    return !1;
                            return !0
                        }
                        ]]
                    },
                    any: {
                        type: Ct,
                        overloads: [[[Ct, Ct], (c, [n,l]) => n.evaluate(c) || l.evaluate(c)], [Ua(Ct), (c, n) => {
                            for (const l of n)
                                if (l.evaluate(c))
                                    return !0;
                            return !1
                        }
                        ]]
                    },
                    "!": [Ct, [Ct], (c, [n]) => !n.evaluate(c)],
                    "is-supported-script": [Ct, [wt], (c, [n]) => {
                        const l = c.globals && c.globals.isSupportedScript;
                        return !l || l(n.evaluate(c))
                    }
                    ],
                    upcase: [wt, [wt], (c, [n]) => n.evaluate(c).toUpperCase()],
                    downcase: [wt, [wt], (c, [n]) => n.evaluate(c).toLowerCase()],
                    concat: [wt, Ua(_r), (c, n) => n.map(l => $s(l.evaluate(c))).join("")],
                    "resolved-locale": [wt, [ri], (c, [n]) => n.evaluate(c).resolvedLocale()]
                });
                class gc {
                    constructor(n, l) {
                        this.expression = n,
                        this._warningHistory = {},
                        this._evaluator = new sa,
                        this._defaultValue = l ? function(p) {
                            if (p.type === "color" && El(p.default))
                                return new Br(0,0,0,0);
                            switch (p.type) {
                            case "color":
                                return Br.parse(p.default) || null;
                            case "padding":
                                return mi.parse(p.default) || null;
                            case "numberArray":
                                return Ui.parse(p.default) || null;
                            case "colorArray":
                                return ii.parse(p.default) || null;
                            case "variableAnchorOffsetCollection":
                                return Yr.parse(p.default) || null;
                            case "projectionDefinition":
                                return jr.parse(p.default) || null;
                            default:
                                return p.default === void 0 ? null : p.default
                            }
                        }(l) : null,
                        this._enumValues = l && l.type === "enum" ? l.values : null
                    }
                    evaluateWithoutErrorHandling(n, l, p, _, b, C) {
                        return this._evaluator.globals = n,
                        this._evaluator.feature = l,
                        this._evaluator.featureState = p,
                        this._evaluator.canonical = _,
                        this._evaluator.availableImages = b || null,
                        this._evaluator.formattedSection = C,
                        this.expression.evaluate(this._evaluator)
                    }
                    evaluate(n, l, p, _, b, C) {
                        this._evaluator.globals = n,
                        this._evaluator.feature = l || null,
                        this._evaluator.featureState = p || null,
                        this._evaluator.canonical = _,
                        this._evaluator.availableImages = b || null,
                        this._evaluator.formattedSection = C || null;
                        try {
                            const M = this.expression.evaluate(this._evaluator);
                            if (M == null || typeof M == "number" && M != M)
                                return this._defaultValue;
                            if (this._enumValues && !(M in this._enumValues))
                                throw new Qn(`Expected value to be one of ${Object.keys(this._enumValues).map(R => JSON.stringify(R)).join(", ")}, but found ${JSON.stringify(M)} instead.`);
                            return M
                        } catch (M) {
                            return this._warningHistory[M.message] || (this._warningHistory[M.message] = !0,
                            typeof console < "u" && console.warn(M.message)),
                            this._defaultValue
                        }
                    }
                }
                function qa(c) {
                    return Array.isArray(c) && c.length > 0 && typeof c[0] == "string" && c[0]in Ps
                }
                function Il(c, n) {
                    const l = new Sl(Ps,wu,[],n ? function(_) {
                        const b = {
                            color: Gt,
                            string: wt,
                            number: Xe,
                            enum: wt,
                            boolean: Ct,
                            formatted: ni,
                            padding: kr,
                            numberArray: Si,
                            colorArray: ci,
                            projectionDefinition: Xt,
                            resolvedImage: $i,
                            variableAnchorOffsetCollection: Ro
                        };
                        return _.type === "array" ? Ln(b[_.value] || _r, _.length) : b[_.type]
                    }(n) : void 0)
                      , p = l.parse(c, void 0, void 0, void 0, n && n.type === "string" ? {
                        typeAnnotation: "coerce"
                    } : void 0);
                    return p ? ua(new gc(p,n)) : Ga(l.errors)
                }
                class Ws {
                    constructor(n, l) {
                        this.kind = n,
                        this._styleExpression = l,
                        this.isStateDependent = n !== "constant" && !pc(l.expression),
                        this.globalStateRefs = ha(l.expression)
                    }
                    evaluateWithoutErrorHandling(n, l, p, _, b, C) {
                        return this._styleExpression.evaluateWithoutErrorHandling(n, l, p, _, b, C)
                    }
                    evaluate(n, l, p, _, b, C) {
                        return this._styleExpression.evaluate(n, l, p, _, b, C)
                    }
                }
                class Cu {
                    constructor(n, l, p, _) {
                        this.kind = n,
                        this.zoomStops = p,
                        this._styleExpression = l,
                        this.isStateDependent = n !== "camera" && !pc(l.expression),
                        this.globalStateRefs = ha(l.expression),
                        this.interpolationType = _
                    }
                    evaluateWithoutErrorHandling(n, l, p, _, b, C) {
                        return this._styleExpression.evaluateWithoutErrorHandling(n, l, p, _, b, C)
                    }
                    evaluate(n, l, p, _, b, C) {
                        return this._styleExpression.evaluate(n, l, p, _, b, C)
                    }
                    interpolationFactor(n, l, p) {
                        return this.interpolationType ? yo.interpolationFactor(this.interpolationType, n, l, p) : 0
                    }
                }
                function Pd(c, n) {
                    const l = Il(c, n);
                    if (l.result === "error")
                        return l;
                    const p = l.value.expression
                      , _ = Su(p);
                    if (!_ && !Wa(n))
                        return Ga([new Ge("","data expressions not supported")]);
                    const b = kl(p, ["zoom"]);
                    if (!b && !xd(n))
                        return Ga([new Ge("","zoom expressions not supported")]);
                    const C = Rl(p);
                    return C || b ? C instanceof Ge ? Ga([C]) : C instanceof yo && !bd(n) ? Ga([new Ge("",'"interpolate" expressions cannot be used with this property')]) : ua(C ? new Cu(_ ? "camera" : "composite",l.value,C.labels,C instanceof yo ? C.interpolation : void 0) : new Ws(_ ? "constant" : "source",l.value)) : Ga([new Ge("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
                }
                class Tu {
                    constructor(n, l) {
                        this._parameters = n,
                        this._specification = l,
                        Ze(this, Sd(this._parameters, this._specification))
                    }
                    static deserialize(n) {
                        return new Tu(n._parameters,n._specification)
                    }
                    static serialize(n) {
                        return {
                            _parameters: n._parameters,
                            _specification: n._specification
                        }
                    }
                }
                function Rl(c) {
                    let n = null;
                    if (c instanceof Oa)
                        n = Rl(c.result);
                    else if (c instanceof eo) {
                        for (const l of c.args)
                            if (n = Rl(l),
                            n)
                                break
                    } else
                        (c instanceof lc || c instanceof yo) && c.input instanceof zo && c.input.name === "zoom" && (n = c);
                    return n instanceof Ge || c.eachChild(l => {
                        const p = Rl(l);
                        p instanceof Ge ? n = p : !n && p ? n = new Ge("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : n && p && n !== p && (n = new Ge("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
                    }
                    ),
                    n
                }
                function ha(c, n=new Set) {
                    return c instanceof Va && n.add(c.key),
                    c.eachChild(l => {
                        ha(l, n)
                    }
                    ),
                    n
                }
                function Ha(c) {
                    if (c === !0 || c === !1)
                        return !0;
                    if (!Array.isArray(c) || c.length === 0)
                        return !1;
                    switch (c[0]) {
                    case "has":
                        return c.length >= 2 && c[1] !== "$id" && c[1] !== "$type";
                    case "in":
                        return c.length >= 3 && (typeof c[1] != "string" || Array.isArray(c[2]));
                    case "!in":
                    case "!has":
                    case "none":
                        return !1;
                    case "==":
                    case "!=":
                    case ">":
                    case ">=":
                    case "<":
                    case "<=":
                        return c.length !== 3 || Array.isArray(c[1]) || Array.isArray(c[2]);
                    case "any":
                    case "all":
                        for (const n of c.slice(1))
                            if (!Ha(n) && typeof n != "boolean")
                                return !1;
                        return !0;
                    default:
                        return !0
                    }
                }
                const Pu = {
                    type: "boolean",
                    default: !1,
                    transition: !1,
                    "property-type": "data-driven",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    }
                };
                function qs(c) {
                    if (c == null)
                        return {
                            filter: () => !0,
                            needGeometry: !1,
                            getGlobalStateRefs: () => new Set
                        };
                    Ha(c) || (c = xh(c));
                    const n = Il(c, Pu);
                    if (n.result === "error")
                        throw new Error(n.value.map(l => `${l.key}: ${l.message}`).join(", "));
                    return {
                        filter: (l, p, _) => n.value.evaluate(l, p, {}, _),
                        needGeometry: vh(c),
                        getGlobalStateRefs: () => ha(n.value.expression)
                    }
                }
                function Md(c, n) {
                    return c < n ? -1 : c > n ? 1 : 0
                }
                function vh(c) {
                    if (!Array.isArray(c))
                        return !1;
                    if (c[0] === "within" || c[0] === "distance")
                        return !0;
                    for (let n = 1; n < c.length; n++)
                        if (vh(c[n]))
                            return !0;
                    return !1
                }
                function xh(c) {
                    if (!c)
                        return !0;
                    const n = c[0];
                    return c.length <= 1 ? n !== "any" : n === "==" ? bh(c[1], c[2], "==") : n === "!=" ? Al(bh(c[1], c[2], "==")) : n === "<" || n === ">" || n === "<=" || n === ">=" ? bh(c[1], c[2], n) : n === "any" ? (l = c.slice(1),
                    ["any"].concat(l.map(xh))) : n === "all" ? ["all"].concat(c.slice(1).map(xh)) : n === "none" ? ["all"].concat(c.slice(1).map(xh).map(Al)) : n === "in" ? Ff(c[1], c.slice(2)) : n === "!in" ? Al(Ff(c[1], c.slice(2))) : n === "has" ? Bf(c[1]) : n !== "!has" || Al(Bf(c[1]));
                    var l
                }
                function bh(c, n, l) {
                    switch (c) {
                    case "$type":
                        return [`filter-type-${l}`, n];
                    case "$id":
                        return [`filter-id-${l}`, n];
                    default:
                        return [`filter-${l}`, c, n]
                    }
                }
                function Ff(c, n) {
                    if (n.length === 0)
                        return !1;
                    switch (c) {
                    case "$type":
                        return ["filter-type-in", ["literal", n]];
                    case "$id":
                        return ["filter-id-in", ["literal", n]];
                    default:
                        return n.length > 200 && !n.some(l => typeof l != typeof n[0]) ? ["filter-in-large", c, ["literal", n.sort(Md)]] : ["filter-in-small", c, ["literal", n]]
                    }
                }
                function Bf(c) {
                    switch (c) {
                    case "$type":
                        return !0;
                    case "$id":
                        return ["filter-has-id"];
                    default:
                        return ["filter-has", c]
                    }
                }
                function Al(c) {
                    return ["!", c]
                }
                function Ms(c) {
                    const n = typeof c;
                    if (n === "number" || n === "boolean" || n === "string" || c == null)
                        return JSON.stringify(c);
                    if (Array.isArray(c)) {
                        let _ = "[";
                        for (const b of c)
                            _ += `${Ms(b)},`;
                        return `${_}]`
                    }
                    const l = Object.keys(c).sort();
                    let p = "{";
                    for (let _ = 0; _ < l.length; _++)
                        p += `${JSON.stringify(l[_])}:${Ms(c[l[_]])},`;
                    return `${p}}`
                }
                function Mu(c) {
                    let n = "";
                    for (const l of Ut)
                        n += `/${Ms(c[l])}`;
                    return n
                }
                function zl(c) {
                    const n = c.value;
                    return n ? [new ee(c.key,n,"constants have been deprecated as of v8")] : []
                }
                function fn(c) {
                    return c instanceof Number || c instanceof String || c instanceof Boolean ? c.valueOf() : c
                }
                function ds(c) {
                    if (Array.isArray(c))
                        return c.map(ds);
                    if (c instanceof Object && !(c instanceof Number || c instanceof String || c instanceof Boolean)) {
                        const n = {};
                        for (const l in c)
                            n[l] = ds(c[l]);
                        return n
                    }
                    return fn(c)
                }
                function gi(c) {
                    const n = c.key
                      , l = c.value
                      , p = c.valueSpec || {}
                      , _ = c.objectElementValidators || {}
                      , b = c.style
                      , C = c.styleSpec
                      , M = c.validateSpec;
                    let R = [];
                    const O = Ur(l);
                    if (O !== "object")
                        return [new ee(n,l,`object expected, ${O} found`)];
                    for (const j in l) {
                        const q = j.split(".")[0]
                          , Q = Xr(p, q) || p["*"];
                        let ne;
                        if (Xr(_, q))
                            ne = _[q];
                        else if (Xr(p, q))
                            ne = M;
                        else if (_["*"])
                            ne = _["*"];
                        else {
                            if (!p["*"]) {
                                R.push(new ee(n,l[j],`unknown property "${j}"`));
                                continue
                            }
                            ne = M
                        }
                        R = R.concat(ne({
                            key: (n && `${n}.`) + j,
                            value: l[j],
                            valueSpec: Q,
                            style: b,
                            styleSpec: C,
                            object: l,
                            objectKey: j,
                            validateSpec: M
                        }, l))
                    }
                    for (const j in p)
                        _[j] || p[j].required && p[j].default === void 0 && l[j] === void 0 && R.push(new ee(n,l,`missing required property "${j}"`));
                    return R
                }
                function yc(c) {
                    const n = c.value
                      , l = c.valueSpec
                      , p = c.style
                      , _ = c.styleSpec
                      , b = c.key
                      , C = c.arrayElementValidator || c.validateSpec;
                    if (Ur(n) !== "array")
                        return [new ee(b,n,`array expected, ${Ur(n)} found`)];
                    if (l.length && n.length !== l.length)
                        return [new ee(b,n,`array length ${l.length} expected, length ${n.length} found`)];
                    if (l["min-length"] && n.length < l["min-length"])
                        return [new ee(b,n,`array length at least ${l["min-length"]} expected, length ${n.length} found`)];
                    let M = {
                        type: l.value,
                        values: l.values
                    };
                    _.$version < 7 && (M.function = l.function),
                    Ur(l.value) === "object" && (M = l.value);
                    let R = [];
                    for (let O = 0; O < n.length; O++)
                        R = R.concat(C({
                            array: n,
                            arrayIndex: O,
                            value: n[O],
                            valueSpec: M,
                            validateSpec: c.validateSpec,
                            style: p,
                            styleSpec: _,
                            key: `${b}[${O}]`
                        }));
                    return R
                }
                function ku(c) {
                    const n = c.key
                      , l = c.value
                      , p = c.valueSpec;
                    let _ = Ur(l);
                    return _ === "number" && l != l && (_ = "NaN"),
                    _ !== "number" ? [new ee(n,l,`number expected, ${_} found`)] : "minimum"in p && l < p.minimum ? [new ee(n,l,`${l} is less than the minimum value ${p.minimum}`)] : "maximum"in p && l > p.maximum ? [new ee(n,l,`${l} is greater than the maximum value ${p.maximum}`)] : []
                }
                function _c(c) {
                    const n = c.valueSpec
                      , l = fn(c.value.type);
                    let p, _, b, C = {};
                    const M = l !== "categorical" && c.value.property === void 0
                      , R = !M
                      , O = Ur(c.value.stops) === "array" && Ur(c.value.stops[0]) === "array" && Ur(c.value.stops[0][0]) === "object"
                      , j = gi({
                        key: c.key,
                        value: c.value,
                        valueSpec: c.styleSpec.function,
                        validateSpec: c.validateSpec,
                        style: c.style,
                        styleSpec: c.styleSpec,
                        objectElementValidators: {
                            stops: function(ne) {
                                if (l === "identity")
                                    return [new ee(ne.key,ne.value,'identity function may not have a "stops" property')];
                                let oe = [];
                                const de = ne.value;
                                return oe = oe.concat(yc({
                                    key: ne.key,
                                    value: de,
                                    valueSpec: ne.valueSpec,
                                    validateSpec: ne.validateSpec,
                                    style: ne.style,
                                    styleSpec: ne.styleSpec,
                                    arrayElementValidator: q
                                })),
                                Ur(de) === "array" && de.length === 0 && oe.push(new ee(ne.key,de,"array must have at least one stop")),
                                oe
                            },
                            default: function(ne) {
                                return ne.validateSpec({
                                    key: ne.key,
                                    value: ne.value,
                                    valueSpec: n,
                                    validateSpec: ne.validateSpec,
                                    style: ne.style,
                                    styleSpec: ne.styleSpec
                                })
                            }
                        }
                    });
                    return l === "identity" && M && j.push(new ee(c.key,c.value,'missing required property "property"')),
                    l === "identity" || c.value.stops || j.push(new ee(c.key,c.value,'missing required property "stops"')),
                    l === "exponential" && c.valueSpec.expression && !bd(c.valueSpec) && j.push(new ee(c.key,c.value,"exponential functions not supported")),
                    c.styleSpec.$version >= 8 && (R && !Wa(c.valueSpec) ? j.push(new ee(c.key,c.value,"property functions not supported")) : M && !xd(c.valueSpec) && j.push(new ee(c.key,c.value,"zoom functions not supported"))),
                    l !== "categorical" && !O || c.value.property !== void 0 || j.push(new ee(c.key,c.value,'"property" property is required')),
                    j;
                    function q(ne) {
                        let oe = [];
                        const de = ne.value
                          , we = ne.key;
                        if (Ur(de) !== "array")
                            return [new ee(we,de,`array expected, ${Ur(de)} found`)];
                        if (de.length !== 2)
                            return [new ee(we,de,`array length 2 expected, length ${de.length} found`)];
                        if (O) {
                            if (Ur(de[0]) !== "object")
                                return [new ee(we,de,`object expected, ${Ur(de[0])} found`)];
                            if (de[0].zoom === void 0)
                                return [new ee(we,de,"object stop key must have zoom")];
                            if (de[0].value === void 0)
                                return [new ee(we,de,"object stop key must have value")];
                            if (b && b > fn(de[0].zoom))
                                return [new ee(we,de[0].zoom,"stop zoom values must appear in ascending order")];
                            fn(de[0].zoom) !== b && (b = fn(de[0].zoom),
                            _ = void 0,
                            C = {}),
                            oe = oe.concat(gi({
                                key: `${we}[0]`,
                                value: de[0],
                                valueSpec: {
                                    zoom: {}
                                },
                                validateSpec: ne.validateSpec,
                                style: ne.style,
                                styleSpec: ne.styleSpec,
                                objectElementValidators: {
                                    zoom: ku,
                                    value: Q
                                }
                            }))
                        } else
                            oe = oe.concat(Q({
                                key: `${we}[0]`,
                                value: de[0],
                                validateSpec: ne.validateSpec,
                                style: ne.style,
                                styleSpec: ne.styleSpec
                            }, de));
                        return qa(ds(de[1])) ? oe.concat([new ee(`${we}[1]`,de[1],"expressions are not allowed in function stops.")]) : oe.concat(ne.validateSpec({
                            key: `${we}[1]`,
                            value: de[1],
                            valueSpec: n,
                            validateSpec: ne.validateSpec,
                            style: ne.style,
                            styleSpec: ne.styleSpec
                        }))
                    }
                    function Q(ne, oe) {
                        const de = Ur(ne.value)
                          , we = fn(ne.value)
                          , Ie = ne.value !== null ? ne.value : oe;
                        if (p) {
                            if (de !== p)
                                return [new ee(ne.key,Ie,`${de} stop domain type must match previous stop domain type ${p}`)]
                        } else
                            p = de;
                        if (de !== "number" && de !== "string" && de !== "boolean")
                            return [new ee(ne.key,Ie,"stop domain value must be a number, string, or boolean")];
                        if (de !== "number" && l !== "categorical") {
                            let Ye = `number expected, ${de} found`;
                            return Wa(n) && l === void 0 && (Ye += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                            [new ee(ne.key,Ie,Ye)]
                        }
                        return l !== "categorical" || de !== "number" || isFinite(we) && Math.floor(we) === we ? l !== "categorical" && de === "number" && _ !== void 0 && we < _ ? [new ee(ne.key,Ie,"stop domain values must appear in ascending order")] : (_ = we,
                        l === "categorical" && we in C ? [new ee(ne.key,Ie,"stop domain values must be unique")] : (C[we] = !0,
                        [])) : [new ee(ne.key,Ie,`integer expected, found ${we}`)]
                    }
                }
                function fs(c) {
                    const n = (c.expressionContext === "property" ? Pd : Il)(ds(c.value), c.valueSpec);
                    if (n.result === "error")
                        return n.value.map(p => new ee(`${c.key}${p.key}`,c.value,p.message));
                    const l = n.value.expression || n.value._styleExpression.expression;
                    if (c.expressionContext === "property" && c.propertyKey === "text-font" && !l.outputDefined())
                        return [new ee(c.key,c.value,`Invalid data expression for "${c.propertyKey}". Output values must be contained as literals within the expression.`)];
                    if (c.expressionContext === "property" && c.propertyType === "layout" && !pc(l))
                        return [new ee(c.key,c.value,'"feature-state" data expressions are not supported with layout properties.')];
                    if (c.expressionContext === "filter" && !pc(l))
                        return [new ee(c.key,c.value,'"feature-state" data expressions are not supported with filters.')];
                    if (c.expressionContext && c.expressionContext.indexOf("cluster") === 0) {
                        if (!kl(l, ["zoom", "feature-state"]))
                            return [new ee(c.key,c.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                        if (c.expressionContext === "cluster-initial" && !Su(l))
                            return [new ee(c.key,c.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]
                    }
                    return []
                }
                function Dl(c) {
                    const n = c.key
                      , l = c.value
                      , p = Ur(l);
                    return p !== "string" ? [new ee(n,l,`color expected, ${p} found`)] : Br.parse(String(l)) ? [] : [new ee(n,l,`color expected, "${l}" found`)]
                }
                function Hs(c) {
                    const n = c.key
                      , l = c.value
                      , p = c.valueSpec
                      , _ = [];
                    return Array.isArray(p.values) ? p.values.indexOf(fn(l)) === -1 && _.push(new ee(n,l,`expected one of [${p.values.join(", ")}], ${JSON.stringify(l)} found`)) : Object.keys(p.values).indexOf(fn(l)) === -1 && _.push(new ee(n,l,`expected one of [${Object.keys(p.values).join(", ")}], ${JSON.stringify(l)} found`)),
                    _
                }
                function vc(c) {
                    return Ha(ds(c.value)) ? fs(Ze({}, c, {
                        expressionContext: "filter",
                        valueSpec: {
                            value: "boolean"
                        }
                    })) : wh(c)
                }
                function wh(c) {
                    const n = c.value
                      , l = c.key;
                    if (Ur(n) !== "array")
                        return [new ee(l,n,`array expected, ${Ur(n)} found`)];
                    const p = c.styleSpec;
                    let _, b = [];
                    if (n.length < 1)
                        return [new ee(l,n,"filter array must have at least 1 element")];
                    switch (b = b.concat(Hs({
                        key: `${l}[0]`,
                        value: n[0],
                        valueSpec: p.filter_operator,
                        style: c.style,
                        styleSpec: c.styleSpec
                    })),
                    fn(n[0])) {
                    case "<":
                    case "<=":
                    case ">":
                    case ">=":
                        n.length >= 2 && fn(n[1]) === "$type" && b.push(new ee(l,n,`"$type" cannot be use with operator "${n[0]}"`));
                    case "==":
                    case "!=":
                        n.length !== 3 && b.push(new ee(l,n,`filter array for operator "${n[0]}" must have 3 elements`));
                    case "in":
                    case "!in":
                        n.length >= 2 && (_ = Ur(n[1]),
                        _ !== "string" && b.push(new ee(`${l}[1]`,n[1],`string expected, ${_} found`)));
                        for (let C = 2; C < n.length; C++)
                            _ = Ur(n[C]),
                            fn(n[1]) === "$type" ? b = b.concat(Hs({
                                key: `${l}[${C}]`,
                                value: n[C],
                                valueSpec: p.geometry_type,
                                style: c.style,
                                styleSpec: c.styleSpec
                            })) : _ !== "string" && _ !== "number" && _ !== "boolean" && b.push(new ee(`${l}[${C}]`,n[C],`string, number, or boolean expected, ${_} found`));
                        break;
                    case "any":
                    case "all":
                    case "none":
                        for (let C = 1; C < n.length; C++)
                            b = b.concat(wh({
                                key: `${l}[${C}]`,
                                value: n[C],
                                style: c.style,
                                styleSpec: c.styleSpec
                            }));
                        break;
                    case "has":
                    case "!has":
                        _ = Ur(n[1]),
                        n.length !== 2 ? b.push(new ee(l,n,`filter array for "${n[0]}" operator must have 2 elements`)) : _ !== "string" && b.push(new ee(`${l}[1]`,n[1],`string expected, ${_} found`))
                    }
                    return b
                }
                function Ll(c, n) {
                    const l = c.key
                      , p = c.validateSpec
                      , _ = c.style
                      , b = c.styleSpec
                      , C = c.value
                      , M = c.objectKey
                      , R = b[`${n}_${c.layerType}`];
                    if (!R)
                        return [];
                    const O = M.match(/^(.*)-transition$/);
                    if (n === "paint" && O && R[O[1]] && R[O[1]].transition)
                        return p({
                            key: l,
                            value: C,
                            valueSpec: b.transition,
                            style: _,
                            styleSpec: b
                        });
                    const j = c.valueSpec || R[M];
                    if (!j)
                        return [new ee(l,C,`unknown property "${M}"`)];
                    let q;
                    if (Ur(C) === "string" && Wa(j) && !j.tokens && (q = /^{([^}]+)}$/.exec(C)))
                        return [new ee(l,C,`"${M}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(q[1])} }\`.`)];
                    const Q = [];
                    return c.layerType === "symbol" && (M === "text-field" && _ && !_.glyphs && Q.push(new ee(l,C,'use of "text-field" requires a style "glyphs" property')),
                    M === "text-font" && El(ds(C)) && fn(C.type) === "identity" && Q.push(new ee(l,C,'"text-font" does not support identity functions'))),
                    Q.concat(p({
                        key: c.key,
                        value: C,
                        valueSpec: j,
                        style: _,
                        styleSpec: b,
                        expressionContext: "property",
                        propertyType: n,
                        propertyKey: M
                    }))
                }
                function Yo(c) {
                    return Ll(c, "paint")
                }
                function wn(c) {
                    return Ll(c, "layout")
                }
                function tn(c) {
                    let n = [];
                    const l = c.value
                      , p = c.key
                      , _ = c.style
                      , b = c.styleSpec;
                    if (Ur(l) !== "object")
                        return [new ee(p,l,`object expected, ${Ur(l)} found`)];
                    l.type || l.ref || n.push(new ee(p,l,'either "type" or "ref" is required'));
                    let C = fn(l.type);
                    const M = fn(l.ref);
                    if (l.id) {
                        const R = fn(l.id);
                        for (let O = 0; O < c.arrayIndex; O++) {
                            const j = _.layers[O];
                            fn(j.id) === R && n.push(new ee(p,l.id,`duplicate layer id "${l.id}", previously used at line ${j.id.__line__}`))
                        }
                    }
                    if ("ref"in l) {
                        let R;
                        ["type", "source", "source-layer", "filter", "layout"].forEach(O => {
                            O in l && n.push(new ee(p,l[O],`"${O}" is prohibited for ref layers`))
                        }
                        ),
                        _.layers.forEach(O => {
                            fn(O.id) === M && (R = O)
                        }
                        ),
                        R ? R.ref ? n.push(new ee(p,l.ref,"ref cannot reference another ref layer")) : C = fn(R.type) : n.push(new ee(p,l.ref,`ref layer "${M}" not found`))
                    } else if (C !== "background")
                        if (l.source) {
                            const R = _.sources && _.sources[l.source]
                              , O = R && fn(R.type);
                            R ? O === "vector" && C === "raster" ? n.push(new ee(p,l.source,`layer "${l.id}" requires a raster source`)) : O !== "raster-dem" && C === "hillshade" || O !== "raster-dem" && C === "color-relief" ? n.push(new ee(p,l.source,`layer "${l.id}" requires a raster-dem source`)) : O === "raster" && C !== "raster" ? n.push(new ee(p,l.source,`layer "${l.id}" requires a vector source`)) : O !== "vector" || l["source-layer"] ? O === "raster-dem" && C !== "hillshade" && C !== "color-relief" ? n.push(new ee(p,l.source,"raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : C !== "line" || !l.paint || !l.paint["line-gradient"] || O === "geojson" && R.lineMetrics || n.push(new ee(p,l,`layer "${l.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : n.push(new ee(p,l,`layer "${l.id}" must specify a "source-layer"`)) : n.push(new ee(p,l.source,`source "${l.source}" not found`))
                        } else
                            n.push(new ee(p,l,'missing required property "source"'));
                    return n = n.concat(gi({
                        key: p,
                        value: l,
                        valueSpec: b.layer,
                        style: c.style,
                        styleSpec: c.styleSpec,
                        validateSpec: c.validateSpec,
                        objectElementValidators: {
                            "*": () => [],
                            type: () => c.validateSpec({
                                key: `${p}.type`,
                                value: l.type,
                                valueSpec: b.layer.type,
                                style: c.style,
                                styleSpec: c.styleSpec,
                                validateSpec: c.validateSpec,
                                object: l,
                                objectKey: "type"
                            }),
                            filter: vc,
                            layout: R => gi({
                                layer: l,
                                key: R.key,
                                value: R.value,
                                style: R.style,
                                styleSpec: R.styleSpec,
                                validateSpec: R.validateSpec,
                                objectElementValidators: {
                                    "*": O => wn(Ze({
                                        layerType: C
                                    }, O))
                                }
                            }),
                            paint: R => gi({
                                layer: l,
                                key: R.key,
                                value: R.value,
                                style: R.style,
                                styleSpec: R.styleSpec,
                                validateSpec: R.validateSpec,
                                objectElementValidators: {
                                    "*": O => Yo(Ze({
                                        layerType: C
                                    }, O))
                                }
                            })
                        }
                    })),
                    n
                }
                function Ri(c) {
                    const n = c.value
                      , l = c.key
                      , p = Ur(n);
                    return p !== "string" ? [new ee(l,n,`string expected, ${p} found`)] : []
                }
                const Ai = {
                    promoteId: function({key: c, value: n}) {
                        if (Ur(n) === "string")
                            return Ri({
                                key: c,
                                value: n
                            });
                        {
                            const l = [];
                            for (const p in n)
                                l.push(...Ri({
                                    key: `${c}.${p}`,
                                    value: n[p]
                                }));
                            return l
                        }
                    }
                };
                function _o(c) {
                    const n = c.value
                      , l = c.key
                      , p = c.styleSpec
                      , _ = c.style
                      , b = c.validateSpec;
                    if (!n.type)
                        return [new ee(l,n,'"type" is required')];
                    const C = fn(n.type);
                    let M;
                    switch (C) {
                    case "vector":
                    case "raster":
                        return M = gi({
                            key: l,
                            value: n,
                            valueSpec: p[`source_${C.replace("-", "_")}`],
                            style: c.style,
                            styleSpec: p,
                            objectElementValidators: Ai,
                            validateSpec: b
                        }),
                        M;
                    case "raster-dem":
                        return M = function(R) {
                            var O;
                            const j = (O = R.sourceName) !== null && O !== void 0 ? O : ""
                              , q = R.value
                              , Q = R.styleSpec
                              , ne = Q.source_raster_dem
                              , oe = R.style;
                            let de = [];
                            const we = Ur(q);
                            if (q === void 0)
                                return de;
                            if (we !== "object")
                                return de.push(new ee("source_raster_dem",q,`object expected, ${we} found`)),
                                de;
                            const Ie = fn(q.encoding) === "custom"
                              , Ye = ["redFactor", "greenFactor", "blueFactor", "baseShift"]
                              , Le = R.value.encoding ? `"${R.value.encoding}"` : "Default";
                            for (const te in q)
                                !Ie && Ye.includes(te) ? de.push(new ee(te,q[te],`In "${j}": "${te}" is only valid when "encoding" is set to "custom". ${Le} encoding found`)) : ne[te] ? de = de.concat(R.validateSpec({
                                    key: te,
                                    value: q[te],
                                    valueSpec: ne[te],
                                    validateSpec: R.validateSpec,
                                    style: oe,
                                    styleSpec: Q
                                })) : de.push(new ee(te,q[te],`unknown property "${te}"`));
                            return de
                        }({
                            sourceName: l,
                            value: n,
                            style: c.style,
                            styleSpec: p,
                            validateSpec: b
                        }),
                        M;
                    case "geojson":
                        if (M = gi({
                            key: l,
                            value: n,
                            valueSpec: p.source_geojson,
                            style: _,
                            styleSpec: p,
                            validateSpec: b,
                            objectElementValidators: Ai
                        }),
                        n.cluster)
                            for (const R in n.clusterProperties) {
                                const [O,j] = n.clusterProperties[R]
                                  , q = typeof O == "string" ? [O, ["accumulated"], ["get", R]] : O;
                                M.push(...fs({
                                    key: `${l}.${R}.map`,
                                    value: j,
                                    expressionContext: "cluster-map"
                                })),
                                M.push(...fs({
                                    key: `${l}.${R}.reduce`,
                                    value: q,
                                    expressionContext: "cluster-reduce"
                                }))
                            }
                        return M;
                    case "video":
                        return gi({
                            key: l,
                            value: n,
                            valueSpec: p.source_video,
                            style: _,
                            validateSpec: b,
                            styleSpec: p
                        });
                    case "image":
                        return gi({
                            key: l,
                            value: n,
                            valueSpec: p.source_image,
                            style: _,
                            validateSpec: b,
                            styleSpec: p
                        });
                    case "canvas":
                        return [new ee(l,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];
                    default:
                        return Hs({
                            key: `${l}.type`,
                            value: n.type,
                            valueSpec: {
                                values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                            }
                        })
                    }
                }
                function Za(c) {
                    const n = c.value
                      , l = c.styleSpec
                      , p = l.light
                      , _ = c.style;
                    let b = [];
                    const C = Ur(n);
                    if (n === void 0)
                        return b;
                    if (C !== "object")
                        return b = b.concat([new ee("light",n,`object expected, ${C} found`)]),
                        b;
                    for (const M in n) {
                        const R = M.match(/^(.*)-transition$/);
                        b = b.concat(R && p[R[1]] && p[R[1]].transition ? c.validateSpec({
                            key: M,
                            value: n[M],
                            valueSpec: l.transition,
                            validateSpec: c.validateSpec,
                            style: _,
                            styleSpec: l
                        }) : p[M] ? c.validateSpec({
                            key: M,
                            value: n[M],
                            valueSpec: p[M],
                            validateSpec: c.validateSpec,
                            style: _,
                            styleSpec: l
                        }) : [new ee(M,n[M],`unknown property "${M}"`)])
                    }
                    return b
                }
                function ks(c) {
                    const n = c.value
                      , l = c.styleSpec
                      , p = l.sky
                      , _ = c.style
                      , b = Ur(n);
                    if (n === void 0)
                        return [];
                    if (b !== "object")
                        return [new ee("sky",n,`object expected, ${b} found`)];
                    let C = [];
                    for (const M in n)
                        C = C.concat(p[M] ? c.validateSpec({
                            key: M,
                            value: n[M],
                            valueSpec: p[M],
                            style: _,
                            styleSpec: l
                        }) : [new ee(M,n[M],`unknown property "${M}"`)]);
                    return C
                }
                function to(c) {
                    const n = c.value
                      , l = c.styleSpec
                      , p = l.terrain
                      , _ = c.style;
                    let b = [];
                    const C = Ur(n);
                    if (n === void 0)
                        return b;
                    if (C !== "object")
                        return b = b.concat([new ee("terrain",n,`object expected, ${C} found`)]),
                        b;
                    for (const M in n)
                        b = b.concat(p[M] ? c.validateSpec({
                            key: M,
                            value: n[M],
                            valueSpec: p[M],
                            validateSpec: c.validateSpec,
                            style: _,
                            styleSpec: l
                        }) : [new ee(M,n[M],`unknown property "${M}"`)]);
                    return b
                }
                function Ol(c) {
                    let n = [];
                    const l = c.value
                      , p = c.key;
                    if (Array.isArray(l)) {
                        const _ = []
                          , b = [];
                        for (const C in l)
                            l[C].id && _.includes(l[C].id) && n.push(new ee(p,l,`all the sprites' ids must be unique, but ${l[C].id} is duplicated`)),
                            _.push(l[C].id),
                            l[C].url && b.includes(l[C].url) && n.push(new ee(p,l,`all the sprites' URLs must be unique, but ${l[C].url} is duplicated`)),
                            b.push(l[C].url),
                            n = n.concat(gi({
                                key: `${p}[${C}]`,
                                value: l[C],
                                valueSpec: {
                                    id: {
                                        type: "string",
                                        required: !0
                                    },
                                    url: {
                                        type: "string",
                                        required: !0
                                    }
                                },
                                validateSpec: c.validateSpec
                            }));
                        return n
                    }
                    return Ri({
                        key: p,
                        value: l
                    })
                }
                function kd(c) {
                    return n = c.value,
                    n && n.constructor === Object ? [] : [new ee(c.key,c.value,`object expected, ${Ur(c.value)} found`)];
                    var n
                }
                const Eu = {
                    "*": () => [],
                    array: yc,
                    boolean: function(c) {
                        const n = c.value
                          , l = c.key
                          , p = Ur(n);
                        return p !== "boolean" ? [new ee(l,n,`boolean expected, ${p} found`)] : []
                    },
                    number: ku,
                    color: Dl,
                    constants: zl,
                    enum: Hs,
                    filter: vc,
                    function: _c,
                    layer: tn,
                    object: gi,
                    source: _o,
                    light: Za,
                    sky: ks,
                    terrain: to,
                    projection: function(c) {
                        const n = c.value
                          , l = c.styleSpec
                          , p = l.projection
                          , _ = c.style
                          , b = Ur(n);
                        if (n === void 0)
                            return [];
                        if (b !== "object")
                            return [new ee("projection",n,`object expected, ${b} found`)];
                        let C = [];
                        for (const M in n)
                            C = C.concat(p[M] ? c.validateSpec({
                                key: M,
                                value: n[M],
                                valueSpec: p[M],
                                style: _,
                                styleSpec: l
                            }) : [new ee(M,n[M],`unknown property "${M}"`)]);
                        return C
                    },
                    projectionDefinition: function(c) {
                        const n = c.key;
                        let l = c.value;
                        l = l instanceof String ? l.valueOf() : l;
                        const p = Ur(l);
                        return p !== "array" || function(_) {
                            return Array.isArray(_) && _.length === 3 && typeof _[0] == "string" && typeof _[1] == "string" && typeof _[2] == "number"
                        }(l) || function(_) {
                            return !!["interpolate", "step", "literal"].includes(_[0])
                        }(l) ? ["array", "string"].includes(p) ? [] : [new ee(n,l,`projection expected, invalid type "${p}" found`)] : [new ee(n,l,`projection expected, invalid array ${JSON.stringify(l)} found`)]
                    },
                    string: Ri,
                    formatted: function(c) {
                        return Ri(c).length === 0 ? [] : fs(c)
                    },
                    resolvedImage: function(c) {
                        return Ri(c).length === 0 ? [] : fs(c)
                    },
                    padding: function(c) {
                        const n = c.key
                          , l = c.value;
                        if (Ur(l) === "array") {
                            if (l.length < 1 || l.length > 4)
                                return [new ee(n,l,`padding requires 1 to 4 values; ${l.length} values found`)];
                            const p = {
                                type: "number"
                            };
                            let _ = [];
                            for (let b = 0; b < l.length; b++)
                                _ = _.concat(c.validateSpec({
                                    key: `${n}[${b}]`,
                                    value: l[b],
                                    validateSpec: c.validateSpec,
                                    valueSpec: p
                                }));
                            return _
                        }
                        return ku({
                            key: n,
                            value: l,
                            valueSpec: {}
                        })
                    },
                    numberArray: function(c) {
                        const n = c.key
                          , l = c.value;
                        if (Ur(l) === "array") {
                            const p = {
                                type: "number"
                            };
                            if (l.length < 1)
                                return [new ee(n,l,"array length at least 1 expected, length 0 found")];
                            let _ = [];
                            for (let b = 0; b < l.length; b++)
                                _ = _.concat(c.validateSpec({
                                    key: `${n}[${b}]`,
                                    value: l[b],
                                    validateSpec: c.validateSpec,
                                    valueSpec: p
                                }));
                            return _
                        }
                        return ku({
                            key: n,
                            value: l,
                            valueSpec: {}
                        })
                    },
                    colorArray: function(c) {
                        const n = c.key
                          , l = c.value;
                        if (Ur(l) === "array") {
                            if (l.length < 1)
                                return [new ee(n,l,"array length at least 1 expected, length 0 found")];
                            let p = [];
                            for (let _ = 0; _ < l.length; _++)
                                p = p.concat(Dl({
                                    key: `${n}[${_}]`,
                                    value: l[_]
                                }));
                            return p
                        }
                        return Dl({
                            key: n,
                            value: l
                        })
                    },
                    variableAnchorOffsetCollection: function(c) {
                        const n = c.key
                          , l = c.value
                          , p = Ur(l)
                          , _ = c.styleSpec;
                        if (p !== "array" || l.length < 1 || l.length % 2 != 0)
                            return [new ee(n,l,"variableAnchorOffsetCollection requires a non-empty array of even length")];
                        let b = [];
                        for (let C = 0; C < l.length; C += 2)
                            b = b.concat(Hs({
                                key: `${n}[${C}]`,
                                value: l[C],
                                valueSpec: _.layout_symbol["text-anchor"]
                            })),
                            b = b.concat(yc({
                                key: `${n}[${C + 1}]`,
                                value: l[C + 1],
                                valueSpec: {
                                    length: 2,
                                    value: "number"
                                },
                                validateSpec: c.validateSpec,
                                style: c.style,
                                styleSpec: _
                            }));
                        return b
                    },
                    sprite: Ol,
                    state: kd
                };
                function Fl(c) {
                    const n = c.value
                      , l = c.valueSpec
                      , p = c.styleSpec;
                    return c.validateSpec = Fl,
                    l.expression && El(fn(n)) ? _c(c) : l.expression && qa(ds(n)) ? fs(c) : l.type && Eu[l.type] ? Eu[l.type](c) : gi(Ze({}, c, {
                        valueSpec: l.type ? p[l.type] : l
                    }))
                }
                function Bl(c) {
                    const n = c.value
                      , l = c.key
                      , p = Ri(c);
                    return p.length || (n.indexOf("{fontstack}") === -1 && p.push(new ee(l,n,'"glyphs" url must include a "{fontstack}" token')),
                    n.indexOf("{range}") === -1 && p.push(new ee(l,n,'"glyphs" url must include a "{range}" token'))),
                    p
                }
                function yi(c, n=Ve) {
                    let l = [];
                    return l = l.concat(Fl({
                        key: "",
                        value: c,
                        valueSpec: n.$root,
                        styleSpec: n,
                        style: c,
                        validateSpec: Fl,
                        objectElementValidators: {
                            glyphs: Bl,
                            "*": () => []
                        }
                    })),
                    c.constants && (l = l.concat(zl({
                        key: "constants",
                        value: c.constants
                    }))),
                    Sh(l)
                }
                function Do(c) {
                    return function(n) {
                        return c({
                            ...n,
                            validateSpec: Fl
                        })
                    }
                }
                function Sh(c) {
                    return [].concat(c).sort( (n, l) => n.line - l.line)
                }
                function ro(c) {
                    return function(...n) {
                        return Sh(c.apply(this, n))
                    }
                }
                yi.source = ro(Do(_o)),
                yi.sprite = ro(Do(Ol)),
                yi.glyphs = ro(Do(Bl)),
                yi.light = ro(Do(Za)),
                yi.sky = ro(Do(ks)),
                yi.terrain = ro(Do(to)),
                yi.state = ro(Do(kd)),
                yi.layer = ro(Do(tn)),
                yi.filter = ro(Do(vc)),
                yi.paintProperty = ro(Do(Yo)),
                yi.layoutProperty = ro(Do(wn));
                const xc = yi
                  , Xa = xc.light
                  , da = xc.sky
                  , bc = xc.paintProperty
                  , wc = xc.layoutProperty;
                function Ya(c, n) {
                    let l = !1;
                    if (n && n.length)
                        for (const p of n)
                            c.fire(new tt(new Error(p.message))),
                            l = !0;
                    return l
                }
                class Wi {
                    constructor(n, l, p) {
                        const _ = this.cells = [];
                        if (n instanceof ArrayBuffer) {
                            this.arrayBuffer = n;
                            const C = new Int32Array(this.arrayBuffer);
                            n = C[0],
                            this.d = (l = C[1]) + 2 * (p = C[2]);
                            for (let R = 0; R < this.d * this.d; R++) {
                                const O = C[3 + R]
                                  , j = C[3 + R + 1];
                                _.push(O === j ? null : C.subarray(O, j))
                            }
                            const M = C[3 + _.length + 1];
                            this.keys = C.subarray(C[3 + _.length], M),
                            this.bboxes = C.subarray(M),
                            this.insert = this._insertReadonly
                        } else {
                            this.d = l + 2 * p;
                            for (let C = 0; C < this.d * this.d; C++)
                                _.push([]);
                            this.keys = [],
                            this.bboxes = []
                        }
                        this.n = l,
                        this.extent = n,
                        this.padding = p,
                        this.scale = l / n,
                        this.uid = 0;
                        const b = p / l * n;
                        this.min = -b,
                        this.max = n + b
                    }
                    insert(n, l, p, _, b) {
                        this._forEachCell(l, p, _, b, this._insertCell, this.uid++, void 0, void 0),
                        this.keys.push(n),
                        this.bboxes.push(l),
                        this.bboxes.push(p),
                        this.bboxes.push(_),
                        this.bboxes.push(b)
                    }
                    _insertReadonly() {
                        throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
                    }
                    _insertCell(n, l, p, _, b, C) {
                        this.cells[b].push(C)
                    }
                    query(n, l, p, _, b) {
                        const C = this.min
                          , M = this.max;
                        if (n <= C && l <= C && M <= p && M <= _ && !b)
                            return Array.prototype.slice.call(this.keys);
                        {
                            const R = [];
                            return this._forEachCell(n, l, p, _, this._queryCell, R, {}, b),
                            R
                        }
                    }
                    _queryCell(n, l, p, _, b, C, M, R) {
                        const O = this.cells[b];
                        if (O !== null) {
                            const j = this.keys
                              , q = this.bboxes;
                            for (let Q = 0; Q < O.length; Q++) {
                                const ne = O[Q];
                                if (M[ne] === void 0) {
                                    const oe = 4 * ne;
                                    (R ? R(q[oe + 0], q[oe + 1], q[oe + 2], q[oe + 3]) : n <= q[oe + 2] && l <= q[oe + 3] && p >= q[oe + 0] && _ >= q[oe + 1]) ? (M[ne] = !0,
                                    C.push(j[ne])) : M[ne] = !1
                                }
                            }
                        }
                    }
                    _forEachCell(n, l, p, _, b, C, M, R) {
                        const O = this._convertToCellCoord(n)
                          , j = this._convertToCellCoord(l)
                          , q = this._convertToCellCoord(p)
                          , Q = this._convertToCellCoord(_);
                        for (let ne = O; ne <= q; ne++)
                            for (let oe = j; oe <= Q; oe++) {
                                const de = this.d * oe + ne;
                                if ((!R || R(this._convertFromCellCoord(ne), this._convertFromCellCoord(oe), this._convertFromCellCoord(ne + 1), this._convertFromCellCoord(oe + 1))) && b.call(this, n, l, p, _, de, C, M, R))
                                    return
                            }
                    }
                    _convertFromCellCoord(n) {
                        return (n - this.padding) / this.scale
                    }
                    _convertToCellCoord(n) {
                        return Math.max(0, Math.min(this.d - 1, Math.floor(n * this.scale) + this.padding))
                    }
                    toArrayBuffer() {
                        if (this.arrayBuffer)
                            return this.arrayBuffer;
                        const n = this.cells
                          , l = 3 + this.cells.length + 1 + 1;
                        let p = 0;
                        for (let C = 0; C < this.cells.length; C++)
                            p += this.cells[C].length;
                        const _ = new Int32Array(l + p + this.keys.length + this.bboxes.length);
                        _[0] = this.extent,
                        _[1] = this.n,
                        _[2] = this.padding;
                        let b = l;
                        for (let C = 0; C < n.length; C++) {
                            const M = n[C];
                            _[3 + C] = b,
                            _.set(M, b),
                            b += M.length
                        }
                        return _[3 + n.length] = b,
                        _.set(this.keys, b),
                        b += this.keys.length,
                        _[3 + n.length + 1] = b,
                        _.set(this.bboxes, b),
                        b += this.bboxes.length,
                        _.buffer
                    }
                    static serialize(n, l) {
                        const p = n.toArrayBuffer();
                        return l && l.push(p),
                        {
                            buffer: p
                        }
                    }
                    static deserialize(n) {
                        return new Wi(n.buffer)
                    }
                }
                const hi = {};
                function Kt(c, n, l={}) {
                    if (hi[c])
                        throw new Error(`${c} is already registered.`);
                    Object.defineProperty(n, "_classRegistryKey", {
                        value: c,
                        writeable: !1
                    }),
                    hi[c] = {
                        klass: n,
                        omit: l.omit || [],
                        shallow: l.shallow || []
                    }
                }
                Kt("Object", Object),
                Kt("Set", Set),
                Kt("TransferableGridIndex", Wi),
                Kt("Color", Br),
                Kt("Error", Error),
                Kt("AJAXError", Me),
                Kt("ResolvedImage", mo),
                Kt("StylePropertyFunction", Tu),
                Kt("StyleExpression", gc, {
                    omit: ["_evaluator"]
                }),
                Kt("ZoomDependentExpression", Cu),
                Kt("ZoomConstantExpression", Ws),
                Kt("CompoundExpression", zo, {
                    omit: ["_evaluate"]
                });
                for (const c in Ps)
                    Ps[c]._classRegistryKey || Kt(`Expression_${c}`, Ps[c]);
                function Es(c) {
                    return c && typeof ArrayBuffer < "u" && (c instanceof ArrayBuffer || c.constructor && c.constructor.name === "ArrayBuffer")
                }
                function Ko(c) {
                    return c.$name || c.constructor._classRegistryKey
                }
                function fa(c) {
                    return !function(n) {
                        if (n === null || typeof n != "object")
                            return !1;
                        const l = Ko(n);
                        return !(!l || l === "Object")
                    }(c) && (c == null || typeof c == "boolean" || typeof c == "number" || typeof c == "string" || c instanceof Boolean || c instanceof Number || c instanceof String || c instanceof Date || c instanceof RegExp || c instanceof Blob || c instanceof Error || Es(c) || Wr(c) || ArrayBuffer.isView(c) || c instanceof ImageData)
                }
                function Sc(c, n) {
                    if (fa(c))
                        return (Es(c) || Wr(c)) && n && n.push(c),
                        ArrayBuffer.isView(c) && n && n.push(c.buffer),
                        c instanceof ImageData && n && n.push(c.data.buffer),
                        c;
                    if (Array.isArray(c)) {
                        const b = [];
                        for (const C of c)
                            b.push(Sc(C, n));
                        return b
                    }
                    if (typeof c != "object")
                        throw new Error("can't serialize object of type " + typeof c);
                    const l = Ko(c);
                    if (!l)
                        throw new Error(`can't serialize object of unregistered class ${c.constructor.name}`);
                    if (!hi[l])
                        throw new Error(`${l} is not registered.`);
                    const {klass: p} = hi[l]
                      , _ = p.serialize ? p.serialize(c, n) : {};
                    if (p.serialize) {
                        if (n && _ === n[n.length - 1])
                            throw new Error("statically serialized object won't survive transfer of $name property")
                    } else {
                        for (const b in c) {
                            if (!c.hasOwnProperty(b) || hi[l].omit.indexOf(b) >= 0)
                                continue;
                            const C = c[b];
                            _[b] = hi[l].shallow.indexOf(b) >= 0 ? C : Sc(C, n)
                        }
                        c instanceof Error && (_.message = c.message)
                    }
                    if (_.$name)
                        throw new Error("$name property is reserved for worker serialization logic.");
                    return l !== "Object" && (_.$name = l),
                    _
                }
                function Ka(c) {
                    if (fa(c))
                        return c;
                    if (Array.isArray(c))
                        return c.map(Ka);
                    if (typeof c != "object")
                        throw new Error("can't deserialize object of type " + typeof c);
                    const n = Ko(c) || "Object";
                    if (!hi[n])
                        throw new Error(`can't deserialize unregistered class ${n}`);
                    const {klass: l} = hi[n];
                    if (!l)
                        throw new Error(`can't deserialize unregistered class ${n}`);
                    if (l.deserialize)
                        return l.deserialize(c);
                    const p = Object.create(l.prototype);
                    for (const _ of Object.keys(c)) {
                        if (_ === "$name")
                            continue;
                        const b = c[_];
                        p[_] = hi[n].shallow.indexOf(_) >= 0 ? b : Ka(b)
                    }
                    return p
                }
                class Iu {
                    constructor() {
                        this.first = !0
                    }
                    update(n, l) {
                        const p = Math.floor(n);
                        return this.first ? (this.first = !1,
                        this.lastIntegerZoom = p,
                        this.lastIntegerZoomTime = 0,
                        this.lastZoom = n,
                        this.lastFloorZoom = p,
                        !0) : (this.lastFloorZoom > p ? (this.lastIntegerZoom = p + 1,
                        this.lastIntegerZoomTime = l) : this.lastFloorZoom < p && (this.lastIntegerZoom = p,
                        this.lastIntegerZoomTime = l),
                        n !== this.lastZoom && (this.lastZoom = n,
                        this.lastFloorZoom = p,
                        !0))
                    }
                }
                const Ir = {
                    "Latin-1 Supplement": c => c >= 128 && c <= 255,
                    "Hangul Jamo": c => c >= 4352 && c <= 4607,
                    Khmer: c => c >= 6016 && c <= 6143,
                    "General Punctuation": c => c >= 8192 && c <= 8303,
                    "Letterlike Symbols": c => c >= 8448 && c <= 8527,
                    "Number Forms": c => c >= 8528 && c <= 8591,
                    "Miscellaneous Technical": c => c >= 8960 && c <= 9215,
                    "Control Pictures": c => c >= 9216 && c <= 9279,
                    "Optical Character Recognition": c => c >= 9280 && c <= 9311,
                    "Enclosed Alphanumerics": c => c >= 9312 && c <= 9471,
                    "Geometric Shapes": c => c >= 9632 && c <= 9727,
                    "Miscellaneous Symbols": c => c >= 9728 && c <= 9983,
                    "Miscellaneous Symbols and Arrows": c => c >= 11008 && c <= 11263,
                    "Ideographic Description Characters": c => c >= 12272 && c <= 12287,
                    "CJK Symbols and Punctuation": c => c >= 12288 && c <= 12351,
                    Hiragana: c => c >= 12352 && c <= 12447,
                    Katakana: c => c >= 12448 && c <= 12543,
                    Kanbun: c => c >= 12688 && c <= 12703,
                    "CJK Strokes": c => c >= 12736 && c <= 12783,
                    "Enclosed CJK Letters and Months": c => c >= 12800 && c <= 13055,
                    "CJK Compatibility": c => c >= 13056 && c <= 13311,
                    "Yijing Hexagram Symbols": c => c >= 19904 && c <= 19967,
                    "CJK Unified Ideographs": c => c >= 19968 && c <= 40959,
                    "Hangul Syllables": c => c >= 44032 && c <= 55215,
                    "Private Use Area": c => c >= 57344 && c <= 63743,
                    "Vertical Forms": c => c >= 65040 && c <= 65055,
                    "CJK Compatibility Forms": c => c >= 65072 && c <= 65103,
                    "Small Form Variants": c => c >= 65104 && c <= 65135,
                    "Halfwidth and Fullwidth Forms": c => c >= 65280 && c <= 65519
                };
                function vo(c) {
                    for (const n of c)
                        if (Cc(n.charCodeAt(0)))
                            return !0;
                    return !1
                }
                function Xn(c) {
                    for (const n of c)
                        if (!Nf(n.charCodeAt(0)))
                            return !1;
                    return !0
                }
                function Lo(c) {
                    const n = c.map(l => {
                        try {
                            return new RegExp(`\\p{sc=${l}}`,"u").source
                        } catch {
                            return null
                        }
                    }
                    ).filter(l => l);
                    return new RegExp(n.join("|"),"u")
                }
                const jf = Lo(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
                function Nf(c) {
                    return !jf.test(String.fromCodePoint(c))
                }
                const Ru = Lo(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
                function Cc(c) {
                    return !(c !== 746 && c !== 747 && (c < 4352 || !(Ir["CJK Compatibility Forms"](c) && !(c >= 65097 && c <= 65103) || Ir["CJK Compatibility"](c) || Ir["CJK Strokes"](c) || !(!Ir["CJK Symbols and Punctuation"](c) || c >= 12296 && c <= 12305 || c >= 12308 && c <= 12319 || c === 12336) || Ir["Enclosed CJK Letters and Months"](c) || Ir["Ideographic Description Characters"](c) || Ir.Kanbun(c) || Ir.Katakana(c) && c !== 12540 || !(!Ir["Halfwidth and Fullwidth Forms"](c) || c === 65288 || c === 65289 || c === 65293 || c >= 65306 && c <= 65310 || c === 65339 || c === 65341 || c === 65343 || c >= 65371 && c <= 65503 || c === 65507 || c >= 65512 && c <= 65519) || !(!Ir["Small Form Variants"](c) || c >= 65112 && c <= 65118 || c >= 65123 && c <= 65126) || Ir["Vertical Forms"](c) || Ir["Yijing Hexagram Symbols"](c) || new RegExp("\\p{sc=Cans}","u").test(String.fromCodePoint(c)) || new RegExp("\\p{sc=Hang}","u").test(String.fromCodePoint(c)) || Ru.test(String.fromCodePoint(c)))))
                }
                function Ch(c) {
                    return !(Cc(c) || function(n) {
                        return !!(Ir["Latin-1 Supplement"](n) && (n === 167 || n === 169 || n === 174 || n === 177 || n === 188 || n === 189 || n === 190 || n === 215 || n === 247) || Ir["General Punctuation"](n) && (n === 8214 || n === 8224 || n === 8225 || n === 8240 || n === 8241 || n === 8251 || n === 8252 || n === 8258 || n === 8263 || n === 8264 || n === 8265 || n === 8273) || Ir["Letterlike Symbols"](n) || Ir["Number Forms"](n) || Ir["Miscellaneous Technical"](n) && (n >= 8960 && n <= 8967 || n >= 8972 && n <= 8991 || n >= 8996 && n <= 9e3 || n === 9003 || n >= 9085 && n <= 9114 || n >= 9150 && n <= 9165 || n === 9167 || n >= 9169 && n <= 9179 || n >= 9186 && n <= 9215) || Ir["Control Pictures"](n) && n !== 9251 || Ir["Optical Character Recognition"](n) || Ir["Enclosed Alphanumerics"](n) || Ir["Geometric Shapes"](n) || Ir["Miscellaneous Symbols"](n) && !(n >= 9754 && n <= 9759) || Ir["Miscellaneous Symbols and Arrows"](n) && (n >= 11026 && n <= 11055 || n >= 11088 && n <= 11097 || n >= 11192 && n <= 11243) || Ir["CJK Symbols and Punctuation"](n) || Ir.Katakana(n) || Ir["Private Use Area"](n) || Ir["CJK Compatibility Forms"](n) || Ir["Small Form Variants"](n) || Ir["Halfwidth and Fullwidth Forms"](n) || n === 8734 || n === 8756 || n === 8757 || n >= 9984 && n <= 10087 || n >= 10102 && n <= 10131 || n === 65532 || n === 65533)
                    }(c))
                }
                const Au = Lo(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
                function Tc(c) {
                    return Au.test(String.fromCodePoint(c))
                }
                function Pc(c, n) {
                    return !(!n && Tc(c) || c >= 2304 && c <= 3583 || c >= 3840 && c <= 4255 || Ir.Khmer(c))
                }
                function zu(c) {
                    for (const n of c)
                        if (Tc(n.charCodeAt(0)))
                            return !0;
                    return !1
                }
                const Qa = new class {
                    constructor() {
                        this.TIMEOUT = 5e3,
                        this.applyArabicShaping = null,
                        this.processBidirectionalText = null,
                        this.processStyledBidirectionalText = null,
                        this.pluginStatus = "unavailable",
                        this.pluginURL = null,
                        this.loadScriptResolve = () => {}
                    }
                    setState(c) {
                        this.pluginStatus = c.pluginStatus,
                        this.pluginURL = c.pluginURL
                    }
                    getState() {
                        return {
                            pluginStatus: this.pluginStatus,
                            pluginURL: this.pluginURL
                        }
                    }
                    setMethods(c) {
                        if (Qa.isParsed())
                            throw new Error("RTL text plugin already registered.");
                        this.applyArabicShaping = c.applyArabicShaping,
                        this.processBidirectionalText = c.processBidirectionalText,
                        this.processStyledBidirectionalText = c.processStyledBidirectionalText,
                        this.loadScriptResolve()
                    }
                    isParsed() {
                        return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
                    }
                    getRTLTextPluginStatus() {
                        return this.pluginStatus
                    }
                    syncState(c, n) {
                        return o(this, void 0, void 0, function*() {
                            if (this.isParsed())
                                return this.getState();
                            if (c.pluginStatus !== "loading")
                                return this.setState(c),
                                c;
                            const l = c.pluginURL
                              , p = new Promise(b => {
                                this.loadScriptResolve = b
                            }
                            );
                            n(l);
                            const _ = new Promise(b => setTimeout( () => b(), this.TIMEOUT));
                            if (yield Promise.race([p, _]),
                            this.isParsed()) {
                                const b = {
                                    pluginStatus: "loaded",
                                    pluginURL: l
                                };
                                return this.setState(b),
                                b
                            }
                            throw this.setState({
                                pluginStatus: "error",
                                pluginURL: ""
                            }),
                            new Error(`RTL Text Plugin failed to import scripts from ${l}`)
                        })
                    }
                }
                ;
                class Mn {
                    constructor(n, l) {
                        this.zoom = n,
                        l ? (this.now = l.now || 0,
                        this.fadeDuration = l.fadeDuration || 0,
                        this.zoomHistory = l.zoomHistory || new Iu,
                        this.transition = l.transition || {},
                        this.globalState = l.globalState || {}) : (this.now = 0,
                        this.fadeDuration = 0,
                        this.zoomHistory = new Iu,
                        this.transition = {},
                        this.globalState = {})
                    }
                    isSupportedScript(n) {
                        return function(l, p) {
                            for (const _ of l)
                                if (!Pc(_.charCodeAt(0), p))
                                    return !1;
                            return !0
                        }(n, Qa.getRTLTextPluginStatus() === "loaded")
                    }
                    crossFadingFactor() {
                        return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
                    }
                    getCrossfadeParameters() {
                        const n = this.zoom
                          , l = n - Math.floor(n)
                          , p = this.crossFadingFactor();
                        return n > this.zoomHistory.lastIntegerZoom ? {
                            fromScale: 2,
                            toScale: 1,
                            t: l + (1 - l) * p
                        } : {
                            fromScale: .5,
                            toScale: 1,
                            t: 1 - (1 - p) * l
                        }
                    }
                }
                class Ja {
                    constructor(n, l) {
                        this.property = n,
                        this.value = l,
                        this.expression = function(p, _) {
                            if (El(p))
                                return new Tu(p,_);
                            if (qa(p)) {
                                const b = Pd(p, _);
                                if (b.result === "error")
                                    throw new Error(b.value.map(C => `${C.key}: ${C.message}`).join(", "));
                                return b.value
                            }
                            {
                                let b = p;
                                return _.type === "color" && typeof p == "string" ? b = Br.parse(p) : _.type !== "padding" || typeof p != "number" && !Array.isArray(p) ? _.type !== "numberArray" || typeof p != "number" && !Array.isArray(p) ? _.type !== "colorArray" || typeof p != "string" && !Array.isArray(p) ? _.type === "variableAnchorOffsetCollection" && Array.isArray(p) ? b = Yr.parse(p) : _.type === "projectionDefinition" && typeof p == "string" && (b = jr.parse(p)) : b = ii.parse(p) : b = Ui.parse(p) : b = mi.parse(p),
                                {
                                    globalStateRefs: new Set,
                                    kind: "constant",
                                    evaluate: () => b
                                }
                            }
                        }(l === void 0 ? n.specification.default : l, n.specification)
                    }
                    isDataDriven() {
                        return this.expression.kind === "source" || this.expression.kind === "composite"
                    }
                    getGlobalStateRefs() {
                        return this.expression.globalStateRefs || new Set
                    }
                    possiblyEvaluate(n, l, p) {
                        return this.property.possiblyEvaluate(this, n, l, p)
                    }
                }
                class Du {
                    constructor(n) {
                        this.property = n,
                        this.value = new Ja(n,void 0)
                    }
                    transitioned(n, l) {
                        return new jl(this.property,this.value,l,xr({}, n.transition, this.transition),n.now)
                    }
                    untransitioned() {
                        return new jl(this.property,this.value,null,{},0)
                    }
                }
                class Th {
                    constructor(n) {
                        this._properties = n,
                        this._values = Object.create(n.defaultTransitionablePropertyValues)
                    }
                    getValue(n) {
                        return gr(this._values[n].value.value)
                    }
                    setValue(n, l) {
                        Object.prototype.hasOwnProperty.call(this._values, n) || (this._values[n] = new Du(this._values[n].property)),
                        this._values[n].value = new Ja(this._values[n].property,l === null ? void 0 : gr(l))
                    }
                    getTransition(n) {
                        return gr(this._values[n].transition)
                    }
                    setTransition(n, l) {
                        Object.prototype.hasOwnProperty.call(this._values, n) || (this._values[n] = new Du(this._values[n].property)),
                        this._values[n].transition = gr(l) || void 0
                    }
                    serialize() {
                        const n = {};
                        for (const l of Object.keys(this._values)) {
                            const p = this.getValue(l);
                            p !== void 0 && (n[l] = p);
                            const _ = this.getTransition(l);
                            _ !== void 0 && (n[`${l}-transition`] = _)
                        }
                        return n
                    }
                    transitioned(n, l) {
                        const p = new Ed(this._properties);
                        for (const _ of Object.keys(this._values))
                            p._values[_] = this._values[_].transitioned(n, l._values[_]);
                        return p
                    }
                    untransitioned() {
                        const n = new Ed(this._properties);
                        for (const l of Object.keys(this._values))
                            n._values[l] = this._values[l].untransitioned();
                        return n
                    }
                }
                class jl {
                    constructor(n, l, p, _, b) {
                        this.property = n,
                        this.value = l,
                        this.begin = b + _.delay || 0,
                        this.end = this.begin + _.duration || 0,
                        n.specification.transition && (_.delay || _.duration) && (this.prior = p)
                    }
                    possiblyEvaluate(n, l, p) {
                        const _ = n.now || 0
                          , b = this.value.possiblyEvaluate(n, l, p)
                          , C = this.prior;
                        if (C) {
                            if (_ > this.end)
                                return this.prior = null,
                                b;
                            if (this.value.isDataDriven())
                                return this.prior = null,
                                b;
                            if (_ < this.begin)
                                return C.possiblyEvaluate(n, l, p);
                            {
                                const M = (_ - this.begin) / (this.end - this.begin);
                                return this.property.interpolate(C.possiblyEvaluate(n, l, p), b, Wt(M))
                            }
                        }
                        return b
                    }
                }
                class Ed {
                    constructor(n) {
                        this._properties = n,
                        this._values = Object.create(n.defaultTransitioningPropertyValues)
                    }
                    possiblyEvaluate(n, l, p) {
                        const _ = new pa(this._properties);
                        for (const b of Object.keys(this._values))
                            _._values[b] = this._values[b].possiblyEvaluate(n, l, p);
                        return _
                    }
                    hasTransition() {
                        for (const n of Object.keys(this._values))
                            if (this._values[n].prior)
                                return !0;
                        return !1
                    }
                }
                class Ph {
                    constructor(n) {
                        this._properties = n,
                        this._values = Object.create(n.defaultPropertyValues)
                    }
                    hasValue(n) {
                        return this._values[n].value !== void 0
                    }
                    getValue(n) {
                        return gr(this._values[n].value)
                    }
                    setValue(n, l) {
                        this._values[n] = new Ja(this._values[n].property,l === null ? void 0 : gr(l))
                    }
                    serialize() {
                        const n = {};
                        for (const l of Object.keys(this._values)) {
                            const p = this.getValue(l);
                            p !== void 0 && (n[l] = p)
                        }
                        return n
                    }
                    possiblyEvaluate(n, l, p) {
                        const _ = new pa(this._properties);
                        for (const b of Object.keys(this._values))
                            _._values[b] = this._values[b].possiblyEvaluate(n, l, p);
                        return _
                    }
                }
                class Qo {
                    constructor(n, l, p) {
                        this.property = n,
                        this.value = l,
                        this.parameters = p
                    }
                    isConstant() {
                        return this.value.kind === "constant"
                    }
                    constantOr(n) {
                        return this.value.kind === "constant" ? this.value.value : n
                    }
                    evaluate(n, l, p, _) {
                        return this.property.evaluate(this.value, this.parameters, n, l, p, _)
                    }
                }
                class pa {
                    constructor(n) {
                        this._properties = n,
                        this._values = Object.create(n.defaultPossiblyEvaluatedValues)
                    }
                    get(n) {
                        return this._values[n]
                    }
                }
                class ir {
                    constructor(n) {
                        this.specification = n
                    }
                    possiblyEvaluate(n, l) {
                        if (n.isDataDriven())
                            throw new Error("Value should not be data driven");
                        return n.expression.evaluate(l)
                    }
                    interpolate(n, l, p) {
                        const _ = Xo[this.specification.type];
                        return _ ? _(n, l, p) : n
                    }
                }
                class Cr {
                    constructor(n, l) {
                        this.specification = n,
                        this.overrides = l
                    }
                    possiblyEvaluate(n, l, p, _) {
                        return new Qo(this,n.expression.kind === "constant" || n.expression.kind === "camera" ? {
                            kind: "constant",
                            value: n.expression.evaluate(l, null, {}, p, _)
                        } : n.expression,l)
                    }
                    interpolate(n, l, p) {
                        if (n.value.kind !== "constant" || l.value.kind !== "constant")
                            return n;
                        if (n.value.value === void 0 || l.value.value === void 0)
                            return new Qo(this,{
                                kind: "constant",
                                value: void 0
                            },n.parameters);
                        const _ = Xo[this.specification.type];
                        if (_) {
                            const b = _(n.value.value, l.value.value, p);
                            return new Qo(this,{
                                kind: "constant",
                                value: b
                            },n.parameters)
                        }
                        return n
                    }
                    evaluate(n, l, p, _, b, C) {
                        return n.kind === "constant" ? n.value : n.evaluate(l, p, _, b, C)
                    }
                }
                class Mc extends Cr {
                    possiblyEvaluate(n, l, p, _) {
                        if (n.value === void 0)
                            return new Qo(this,{
                                kind: "constant",
                                value: void 0
                            },l);
                        if (n.expression.kind === "constant") {
                            const b = n.expression.evaluate(l, null, {}, p, _)
                              , C = n.property.specification.type === "resolvedImage" && typeof b != "string" ? b.name : b
                              , M = this._calculate(C, C, C, l);
                            return new Qo(this,{
                                kind: "constant",
                                value: M
                            },l)
                        }
                        if (n.expression.kind === "camera") {
                            const b = this._calculate(n.expression.evaluate({
                                zoom: l.zoom - 1
                            }), n.expression.evaluate({
                                zoom: l.zoom
                            }), n.expression.evaluate({
                                zoom: l.zoom + 1
                            }), l);
                            return new Qo(this,{
                                kind: "constant",
                                value: b
                            },l)
                        }
                        return new Qo(this,n.expression,l)
                    }
                    evaluate(n, l, p, _, b, C) {
                        if (n.kind === "source") {
                            const M = n.evaluate(l, p, _, b, C);
                            return this._calculate(M, M, M, l)
                        }
                        return n.kind === "composite" ? this._calculate(n.evaluate({
                            zoom: Math.floor(l.zoom) - 1
                        }, p, _), n.evaluate({
                            zoom: Math.floor(l.zoom)
                        }, p, _), n.evaluate({
                            zoom: Math.floor(l.zoom) + 1
                        }, p, _), l) : n.value
                    }
                    _calculate(n, l, p, _) {
                        return _.zoom > _.zoomHistory.lastIntegerZoom ? {
                            from: n,
                            to: l
                        } : {
                            from: p,
                            to: l
                        }
                    }
                    interpolate(n) {
                        return n
                    }
                }
                class Lu {
                    constructor(n) {
                        this.specification = n
                    }
                    possiblyEvaluate(n, l, p, _) {
                        if (n.value !== void 0) {
                            if (n.expression.kind === "constant") {
                                const b = n.expression.evaluate(l, null, {}, p, _);
                                return this._calculate(b, b, b, l)
                            }
                            return this._calculate(n.expression.evaluate(new Mn(Math.floor(l.zoom - 1),l)), n.expression.evaluate(new Mn(Math.floor(l.zoom),l)), n.expression.evaluate(new Mn(Math.floor(l.zoom + 1),l)), l)
                        }
                    }
                    _calculate(n, l, p, _) {
                        return _.zoom > _.zoomHistory.lastIntegerZoom ? {
                            from: n,
                            to: l
                        } : {
                            from: p,
                            to: l
                        }
                    }
                    interpolate(n) {
                        return n
                    }
                }
                class Zs {
                    constructor(n) {
                        this.specification = n
                    }
                    possiblyEvaluate(n, l, p, _) {
                        return !!n.expression.evaluate(l, null, {}, p, _)
                    }
                    interpolate() {
                        return !1
                    }
                }
                class Vn {
                    constructor(n) {
                        this.properties = n,
                        this.defaultPropertyValues = {},
                        this.defaultTransitionablePropertyValues = {},
                        this.defaultTransitioningPropertyValues = {},
                        this.defaultPossiblyEvaluatedValues = {},
                        this.overridableProperties = [];
                        for (const l in n) {
                            const p = n[l];
                            p.specification.overridable && this.overridableProperties.push(l);
                            const _ = this.defaultPropertyValues[l] = new Ja(p,void 0)
                              , b = this.defaultTransitionablePropertyValues[l] = new Du(p);
                            this.defaultTransitioningPropertyValues[l] = b.untransitioned(),
                            this.defaultPossiblyEvaluatedValues[l] = _.possiblyEvaluate({})
                        }
                    }
                }
                Kt("DataDrivenProperty", Cr),
                Kt("DataConstantProperty", ir),
                Kt("CrossFadedDataDrivenProperty", Mc),
                Kt("CrossFadedProperty", Lu),
                Kt("ColorRampProperty", Zs);
                const el = "-transition";
                class Ci extends St {
                    constructor(n, l) {
                        if (super(),
                        this.id = n.id,
                        this.type = n.type,
                        this._featureFilter = {
                            filter: () => !0,
                            needGeometry: !1,
                            getGlobalStateRefs: () => new Set
                        },
                        n.type !== "custom" && (this.metadata = n.metadata,
                        this.minzoom = n.minzoom,
                        this.maxzoom = n.maxzoom,
                        n.type !== "background" && (this.source = n.source,
                        this.sourceLayer = n["source-layer"],
                        this.filter = n.filter,
                        this._featureFilter = qs(n.filter)),
                        l.layout && (this._unevaluatedLayout = new Ph(l.layout)),
                        l.paint)) {
                            this._transitionablePaint = new Th(l.paint);
                            for (const p in n.paint)
                                this.setPaintProperty(p, n.paint[p], {
                                    validate: !1
                                });
                            for (const p in n.layout)
                                this.setLayoutProperty(p, n.layout[p], {
                                    validate: !1
                                });
                            this._transitioningPaint = this._transitionablePaint.untransitioned(),
                            this.paint = new pa(l.paint)
                        }
                    }
                    setFilter(n) {
                        this.filter = n,
                        this._featureFilter = qs(n)
                    }
                    getCrossfadeParameters() {
                        return this._crossfadeParameters
                    }
                    getLayoutProperty(n) {
                        return n === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(n)
                    }
                    getLayoutAffectingGlobalStateRefs() {
                        const n = new Set;
                        if (this._unevaluatedLayout)
                            for (const l in this._unevaluatedLayout._values) {
                                const p = this._unevaluatedLayout._values[l];
                                for (const _ of p.getGlobalStateRefs())
                                    n.add(_)
                            }
                        for (const l of this._featureFilter.getGlobalStateRefs())
                            n.add(l);
                        return n
                    }
                    setLayoutProperty(n, l, p={}) {
                        l != null && this._validate(wc, `layers.${this.id}.layout.${n}`, n, l, p) || (n !== "visibility" ? this._unevaluatedLayout.setValue(n, l) : this.visibility = l)
                    }
                    getPaintProperty(n) {
                        return n.endsWith(el) ? this._transitionablePaint.getTransition(n.slice(0, -11)) : this._transitionablePaint.getValue(n)
                    }
                    setPaintProperty(n, l, p={}) {
                        if (l != null && this._validate(bc, `layers.${this.id}.paint.${n}`, n, l, p))
                            return !1;
                        if (n.endsWith(el))
                            return this._transitionablePaint.setTransition(n.slice(0, -11), l || void 0),
                            !1;
                        {
                            const _ = this._transitionablePaint._values[n]
                              , b = _.property.specification["property-type"] === "cross-faded-data-driven"
                              , C = _.value.isDataDriven()
                              , M = _.value;
                            this._transitionablePaint.setValue(n, l),
                            this._handleSpecialPaintPropertyUpdate(n);
                            const R = this._transitionablePaint._values[n].value;
                            return R.isDataDriven() || C || b || this._handleOverridablePaintPropertyUpdate(n, M, R)
                        }
                    }
                    _handleSpecialPaintPropertyUpdate(n) {}
                    _handleOverridablePaintPropertyUpdate(n, l, p) {
                        return !1
                    }
                    isHidden(n) {
                        return !!(this.minzoom && n < this.minzoom) || !!(this.maxzoom && n >= this.maxzoom) || this.visibility === "none"
                    }
                    updateTransitions(n) {
                        this._transitioningPaint = this._transitionablePaint.transitioned(n, this._transitioningPaint)
                    }
                    hasTransition() {
                        return this._transitioningPaint.hasTransition()
                    }
                    recalculate(n, l) {
                        n.getCrossfadeParameters && (this._crossfadeParameters = n.getCrossfadeParameters()),
                        this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(n, void 0, l)),
                        this.paint = this._transitioningPaint.possiblyEvaluate(n, void 0, l)
                    }
                    serialize() {
                        const n = {
                            id: this.id,
                            type: this.type,
                            source: this.source,
                            "source-layer": this.sourceLayer,
                            metadata: this.metadata,
                            minzoom: this.minzoom,
                            maxzoom: this.maxzoom,
                            filter: this.filter,
                            layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                            paint: this._transitionablePaint && this._transitionablePaint.serialize()
                        };
                        return this.visibility && (n.layout = n.layout || {},
                        n.layout.visibility = this.visibility),
                        vr(n, (l, p) => !(l === void 0 || p === "layout" && !Object.keys(l).length || p === "paint" && !Object.keys(l).length))
                    }
                    _validate(n, l, p, _, b={}) {
                        return (!b || b.validate !== !1) && Ya(this, n.call(xc, {
                            key: l,
                            layerType: this.type,
                            objectKey: p,
                            value: _,
                            styleSpec: Ve,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            }
                        }))
                    }
                    is3D() {
                        return !1
                    }
                    isTileClipped() {
                        return !1
                    }
                    hasOffscreenPass() {
                        return !1
                    }
                    resize() {}
                    isStateDependent() {
                        for (const n in this.paint._values) {
                            const l = this.paint.get(n);
                            if (l instanceof Qo && Wa(l.property.specification) && (l.value.kind === "source" || l.value.kind === "composite") && l.value.isStateDependent)
                                return !0
                        }
                        return !1
                    }
                }
                const Id = {
                    Int8: Int8Array,
                    Uint8: Uint8Array,
                    Int16: Int16Array,
                    Uint16: Uint16Array,
                    Int32: Int32Array,
                    Uint32: Uint32Array,
                    Float32: Float32Array
                };
                class xo {
                    constructor(n, l) {
                        this._structArray = n,
                        this._pos1 = l * this.size,
                        this._pos2 = this._pos1 / 2,
                        this._pos4 = this._pos1 / 4,
                        this._pos8 = this._pos1 / 8
                    }
                }
                class _n {
                    constructor() {
                        this.isTransferred = !1,
                        this.capacity = -1,
                        this.resize(0)
                    }
                    static serialize(n, l) {
                        return n._trim(),
                        l && (n.isTransferred = !0,
                        l.push(n.arrayBuffer)),
                        {
                            length: n.length,
                            arrayBuffer: n.arrayBuffer
                        }
                    }
                    static deserialize(n) {
                        const l = Object.create(this.prototype);
                        return l.arrayBuffer = n.arrayBuffer,
                        l.length = n.length,
                        l.capacity = n.arrayBuffer.byteLength / l.bytesPerElement,
                        l._refreshViews(),
                        l
                    }
                    _trim() {
                        this.length !== this.capacity && (this.capacity = this.length,
                        this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement),
                        this._refreshViews())
                    }
                    clear() {
                        this.length = 0
                    }
                    resize(n) {
                        this.reserve(n),
                        this.length = n
                    }
                    reserve(n) {
                        if (n > this.capacity) {
                            this.capacity = Math.max(n, Math.floor(5 * this.capacity), 128),
                            this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                            const l = this.uint8;
                            this._refreshViews(),
                            l && this.uint8.set(l)
                        }
                    }
                    _refreshViews() {
                        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
                    }
                }
                function Yn(c, n=1) {
                    let l = 0
                      , p = 0;
                    return {
                        members: c.map(_ => {
                            const b = Id[_.type].BYTES_PER_ELEMENT
                              , C = l = Rd(l, Math.max(n, b))
                              , M = _.components || 1;
                            return p = Math.max(p, b),
                            l += b * M,
                            {
                                name: _.name,
                                type: _.type,
                                components: M,
                                offset: C
                            }
                        }
                        ),
                        size: Rd(l, Math.max(p, n)),
                        alignment: n
                    }
                }
                function Rd(c, n) {
                    return Math.ceil(c / n) * n
                }
                class no extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l) {
                        const p = this.length;
                        return this.resize(p + 1),
                        this.emplace(p, n, l)
                    }
                    emplace(n, l, p) {
                        const _ = 2 * n;
                        return this.int16[_ + 0] = l,
                        this.int16[_ + 1] = p,
                        n
                    }
                }
                no.prototype.bytesPerElement = 4,
                Kt("StructArrayLayout2i4", no);
                class bo extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p) {
                        const _ = this.length;
                        return this.resize(_ + 1),
                        this.emplace(_, n, l, p)
                    }
                    emplace(n, l, p, _) {
                        const b = 3 * n;
                        return this.int16[b + 0] = l,
                        this.int16[b + 1] = p,
                        this.int16[b + 2] = _,
                        n
                    }
                }
                bo.prototype.bytesPerElement = 6,
                Kt("StructArrayLayout3i6", bo);
                class kc extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p, _) {
                        const b = this.length;
                        return this.resize(b + 1),
                        this.emplace(b, n, l, p, _)
                    }
                    emplace(n, l, p, _, b) {
                        const C = 4 * n;
                        return this.int16[C + 0] = l,
                        this.int16[C + 1] = p,
                        this.int16[C + 2] = _,
                        this.int16[C + 3] = b,
                        n
                    }
                }
                kc.prototype.bytesPerElement = 8,
                Kt("StructArrayLayout4i8", kc);
                class Ou extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p, _, b, C) {
                        const M = this.length;
                        return this.resize(M + 1),
                        this.emplace(M, n, l, p, _, b, C)
                    }
                    emplace(n, l, p, _, b, C, M) {
                        const R = 6 * n;
                        return this.int16[R + 0] = l,
                        this.int16[R + 1] = p,
                        this.int16[R + 2] = _,
                        this.int16[R + 3] = b,
                        this.int16[R + 4] = C,
                        this.int16[R + 5] = M,
                        n
                    }
                }
                Ou.prototype.bytesPerElement = 12,
                Kt("StructArrayLayout2i4i12", Ou);
                class Xs extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p, _, b, C) {
                        const M = this.length;
                        return this.resize(M + 1),
                        this.emplace(M, n, l, p, _, b, C)
                    }
                    emplace(n, l, p, _, b, C, M) {
                        const R = 4 * n
                          , O = 8 * n;
                        return this.int16[R + 0] = l,
                        this.int16[R + 1] = p,
                        this.uint8[O + 4] = _,
                        this.uint8[O + 5] = b,
                        this.uint8[O + 6] = C,
                        this.uint8[O + 7] = M,
                        n
                    }
                }
                Xs.prototype.bytesPerElement = 8,
                Kt("StructArrayLayout2i4ub8", Xs);
                class Ec extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l) {
                        const p = this.length;
                        return this.resize(p + 1),
                        this.emplace(p, n, l)
                    }
                    emplace(n, l, p) {
                        const _ = 2 * n;
                        return this.float32[_ + 0] = l,
                        this.float32[_ + 1] = p,
                        n
                    }
                }
                Ec.prototype.bytesPerElement = 8,
                Kt("StructArrayLayout2f8", Ec);
                class Nl extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p, _, b, C, M, R, O, j) {
                        const q = this.length;
                        return this.resize(q + 1),
                        this.emplace(q, n, l, p, _, b, C, M, R, O, j)
                    }
                    emplace(n, l, p, _, b, C, M, R, O, j, q) {
                        const Q = 10 * n;
                        return this.uint16[Q + 0] = l,
                        this.uint16[Q + 1] = p,
                        this.uint16[Q + 2] = _,
                        this.uint16[Q + 3] = b,
                        this.uint16[Q + 4] = C,
                        this.uint16[Q + 5] = M,
                        this.uint16[Q + 6] = R,
                        this.uint16[Q + 7] = O,
                        this.uint16[Q + 8] = j,
                        this.uint16[Q + 9] = q,
                        n
                    }
                }
                Nl.prototype.bytesPerElement = 20,
                Kt("StructArrayLayout10ui20", Nl);
                class Jo extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p, _, b, C, M, R, O, j, q, Q) {
                        const ne = this.length;
                        return this.resize(ne + 1),
                        this.emplace(ne, n, l, p, _, b, C, M, R, O, j, q, Q)
                    }
                    emplace(n, l, p, _, b, C, M, R, O, j, q, Q, ne) {
                        const oe = 12 * n;
                        return this.int16[oe + 0] = l,
                        this.int16[oe + 1] = p,
                        this.int16[oe + 2] = _,
                        this.int16[oe + 3] = b,
                        this.uint16[oe + 4] = C,
                        this.uint16[oe + 5] = M,
                        this.uint16[oe + 6] = R,
                        this.uint16[oe + 7] = O,
                        this.int16[oe + 8] = j,
                        this.int16[oe + 9] = q,
                        this.int16[oe + 10] = Q,
                        this.int16[oe + 11] = ne,
                        n
                    }
                }
                Jo.prototype.bytesPerElement = 24,
                Kt("StructArrayLayout4i4ui4i24", Jo);
                class $l extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p) {
                        const _ = this.length;
                        return this.resize(_ + 1),
                        this.emplace(_, n, l, p)
                    }
                    emplace(n, l, p, _) {
                        const b = 3 * n;
                        return this.float32[b + 0] = l,
                        this.float32[b + 1] = p,
                        this.float32[b + 2] = _,
                        n
                    }
                }
                $l.prototype.bytesPerElement = 12,
                Kt("StructArrayLayout3f12", $l);
                class v extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer)
                    }
                    emplaceBack(n) {
                        const l = this.length;
                        return this.resize(l + 1),
                        this.emplace(l, n)
                    }
                    emplace(n, l) {
                        return this.uint32[1 * n + 0] = l,
                        n
                    }
                }
                v.prototype.bytesPerElement = 4,
                Kt("StructArrayLayout1ul4", v);
                class r extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p, _, b, C, M, R, O) {
                        const j = this.length;
                        return this.resize(j + 1),
                        this.emplace(j, n, l, p, _, b, C, M, R, O)
                    }
                    emplace(n, l, p, _, b, C, M, R, O, j) {
                        const q = 10 * n
                          , Q = 5 * n;
                        return this.int16[q + 0] = l,
                        this.int16[q + 1] = p,
                        this.int16[q + 2] = _,
                        this.int16[q + 3] = b,
                        this.int16[q + 4] = C,
                        this.int16[q + 5] = M,
                        this.uint32[Q + 3] = R,
                        this.uint16[q + 8] = O,
                        this.uint16[q + 9] = j,
                        n
                    }
                }
                r.prototype.bytesPerElement = 20,
                Kt("StructArrayLayout6i1ul2ui20", r);
                class a extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p, _, b, C) {
                        const M = this.length;
                        return this.resize(M + 1),
                        this.emplace(M, n, l, p, _, b, C)
                    }
                    emplace(n, l, p, _, b, C, M) {
                        const R = 6 * n;
                        return this.int16[R + 0] = l,
                        this.int16[R + 1] = p,
                        this.int16[R + 2] = _,
                        this.int16[R + 3] = b,
                        this.int16[R + 4] = C,
                        this.int16[R + 5] = M,
                        n
                    }
                }
                a.prototype.bytesPerElement = 12,
                Kt("StructArrayLayout2i2i2i12", a);
                class m extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p, _, b) {
                        const C = this.length;
                        return this.resize(C + 1),
                        this.emplace(C, n, l, p, _, b)
                    }
                    emplace(n, l, p, _, b, C) {
                        const M = 4 * n
                          , R = 8 * n;
                        return this.float32[M + 0] = l,
                        this.float32[M + 1] = p,
                        this.float32[M + 2] = _,
                        this.int16[R + 6] = b,
                        this.int16[R + 7] = C,
                        n
                    }
                }
                m.prototype.bytesPerElement = 16,
                Kt("StructArrayLayout2f1f2i16", m);
                class y extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p, _, b, C) {
                        const M = this.length;
                        return this.resize(M + 1),
                        this.emplace(M, n, l, p, _, b, C)
                    }
                    emplace(n, l, p, _, b, C, M) {
                        const R = 16 * n
                          , O = 4 * n
                          , j = 8 * n;
                        return this.uint8[R + 0] = l,
                        this.uint8[R + 1] = p,
                        this.float32[O + 1] = _,
                        this.float32[O + 2] = b,
                        this.int16[j + 6] = C,
                        this.int16[j + 7] = M,
                        n
                    }
                }
                y.prototype.bytesPerElement = 16,
                Kt("StructArrayLayout2ub2f2i16", y);
                class x extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p) {
                        const _ = this.length;
                        return this.resize(_ + 1),
                        this.emplace(_, n, l, p)
                    }
                    emplace(n, l, p, _) {
                        const b = 3 * n;
                        return this.uint16[b + 0] = l,
                        this.uint16[b + 1] = p,
                        this.uint16[b + 2] = _,
                        n
                    }
                }
                x.prototype.bytesPerElement = 6,
                Kt("StructArrayLayout3ui6", x);
                class P extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p, _, b, C, M, R, O, j, q, Q, ne, oe, de, we, Ie) {
                        const Ye = this.length;
                        return this.resize(Ye + 1),
                        this.emplace(Ye, n, l, p, _, b, C, M, R, O, j, q, Q, ne, oe, de, we, Ie)
                    }
                    emplace(n, l, p, _, b, C, M, R, O, j, q, Q, ne, oe, de, we, Ie, Ye) {
                        const Le = 24 * n
                          , te = 12 * n
                          , _e = 48 * n;
                        return this.int16[Le + 0] = l,
                        this.int16[Le + 1] = p,
                        this.uint16[Le + 2] = _,
                        this.uint16[Le + 3] = b,
                        this.uint32[te + 2] = C,
                        this.uint32[te + 3] = M,
                        this.uint32[te + 4] = R,
                        this.uint16[Le + 10] = O,
                        this.uint16[Le + 11] = j,
                        this.uint16[Le + 12] = q,
                        this.float32[te + 7] = Q,
                        this.float32[te + 8] = ne,
                        this.uint8[_e + 36] = oe,
                        this.uint8[_e + 37] = de,
                        this.uint8[_e + 38] = we,
                        this.uint32[te + 10] = Ie,
                        this.int16[Le + 22] = Ye,
                        n
                    }
                }
                P.prototype.bytesPerElement = 48,
                Kt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", P);
                class I extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p, _, b, C, M, R, O, j, q, Q, ne, oe, de, we, Ie, Ye, Le, te, _e, Oe, ft, Rt, yt, bt, Dt, At) {
                        const Ft = this.length;
                        return this.resize(Ft + 1),
                        this.emplace(Ft, n, l, p, _, b, C, M, R, O, j, q, Q, ne, oe, de, we, Ie, Ye, Le, te, _e, Oe, ft, Rt, yt, bt, Dt, At)
                    }
                    emplace(n, l, p, _, b, C, M, R, O, j, q, Q, ne, oe, de, we, Ie, Ye, Le, te, _e, Oe, ft, Rt, yt, bt, Dt, At, Ft) {
                        const Tt = 32 * n
                          , ar = 16 * n;
                        return this.int16[Tt + 0] = l,
                        this.int16[Tt + 1] = p,
                        this.int16[Tt + 2] = _,
                        this.int16[Tt + 3] = b,
                        this.int16[Tt + 4] = C,
                        this.int16[Tt + 5] = M,
                        this.int16[Tt + 6] = R,
                        this.int16[Tt + 7] = O,
                        this.uint16[Tt + 8] = j,
                        this.uint16[Tt + 9] = q,
                        this.uint16[Tt + 10] = Q,
                        this.uint16[Tt + 11] = ne,
                        this.uint16[Tt + 12] = oe,
                        this.uint16[Tt + 13] = de,
                        this.uint16[Tt + 14] = we,
                        this.uint16[Tt + 15] = Ie,
                        this.uint16[Tt + 16] = Ye,
                        this.uint16[Tt + 17] = Le,
                        this.uint16[Tt + 18] = te,
                        this.uint16[Tt + 19] = _e,
                        this.uint16[Tt + 20] = Oe,
                        this.uint16[Tt + 21] = ft,
                        this.uint16[Tt + 22] = Rt,
                        this.uint32[ar + 12] = yt,
                        this.float32[ar + 13] = bt,
                        this.float32[ar + 14] = Dt,
                        this.uint16[Tt + 30] = At,
                        this.uint16[Tt + 31] = Ft,
                        n
                    }
                }
                I.prototype.bytesPerElement = 64,
                Kt("StructArrayLayout8i15ui1ul2f2ui64", I);
                class A extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(n) {
                        const l = this.length;
                        return this.resize(l + 1),
                        this.emplace(l, n)
                    }
                    emplace(n, l) {
                        return this.float32[1 * n + 0] = l,
                        n
                    }
                }
                A.prototype.bytesPerElement = 4,
                Kt("StructArrayLayout1f4", A);
                class B extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p) {
                        const _ = this.length;
                        return this.resize(_ + 1),
                        this.emplace(_, n, l, p)
                    }
                    emplace(n, l, p, _) {
                        const b = 3 * n;
                        return this.uint16[6 * n + 0] = l,
                        this.float32[b + 1] = p,
                        this.float32[b + 2] = _,
                        n
                    }
                }
                B.prototype.bytesPerElement = 12,
                Kt("StructArrayLayout1ui2f12", B);
                class $ extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p) {
                        const _ = this.length;
                        return this.resize(_ + 1),
                        this.emplace(_, n, l, p)
                    }
                    emplace(n, l, p, _) {
                        const b = 4 * n;
                        return this.uint32[2 * n + 0] = l,
                        this.uint16[b + 2] = p,
                        this.uint16[b + 3] = _,
                        n
                    }
                }
                $.prototype.bytesPerElement = 8,
                Kt("StructArrayLayout1ul2ui8", $);
                class Z extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l) {
                        const p = this.length;
                        return this.resize(p + 1),
                        this.emplace(p, n, l)
                    }
                    emplace(n, l, p) {
                        const _ = 2 * n;
                        return this.uint16[_ + 0] = l,
                        this.uint16[_ + 1] = p,
                        n
                    }
                }
                Z.prototype.bytesPerElement = 4,
                Kt("StructArrayLayout2ui4", Z);
                class H extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(n) {
                        const l = this.length;
                        return this.resize(l + 1),
                        this.emplace(l, n)
                    }
                    emplace(n, l) {
                        return this.uint16[1 * n + 0] = l,
                        n
                    }
                }
                H.prototype.bytesPerElement = 2,
                Kt("StructArrayLayout1ui2", H);
                class Y extends _n {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(n, l, p, _) {
                        const b = this.length;
                        return this.resize(b + 1),
                        this.emplace(b, n, l, p, _)
                    }
                    emplace(n, l, p, _, b) {
                        const C = 4 * n;
                        return this.float32[C + 0] = l,
                        this.float32[C + 1] = p,
                        this.float32[C + 2] = _,
                        this.float32[C + 3] = b,
                        n
                    }
                }
                Y.prototype.bytesPerElement = 16,
                Kt("StructArrayLayout4f16", Y);
                class ae extends xo {
                    get anchorPointX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get anchorPointY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get x1() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                    get y1() {
                        return this._structArray.int16[this._pos2 + 3]
                    }
                    get x2() {
                        return this._structArray.int16[this._pos2 + 4]
                    }
                    get y2() {
                        return this._structArray.int16[this._pos2 + 5]
                    }
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 3]
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 8]
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 9]
                    }
                    get anchorPoint() {
                        return new N(this.anchorPointX,this.anchorPointY)
                    }
                }
                ae.prototype.size = 20;
                class ye extends r {
                    get(n) {
                        return new ae(this,n)
                    }
                }
                Kt("CollisionBoxArray", ye);
                class Se extends xo {
                    get anchorX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get anchorY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get glyphStartIndex() {
                        return this._structArray.uint16[this._pos2 + 2]
                    }
                    get numGlyphs() {
                        return this._structArray.uint16[this._pos2 + 3]
                    }
                    get vertexStartIndex() {
                        return this._structArray.uint32[this._pos4 + 2]
                    }
                    get lineStartIndex() {
                        return this._structArray.uint32[this._pos4 + 3]
                    }
                    get lineLength() {
                        return this._structArray.uint32[this._pos4 + 4]
                    }
                    get segment() {
                        return this._structArray.uint16[this._pos2 + 10]
                    }
                    get lowerSize() {
                        return this._structArray.uint16[this._pos2 + 11]
                    }
                    get upperSize() {
                        return this._structArray.uint16[this._pos2 + 12]
                    }
                    get lineOffsetX() {
                        return this._structArray.float32[this._pos4 + 7]
                    }
                    get lineOffsetY() {
                        return this._structArray.float32[this._pos4 + 8]
                    }
                    get writingMode() {
                        return this._structArray.uint8[this._pos1 + 36]
                    }
                    get placedOrientation() {
                        return this._structArray.uint8[this._pos1 + 37]
                    }
                    set placedOrientation(n) {
                        this._structArray.uint8[this._pos1 + 37] = n
                    }
                    get hidden() {
                        return this._structArray.uint8[this._pos1 + 38]
                    }
                    set hidden(n) {
                        this._structArray.uint8[this._pos1 + 38] = n
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 10]
                    }
                    set crossTileID(n) {
                        this._structArray.uint32[this._pos4 + 10] = n
                    }
                    get associatedIconIndex() {
                        return this._structArray.int16[this._pos2 + 22]
                    }
                }
                Se.prototype.size = 48;
                class Te extends P {
                    get(n) {
                        return new Se(this,n)
                    }
                }
                Kt("PlacedSymbolArray", Te);
                class Re extends xo {
                    get anchorX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get anchorY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get rightJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                    get centerJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 3]
                    }
                    get leftJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 4]
                    }
                    get verticalPlacedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 5]
                    }
                    get placedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 6]
                    }
                    get verticalPlacedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 7]
                    }
                    get key() {
                        return this._structArray.uint16[this._pos2 + 8]
                    }
                    get textBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 9]
                    }
                    get textBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 10]
                    }
                    get verticalTextBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 11]
                    }
                    get verticalTextBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 12]
                    }
                    get iconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 13]
                    }
                    get iconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 14]
                    }
                    get verticalIconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 15]
                    }
                    get verticalIconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 16]
                    }
                    get featureIndex() {
                        return this._structArray.uint16[this._pos2 + 17]
                    }
                    get numHorizontalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 18]
                    }
                    get numVerticalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 19]
                    }
                    get numIconVertices() {
                        return this._structArray.uint16[this._pos2 + 20]
                    }
                    get numVerticalIconVertices() {
                        return this._structArray.uint16[this._pos2 + 21]
                    }
                    get useRuntimeCollisionCircles() {
                        return this._structArray.uint16[this._pos2 + 22]
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 12]
                    }
                    set crossTileID(n) {
                        this._structArray.uint32[this._pos4 + 12] = n
                    }
                    get textBoxScale() {
                        return this._structArray.float32[this._pos4 + 13]
                    }
                    get collisionCircleDiameter() {
                        return this._structArray.float32[this._pos4 + 14]
                    }
                    get textAnchorOffsetStartIndex() {
                        return this._structArray.uint16[this._pos2 + 30]
                    }
                    get textAnchorOffsetEndIndex() {
                        return this._structArray.uint16[this._pos2 + 31]
                    }
                }
                Re.prototype.size = 64;
                class De extends I {
                    get(n) {
                        return new Re(this,n)
                    }
                }
                Kt("SymbolInstanceArray", De);
                class Ae extends A {
                    getoffsetX(n) {
                        return this.float32[1 * n + 0]
                    }
                }
                Kt("GlyphOffsetArray", Ae);
                class Be extends bo {
                    getx(n) {
                        return this.int16[3 * n + 0]
                    }
                    gety(n) {
                        return this.int16[3 * n + 1]
                    }
                    gettileUnitDistanceFromAnchor(n) {
                        return this.int16[3 * n + 2]
                    }
                }
                Kt("SymbolLineVertexArray", Be);
                class qe extends xo {
                    get textAnchor() {
                        return this._structArray.uint16[this._pos2 + 0]
                    }
                    get textOffset0() {
                        return this._structArray.float32[this._pos4 + 1]
                    }
                    get textOffset1() {
                        return this._structArray.float32[this._pos4 + 2]
                    }
                }
                qe.prototype.size = 12;
                class ze extends B {
                    get(n) {
                        return new qe(this,n)
                    }
                }
                Kt("TextAnchorOffsetArray", ze);
                class Ke extends xo {
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 0]
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 2]
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 3]
                    }
                }
                Ke.prototype.size = 8;
                class ht extends $ {
                    get(n) {
                        return new Ke(this,n)
                    }
                }
                Kt("FeatureIndexArray", ht);
                class ot extends no {
                }
                class ut extends no {
                }
                class mt extends no {
                }
                class $t extends Ou {
                }
                class jt extends Xs {
                }
                class It extends Ec {
                }
                class or extends Nl {
                }
                class Vr extends Jo {
                }
                class cn extends $l {
                }
                class Kn extends v {
                }
                class Sn extends a {
                }
                class On extends y {
                }
                class kn extends x {
                }
                class pn extends Z {
                }
                const vn = Yn([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: zi} = vn;
                class rn {
                    constructor(n=[]) {
                        this._forceNewSegmentOnNextPrepare = !1,
                        this.segments = n
                    }
                    prepareSegment(n, l, p, _) {
                        const b = this.segments[this.segments.length - 1];
                        return n > rn.MAX_VERTEX_ARRAY_LENGTH && Zr(`Max vertices per segment is ${rn.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${n}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${rn.MAX_VERTEX_ARRAY_LENGTH} vertices.`),
                        this._forceNewSegmentOnNextPrepare || !b || b.vertexLength + n > rn.MAX_VERTEX_ARRAY_LENGTH || b.sortKey !== _ ? this.createNewSegment(l, p, _) : b
                    }
                    createNewSegment(n, l, p) {
                        const _ = {
                            vertexOffset: n.length,
                            primitiveOffset: l.length,
                            vertexLength: 0,
                            primitiveLength: 0,
                            vaos: {}
                        };
                        return p !== void 0 && (_.sortKey = p),
                        this._forceNewSegmentOnNextPrepare = !1,
                        this.segments.push(_),
                        _
                    }
                    getOrCreateLatestSegment(n, l, p) {
                        return this.prepareSegment(0, n, l, p)
                    }
                    forceNewSegmentOnNextPrepare() {
                        this._forceNewSegmentOnNextPrepare = !0
                    }
                    get() {
                        return this.segments
                    }
                    destroy() {
                        for (const n of this.segments)
                            for (const l in n.vaos)
                                n.vaos[l].destroy()
                    }
                    static simpleSegment(n, l, p, _) {
                        return new rn([{
                            vertexOffset: n,
                            primitiveOffset: l,
                            vertexLength: p,
                            primitiveLength: _,
                            vaos: {},
                            sortKey: 0
                        }])
                    }
                }
                function Ti(c, n) {
                    return 256 * (c = Yt(Math.floor(c), 0, 255)) + Yt(Math.floor(n), 0, 255)
                }
                rn.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1,
                Kt("SegmentVector", rn);
                const Di = Yn([{
                    name: "a_pattern_from",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pattern_to",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pixel_ratio_from",
                    components: 1,
                    type: "Uint16"
                }, {
                    name: "a_pixel_ratio_to",
                    components: 1,
                    type: "Uint16"
                }]);
                var ma, ga, Ys, Is = {
                    exports: {}
                }, Ic = {
                    exports: {}
                }, Rc = {
                    exports: {}
                }, Ac = function() {
                    if (Ys)
                        return Is.exports;
                    Ys = 1;
                    var c = (ma || (ma = 1,
                    Ic.exports = function(l, p) {
                        var _, b, C, M, R, O, j, q;
                        for (b = l.length - (_ = 3 & l.length),
                        C = p,
                        R = 3432918353,
                        O = 461845907,
                        q = 0; q < b; )
                            j = 255 & l.charCodeAt(q) | (255 & l.charCodeAt(++q)) << 8 | (255 & l.charCodeAt(++q)) << 16 | (255 & l.charCodeAt(++q)) << 24,
                            ++q,
                            C = 27492 + (65535 & (M = 5 * (65535 & (C = (C ^= j = (65535 & (j = (j = (65535 & j) * R + (((j >>> 16) * R & 65535) << 16) & 4294967295) << 15 | j >>> 17)) * O + (((j >>> 16) * O & 65535) << 16) & 4294967295) << 13 | C >>> 19)) + ((5 * (C >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (M >>> 16) & 65535) << 16);
                        switch (j = 0,
                        _) {
                        case 3:
                            j ^= (255 & l.charCodeAt(q + 2)) << 16;
                        case 2:
                            j ^= (255 & l.charCodeAt(q + 1)) << 8;
                        case 1:
                            C ^= j = (65535 & (j = (j = (65535 & (j ^= 255 & l.charCodeAt(q))) * R + (((j >>> 16) * R & 65535) << 16) & 4294967295) << 15 | j >>> 17)) * O + (((j >>> 16) * O & 65535) << 16) & 4294967295
                        }
                        return C ^= l.length,
                        C = 2246822507 * (65535 & (C ^= C >>> 16)) + ((2246822507 * (C >>> 16) & 65535) << 16) & 4294967295,
                        C = 3266489909 * (65535 & (C ^= C >>> 13)) + ((3266489909 * (C >>> 16) & 65535) << 16) & 4294967295,
                        (C ^= C >>> 16) >>> 0
                    }
                    ),
                    Ic.exports)
                      , n = (ga || (ga = 1,
                    Rc.exports = function(l, p) {
                        for (var _, b = l.length, C = p ^ b, M = 0; b >= 4; )
                            _ = 1540483477 * (65535 & (_ = 255 & l.charCodeAt(M) | (255 & l.charCodeAt(++M)) << 8 | (255 & l.charCodeAt(++M)) << 16 | (255 & l.charCodeAt(++M)) << 24)) + ((1540483477 * (_ >>> 16) & 65535) << 16),
                            C = 1540483477 * (65535 & C) + ((1540483477 * (C >>> 16) & 65535) << 16) ^ (_ = 1540483477 * (65535 & (_ ^= _ >>> 24)) + ((1540483477 * (_ >>> 16) & 65535) << 16)),
                            b -= 4,
                            ++M;
                        switch (b) {
                        case 3:
                            C ^= (255 & l.charCodeAt(M + 2)) << 16;
                        case 2:
                            C ^= (255 & l.charCodeAt(M + 1)) << 8;
                        case 1:
                            C = 1540483477 * (65535 & (C ^= 255 & l.charCodeAt(M))) + ((1540483477 * (C >>> 16) & 65535) << 16)
                        }
                        return C = 1540483477 * (65535 & (C ^= C >>> 13)) + ((1540483477 * (C >>> 16) & 65535) << 16),
                        (C ^= C >>> 15) >>> 0
                    }
                    ),
                    Rc.exports);
                    return Is.exports = c,
                    Is.exports.murmur3 = c,
                    Is.exports.murmur2 = n,
                    Is.exports
                }(), wo = w(Ac);
                class Rs {
                    constructor() {
                        this.ids = [],
                        this.positions = [],
                        this.indexed = !1
                    }
                    add(n, l, p, _) {
                        this.ids.push(tl(n)),
                        this.positions.push(l, p, _)
                    }
                    getPositions(n) {
                        if (!this.indexed)
                            throw new Error("Trying to get index, but feature positions are not indexed");
                        const l = tl(n);
                        let p = 0
                          , _ = this.ids.length - 1;
                        for (; p < _; ) {
                            const C = p + _ >> 1;
                            this.ids[C] >= l ? _ = C : p = C + 1
                        }
                        const b = [];
                        for (; this.ids[p] === l; )
                            b.push({
                                index: this.positions[3 * p],
                                start: this.positions[3 * p + 1],
                                end: this.positions[3 * p + 2]
                            }),
                            p++;
                        return b
                    }
                    static serialize(n, l) {
                        const p = new Float64Array(n.ids)
                          , _ = new Uint32Array(n.positions);
                        return rl(p, _, 0, p.length - 1),
                        l && l.push(p.buffer, _.buffer),
                        {
                            ids: p,
                            positions: _
                        }
                    }
                    static deserialize(n) {
                        const l = new Rs;
                        return l.ids = n.ids,
                        l.positions = n.positions,
                        l.indexed = !0,
                        l
                    }
                }
                function tl(c) {
                    const n = +c;
                    return !isNaN(n) && n <= Number.MAX_SAFE_INTEGER ? n : wo(String(c))
                }
                function rl(c, n, l, p) {
                    for (; l < p; ) {
                        const _ = c[l + p >> 1];
                        let b = l - 1
                          , C = p + 1;
                        for (; ; ) {
                            do
                                b++;
                            while (c[b] < _);
                            do
                                C--;
                            while (c[C] > _);
                            if (b >= C)
                                break;
                            ti(c, b, C),
                            ti(n, 3 * b, 3 * C),
                            ti(n, 3 * b + 1, 3 * C + 1),
                            ti(n, 3 * b + 2, 3 * C + 2)
                        }
                        C - l < p - C ? (rl(c, n, l, C),
                        l = C + 1) : (rl(c, n, C + 1, p),
                        p = C)
                    }
                }
                function ti(c, n, l) {
                    const p = c[n];
                    c[n] = c[l],
                    c[l] = p
                }
                Kt("FeaturePositionMap", Rs);
                class Bn {
                    constructor(n, l) {
                        this.gl = n.gl,
                        this.location = l
                    }
                }
                class Li extends Bn {
                    constructor(n, l) {
                        super(n, l),
                        this.current = 0
                    }
                    set(n) {
                        this.current !== n && (this.current = n,
                        this.gl.uniform1f(this.location, n))
                    }
                }
                class Pi extends Bn {
                    constructor(n, l) {
                        super(n, l),
                        this.current = [0, 0, 0, 0]
                    }
                    set(n) {
                        n[0] === this.current[0] && n[1] === this.current[1] && n[2] === this.current[2] && n[3] === this.current[3] || (this.current = n,
                        this.gl.uniform4f(this.location, n[0], n[1], n[2], n[3]))
                    }
                }
                class $f extends Bn {
                    constructor(n, l) {
                        super(n, l),
                        this.current = Br.transparent
                    }
                    set(n) {
                        n.r === this.current.r && n.g === this.current.g && n.b === this.current.b && n.a === this.current.a || (this.current = n,
                        this.gl.uniform4f(this.location, n.r, n.g, n.b, n.a))
                    }
                }
                const cm = new Float32Array(16);
                function es(c) {
                    return [Ti(255 * c.r, 255 * c.g), Ti(255 * c.b, 255 * c.a)]
                }
                class Vl {
                    constructor(n, l, p) {
                        this.value = n,
                        this.uniformNames = l.map(_ => `u_${_}`),
                        this.type = p
                    }
                    setUniform(n, l, p) {
                        n.set(p.constantOr(this.value))
                    }
                    getBinding(n, l, p) {
                        return this.type === "color" ? new $f(n,l) : new Li(n,l)
                    }
                }
                class ya {
                    constructor(n, l) {
                        this.uniformNames = l.map(p => `u_${p}`),
                        this.patternFrom = null,
                        this.patternTo = null,
                        this.pixelRatioFrom = 1,
                        this.pixelRatioTo = 1
                    }
                    setConstantPatternPositions(n, l) {
                        this.pixelRatioFrom = l.pixelRatio,
                        this.pixelRatioTo = n.pixelRatio,
                        this.patternFrom = l.tlbr,
                        this.patternTo = n.tlbr
                    }
                    setUniform(n, l, p, _) {
                        const b = _ === "u_pattern_to" ? this.patternTo : _ === "u_pattern_from" ? this.patternFrom : _ === "u_pixel_ratio_to" ? this.pixelRatioTo : _ === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
                        b && n.set(b)
                    }
                    getBinding(n, l, p) {
                        return p.substr(0, 9) === "u_pattern" ? new Pi(n,l) : new Li(n,l)
                    }
                }
                class Ks {
                    constructor(n, l, p, _) {
                        this.expression = n,
                        this.type = p,
                        this.maxValue = 0,
                        this.paintVertexAttributes = l.map(b => ({
                            name: `a_${b}`,
                            type: "Float32",
                            components: p === "color" ? 2 : 1,
                            offset: 0
                        })),
                        this.paintVertexArray = new _
                    }
                    populatePaintArray(n, l, p, _, b) {
                        const C = this.paintVertexArray.length
                          , M = this.expression.evaluate(new Mn(0), l, {}, _, [], b);
                        this.paintVertexArray.resize(n),
                        this._setPaintValue(C, n, M)
                    }
                    updatePaintArray(n, l, p, _) {
                        const b = this.expression.evaluate({
                            zoom: 0
                        }, p, _);
                        this._setPaintValue(n, l, b)
                    }
                    _setPaintValue(n, l, p) {
                        if (this.type === "color") {
                            const _ = es(p);
                            for (let b = n; b < l; b++)
                                this.paintVertexArray.emplace(b, _[0], _[1])
                        } else {
                            for (let _ = n; _ < l; _++)
                                this.paintVertexArray.emplace(_, p);
                            this.maxValue = Math.max(this.maxValue, Math.abs(p))
                        }
                    }
                    upload(n) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = n.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                }
                class Oi {
                    constructor(n, l, p, _, b, C) {
                        this.expression = n,
                        this.uniformNames = l.map(M => `u_${M}_t`),
                        this.type = p,
                        this.useIntegerZoom = _,
                        this.zoom = b,
                        this.maxValue = 0,
                        this.paintVertexAttributes = l.map(M => ({
                            name: `a_${M}`,
                            type: "Float32",
                            components: p === "color" ? 4 : 2,
                            offset: 0
                        })),
                        this.paintVertexArray = new C
                    }
                    populatePaintArray(n, l, p, _, b) {
                        const C = this.expression.evaluate(new Mn(this.zoom), l, {}, _, [], b)
                          , M = this.expression.evaluate(new Mn(this.zoom + 1), l, {}, _, [], b)
                          , R = this.paintVertexArray.length;
                        this.paintVertexArray.resize(n),
                        this._setPaintValue(R, n, C, M)
                    }
                    updatePaintArray(n, l, p, _) {
                        const b = this.expression.evaluate({
                            zoom: this.zoom
                        }, p, _)
                          , C = this.expression.evaluate({
                            zoom: this.zoom + 1
                        }, p, _);
                        this._setPaintValue(n, l, b, C)
                    }
                    _setPaintValue(n, l, p, _) {
                        if (this.type === "color") {
                            const b = es(p)
                              , C = es(_);
                            for (let M = n; M < l; M++)
                                this.paintVertexArray.emplace(M, b[0], b[1], C[0], C[1])
                        } else {
                            for (let b = n; b < l; b++)
                                this.paintVertexArray.emplace(b, p, _);
                            this.maxValue = Math.max(this.maxValue, Math.abs(p), Math.abs(_))
                        }
                    }
                    upload(n) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = n.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                    setUniform(n, l) {
                        const p = this.useIntegerZoom ? Math.floor(l.zoom) : l.zoom
                          , _ = Yt(this.expression.interpolationFactor(p, this.zoom, this.zoom + 1), 0, 1);
                        n.set(_)
                    }
                    getBinding(n, l, p) {
                        return new Li(n,l)
                    }
                }
                class Qs {
                    constructor(n, l, p, _, b, C) {
                        this.expression = n,
                        this.type = l,
                        this.useIntegerZoom = p,
                        this.zoom = _,
                        this.layerId = C,
                        this.zoomInPaintVertexArray = new b,
                        this.zoomOutPaintVertexArray = new b
                    }
                    populatePaintArray(n, l, p) {
                        const _ = this.zoomInPaintVertexArray.length;
                        this.zoomInPaintVertexArray.resize(n),
                        this.zoomOutPaintVertexArray.resize(n),
                        this._setPaintValues(_, n, l.patterns && l.patterns[this.layerId], p)
                    }
                    updatePaintArray(n, l, p, _, b) {
                        this._setPaintValues(n, l, p.patterns && p.patterns[this.layerId], b)
                    }
                    _setPaintValues(n, l, p, _) {
                        if (!_ || !p)
                            return;
                        const {min: b, mid: C, max: M} = p
                          , R = _[b]
                          , O = _[C]
                          , j = _[M];
                        if (R && O && j)
                            for (let q = n; q < l; q++)
                                this.zoomInPaintVertexArray.emplace(q, O.tl[0], O.tl[1], O.br[0], O.br[1], R.tl[0], R.tl[1], R.br[0], R.br[1], O.pixelRatio, R.pixelRatio),
                                this.zoomOutPaintVertexArray.emplace(q, O.tl[0], O.tl[1], O.br[0], O.br[1], j.tl[0], j.tl[1], j.br[0], j.br[1], O.pixelRatio, j.pixelRatio)
                    }
                    upload(n) {
                        this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = n.createVertexBuffer(this.zoomInPaintVertexArray, Di.members, this.expression.isStateDependent),
                        this.zoomOutPaintVertexBuffer = n.createVertexBuffer(this.zoomOutPaintVertexArray, Di.members, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(),
                        this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
                    }
                }
                class Fu {
                    constructor(n, l, p) {
                        this.binders = {},
                        this._buffers = [];
                        const _ = [];
                        for (const b in n.paint._values) {
                            if (!p(b))
                                continue;
                            const C = n.paint.get(b);
                            if (!(C instanceof Qo && Wa(C.property.specification)))
                                continue;
                            const M = Bu(b, n.type)
                              , R = C.value
                              , O = C.property.specification.type
                              , j = C.property.useIntegerZoom
                              , q = C.property.specification["property-type"]
                              , Q = q === "cross-faded" || q === "cross-faded-data-driven";
                            if (R.kind === "constant")
                                this.binders[b] = Q ? new ya(R.value,M) : new Vl(R.value,M,O),
                                _.push(`/u_${b}`);
                            else if (R.kind === "source" || Q) {
                                const ne = ju(b, O, "source");
                                this.binders[b] = Q ? new Qs(R,O,j,l,ne,n.id) : new Ks(R,M,O,ne),
                                _.push(`/a_${b}`)
                            } else {
                                const ne = ju(b, O, "composite");
                                this.binders[b] = new Oi(R,M,O,j,l,ne),
                                _.push(`/z_${b}`)
                            }
                        }
                        this.cacheKey = _.sort().join("")
                    }
                    getMaxValue(n) {
                        const l = this.binders[n];
                        return l instanceof Ks || l instanceof Oi ? l.maxValue : 0
                    }
                    populatePaintArrays(n, l, p, _, b) {
                        for (const C in this.binders) {
                            const M = this.binders[C];
                            (M instanceof Ks || M instanceof Oi || M instanceof Qs) && M.populatePaintArray(n, l, p, _, b)
                        }
                    }
                    setConstantPatternPositions(n, l) {
                        for (const p in this.binders) {
                            const _ = this.binders[p];
                            _ instanceof ya && _.setConstantPatternPositions(n, l)
                        }
                    }
                    updatePaintArrays(n, l, p, _, b) {
                        let C = !1;
                        for (const M in n) {
                            const R = l.getPositions(M);
                            for (const O of R) {
                                const j = p.feature(O.index);
                                for (const q in this.binders) {
                                    const Q = this.binders[q];
                                    if ((Q instanceof Ks || Q instanceof Oi || Q instanceof Qs) && Q.expression.isStateDependent === !0) {
                                        const ne = _.paint.get(q);
                                        Q.expression = ne.value,
                                        Q.updatePaintArray(O.start, O.end, j, n[M], b),
                                        C = !0
                                    }
                                }
                            }
                        }
                        return C
                    }
                    defines() {
                        const n = [];
                        for (const l in this.binders) {
                            const p = this.binders[l];
                            (p instanceof Vl || p instanceof ya) && n.push(...p.uniformNames.map(_ => `#define HAS_UNIFORM_${_}`))
                        }
                        return n
                    }
                    getBinderAttributes() {
                        const n = [];
                        for (const l in this.binders) {
                            const p = this.binders[l];
                            if (p instanceof Ks || p instanceof Oi)
                                for (let _ = 0; _ < p.paintVertexAttributes.length; _++)
                                    n.push(p.paintVertexAttributes[_].name);
                            else if (p instanceof Qs)
                                for (let _ = 0; _ < Di.members.length; _++)
                                    n.push(Di.members[_].name)
                        }
                        return n
                    }
                    getBinderUniforms() {
                        const n = [];
                        for (const l in this.binders) {
                            const p = this.binders[l];
                            if (p instanceof Vl || p instanceof ya || p instanceof Oi)
                                for (const _ of p.uniformNames)
                                    n.push(_)
                        }
                        return n
                    }
                    getPaintVertexBuffers() {
                        return this._buffers
                    }
                    getUniforms(n, l) {
                        const p = [];
                        for (const _ in this.binders) {
                            const b = this.binders[_];
                            if (b instanceof Vl || b instanceof ya || b instanceof Oi) {
                                for (const C of b.uniformNames)
                                    if (l[C]) {
                                        const M = b.getBinding(n, l[C], C);
                                        p.push({
                                            name: C,
                                            property: _,
                                            binding: M
                                        })
                                    }
                            }
                        }
                        return p
                    }
                    setUniforms(n, l, p, _) {
                        for (const {name: b, property: C, binding: M} of l)
                            this.binders[C].setUniform(M, _, p.get(C), b)
                    }
                    updatePaintBuffers(n) {
                        this._buffers = [];
                        for (const l in this.binders) {
                            const p = this.binders[l];
                            if (n && p instanceof Qs) {
                                const _ = n.fromScale === 2 ? p.zoomInPaintVertexBuffer : p.zoomOutPaintVertexBuffer;
                                _ && this._buffers.push(_)
                            } else
                                (p instanceof Ks || p instanceof Oi) && p.paintVertexBuffer && this._buffers.push(p.paintVertexBuffer)
                        }
                    }
                    upload(n) {
                        for (const l in this.binders) {
                            const p = this.binders[l];
                            (p instanceof Ks || p instanceof Oi || p instanceof Qs) && p.upload(n)
                        }
                        this.updatePaintBuffers()
                    }
                    destroy() {
                        for (const n in this.binders) {
                            const l = this.binders[n];
                            (l instanceof Ks || l instanceof Oi || l instanceof Qs) && l.destroy()
                        }
                    }
                }
                class ts {
                    constructor(n, l, p= () => !0) {
                        this.programConfigurations = {};
                        for (const _ of n)
                            this.programConfigurations[_.id] = new Fu(_,l,p);
                        this.needsUpload = !1,
                        this._featureMap = new Rs,
                        this._bufferOffset = 0
                    }
                    populatePaintArrays(n, l, p, _, b, C) {
                        for (const M in this.programConfigurations)
                            this.programConfigurations[M].populatePaintArrays(n, l, _, b, C);
                        l.id !== void 0 && this._featureMap.add(l.id, p, this._bufferOffset, n),
                        this._bufferOffset = n,
                        this.needsUpload = !0
                    }
                    updatePaintArrays(n, l, p, _) {
                        for (const b of p)
                            this.needsUpload = this.programConfigurations[b.id].updatePaintArrays(n, this._featureMap, l, b, _) || this.needsUpload
                    }
                    get(n) {
                        return this.programConfigurations[n]
                    }
                    upload(n) {
                        if (this.needsUpload) {
                            for (const l in this.programConfigurations)
                                this.programConfigurations[l].upload(n);
                            this.needsUpload = !1
                        }
                    }
                    destroy() {
                        for (const n in this.programConfigurations)
                            this.programConfigurations[n].destroy()
                    }
                }
                function Bu(c, n) {
                    return {
                        "text-opacity": ["opacity"],
                        "icon-opacity": ["opacity"],
                        "text-color": ["fill_color"],
                        "icon-color": ["fill_color"],
                        "text-halo-color": ["halo_color"],
                        "icon-halo-color": ["halo_color"],
                        "text-halo-blur": ["halo_blur"],
                        "icon-halo-blur": ["halo_blur"],
                        "text-halo-width": ["halo_width"],
                        "icon-halo-width": ["halo_width"],
                        "line-gap-width": ["gapwidth"],
                        "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
                        "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
                        "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
                    }[c] || [c.replace(`${n}-`, "").replace(/-/g, "_")]
                }
                function ju(c, n, l) {
                    const p = {
                        color: {
                            source: Ec,
                            composite: Y
                        },
                        number: {
                            source: A,
                            composite: Ec
                        }
                    }
                      , _ = function(b) {
                        return {
                            "line-pattern": {
                                source: or,
                                composite: or
                            },
                            "fill-pattern": {
                                source: or,
                                composite: or
                            },
                            "fill-extrusion-pattern": {
                                source: or,
                                composite: or
                            }
                        }[b]
                    }(c);
                    return _ && _[l] || p[n][l]
                }
                Kt("ConstantBinder", Vl),
                Kt("CrossFadedConstantBinder", ya),
                Kt("SourceExpressionBinder", Ks),
                Kt("CrossFadedCompositeBinder", Qs),
                Kt("CompositeExpressionBinder", Oi),
                Kt("ProgramConfiguration", Fu, {
                    omit: ["_buffers"]
                }),
                Kt("ProgramConfigurationSet", ts);
                const Nu = Math.pow(2, 14) - 1
                  , um = -Nu - 1;
                function zc(c) {
                    const n = st / c.extent
                      , l = c.loadGeometry();
                    for (let p = 0; p < l.length; p++) {
                        const _ = l[p];
                        for (let b = 0; b < _.length; b++) {
                            const C = _[b]
                              , M = Math.round(C.x * n)
                              , R = Math.round(C.y * n);
                            C.x = Yt(M, um, Nu),
                            C.y = Yt(R, um, Nu),
                            (M < C.x || M > C.x + 1 || R < C.y || R > C.y + 1) && Zr("Geometry exceeds allowed extent, reduce your vector tile buffer size")
                        }
                    }
                    return l
                }
                function Dc(c, n) {
                    return {
                        type: c.type,
                        id: c.id,
                        properties: c.properties,
                        geometry: n ? zc(c) : []
                    }
                }
                const hm = -32768;
                function _y(c, n, l, p, _) {
                    c.emplaceBack(hm + 8 * n + p, hm + 8 * l + _)
                }
                class dm {
                    constructor(n) {
                        this.zoom = n.zoom,
                        this.globalState = n.globalState,
                        this.overscaling = n.overscaling,
                        this.layers = n.layers,
                        this.layerIds = this.layers.map(l => l.id),
                        this.index = n.index,
                        this.hasPattern = !1,
                        this.layoutVertexArray = new ut,
                        this.indexArray = new kn,
                        this.segments = new rn,
                        this.programConfigurations = new ts(n.layers,n.zoom),
                        this.stateDependentLayerIds = this.layers.filter(l => l.isStateDependent()).map(l => l.id)
                    }
                    populate(n, l, p) {
                        const _ = this.layers[0]
                          , b = [];
                        let C = null
                          , M = !1
                          , R = _.type === "heatmap";
                        if (_.type === "circle") {
                            const j = _;
                            C = j.layout.get("circle-sort-key"),
                            M = !C.isConstant(),
                            R = R || j.paint.get("circle-pitch-alignment") === "map"
                        }
                        const O = R ? l.subdivisionGranularity.circle : 1;
                        for (const {feature: j, id: q, index: Q, sourceLayerIndex: ne} of n) {
                            const oe = this.layers[0]._featureFilter.needGeometry
                              , de = Dc(j, oe);
                            if (!this.layers[0]._featureFilter.filter(new Mn(this.zoom,{
                                globalState: this.globalState
                            }), de, p))
                                continue;
                            const we = M ? C.evaluate(de, {}, p) : void 0
                              , Ie = {
                                id: q,
                                properties: j.properties,
                                type: j.type,
                                sourceLayerIndex: ne,
                                index: Q,
                                geometry: oe ? de.geometry : zc(j),
                                patterns: {},
                                sortKey: we
                            };
                            b.push(Ie)
                        }
                        M && b.sort( (j, q) => j.sortKey - q.sortKey);
                        for (const j of b) {
                            const {geometry: q, index: Q, sourceLayerIndex: ne} = j
                              , oe = n[Q].feature;
                            this.addFeature(j, q, Q, p, O),
                            l.featureIndex.insert(oe, q, Q, ne, this.index)
                        }
                    }
                    update(n, l, p) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, l, this.stateDependentLayers, p)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(n) {
                        this.uploaded || (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, zi),
                        this.indexBuffer = n.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(n),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy())
                    }
                    addFeature(n, l, p, _, b=1) {
                        let C;
                        switch (b) {
                        case 1:
                            C = [0, 7];
                            break;
                        case 3:
                            C = [0, 2, 5, 7];
                            break;
                        case 5:
                            C = [0, 1, 3, 4, 6, 7];
                            break;
                        case 7:
                            C = [0, 1, 2, 3, 4, 5, 6, 7];
                            break;
                        default:
                            throw new Error(`Invalid circle bucket granularity: ${b}; valid values are 1, 3, 5, 7.`)
                        }
                        const M = C.length;
                        for (const R of l)
                            for (const O of R) {
                                const j = O.x
                                  , q = O.y;
                                if (j < 0 || j >= st || q < 0 || q >= st)
                                    continue;
                                const Q = this.segments.prepareSegment(M * M, this.layoutVertexArray, this.indexArray, n.sortKey)
                                  , ne = Q.vertexLength;
                                for (let oe = 0; oe < M; oe++)
                                    for (let de = 0; de < M; de++)
                                        _y(this.layoutVertexArray, j, q, C[de], C[oe]);
                                for (let oe = 0; oe < M - 1; oe++)
                                    for (let de = 0; de < M - 1; de++) {
                                        const we = ne + oe * M + de
                                          , Ie = ne + (oe + 1) * M + de;
                                        this.indexArray.emplaceBack(we, Ie + 1, we + 1),
                                        this.indexArray.emplaceBack(we, Ie, Ie + 1)
                                    }
                                Q.vertexLength += M * M,
                                Q.primitiveLength += (M - 1) * (M - 1) * 2
                            }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, p, {}, _)
                    }
                }
                function rs(c, n) {
                    for (let l = 0; l < c.length; l++)
                        if (Lc(n, c[l]))
                            return !0;
                    for (let l = 0; l < n.length; l++)
                        if (Lc(c, n[l]))
                            return !0;
                    return !!Vf(c, n)
                }
                function ns(c, n, l) {
                    return !!Lc(c, n) || !!Uf(n, c, l)
                }
                function fm(c, n) {
                    if (c.length === 1)
                        return pm(n, c[0]);
                    for (let l = 0; l < n.length; l++) {
                        const p = n[l];
                        for (let _ = 0; _ < p.length; _++)
                            if (Lc(c, p[_]))
                                return !0
                    }
                    for (let l = 0; l < c.length; l++)
                        if (pm(n, c[l]))
                            return !0;
                    for (let l = 0; l < n.length; l++)
                        if (Vf(c, n[l]))
                            return !0;
                    return !1
                }
                function vy(c, n, l) {
                    if (c.length > 1) {
                        if (Vf(c, n))
                            return !0;
                        for (let p = 0; p < n.length; p++)
                            if (Uf(n[p], c, l))
                                return !0
                    }
                    for (let p = 0; p < c.length; p++)
                        if (Uf(c[p], n, l))
                            return !0;
                    return !1
                }
                function Vf(c, n) {
                    if (c.length === 0 || n.length === 0)
                        return !1;
                    for (let l = 0; l < c.length - 1; l++) {
                        const p = c[l]
                          , _ = c[l + 1];
                        for (let b = 0; b < n.length - 1; b++)
                            if (xy(p, _, n[b], n[b + 1]))
                                return !0
                    }
                    return !1
                }
                function xy(c, n, l, p) {
                    return $r(c, l, p) !== $r(n, l, p) && $r(c, n, l) !== $r(c, n, p)
                }
                function Uf(c, n, l) {
                    const p = l * l;
                    if (n.length === 1)
                        return c.distSqr(n[0]) < p;
                    for (let _ = 1; _ < n.length; _++)
                        if (Gf(c, n[_ - 1], n[_]) < p)
                            return !0;
                    return !1
                }
                function Gf(c, n, l) {
                    const p = n.distSqr(l);
                    if (p === 0)
                        return c.distSqr(n);
                    const _ = ((c.x - n.x) * (l.x - n.x) + (c.y - n.y) * (l.y - n.y)) / p;
                    return c.distSqr(_ < 0 ? n : _ > 1 ? l : l.sub(n)._mult(_)._add(n))
                }
                function pm(c, n) {
                    let l, p, _, b = !1;
                    for (let C = 0; C < c.length; C++) {
                        l = c[C];
                        for (let M = 0, R = l.length - 1; M < l.length; R = M++)
                            p = l[M],
                            _ = l[R],
                            p.y > n.y != _.y > n.y && n.x < (_.x - p.x) * (n.y - p.y) / (_.y - p.y) + p.x && (b = !b)
                    }
                    return b
                }
                function Lc(c, n) {
                    let l = !1;
                    for (let p = 0, _ = c.length - 1; p < c.length; _ = p++) {
                        const b = c[p]
                          , C = c[_];
                        b.y > n.y != C.y > n.y && n.x < (C.x - b.x) * (n.y - b.y) / (C.y - b.y) + b.x && (l = !l)
                    }
                    return l
                }
                function by(c, n, l) {
                    const p = l[0]
                      , _ = l[2];
                    if (c.x < p.x && n.x < p.x || c.x > _.x && n.x > _.x || c.y < p.y && n.y < p.y || c.y > _.y && n.y > _.y)
                        return !1;
                    const b = $r(c, n, l[0]);
                    return b !== $r(c, n, l[1]) || b !== $r(c, n, l[2]) || b !== $r(c, n, l[3])
                }
                function Mh(c, n, l) {
                    const p = n.paint.get(c).value;
                    return p.kind === "constant" ? p.value : l.programConfigurations.get(n.id).getMaxValue(c)
                }
                function kh(c) {
                    return Math.sqrt(c[0] * c[0] + c[1] * c[1])
                }
                function Eh(c, n, l, p, _) {
                    if (!n[0] && !n[1])
                        return c;
                    const b = N.convert(n)._mult(_);
                    l === "viewport" && b._rotate(-p);
                    const C = [];
                    for (let M = 0; M < c.length; M++)
                        C.push(c[M].sub(b));
                    return C
                }
                let mm, Wf;
                Kt("CircleBucket", dm, {
                    omit: ["layers"]
                });
                var qf = {
                    get paint() {
                        return Wf = Wf || new Vn({
                            "circle-radius": new Cr(Ve.paint_circle["circle-radius"]),
                            "circle-color": new Cr(Ve.paint_circle["circle-color"]),
                            "circle-blur": new Cr(Ve.paint_circle["circle-blur"]),
                            "circle-opacity": new Cr(Ve.paint_circle["circle-opacity"]),
                            "circle-translate": new ir(Ve.paint_circle["circle-translate"]),
                            "circle-translate-anchor": new ir(Ve.paint_circle["circle-translate-anchor"]),
                            "circle-pitch-scale": new ir(Ve.paint_circle["circle-pitch-scale"]),
                            "circle-pitch-alignment": new ir(Ve.paint_circle["circle-pitch-alignment"]),
                            "circle-stroke-width": new Cr(Ve.paint_circle["circle-stroke-width"]),
                            "circle-stroke-color": new Cr(Ve.paint_circle["circle-stroke-color"]),
                            "circle-stroke-opacity": new Cr(Ve.paint_circle["circle-stroke-opacity"])
                        })
                    },
                    get layout() {
                        return mm = mm || new Vn({
                            "circle-sort-key": new Cr(Ve.layout_circle["circle-sort-key"])
                        })
                    }
                };
                class Dv extends Ci {
                    constructor(n) {
                        super(n, qf)
                    }
                    createBucket(n) {
                        return new dm(n)
                    }
                    queryRadius(n) {
                        const l = n;
                        return Mh("circle-radius", this, l) + Mh("circle-stroke-width", this, l) + kh(this.paint.get("circle-translate"))
                    }
                    queryIntersectsFeature({queryGeometry: n, feature: l, featureState: p, geometry: _, transform: b, pixelsToTileUnits: C, unwrappedTileID: M, getElevation: R}) {
                        const O = Eh(n, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -b.bearingInRadians, C)
                          , j = this.paint.get("circle-radius").evaluate(l, p) + this.paint.get("circle-stroke-width").evaluate(l, p)
                          , q = this.paint.get("circle-pitch-alignment") === "map"
                          , Q = q ? O : function(oe, de, we, Ie) {
                            return oe.map(Ye => gm(Ye, de, we, Ie))
                        }(O, b, M, R)
                          , ne = q ? j * C : j;
                        for (const oe of _)
                            for (const de of oe) {
                                const we = q ? de : gm(de, b, M, R);
                                let Ie = ne;
                                const Ye = b.projectTileCoordinates(de.x, de.y, M, R).signedDistanceFromCamera;
                                if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? Ie *= Ye / b.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (Ie *= b.cameraToCenterDistance / Ye),
                                ns(Q, we, Ie))
                                    return !0
                            }
                        return !1
                    }
                }
                function gm(c, n, l, p) {
                    const _ = n.projectTileCoordinates(c.x, c.y, l, p).point;
                    return new N((.5 * _.x + .5) * n.width,(.5 * -_.y + .5) * n.height)
                }
                class Hf extends dm {
                }
                let ym;
                Kt("HeatmapBucket", Hf, {
                    omit: ["layers"]
                });
                var Zf = {
                    get paint() {
                        return ym = ym || new Vn({
                            "heatmap-radius": new Cr(Ve.paint_heatmap["heatmap-radius"]),
                            "heatmap-weight": new Cr(Ve.paint_heatmap["heatmap-weight"]),
                            "heatmap-intensity": new ir(Ve.paint_heatmap["heatmap-intensity"]),
                            "heatmap-color": new Zs(Ve.paint_heatmap["heatmap-color"]),
                            "heatmap-opacity": new ir(Ve.paint_heatmap["heatmap-opacity"])
                        })
                    }
                };
                function _a(c, {width: n, height: l}, p, _) {
                    if (_) {
                        if (_ instanceof Uint8ClampedArray)
                            _ = new Uint8Array(_.buffer);
                        else if (_.length !== n * l * p)
                            throw new RangeError(`mismatched image size. expected: ${_.length} but got: ${n * l * p}`)
                    } else
                        _ = new Uint8Array(n * l * p);
                    return c.width = n,
                    c.height = l,
                    c.data = _,
                    c
                }
                function wy(c, {width: n, height: l}, p) {
                    if (n === c.width && l === c.height)
                        return;
                    const _ = _a({}, {
                        width: n,
                        height: l
                    }, p);
                    Xf(c, _, {
                        x: 0,
                        y: 0
                    }, {
                        x: 0,
                        y: 0
                    }, {
                        width: Math.min(c.width, n),
                        height: Math.min(c.height, l)
                    }, p),
                    c.width = n,
                    c.height = l,
                    c.data = _.data
                }
                function Xf(c, n, l, p, _, b) {
                    if (_.width === 0 || _.height === 0)
                        return n;
                    if (_.width > c.width || _.height > c.height || l.x > c.width - _.width || l.y > c.height - _.height)
                        throw new RangeError("out of range source coordinates for image copy");
                    if (_.width > n.width || _.height > n.height || p.x > n.width - _.width || p.y > n.height - _.height)
                        throw new RangeError("out of range destination coordinates for image copy");
                    const C = c.data
                      , M = n.data;
                    if (C === M)
                        throw new Error("srcData equals dstData, so image is already copied");
                    for (let R = 0; R < _.height; R++) {
                        const O = ((l.y + R) * c.width + l.x) * b
                          , j = ((p.y + R) * n.width + p.x) * b;
                        for (let q = 0; q < _.width * b; q++)
                            M[j + q] = C[O + q]
                    }
                    return n
                }
                class $u {
                    constructor(n, l) {
                        _a(this, n, 1, l)
                    }
                    resize(n) {
                        wy(this, n, 1)
                    }
                    clone() {
                        return new $u({
                            width: this.width,
                            height: this.height
                        },new Uint8Array(this.data))
                    }
                    static copy(n, l, p, _, b) {
                        Xf(n, l, p, _, b, 1)
                    }
                }
                class Oo {
                    constructor(n, l) {
                        _a(this, n, 4, l)
                    }
                    resize(n) {
                        wy(this, n, 4)
                    }
                    replace(n, l) {
                        l ? this.data.set(n) : this.data = n instanceof Uint8ClampedArray ? new Uint8Array(n.buffer) : n
                    }
                    clone() {
                        return new Oo({
                            width: this.width,
                            height: this.height
                        },new Uint8Array(this.data))
                    }
                    static copy(n, l, p, _, b) {
                        Xf(n, l, p, _, b, 4)
                    }
                    setPixel(n, l, p) {
                        const _ = 4 * (n * this.width + l);
                        this.data[_ + 0] = Math.round(255 * p.r / p.a),
                        this.data[_ + 1] = Math.round(255 * p.g / p.a),
                        this.data[_ + 2] = Math.round(255 * p.b / p.a),
                        this.data[_ + 3] = Math.round(255 * p.a)
                    }
                }
                function _m(c) {
                    const n = {}
                      , l = c.resolution || 256
                      , p = c.clips ? c.clips.length : 1
                      , _ = c.image || new Oo({
                        width: l,
                        height: p
                    });
                    if (Math.log(l) / Math.LN2 % 1 != 0)
                        throw new Error(`width is not a power of 2 - ${l}`);
                    const b = (C, M, R) => {
                        n[c.evaluationKey] = R;
                        const O = c.expression.evaluate(n);
                        _.setPixel(C / 4 / l, M / 4, O)
                    }
                    ;
                    if (c.clips)
                        for (let C = 0, M = 0; C < p; ++C,
                        M += 4 * l)
                            for (let R = 0, O = 0; R < l; R++,
                            O += 4) {
                                const j = R / (l - 1)
                                  , {start: q, end: Q} = c.clips[C];
                                b(M, O, q * (1 - j) + Q * j)
                            }
                    else
                        for (let C = 0, M = 0; C < l; C++,
                        M += 4)
                            b(0, M, C / (l - 1));
                    return _
                }
                Kt("AlphaImage", $u),
                Kt("RGBAImage", Oo);
                const Vu = "big-fb";
                class Fo extends Ci {
                    createBucket(n) {
                        return new Hf(n)
                    }
                    constructor(n) {
                        super(n, Zf),
                        this.heatmapFbos = new Map,
                        this._updateColorRamp()
                    }
                    _handleSpecialPaintPropertyUpdate(n) {
                        n === "heatmap-color" && this._updateColorRamp()
                    }
                    _updateColorRamp() {
                        this.colorRamp = _m({
                            expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                            evaluationKey: "heatmapDensity",
                            image: this.colorRamp
                        }),
                        this.colorRampTexture = null
                    }
                    resize() {
                        this.heatmapFbos.has(Vu) && this.heatmapFbos.delete(Vu)
                    }
                    queryRadius() {
                        return 0
                    }
                    queryIntersectsFeature() {
                        return !1
                    }
                    hasOffscreenPass() {
                        return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
                    }
                }
                let Sy;
                var Lv = {
                    get paint() {
                        return Sy = Sy || new Vn({
                            "hillshade-illumination-direction": new ir(Ve.paint_hillshade["hillshade-illumination-direction"]),
                            "hillshade-illumination-altitude": new ir(Ve.paint_hillshade["hillshade-illumination-altitude"]),
                            "hillshade-illumination-anchor": new ir(Ve.paint_hillshade["hillshade-illumination-anchor"]),
                            "hillshade-exaggeration": new ir(Ve.paint_hillshade["hillshade-exaggeration"]),
                            "hillshade-shadow-color": new ir(Ve.paint_hillshade["hillshade-shadow-color"]),
                            "hillshade-highlight-color": new ir(Ve.paint_hillshade["hillshade-highlight-color"]),
                            "hillshade-accent-color": new ir(Ve.paint_hillshade["hillshade-accent-color"]),
                            "hillshade-method": new ir(Ve.paint_hillshade["hillshade-method"])
                        })
                    }
                };
                class Yf extends Ci {
                    constructor(n) {
                        super(n, Lv),
                        this.recalculate({
                            zoom: 0,
                            zoomHistory: {}
                        }, void 0)
                    }
                    getIlluminationProperties() {
                        let n = this.paint.get("hillshade-illumination-direction").values
                          , l = this.paint.get("hillshade-illumination-altitude").values
                          , p = this.paint.get("hillshade-highlight-color").values
                          , _ = this.paint.get("hillshade-shadow-color").values;
                        const b = Math.max(n.length, l.length, p.length, _.length);
                        n = n.concat(Array(b - n.length).fill(n.at(-1))),
                        l = l.concat(Array(b - l.length).fill(l.at(-1))),
                        p = p.concat(Array(b - p.length).fill(p.at(-1))),
                        _ = _.concat(Array(b - _.length).fill(_.at(-1)));
                        const C = l.map(sn);
                        return {
                            directionRadians: n.map(sn),
                            altitudeRadians: C,
                            shadowColor: _,
                            highlightColor: p
                        }
                    }
                    hasOffscreenPass() {
                        return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
                    }
                }
                let So;
                var Ov = {
                    get paint() {
                        return So = So || new Vn({
                            "color-relief-opacity": new ir(Ve["paint_color-relief"]["color-relief-opacity"]),
                            "color-relief-color": new Zs(Ve["paint_color-relief"]["color-relief-color"])
                        })
                    }
                };
                class mr {
                    constructor(n, l, p, _) {
                        this.context = n,
                        this.format = p,
                        this.texture = n.gl.createTexture(),
                        this.update(l, _)
                    }
                    update(n, l, p) {
                        const {width: _, height: b} = n
                          , C = !(this.size && this.size[0] === _ && this.size[1] === b || p)
                          , {context: M} = this
                          , {gl: R} = M;
                        if (this.useMipmap = !!(l && l.useMipmap),
                        R.bindTexture(R.TEXTURE_2D, this.texture),
                        M.pixelStoreUnpackFlipY.set(!1),
                        M.pixelStoreUnpack.set(1),
                        M.pixelStoreUnpackPremultiplyAlpha.set(this.format === R.RGBA && (!l || l.premultiply !== !1)),
                        C)
                            this.size = [_, b],
                            n instanceof HTMLImageElement || n instanceof HTMLCanvasElement || n instanceof HTMLVideoElement || n instanceof ImageData || Wr(n) ? R.texImage2D(R.TEXTURE_2D, 0, this.format, this.format, R.UNSIGNED_BYTE, n) : R.texImage2D(R.TEXTURE_2D, 0, this.format, _, b, 0, this.format, R.UNSIGNED_BYTE, n.data);
                        else {
                            const {x: O, y: j} = p || {
                                x: 0,
                                y: 0
                            };
                            n instanceof HTMLImageElement || n instanceof HTMLCanvasElement || n instanceof HTMLVideoElement || n instanceof ImageData || Wr(n) ? R.texSubImage2D(R.TEXTURE_2D, 0, O, j, R.RGBA, R.UNSIGNED_BYTE, n) : R.texSubImage2D(R.TEXTURE_2D, 0, O, j, _, b, R.RGBA, R.UNSIGNED_BYTE, n.data)
                        }
                        this.useMipmap && this.isSizePowerOfTwo() && R.generateMipmap(R.TEXTURE_2D),
                        M.pixelStoreUnpackFlipY.setDefault(),
                        M.pixelStoreUnpack.setDefault(),
                        M.pixelStoreUnpackPremultiplyAlpha.setDefault()
                    }
                    bind(n, l, p) {
                        const {context: _} = this
                          , {gl: b} = _;
                        b.bindTexture(b.TEXTURE_2D, this.texture),
                        p !== b.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (p = b.LINEAR),
                        n !== this.filter && (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, n),
                        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, p || n),
                        this.filter = n),
                        l !== this.wrap && (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, l),
                        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, l),
                        this.wrap = l)
                    }
                    isSizePowerOfTwo() {
                        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
                    }
                    destroy() {
                        const {gl: n} = this.context;
                        n.deleteTexture(this.texture),
                        this.texture = null
                    }
                }
                class Uu {
                    constructor(n, l, p, _=1, b=1, C=1, M=0) {
                        if (this.uid = n,
                        l.height !== l.width)
                            throw new RangeError("DEM tiles must be square");
                        if (p && !["mapbox", "terrarium", "custom"].includes(p))
                            return void Zr(`"${p}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
                        this.stride = l.height;
                        const R = this.dim = l.height - 2;
                        switch (this.data = new Uint32Array(l.data.buffer),
                        p) {
                        case "terrarium":
                            this.redFactor = 256,
                            this.greenFactor = 1,
                            this.blueFactor = 1 / 256,
                            this.baseShift = 32768;
                            break;
                        case "custom":
                            this.redFactor = _,
                            this.greenFactor = b,
                            this.blueFactor = C,
                            this.baseShift = M;
                            break;
                        default:
                            this.redFactor = 6553.6,
                            this.greenFactor = 25.6,
                            this.blueFactor = .1,
                            this.baseShift = 1e4
                        }
                        for (let O = 0; O < R; O++)
                            this.data[this._idx(-1, O)] = this.data[this._idx(0, O)],
                            this.data[this._idx(R, O)] = this.data[this._idx(R - 1, O)],
                            this.data[this._idx(O, -1)] = this.data[this._idx(O, 0)],
                            this.data[this._idx(O, R)] = this.data[this._idx(O, R - 1)];
                        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)],
                        this.data[this._idx(R, -1)] = this.data[this._idx(R - 1, 0)],
                        this.data[this._idx(-1, R)] = this.data[this._idx(0, R - 1)],
                        this.data[this._idx(R, R)] = this.data[this._idx(R - 1, R - 1)],
                        this.min = Number.MAX_SAFE_INTEGER,
                        this.max = Number.MIN_SAFE_INTEGER;
                        for (let O = 0; O < R; O++)
                            for (let j = 0; j < R; j++) {
                                const q = this.get(O, j);
                                q > this.max && (this.max = q),
                                q < this.min && (this.min = q)
                            }
                    }
                    get(n, l) {
                        const p = new Uint8Array(this.data.buffer)
                          , _ = 4 * this._idx(n, l);
                        return this.unpack(p[_], p[_ + 1], p[_ + 2])
                    }
                    getUnpackVector() {
                        return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
                    }
                    _idx(n, l) {
                        if (n < -1 || n >= this.dim + 1 || l < -1 || l >= this.dim + 1)
                            throw new RangeError("out of range source coordinates for DEM data");
                        return (l + 1) * this.stride + (n + 1)
                    }
                    unpack(n, l, p) {
                        return n * this.redFactor + l * this.greenFactor + p * this.blueFactor - this.baseShift
                    }
                    pack(n) {
                        return Kf(n, this.getUnpackVector())
                    }
                    getPixels() {
                        return new Oo({
                            width: this.stride,
                            height: this.stride
                        },new Uint8Array(this.data.buffer))
                    }
                    backfillBorder(n, l, p) {
                        if (this.dim !== n.dim)
                            throw new Error("dem dimension mismatch");
                        let _ = l * this.dim
                          , b = l * this.dim + this.dim
                          , C = p * this.dim
                          , M = p * this.dim + this.dim;
                        switch (l) {
                        case -1:
                            _ = b - 1;
                            break;
                        case 1:
                            b = _ + 1
                        }
                        switch (p) {
                        case -1:
                            C = M - 1;
                            break;
                        case 1:
                            M = C + 1
                        }
                        const R = -l * this.dim
                          , O = -p * this.dim;
                        for (let j = C; j < M; j++)
                            for (let q = _; q < b; q++)
                                this.data[this._idx(q, j)] = n.data[this._idx(q + R, j + O)]
                    }
                }
                function Kf(c, n) {
                    const l = n[0]
                      , p = n[1]
                      , _ = n[2]
                      , b = n[3]
                      , C = Math.min(l, p, _)
                      , M = Math.round((c + b) / C);
                    return {
                        r: Math.floor(M * C / l) % 256,
                        g: Math.floor(M * C / p) % 256,
                        b: Math.floor(M * C / _) % 256
                    }
                }
                Kt("DEMData", Uu);
                class Cy extends Ci {
                    constructor(n) {
                        super(n, Ov)
                    }
                    _createColorRamp(n) {
                        const l = {
                            elevationStops: [],
                            colorStops: []
                        }
                          , p = this._transitionablePaint._values["color-relief-color"].value.expression;
                        if (p instanceof Ws && p._styleExpression.expression instanceof yo) {
                            this.colorRampExpression = p;
                            const C = p._styleExpression.expression;
                            l.elevationStops = C.labels,
                            l.colorStops = [];
                            for (const M of l.elevationStops)
                                l.colorStops.push(C.evaluate({
                                    globals: {
                                        elevation: M
                                    }
                                }))
                        }
                        if (l.elevationStops.length < 1 && (l.elevationStops = [0],
                        l.colorStops = [Br.transparent]),
                        l.elevationStops.length < 2 && (l.elevationStops.push(l.elevationStops[0] + 1),
                        l.colorStops.push(l.colorStops[0])),
                        l.elevationStops.length <= n)
                            return l;
                        const _ = {
                            elevationStops: [],
                            colorStops: []
                        }
                          , b = (l.elevationStops.length - 1) / (n - 1);
                        for (let C = 0; C < l.elevationStops.length - .5; C += b)
                            _.elevationStops.push(l.elevationStops[Math.round(C)]),
                            _.colorStops.push(l.colorStops[Math.round(C)]);
                        return Zr(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`),
                        _
                    }
                    _colorRampChanged() {
                        return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
                    }
                    getColorRampTextures(n, l, p) {
                        if (this.colorRampTextures && !this._colorRampChanged())
                            return this.colorRampTextures;
                        const _ = this._createColorRamp(l)
                          , b = new Oo({
                            width: _.colorStops.length,
                            height: 1
                        })
                          , C = new Oo({
                            width: _.colorStops.length,
                            height: 1
                        });
                        for (let M = 0; M < _.elevationStops.length; M++) {
                            const R = Kf(_.elevationStops[M], p);
                            C.setPixel(0, M, new Br(R.r / 255,R.g / 255,R.b / 255,1)),
                            b.setPixel(0, M, _.colorStops[M])
                        }
                        return this.colorRampTextures = {
                            elevationTexture: new mr(n,C,n.gl.RGBA),
                            colorTexture: new mr(n,b,n.gl.RGBA)
                        },
                        this.colorRampTextures
                    }
                    hasOffscreenPass() {
                        return this.visibility !== "none" && !!this.colorRampTextures
                    }
                }
                const Fv = Yn([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: Ad} = Fv;
                function Ih(c, n, l) {
                    const p = l.patternDependencies;
                    let _ = !1;
                    for (const b of n) {
                        const C = b.paint.get(`${c}-pattern`);
                        C.isConstant() || (_ = !0);
                        const M = C.constantOr(null);
                        M && (_ = !0,
                        p[M.to] = !0,
                        p[M.from] = !0)
                    }
                    return _
                }
                function zd(c, n, l, p, _) {
                    const b = _.patternDependencies;
                    for (const C of n) {
                        const M = C.paint.get(`${c}-pattern`).value;
                        if (M.kind !== "constant") {
                            let R = M.evaluate({
                                zoom: p - 1
                            }, l, {}, _.availableImages)
                              , O = M.evaluate({
                                zoom: p
                            }, l, {}, _.availableImages)
                              , j = M.evaluate({
                                zoom: p + 1
                            }, l, {}, _.availableImages);
                            R = R && R.name ? R.name : R,
                            O = O && O.name ? O.name : O,
                            j = j && j.name ? j.name : j,
                            b[R] = !0,
                            b[O] = !0,
                            b[j] = !0,
                            l.patterns[C.id] = {
                                min: R,
                                mid: O,
                                max: j
                            }
                        }
                    }
                    return l
                }
                function vm(c, n, l, p, _) {
                    let b;
                    if (_ === function(C, M, R, O) {
                        let j = 0;
                        for (let q = M, Q = R - O; q < R; q += O)
                            j += (C[Q] - C[q]) * (C[q + 1] + C[Q + 1]),
                            Q = q;
                        return j
                    }(c, n, l, p) > 0)
                        for (let C = n; C < l; C += p)
                            b = mn(C / p | 0, c[C], c[C + 1], b);
                    else
                        for (let C = l - p; C >= n; C -= p)
                            b = mn(C / p | 0, c[C], c[C + 1], b);
                    return b && Gu(b, b.next) && (_i(b),
                    b = b.next),
                    b
                }
                function Oc(c, n) {
                    if (!c)
                        return c;
                    n || (n = c);
                    let l, p = c;
                    do
                        if (l = !1,
                        p.steiner || !Gu(p, p.next) && oi(p.prev, p, p.next) !== 0)
                            p = p.next;
                        else {
                            if (_i(p),
                            p = n = p.prev,
                            p === p.next)
                                break;
                            l = !0
                        }
                    while (l || p !== n);
                    return n
                }
                function Rh(c, n, l, p, _, b, C) {
                    if (!c)
                        return;
                    !C && b && function(R, O, j, q) {
                        let Q = R;
                        do
                            Q.z === 0 && (Q.z = As(Q.x, Q.y, O, j, q)),
                            Q.prevZ = Q.prev,
                            Q.nextZ = Q.next,
                            Q = Q.next;
                        while (Q !== R);
                        Q.prevZ.nextZ = null,
                        Q.prevZ = null,
                        function(ne) {
                            let oe, de = 1;
                            do {
                                let we, Ie = ne;
                                ne = null;
                                let Ye = null;
                                for (oe = 0; Ie; ) {
                                    oe++;
                                    let Le = Ie
                                      , te = 0;
                                    for (let Oe = 0; Oe < de && (te++,
                                    Le = Le.nextZ,
                                    Le); Oe++)
                                        ;
                                    let _e = de;
                                    for (; te > 0 || _e > 0 && Le; )
                                        te !== 0 && (_e === 0 || !Le || Ie.z <= Le.z) ? (we = Ie,
                                        Ie = Ie.nextZ,
                                        te--) : (we = Le,
                                        Le = Le.nextZ,
                                        _e--),
                                        Ye ? Ye.nextZ = we : ne = we,
                                        we.prevZ = Ye,
                                        Ye = we;
                                    Ie = Le
                                }
                                Ye.nextZ = null,
                                de *= 2
                            } while (oe > 1)
                        }(Q)
                    }(c, p, _, b);
                    let M = c;
                    for (; c.prev !== c.next; ) {
                        const R = c.prev
                          , O = c.next;
                        if (b ? bm(c, p, _, b) : xm(c))
                            n.push(R.i, c.i, O.i),
                            _i(c),
                            c = O.next,
                            M = O.next;
                        else if ((c = O) === M) {
                            C ? C === 1 ? Rh(c = Co(Oc(c), n), n, l, p, _, b, 2) : C === 2 && va(c, n, l, p, _, b) : Rh(Oc(c), n, l, p, _, b, 1);
                            break
                        }
                    }
                }
                function xm(c) {
                    const n = c.prev
                      , l = c
                      , p = c.next;
                    if (oi(n, l, p) >= 0)
                        return !1;
                    const _ = n.x
                      , b = l.x
                      , C = p.x
                      , M = n.y
                      , R = l.y
                      , O = p.y
                      , j = Math.min(_, b, C)
                      , q = Math.min(M, R, O)
                      , Q = Math.max(_, b, C)
                      , ne = Math.max(M, R, O);
                    let oe = p.next;
                    for (; oe !== n; ) {
                        if (oe.x >= j && oe.x <= Q && oe.y >= q && oe.y <= ne && Dd(_, M, b, R, C, O, oe.x, oe.y) && oi(oe.prev, oe, oe.next) >= 0)
                            return !1;
                        oe = oe.next
                    }
                    return !0
                }
                function bm(c, n, l, p) {
                    const _ = c.prev
                      , b = c
                      , C = c.next;
                    if (oi(_, b, C) >= 0)
                        return !1;
                    const M = _.x
                      , R = b.x
                      , O = C.x
                      , j = _.y
                      , q = b.y
                      , Q = C.y
                      , ne = Math.min(M, R, O)
                      , oe = Math.min(j, q, Q)
                      , de = Math.max(M, R, O)
                      , we = Math.max(j, q, Q)
                      , Ie = As(ne, oe, n, l, p)
                      , Ye = As(de, we, n, l, p);
                    let Le = c.prevZ
                      , te = c.nextZ;
                    for (; Le && Le.z >= Ie && te && te.z <= Ye; ) {
                        if (Le.x >= ne && Le.x <= de && Le.y >= oe && Le.y <= we && Le !== _ && Le !== C && Dd(M, j, R, q, O, Q, Le.x, Le.y) && oi(Le.prev, Le, Le.next) >= 0 || (Le = Le.prevZ,
                        te.x >= ne && te.x <= de && te.y >= oe && te.y <= we && te !== _ && te !== C && Dd(M, j, R, q, O, Q, te.x, te.y) && oi(te.prev, te, te.next) >= 0))
                            return !1;
                        te = te.nextZ
                    }
                    for (; Le && Le.z >= Ie; ) {
                        if (Le.x >= ne && Le.x <= de && Le.y >= oe && Le.y <= we && Le !== _ && Le !== C && Dd(M, j, R, q, O, Q, Le.x, Le.y) && oi(Le.prev, Le, Le.next) >= 0)
                            return !1;
                        Le = Le.prevZ
                    }
                    for (; te && te.z <= Ye; ) {
                        if (te.x >= ne && te.x <= de && te.y >= oe && te.y <= we && te !== _ && te !== C && Dd(M, j, R, q, O, Q, te.x, te.y) && oi(te.prev, te, te.next) >= 0)
                            return !1;
                        te = te.nextZ
                    }
                    return !0
                }
                function Co(c, n) {
                    let l = c;
                    do {
                        const p = l.prev
                          , _ = l.next.next;
                        !Gu(p, _) && wm(p, l, l.next, _) && qu(p, _) && qu(_, p) && (n.push(p.i, l.i, _.i),
                        _i(l),
                        _i(l.next),
                        l = c = _),
                        l = l.next
                    } while (l !== c);
                    return Oc(l)
                }
                function va(c, n, l, p, _, b) {
                    let C = c;
                    do {
                        let M = C.next.next;
                        for (; M !== C.prev; ) {
                            if (C.i !== M.i && ky(C, M)) {
                                let R = zs(C, M);
                                return C = Oc(C, C.next),
                                R = Oc(R, R.next),
                                Rh(C, n, l, p, _, b, 0),
                                void Rh(R, n, l, p, _, b, 0)
                            }
                            M = M.next
                        }
                        C = C.next
                    } while (C !== c)
                }
                function Fc(c, n) {
                    let l = c.x - n.x;
                    return l === 0 && (l = c.y - n.y,
                    l === 0) && (l = (c.next.y - c.y) / (c.next.x - c.x) - (n.next.y - n.y) / (n.next.x - n.x)),
                    l
                }
                function Ty(c, n) {
                    const l = function(_, b) {
                        let C = b;
                        const M = _.x
                          , R = _.y;
                        let O, j = -1 / 0;
                        if (Gu(_, C))
                            return C;
                        do {
                            if (Gu(_, C.next))
                                return C.next;
                            if (R <= C.y && R >= C.next.y && C.next.y !== C.y) {
                                const de = C.x + (R - C.y) * (C.next.x - C.x) / (C.next.y - C.y);
                                if (de <= M && de > j && (j = de,
                                O = C.x < C.next.x ? C : C.next,
                                de === M))
                                    return O
                            }
                            C = C.next
                        } while (C !== b);
                        if (!O)
                            return null;
                        const q = O
                          , Q = O.x
                          , ne = O.y;
                        let oe = 1 / 0;
                        C = O;
                        do {
                            if (M >= C.x && C.x >= Q && M !== C.x && xa(R < ne ? M : j, R, Q, ne, R < ne ? j : M, R, C.x, C.y)) {
                                const de = Math.abs(R - C.y) / (M - C.x);
                                qu(C, _) && (de < oe || de === oe && (C.x > O.x || C.x === O.x && Py(O, C))) && (O = C,
                                oe = de)
                            }
                            C = C.next
                        } while (C !== q);
                        return O
                    }(c, n);
                    if (!l)
                        return n;
                    const p = zs(l, c);
                    return Oc(p, p.next),
                    Oc(l, l.next)
                }
                function Py(c, n) {
                    return oi(c.prev, c, n.prev) < 0 && oi(n.next, c, c.next) < 0
                }
                function As(c, n, l, p, _) {
                    return (c = 1431655765 & ((c = 858993459 & ((c = 252645135 & ((c = 16711935 & ((c = (c - l) * _ | 0) | c << 8)) | c << 4)) | c << 2)) | c << 1)) | (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - p) * _ | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) << 1
                }
                function My(c) {
                    let n = c
                      , l = c;
                    do
                        (n.x < l.x || n.x === l.x && n.y < l.y) && (l = n),
                        n = n.next;
                    while (n !== c);
                    return l
                }
                function xa(c, n, l, p, _, b, C, M) {
                    return (_ - C) * (n - M) >= (c - C) * (b - M) && (c - C) * (p - M) >= (l - C) * (n - M) && (l - C) * (b - M) >= (_ - C) * (p - M)
                }
                function Dd(c, n, l, p, _, b, C, M) {
                    return !(c === C && n === M) && xa(c, n, l, p, _, b, C, M)
                }
                function ky(c, n) {
                    return c.next.i !== n.i && c.prev.i !== n.i && !function(l, p) {
                        let _ = l;
                        do {
                            if (_.i !== l.i && _.next.i !== l.i && _.i !== p.i && _.next.i !== p.i && wm(_, _.next, l, p))
                                return !0;
                            _ = _.next
                        } while (_ !== l);
                        return !1
                    }(c, n) && (qu(c, n) && qu(n, c) && function(l, p) {
                        let _ = l
                          , b = !1;
                        const C = (l.x + p.x) / 2
                          , M = (l.y + p.y) / 2;
                        do
                            _.y > M != _.next.y > M && _.next.y !== _.y && C < (_.next.x - _.x) * (M - _.y) / (_.next.y - _.y) + _.x && (b = !b),
                            _ = _.next;
                        while (_ !== l);
                        return b
                    }(c, n) && (oi(c.prev, c, n.prev) || oi(c, n.prev, n)) || Gu(c, n) && oi(c.prev, c, c.next) > 0 && oi(n.prev, n, n.next) > 0)
                }
                function oi(c, n, l) {
                    return (n.y - c.y) * (l.x - n.x) - (n.x - c.x) * (l.y - n.y)
                }
                function Gu(c, n) {
                    return c.x === n.x && c.y === n.y
                }
                function wm(c, n, l, p) {
                    const _ = Wu(oi(c, n, l))
                      , b = Wu(oi(c, n, p))
                      , C = Wu(oi(l, p, c))
                      , M = Wu(oi(l, p, n));
                    return _ !== b && C !== M || !(_ !== 0 || !Qf(c, l, n)) || !(b !== 0 || !Qf(c, p, n)) || !(C !== 0 || !Qf(l, c, p)) || !(M !== 0 || !Qf(l, n, p))
                }
                function Qf(c, n, l) {
                    return n.x <= Math.max(c.x, l.x) && n.x >= Math.min(c.x, l.x) && n.y <= Math.max(c.y, l.y) && n.y >= Math.min(c.y, l.y)
                }
                function Wu(c) {
                    return c > 0 ? 1 : c < 0 ? -1 : 0
                }
                function qu(c, n) {
                    return oi(c.prev, c, c.next) < 0 ? oi(c, n, c.next) >= 0 && oi(c, c.prev, n) >= 0 : oi(c, n, c.prev) < 0 || oi(c, c.next, n) < 0
                }
                function zs(c, n) {
                    const l = vi(c.i, c.x, c.y)
                      , p = vi(n.i, n.x, n.y)
                      , _ = c.next
                      , b = n.prev;
                    return c.next = n,
                    n.prev = c,
                    l.next = _,
                    _.prev = l,
                    p.next = l,
                    l.prev = p,
                    b.next = p,
                    p.prev = b,
                    p
                }
                function mn(c, n, l, p) {
                    const _ = vi(c, n, l);
                    return p ? (_.next = p.next,
                    _.prev = p,
                    p.next.prev = _,
                    p.next = _) : (_.prev = _,
                    _.next = _),
                    _
                }
                function _i(c) {
                    c.next.prev = c.prev,
                    c.prev.next = c.next,
                    c.prevZ && (c.prevZ.nextZ = c.nextZ),
                    c.nextZ && (c.nextZ.prevZ = c.prevZ)
                }
                function vi(c, n, l) {
                    return {
                        i: c,
                        x: n,
                        y: l,
                        prev: null,
                        next: null,
                        z: 0,
                        prevZ: null,
                        nextZ: null,
                        steiner: !1
                    }
                }
                class xi {
                    constructor(n, l) {
                        if (l > n)
                            throw new Error("Min granularity must not be greater than base granularity.");
                        this._baseZoomGranularity = n,
                        this._minGranularity = l
                    }
                    getGranularityForZoomLevel(n) {
                        return Math.max(Math.floor(this._baseZoomGranularity / (1 << n)), this._minGranularity, 1)
                    }
                }
                class Bo {
                    constructor(n) {
                        this.fill = n.fill,
                        this.line = n.line,
                        this.tile = n.tile,
                        this.stencil = n.stencil,
                        this.circle = n.circle
                    }
                }
                Bo.noSubdivision = new Bo({
                    fill: new xi(0,0),
                    line: new xi(0,0),
                    tile: new xi(0,0),
                    stencil: new xi(0,0),
                    circle: 1
                }),
                Kt("SubdivisionGranularityExpression", xi),
                Kt("SubdivisionGranularitySetting", Bo);
                const ba = -32768
                  , di = 32767;
                class Ld {
                    constructor(n, l) {
                        this._vertexBuffer = [],
                        this._vertexDictionary = new Map,
                        this._used = !1,
                        this._granularity = n,
                        this._granularityCellSize = st / n,
                        this._canonical = l
                    }
                    _getKey(n, l) {
                        return (n += 32768) << 16 | l + 32768
                    }
                    _vertexToIndex(n, l) {
                        if (n < -32768 || l < -32768 || n > 32767 || l > 32767)
                            throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
                        const p = 0 | Math.round(n)
                          , _ = 0 | Math.round(l)
                          , b = this._getKey(p, _);
                        if (this._vertexDictionary.has(b))
                            return this._vertexDictionary.get(b);
                        const C = this._vertexBuffer.length / 2;
                        return this._vertexDictionary.set(b, C),
                        this._vertexBuffer.push(p, _),
                        C
                    }
                    _subdivideTrianglesScanline(n) {
                        if (this._granularity < 2)
                            return function(_, b) {
                                const C = [];
                                for (let M = 0; M < b.length; M += 3) {
                                    const R = b[M]
                                      , O = b[M + 1]
                                      , j = b[M + 2]
                                      , q = _[2 * R]
                                      , Q = _[2 * R + 1];
                                    (_[2 * O] - q) * (_[2 * j + 1] - Q) - (_[2 * O + 1] - Q) * (_[2 * j] - q) > 0 ? (C.push(R),
                                    C.push(j),
                                    C.push(O)) : (C.push(R),
                                    C.push(O),
                                    C.push(j))
                                }
                                return C
                            }(this._vertexBuffer, n);
                        const l = []
                          , p = n.length;
                        for (let _ = 0; _ < p; _ += 3) {
                            const b = [n[_ + 0], n[_ + 1], n[_ + 2]]
                              , C = [this._vertexBuffer[2 * n[_ + 0] + 0], this._vertexBuffer[2 * n[_ + 0] + 1], this._vertexBuffer[2 * n[_ + 1] + 0], this._vertexBuffer[2 * n[_ + 1] + 1], this._vertexBuffer[2 * n[_ + 2] + 0], this._vertexBuffer[2 * n[_ + 2] + 1]];
                            let M = 1 / 0
                              , R = 1 / 0
                              , O = -1 / 0
                              , j = -1 / 0;
                            for (let de = 0; de < 3; de++) {
                                const we = C[2 * de]
                                  , Ie = C[2 * de + 1];
                                M = Math.min(M, we),
                                O = Math.max(O, we),
                                R = Math.min(R, Ie),
                                j = Math.max(j, Ie)
                            }
                            if (M === O || R === j)
                                continue;
                            const q = Math.floor(M / this._granularityCellSize)
                              , Q = Math.ceil(O / this._granularityCellSize)
                              , ne = Math.floor(R / this._granularityCellSize)
                              , oe = Math.ceil(j / this._granularityCellSize);
                            if (q !== Q || ne !== oe)
                                for (let de = ne; de < oe; de++) {
                                    const we = this._scanlineGenerateVertexRingForCellRow(de, C, b);
                                    Sm(this._vertexBuffer, we, l)
                                }
                            else
                                l.push(...b)
                        }
                        return l
                    }
                    _scanlineGenerateVertexRingForCellRow(n, l, p) {
                        const _ = n * this._granularityCellSize
                          , b = _ + this._granularityCellSize
                          , C = [];
                        for (let M = 0; M < 3; M++) {
                            const R = l[2 * M]
                              , O = l[2 * M + 1]
                              , j = l[2 * (M + 1) % 6]
                              , q = l[(2 * (M + 1) + 1) % 6]
                              , Q = l[2 * (M + 2) % 6]
                              , ne = l[(2 * (M + 2) + 1) % 6]
                              , oe = j - R
                              , de = q - O
                              , we = oe === 0
                              , Ie = de === 0
                              , Ye = (_ - O) / de
                              , Le = (b - O) / de
                              , te = Math.min(Ye, Le)
                              , _e = Math.max(Ye, Le);
                            if (!Ie && (te >= 1 || _e <= 0) || Ie && (O < _ || O > b)) {
                                q >= _ && q <= b && C.push(p[(M + 1) % 3]);
                                continue
                            }
                            !Ie && te > 0 && C.push(this._vertexToIndex(R + oe * te, O + de * te));
                            const Oe = R + oe * Math.max(te, 0)
                              , ft = R + oe * Math.min(_e, 1);
                            we || this._generateIntraEdgeVertices(C, R, O, j, q, Oe, ft),
                            !Ie && _e < 1 && C.push(this._vertexToIndex(R + oe * _e, O + de * _e)),
                            (Ie || q >= _ && q <= b) && C.push(p[(M + 1) % 3]),
                            !Ie && (q <= _ || q >= b) && this._generateInterEdgeVertices(C, R, O, j, q, Q, ne, ft, _, b)
                        }
                        return C
                    }
                    _generateIntraEdgeVertices(n, l, p, _, b, C, M) {
                        const R = _ - l
                          , O = b - p
                          , j = O === 0
                          , q = j ? Math.min(l, _) : Math.min(C, M)
                          , Q = j ? Math.max(l, _) : Math.max(C, M)
                          , ne = Math.floor(q / this._granularityCellSize) + 1
                          , oe = Math.ceil(Q / this._granularityCellSize) - 1;
                        if (j ? l < _ : C < M)
                            for (let de = ne; de <= oe; de++) {
                                const we = de * this._granularityCellSize;
                                n.push(this._vertexToIndex(we, p + O * (we - l) / R))
                            }
                        else
                            for (let de = oe; de >= ne; de--) {
                                const we = de * this._granularityCellSize;
                                n.push(this._vertexToIndex(we, p + O * (we - l) / R))
                            }
                    }
                    _generateInterEdgeVertices(n, l, p, _, b, C, M, R, O, j) {
                        const q = b - p
                          , Q = C - _
                          , ne = M - b
                          , oe = (O - b) / ne
                          , de = (j - b) / ne
                          , we = Math.min(oe, de)
                          , Ie = Math.max(oe, de)
                          , Ye = _ + Q * we;
                        let Le = Math.floor(Math.min(Ye, R) / this._granularityCellSize) + 1
                          , te = Math.ceil(Math.max(Ye, R) / this._granularityCellSize) - 1
                          , _e = R < Ye;
                        const Oe = ne === 0;
                        if (Oe && (M === O || M === j))
                            return;
                        if (Oe || we >= 1 || Ie <= 0) {
                            const Rt = p - M
                              , yt = C + (l - C) * Math.min((O - M) / Rt, (j - M) / Rt);
                            Le = Math.floor(Math.min(yt, R) / this._granularityCellSize) + 1,
                            te = Math.ceil(Math.max(yt, R) / this._granularityCellSize) - 1,
                            _e = R < yt
                        }
                        const ft = q > 0 ? j : O;
                        if (_e)
                            for (let Rt = Le; Rt <= te; Rt++)
                                n.push(this._vertexToIndex(Rt * this._granularityCellSize, ft));
                        else
                            for (let Rt = te; Rt >= Le; Rt--)
                                n.push(this._vertexToIndex(Rt * this._granularityCellSize, ft))
                    }
                    _generateOutline(n) {
                        const l = [];
                        for (const p of n) {
                            const _ = nl(p, this._granularity, !0)
                              , b = this._pointArrayToIndices(_)
                              , C = [];
                            for (let M = 1; M < b.length; M++)
                                C.push(b[M - 1]),
                                C.push(b[M]);
                            l.push(C)
                        }
                        return l
                    }
                    _handlePoles(n) {
                        let l = !1
                          , p = !1;
                        this._canonical && (this._canonical.y === 0 && (l = !0),
                        this._canonical.y === (1 << this._canonical.z) - 1 && (p = !0)),
                        (l || p) && this._fillPoles(n, l, p)
                    }
                    _ensureNoPoleVertices() {
                        const n = this._vertexBuffer;
                        for (let l = 0; l < n.length; l += 2) {
                            const p = n[l + 1];
                            p === ba && (n[l + 1] = -32767),
                            p === di && (n[l + 1] = 32766)
                        }
                    }
                    _generatePoleQuad(n, l, p, _, b, C) {
                        _ > b != (C === ba) ? (n.push(l),
                        n.push(p),
                        n.push(this._vertexToIndex(_, C)),
                        n.push(p),
                        n.push(this._vertexToIndex(b, C)),
                        n.push(this._vertexToIndex(_, C))) : (n.push(p),
                        n.push(l),
                        n.push(this._vertexToIndex(_, C)),
                        n.push(this._vertexToIndex(b, C)),
                        n.push(p),
                        n.push(this._vertexToIndex(_, C)))
                    }
                    _fillPoles(n, l, p) {
                        const _ = this._vertexBuffer
                          , b = st
                          , C = n.length;
                        for (let M = 2; M < C; M += 3) {
                            const R = n[M - 2]
                              , O = n[M - 1]
                              , j = n[M]
                              , q = _[2 * R]
                              , Q = _[2 * R + 1]
                              , ne = _[2 * O]
                              , oe = _[2 * O + 1]
                              , de = _[2 * j]
                              , we = _[2 * j + 1];
                            l && (Q === 0 && oe === 0 && this._generatePoleQuad(n, R, O, q, ne, ba),
                            oe === 0 && we === 0 && this._generatePoleQuad(n, O, j, ne, de, ba),
                            we === 0 && Q === 0 && this._generatePoleQuad(n, j, R, de, q, ba)),
                            p && (Q === b && oe === b && this._generatePoleQuad(n, R, O, q, ne, di),
                            oe === b && we === b && this._generatePoleQuad(n, O, j, ne, de, di),
                            we === b && Q === b && this._generatePoleQuad(n, j, R, de, q, di))
                        }
                    }
                    _initializeVertices(n) {
                        for (let l = 0; l < n.length; l += 2)
                            this._vertexToIndex(n[l], n[l + 1])
                    }
                    subdividePolygonInternal(n, l) {
                        if (this._used)
                            throw new Error("Subdivision: multiple use not allowed.");
                        this._used = !0;
                        const {flattened: p, holeIndices: _} = function(M) {
                            const R = []
                              , O = [];
                            for (const j of M)
                                if (j.length !== 0) {
                                    j !== M[0] && R.push(O.length / 2);
                                    for (let q = 0; q < j.length; q++)
                                        O.push(j[q].x),
                                        O.push(j[q].y)
                                }
                            return {
                                flattened: O,
                                holeIndices: R
                            }
                        }(n);
                        let b;
                        this._initializeVertices(p);
                        try {
                            const M = function(O, j, q=2) {
                                const Q = j && j.length
                                  , ne = Q ? j[0] * q : O.length;
                                let oe = vm(O, 0, ne, q, !0);
                                const de = [];
                                if (!oe || oe.next === oe.prev)
                                    return de;
                                let we, Ie, Ye;
                                if (Q && (oe = function(Le, te, _e, Oe) {
                                    const ft = [];
                                    for (let Rt = 0, yt = te.length; Rt < yt; Rt++) {
                                        const bt = vm(Le, te[Rt] * Oe, Rt < yt - 1 ? te[Rt + 1] * Oe : Le.length, Oe, !1);
                                        bt === bt.next && (bt.steiner = !0),
                                        ft.push(My(bt))
                                    }
                                    ft.sort(Fc);
                                    for (let Rt = 0; Rt < ft.length; Rt++)
                                        _e = Ty(ft[Rt], _e);
                                    return _e
                                }(O, j, oe, q)),
                                O.length > 80 * q) {
                                    we = 1 / 0,
                                    Ie = 1 / 0;
                                    let Le = -1 / 0
                                      , te = -1 / 0;
                                    for (let _e = q; _e < ne; _e += q) {
                                        const Oe = O[_e]
                                          , ft = O[_e + 1];
                                        Oe < we && (we = Oe),
                                        ft < Ie && (Ie = ft),
                                        Oe > Le && (Le = Oe),
                                        ft > te && (te = ft)
                                    }
                                    Ye = Math.max(Le - we, te - Ie),
                                    Ye = Ye !== 0 ? 32767 / Ye : 0
                                }
                                return Rh(oe, de, q, we, Ie, Ye, 0),
                                de
                            }(p, _)
                              , R = this._convertIndices(p, M);
                            b = this._subdivideTrianglesScanline(R)
                        } catch (M) {
                            console.error(M)
                        }
                        let C = [];
                        return l && (C = this._generateOutline(n)),
                        this._ensureNoPoleVertices(),
                        this._handlePoles(b),
                        {
                            verticesFlattened: this._vertexBuffer,
                            indicesTriangles: b,
                            indicesLineList: C
                        }
                    }
                    _convertIndices(n, l) {
                        const p = [];
                        for (let _ = 0; _ < l.length; _++)
                            p.push(this._vertexToIndex(n[2 * l[_]], n[2 * l[_] + 1]));
                        return p
                    }
                    _pointArrayToIndices(n) {
                        const l = [];
                        for (let p = 0; p < n.length; p++) {
                            const _ = n[p];
                            l.push(this._vertexToIndex(_.x, _.y))
                        }
                        return l
                    }
                }
                function Bc(c, n, l, p=!0) {
                    return new Ld(l,n).subdividePolygonInternal(c, p)
                }
                function nl(c, n, l=!1) {
                    if (!c || c.length < 1)
                        return [];
                    if (c.length < 2)
                        return [];
                    const p = c[0]
                      , _ = c[c.length - 1]
                      , b = l && (p.x !== _.x || p.y !== _.y);
                    if (n < 2)
                        return b ? [...c, c[0]] : [...c];
                    const C = Math.floor(st / n)
                      , M = [];
                    M.push(new N(c[0].x,c[0].y));
                    const R = c.length
                      , O = b ? R : R - 1;
                    for (let j = 0; j < O; j++) {
                        const q = c[j]
                          , Q = j < R - 1 ? c[j + 1] : c[0]
                          , ne = q.x
                          , oe = q.y
                          , de = Q.x
                          , we = Q.y
                          , Ie = ne !== de
                          , Ye = oe !== we;
                        if (!Ie && !Ye)
                            continue;
                        const Le = de - ne
                          , te = we - oe
                          , _e = Math.abs(Le)
                          , Oe = Math.abs(te);
                        let ft = ne
                          , Rt = oe;
                        for (; ; ) {
                            const bt = Le > 0 ? (Math.floor(ft / C) + 1) * C : (Math.ceil(ft / C) - 1) * C
                              , Dt = te > 0 ? (Math.floor(Rt / C) + 1) * C : (Math.ceil(Rt / C) - 1) * C
                              , At = Math.abs(ft - bt)
                              , Ft = Math.abs(Rt - Dt)
                              , Tt = Math.abs(ft - de)
                              , ar = Math.abs(Rt - we)
                              , Mr = Ie ? At / _e : Number.POSITIVE_INFINITY
                              , Tr = Ye ? Ft / Oe : Number.POSITIVE_INFINITY;
                            if ((Tt <= At || !Ie) && (ar <= Ft || !Ye))
                                break;
                            if (Mr < Tr && Ie || !Ye) {
                                ft = bt,
                                Rt += te * Mr;
                                const pr = new N(ft,Math.round(Rt));
                                M[M.length - 1].x === pr.x && M[M.length - 1].y === pr.y || M.push(pr)
                            } else {
                                ft += Le * Tr,
                                Rt = Dt;
                                const pr = new N(Math.round(ft),Rt);
                                M[M.length - 1].x === pr.x && M[M.length - 1].y === pr.y || M.push(pr)
                            }
                        }
                        const yt = new N(de,we);
                        M[M.length - 1].x === yt.x && M[M.length - 1].y === yt.y || M.push(yt)
                    }
                    return M
                }
                function Sm(c, n, l) {
                    if (n.length === 0)
                        throw new Error("Subdivision vertex ring is empty.");
                    let p = 0
                      , _ = c[2 * n[0]];
                    for (let R = 1; R < n.length; R++) {
                        const O = c[2 * n[R]];
                        O < _ && (_ = O,
                        p = R)
                    }
                    const b = n.length;
                    let C = p
                      , M = (C + 1) % b;
                    for (; ; ) {
                        const R = C - 1 >= 0 ? C - 1 : b - 1
                          , O = (M + 1) % b
                          , j = c[2 * n[R]]
                          , q = c[2 * n[O]]
                          , Q = c[2 * n[C]]
                          , ne = c[2 * n[C] + 1]
                          , oe = c[2 * n[M] + 1];
                        let de = !1;
                        if (j < q)
                            de = !0;
                        else if (j > q)
                            de = !1;
                        else {
                            const we = oe - ne
                              , Ie = -(c[2 * n[M]] - Q)
                              , Ye = ne < oe ? 1 : -1;
                            ((j - Q) * we + (c[2 * n[R] + 1] - ne) * Ie) * Ye > ((q - Q) * we + (c[2 * n[O] + 1] - ne) * Ie) * Ye && (de = !0)
                        }
                        if (de) {
                            const we = n[R]
                              , Ie = n[C]
                              , Ye = n[M];
                            we !== Ie && we !== Ye && Ie !== Ye && l.push(Ye, Ie, we),
                            C--,
                            C < 0 && (C = b - 1)
                        } else {
                            const we = n[O]
                              , Ie = n[C]
                              , Ye = n[M];
                            we !== Ie && we !== Ye && Ie !== Ye && l.push(Ye, Ie, we),
                            M++,
                            M >= b && (M = 0)
                        }
                        if (R === O)
                            break
                    }
                }
                function Ah(c, n, l, p, _, b, C, M, R) {
                    const O = _.length / 2
                      , j = C && M && R;
                    if (O < rn.MAX_VERTEX_ARRAY_LENGTH) {
                        const q = n.prepareSegment(O, l, p)
                          , Q = q.vertexLength;
                        for (let de = 0; de < b.length; de += 3)
                            p.emplaceBack(Q + b[de], Q + b[de + 1], Q + b[de + 2]);
                        let ne, oe;
                        q.vertexLength += O,
                        q.primitiveLength += b.length / 3,
                        j && (oe = C.prepareSegment(O, l, M),
                        ne = oe.vertexLength,
                        oe.vertexLength += O);
                        for (let de = 0; de < _.length; de += 2)
                            c(_[de], _[de + 1]);
                        if (j)
                            for (let de = 0; de < R.length; de++) {
                                const we = R[de];
                                for (let Ie = 1; Ie < we.length; Ie += 2)
                                    M.emplaceBack(ne + we[Ie - 1], ne + we[Ie]);
                                oe.primitiveLength += we.length / 2
                            }
                    } else
                        (function(q, Q, ne, oe, de, we) {
                            const Ie = [];
                            for (let Oe = 0; Oe < oe.length / 2; Oe++)
                                Ie.push(-1);
                            const Ye = {
                                count: 0
                            };
                            let Le = 0
                              , te = q.getOrCreateLatestSegment(Q, ne)
                              , _e = te.vertexLength;
                            for (let Oe = 2; Oe < de.length; Oe += 3) {
                                const ft = de[Oe - 2]
                                  , Rt = de[Oe - 1]
                                  , yt = de[Oe];
                                let bt = Ie[ft] < Le
                                  , Dt = Ie[Rt] < Le
                                  , At = Ie[yt] < Le;
                                te.vertexLength + ((bt ? 1 : 0) + (Dt ? 1 : 0) + (At ? 1 : 0)) > rn.MAX_VERTEX_ARRAY_LENGTH && (te = q.createNewSegment(Q, ne),
                                Le = Ye.count,
                                bt = !0,
                                Dt = !0,
                                At = !0,
                                _e = 0);
                                const Ft = io(Ie, oe, we, Ye, ft, bt, te)
                                  , Tt = io(Ie, oe, we, Ye, Rt, Dt, te)
                                  , ar = io(Ie, oe, we, Ye, yt, At, te);
                                ne.emplaceBack(_e + Ft - Le, _e + Tt - Le, _e + ar - Le),
                                te.primitiveLength++
                            }
                        }
                        )(n, l, p, _, b, c),
                        j && function(q, Q, ne, oe, de, we) {
                            const Ie = [];
                            for (let Oe = 0; Oe < oe.length / 2; Oe++)
                                Ie.push(-1);
                            const Ye = {
                                count: 0
                            };
                            let Le = 0
                              , te = q.getOrCreateLatestSegment(Q, ne)
                              , _e = te.vertexLength;
                            for (let Oe = 0; Oe < de.length; Oe++) {
                                const ft = de[Oe];
                                for (let Rt = 1; Rt < de[Oe].length; Rt += 2) {
                                    const yt = ft[Rt - 1]
                                      , bt = ft[Rt];
                                    let Dt = Ie[yt] < Le
                                      , At = Ie[bt] < Le;
                                    te.vertexLength + ((Dt ? 1 : 0) + (At ? 1 : 0)) > rn.MAX_VERTEX_ARRAY_LENGTH && (te = q.createNewSegment(Q, ne),
                                    Le = Ye.count,
                                    Dt = !0,
                                    At = !0,
                                    _e = 0);
                                    const Ft = io(Ie, oe, we, Ye, yt, Dt, te)
                                      , Tt = io(Ie, oe, we, Ye, bt, At, te);
                                    ne.emplaceBack(_e + Ft - Le, _e + Tt - Le),
                                    te.primitiveLength++
                                }
                            }
                        }(C, l, M, _, R, c),
                        n.forceNewSegmentOnNextPrepare(),
                        C?.forceNewSegmentOnNextPrepare()
                }
                function io(c, n, l, p, _, b, C) {
                    if (b) {
                        const M = p.count;
                        return l(n[2 * _], n[2 * _ + 1]),
                        c[_] = p.count,
                        p.count++,
                        C.vertexLength++,
                        M
                    }
                    return c[_]
                }
                class Od {
                    constructor(n) {
                        this.zoom = n.zoom,
                        this.globalState = n.globalState,
                        this.overscaling = n.overscaling,
                        this.layers = n.layers,
                        this.layerIds = this.layers.map(l => l.id),
                        this.index = n.index,
                        this.hasPattern = !1,
                        this.patternFeatures = [],
                        this.layoutVertexArray = new mt,
                        this.indexArray = new kn,
                        this.indexArray2 = new pn,
                        this.programConfigurations = new ts(n.layers,n.zoom),
                        this.segments = new rn,
                        this.segments2 = new rn,
                        this.stateDependentLayerIds = this.layers.filter(l => l.isStateDependent()).map(l => l.id)
                    }
                    populate(n, l, p) {
                        this.hasPattern = Ih("fill", this.layers, l);
                        const _ = this.layers[0].layout.get("fill-sort-key")
                          , b = !_.isConstant()
                          , C = [];
                        for (const {feature: M, id: R, index: O, sourceLayerIndex: j} of n) {
                            const q = this.layers[0]._featureFilter.needGeometry
                              , Q = Dc(M, q);
                            if (!this.layers[0]._featureFilter.filter(new Mn(this.zoom,{
                                globalState: this.globalState
                            }), Q, p))
                                continue;
                            const ne = b ? _.evaluate(Q, {}, p, l.availableImages) : void 0
                              , oe = {
                                id: R,
                                properties: M.properties,
                                type: M.type,
                                sourceLayerIndex: j,
                                index: O,
                                geometry: q ? Q.geometry : zc(M),
                                patterns: {},
                                sortKey: ne
                            };
                            C.push(oe)
                        }
                        b && C.sort( (M, R) => M.sortKey - R.sortKey);
                        for (const M of C) {
                            const {geometry: R, index: O, sourceLayerIndex: j} = M;
                            if (this.hasPattern) {
                                const q = zd("fill", this.layers, M, this.zoom, l);
                                this.patternFeatures.push(q)
                            } else
                                this.addFeature(M, R, O, p, {}, l.subdivisionGranularity);
                            l.featureIndex.insert(n[O].feature, R, O, j, this.index)
                        }
                    }
                    update(n, l, p) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, l, this.stateDependentLayers, p)
                    }
                    addFeatures(n, l, p) {
                        for (const _ of this.patternFeatures)
                            this.addFeature(_, _.geometry, _.index, l, p, n.subdivisionGranularity)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(n) {
                        this.uploaded || (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, Ad),
                        this.indexBuffer = n.createIndexBuffer(this.indexArray),
                        this.indexBuffer2 = n.createIndexBuffer(this.indexArray2)),
                        this.programConfigurations.upload(n),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.indexBuffer2.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.segments2.destroy())
                    }
                    addFeature(n, l, p, _, b, C) {
                        for (const M of ja(l, 500)) {
                            const R = Bc(M, _, C.fill.getGranularityForZoomLevel(_.z))
                              , O = this.layoutVertexArray;
                            Ah( (j, q) => {
                                O.emplaceBack(j, q)
                            }
                            , this.segments, this.layoutVertexArray, this.indexArray, R.verticesFlattened, R.indicesTriangles, this.segments2, this.indexArray2, R.indicesLineList)
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, p, b, _)
                    }
                }
                let Hu, il;
                Kt("FillBucket", Od, {
                    omit: ["layers", "patternFeatures"]
                });
                var Jf = {
                    get paint() {
                        return il = il || new Vn({
                            "fill-antialias": new ir(Ve.paint_fill["fill-antialias"]),
                            "fill-opacity": new Cr(Ve.paint_fill["fill-opacity"]),
                            "fill-color": new Cr(Ve.paint_fill["fill-color"]),
                            "fill-outline-color": new Cr(Ve.paint_fill["fill-outline-color"]),
                            "fill-translate": new ir(Ve.paint_fill["fill-translate"]),
                            "fill-translate-anchor": new ir(Ve.paint_fill["fill-translate-anchor"]),
                            "fill-pattern": new Mc(Ve.paint_fill["fill-pattern"])
                        })
                    },
                    get layout() {
                        return Hu = Hu || new Vn({
                            "fill-sort-key": new Cr(Ve.layout_fill["fill-sort-key"])
                        })
                    }
                };
                class Cm extends Ci {
                    constructor(n) {
                        super(n, Jf)
                    }
                    recalculate(n, l) {
                        super.recalculate(n, l);
                        const p = this.paint._values["fill-outline-color"];
                        p.value.kind === "constant" && p.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
                    }
                    createBucket(n) {
                        return new Od(n)
                    }
                    queryRadius() {
                        return kh(this.paint.get("fill-translate"))
                    }
                    queryIntersectsFeature({queryGeometry: n, geometry: l, transform: p, pixelsToTileUnits: _}) {
                        return fm(Eh(n, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -p.bearingInRadians, _), l)
                    }
                    isTileClipped() {
                        return !0
                    }
                }
                const jc = Yn([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_normal_ed",
                    components: 4,
                    type: "Int16"
                }], 4)
                  , ep = Yn([{
                    name: "a_centroid",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: Nc} = jc;
                var zh, Dh, Fd, Bd, Lh, jo, Ul, ps = {};
                function is() {
                    if (Dh)
                        return zh;
                    Dh = 1;
                    var c = L();
                    function n(_, b, C, M, R) {
                        this.properties = {},
                        this.extent = C,
                        this.type = 0,
                        this._pbf = _,
                        this._geometry = -1,
                        this._keys = M,
                        this._values = R,
                        _.readFields(l, this, b)
                    }
                    function l(_, b, C) {
                        _ == 1 ? b.id = C.readVarint() : _ == 2 ? function(M, R) {
                            for (var O = M.readVarint() + M.pos; M.pos < O; ) {
                                var j = R._keys[M.readVarint()]
                                  , q = R._values[M.readVarint()];
                                R.properties[j] = q
                            }
                        }(C, b) : _ == 3 ? b.type = C.readVarint() : _ == 4 && (b._geometry = C.pos)
                    }
                    function p(_) {
                        for (var b, C, M = 0, R = 0, O = _.length, j = O - 1; R < O; j = R++)
                            M += ((C = _[j]).x - (b = _[R]).x) * (b.y + C.y);
                        return M
                    }
                    return zh = n,
                    n.types = ["Unknown", "Point", "LineString", "Polygon"],
                    n.prototype.loadGeometry = function() {
                        var _ = this._pbf;
                        _.pos = this._geometry;
                        for (var b, C = _.readVarint() + _.pos, M = 1, R = 0, O = 0, j = 0, q = []; _.pos < C; ) {
                            if (R <= 0) {
                                var Q = _.readVarint();
                                M = 7 & Q,
                                R = Q >> 3
                            }
                            if (R--,
                            M === 1 || M === 2)
                                O += _.readSVarint(),
                                j += _.readSVarint(),
                                M === 1 && (b && q.push(b),
                                b = []),
                                b.push(new c(O,j));
                            else {
                                if (M !== 7)
                                    throw new Error("unknown command " + M);
                                b && b.push(b[0].clone())
                            }
                        }
                        return b && q.push(b),
                        q
                    }
                    ,
                    n.prototype.bbox = function() {
                        var _ = this._pbf;
                        _.pos = this._geometry;
                        for (var b = _.readVarint() + _.pos, C = 1, M = 0, R = 0, O = 0, j = 1 / 0, q = -1 / 0, Q = 1 / 0, ne = -1 / 0; _.pos < b; ) {
                            if (M <= 0) {
                                var oe = _.readVarint();
                                C = 7 & oe,
                                M = oe >> 3
                            }
                            if (M--,
                            C === 1 || C === 2)
                                (R += _.readSVarint()) < j && (j = R),
                                R > q && (q = R),
                                (O += _.readSVarint()) < Q && (Q = O),
                                O > ne && (ne = O);
                            else if (C !== 7)
                                throw new Error("unknown command " + C)
                        }
                        return [j, Q, q, ne]
                    }
                    ,
                    n.prototype.toGeoJSON = function(_, b, C) {
                        var M, R, O = this.extent * Math.pow(2, C), j = this.extent * _, q = this.extent * b, Q = this.loadGeometry(), ne = n.types[this.type];
                        function oe(Ie) {
                            for (var Ye = 0; Ye < Ie.length; Ye++) {
                                var Le = Ie[Ye];
                                Ie[Ye] = [360 * (Le.x + j) / O - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (Le.y + q) / O) * Math.PI / 180)) - 90]
                            }
                        }
                        switch (this.type) {
                        case 1:
                            var de = [];
                            for (M = 0; M < Q.length; M++)
                                de[M] = Q[M][0];
                            oe(Q = de);
                            break;
                        case 2:
                            for (M = 0; M < Q.length; M++)
                                oe(Q[M]);
                            break;
                        case 3:
                            for (Q = function(Ie) {
                                var Ye = Ie.length;
                                if (Ye <= 1)
                                    return [Ie];
                                for (var Le, te, _e = [], Oe = 0; Oe < Ye; Oe++) {
                                    var ft = p(Ie[Oe]);
                                    ft !== 0 && (te === void 0 && (te = ft < 0),
                                    te === ft < 0 ? (Le && _e.push(Le),
                                    Le = [Ie[Oe]]) : Le.push(Ie[Oe]))
                                }
                                return Le && _e.push(Le),
                                _e
                            }(Q),
                            M = 0; M < Q.length; M++)
                                for (R = 0; R < Q[M].length; R++)
                                    oe(Q[M][R])
                        }
                        Q.length === 1 ? Q = Q[0] : ne = "Multi" + ne;
                        var we = {
                            type: "Feature",
                            geometry: {
                                type: ne,
                                coordinates: Q
                            },
                            properties: this.properties
                        };
                        return "id"in this && (we.id = this.id),
                        we
                    }
                    ,
                    zh
                }
                function Tm() {
                    if (Bd)
                        return Fd;
                    Bd = 1;
                    var c = is();
                    function n(p, _) {
                        this.version = 1,
                        this.name = null,
                        this.extent = 4096,
                        this.length = 0,
                        this._pbf = p,
                        this._keys = [],
                        this._values = [],
                        this._features = [],
                        p.readFields(l, this, _),
                        this.length = this._features.length
                    }
                    function l(p, _, b) {
                        p === 15 ? _.version = b.readVarint() : p === 1 ? _.name = b.readString() : p === 5 ? _.extent = b.readVarint() : p === 2 ? _._features.push(b.pos) : p === 3 ? _._keys.push(b.readString()) : p === 4 && _._values.push(function(C) {
                            for (var M = null, R = C.readVarint() + C.pos; C.pos < R; ) {
                                var O = C.readVarint() >> 3;
                                M = O === 1 ? C.readString() : O === 2 ? C.readFloat() : O === 3 ? C.readDouble() : O === 4 ? C.readVarint64() : O === 5 ? C.readVarint() : O === 6 ? C.readSVarint() : O === 7 ? C.readBoolean() : null
                            }
                            return M
                        }(b))
                    }
                    return Fd = n,
                    n.prototype.feature = function(p) {
                        if (p < 0 || p >= this._features.length)
                            throw new Error("feature index out of bounds");
                        this._pbf.pos = this._features[p];
                        var _ = this._pbf.readVarint() + this._pbf.pos;
                        return new c(this._pbf,_,this.extent,this._keys,this._values)
                    }
                    ,
                    Fd
                }
                function tp() {
                    return Ul || (Ul = 1,
                    ps.VectorTile = function() {
                        if (jo)
                            return Lh;
                        jo = 1;
                        var c = Tm();
                        function n(l, p, _) {
                            if (l === 3) {
                                var b = new c(_,_.readVarint() + _.pos);
                                b.length && (p[b.name] = b)
                            }
                        }
                        return Lh = function(l, p) {
                            this.layers = l.readFields(n, {}, p)
                        }
                        ,
                        Lh
                    }(),
                    ps.VectorTileFeature = is(),
                    ps.VectorTileLayer = Tm()),
                    ps
                }
                var Zu = w(tp());
                const Bv = Zu.VectorTileFeature.types
                  , ol = Math.pow(2, 13);
                function Oh(c, n, l, p, _, b, C, M) {
                    c.emplaceBack(n, l, 2 * Math.floor(p * ol) + C, _ * ol * 2, b * ol * 2, Math.round(M))
                }
                class jd {
                    constructor(n) {
                        this.zoom = n.zoom,
                        this.globalState = n.globalState,
                        this.overscaling = n.overscaling,
                        this.layers = n.layers,
                        this.layerIds = this.layers.map(l => l.id),
                        this.index = n.index,
                        this.hasPattern = !1,
                        this.layoutVertexArray = new $t,
                        this.centroidVertexArray = new ot,
                        this.indexArray = new kn,
                        this.programConfigurations = new ts(n.layers,n.zoom),
                        this.segments = new rn,
                        this.stateDependentLayerIds = this.layers.filter(l => l.isStateDependent()).map(l => l.id)
                    }
                    populate(n, l, p) {
                        this.features = [],
                        this.hasPattern = Ih("fill-extrusion", this.layers, l);
                        for (const {feature: _, id: b, index: C, sourceLayerIndex: M} of n) {
                            const R = this.layers[0]._featureFilter.needGeometry
                              , O = Dc(_, R);
                            if (!this.layers[0]._featureFilter.filter(new Mn(this.zoom,{
                                globalState: this.globalState
                            }), O, p))
                                continue;
                            const j = {
                                id: b,
                                sourceLayerIndex: M,
                                index: C,
                                geometry: R ? O.geometry : zc(_),
                                properties: _.properties,
                                type: _.type,
                                patterns: {}
                            };
                            this.hasPattern ? this.features.push(zd("fill-extrusion", this.layers, j, this.zoom, l)) : this.addFeature(j, j.geometry, C, p, {}, l.subdivisionGranularity),
                            l.featureIndex.insert(_, j.geometry, C, M, this.index, !0)
                        }
                    }
                    addFeatures(n, l, p) {
                        for (const _ of this.features) {
                            const {geometry: b} = _;
                            this.addFeature(_, b, _.index, l, p, n.subdivisionGranularity)
                        }
                    }
                    update(n, l, p) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, l, this.stateDependentLayers, p)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(n) {
                        this.uploaded || (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, Nc),
                        this.centroidVertexBuffer = n.createVertexBuffer(this.centroidVertexArray, ep.members, !0),
                        this.indexBuffer = n.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(n),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.centroidVertexBuffer.destroy())
                    }
                    addFeature(n, l, p, _, b, C) {
                        for (const M of ja(l, 500)) {
                            const R = {
                                x: 0,
                                y: 0,
                                sampleCount: 0
                            }
                              , O = this.layoutVertexArray.length;
                            this.processPolygon(R, _, n, M, C);
                            const j = this.layoutVertexArray.length - O
                              , q = Math.floor(R.x / R.sampleCount)
                              , Q = Math.floor(R.y / R.sampleCount);
                            for (let ne = 0; ne < j; ne++)
                                this.centroidVertexArray.emplaceBack(q, Q)
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, p, b, _)
                    }
                    processPolygon(n, l, p, _, b) {
                        if (_.length < 1 || $c(_[0]))
                            return;
                        for (const q of _)
                            q.length !== 0 && Xu(n, q);
                        const C = {
                            segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
                        }
                          , M = b.fill.getGranularityForZoomLevel(l.z)
                          , R = Bv[p.type] === "Polygon";
                        for (const q of _) {
                            if (q.length === 0 || $c(q))
                                continue;
                            const Q = nl(q, M, R);
                            this._generateSideFaces(Q, C)
                        }
                        if (!R)
                            return;
                        const O = Bc(_, l, M, !1)
                          , j = this.layoutVertexArray;
                        Ah( (q, Q) => {
                            Oh(j, q, Q, 0, 0, 1, 1, 0)
                        }
                        , this.segments, this.layoutVertexArray, this.indexArray, O.verticesFlattened, O.indicesTriangles)
                    }
                    _generateSideFaces(n, l) {
                        let p = 0;
                        for (let _ = 1; _ < n.length; _++) {
                            const b = n[_]
                              , C = n[_ - 1];
                            if (Pm(b, C))
                                continue;
                            l.segment.vertexLength + 4 > rn.MAX_VERTEX_ARRAY_LENGTH && (l.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                            const M = b.sub(C)._perp()._unit()
                              , R = C.dist(b);
                            p + R > 32768 && (p = 0),
                            Oh(this.layoutVertexArray, b.x, b.y, M.x, M.y, 0, 0, p),
                            Oh(this.layoutVertexArray, b.x, b.y, M.x, M.y, 0, 1, p),
                            p += R,
                            Oh(this.layoutVertexArray, C.x, C.y, M.x, M.y, 0, 0, p),
                            Oh(this.layoutVertexArray, C.x, C.y, M.x, M.y, 0, 1, p);
                            const O = l.segment.vertexLength;
                            this.indexArray.emplaceBack(O, O + 2, O + 1),
                            this.indexArray.emplaceBack(O + 1, O + 2, O + 3),
                            l.segment.vertexLength += 4,
                            l.segment.primitiveLength += 2
                        }
                    }
                }
                function Xu(c, n) {
                    for (let l = 0; l < n.length; l++) {
                        const p = n[l];
                        l === n.length - 1 && n[0].x === p.x && n[0].y === p.y || (c.x += p.x,
                        c.y += p.y,
                        c.sampleCount++)
                    }
                }
                function Pm(c, n) {
                    return c.x === n.x && (c.x < 0 || c.x > st) || c.y === n.y && (c.y < 0 || c.y > st)
                }
                function $c(c) {
                    return c.every(n => n.x < 0) || c.every(n => n.x > st) || c.every(n => n.y < 0) || c.every(n => n.y > st)
                }
                let Mm;
                Kt("FillExtrusionBucket", jd, {
                    omit: ["layers", "features"]
                });
                var Ey = {
                    get paint() {
                        return Mm = Mm || new Vn({
                            "fill-extrusion-opacity": new ir(Ve["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                            "fill-extrusion-color": new Cr(Ve["paint_fill-extrusion"]["fill-extrusion-color"]),
                            "fill-extrusion-translate": new ir(Ve["paint_fill-extrusion"]["fill-extrusion-translate"]),
                            "fill-extrusion-translate-anchor": new ir(Ve["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                            "fill-extrusion-pattern": new Mc(Ve["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                            "fill-extrusion-height": new Cr(Ve["paint_fill-extrusion"]["fill-extrusion-height"]),
                            "fill-extrusion-base": new Cr(Ve["paint_fill-extrusion"]["fill-extrusion-base"]),
                            "fill-extrusion-vertical-gradient": new ir(Ve["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
                        })
                    }
                };
                class km extends Ci {
                    constructor(n) {
                        super(n, Ey)
                    }
                    createBucket(n) {
                        return new jd(n)
                    }
                    queryRadius() {
                        return kh(this.paint.get("fill-extrusion-translate"))
                    }
                    is3D() {
                        return !0
                    }
                    queryIntersectsFeature({queryGeometry: n, feature: l, featureState: p, geometry: _, transform: b, pixelsToTileUnits: C, pixelPosMatrix: M}) {
                        const R = Eh(n, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -b.bearingInRadians, C)
                          , O = this.paint.get("fill-extrusion-height").evaluate(l, p)
                          , j = this.paint.get("fill-extrusion-base").evaluate(l, p)
                          , q = function(ne, oe) {
                            const de = [];
                            for (const we of ne) {
                                const Ie = [we.x, we.y, 0, 1];
                                Ne(Ie, Ie, oe),
                                de.push(new N(Ie[0] / Ie[3],Ie[1] / Ie[3]))
                            }
                            return de
                        }(R, M)
                          , Q = function(ne, oe, de, we) {
                            const Ie = []
                              , Ye = []
                              , Le = we[8] * oe
                              , te = we[9] * oe
                              , _e = we[10] * oe
                              , Oe = we[11] * oe
                              , ft = we[8] * de
                              , Rt = we[9] * de
                              , yt = we[10] * de
                              , bt = we[11] * de;
                            for (const Dt of ne) {
                                const At = []
                                  , Ft = [];
                                for (const Tt of Dt) {
                                    const ar = Tt.x
                                      , Mr = Tt.y
                                      , Tr = we[0] * ar + we[4] * Mr + we[12]
                                      , pr = we[1] * ar + we[5] * Mr + we[13]
                                      , on = we[2] * ar + we[6] * Mr + we[14]
                                      , pi = we[3] * ar + we[7] * Mr + we[15]
                                      , Hi = on + _e
                                      , $o = pi + Oe
                                      , Ca = Tr + ft
                                      , Ds = pr + Rt
                                      , To = on + yt
                                      , ai = pi + bt
                                      , oo = new N((Tr + Le) / $o,(pr + te) / $o);
                                    oo.z = Hi / $o,
                                    At.push(oo);
                                    const Po = new N(Ca / ai,Ds / ai);
                                    Po.z = To / ai,
                                    Ft.push(Po)
                                }
                                Ie.push(At),
                                Ye.push(Ft)
                            }
                            return [Ie, Ye]
                        }(_, j, O, M);
                        return function(ne, oe, de) {
                            let we = 1 / 0;
                            fm(de, oe) && (we = Iy(de, oe[0]));
                            for (let Ie = 0; Ie < oe.length; Ie++) {
                                const Ye = oe[Ie]
                                  , Le = ne[Ie];
                                for (let te = 0; te < Ye.length - 1; te++) {
                                    const _e = Ye[te]
                                      , Oe = [_e, Ye[te + 1], Le[te + 1], Le[te], _e];
                                    rs(de, Oe) && (we = Math.min(we, Iy(de, Oe)))
                                }
                            }
                            return we !== 1 / 0 && we
                        }(Q[0], Q[1], q)
                    }
                }
                function Vc(c, n) {
                    return c.x * n.x + c.y * n.y
                }
                function Iy(c, n) {
                    if (c.length === 1) {
                        let l = 0;
                        const p = n[l++];
                        let _;
                        for (; !_ || p.equals(_); )
                            if (_ = n[l++],
                            !_)
                                return 1 / 0;
                        for (; l < n.length; l++) {
                            const b = n[l]
                              , C = c[0]
                              , M = _.sub(p)
                              , R = b.sub(p)
                              , O = C.sub(p)
                              , j = Vc(M, M)
                              , q = Vc(M, R)
                              , Q = Vc(R, R)
                              , ne = Vc(O, M)
                              , oe = Vc(O, R)
                              , de = j * Q - q * q
                              , we = (Q * ne - q * oe) / de
                              , Ie = (j * oe - q * ne) / de
                              , Ye = p.z * (1 - we - Ie) + _.z * we + b.z * Ie;
                            if (isFinite(Ye))
                                return Ye
                        }
                        return 1 / 0
                    }
                    {
                        let l = 1 / 0;
                        for (const p of n)
                            l = Math.min(l, p.z);
                        return l
                    }
                }
                const jv = Yn([{
                    name: "a_pos_normal",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_data",
                    components: 4,
                    type: "Uint8"
                }], 4)
                  , {members: Ry} = jv
                  , Ay = Yn([{
                    name: "a_uv_x",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_split_index",
                    components: 1,
                    type: "Float32"
                }])
                  , {members: Yu} = Ay
                  , Nv = Zu.VectorTileFeature.types
                  , Fh = Math.cos(Math.PI / 180 * 37.5)
                  , Em = Math.pow(2, 14) / .5;
                class si {
                    constructor(n) {
                        this.zoom = n.zoom,
                        this.globalState = n.globalState,
                        this.overscaling = n.overscaling,
                        this.layers = n.layers,
                        this.layerIds = this.layers.map(l => l.id),
                        this.index = n.index,
                        this.hasPattern = !1,
                        this.patternFeatures = [],
                        this.lineClipsArray = [],
                        this.gradients = {},
                        this.layers.forEach(l => {
                            this.gradients[l.id] = {}
                        }
                        ),
                        this.layoutVertexArray = new jt,
                        this.layoutVertexArray2 = new It,
                        this.indexArray = new kn,
                        this.programConfigurations = new ts(n.layers,n.zoom),
                        this.segments = new rn,
                        this.maxLineLength = 0,
                        this.stateDependentLayerIds = this.layers.filter(l => l.isStateDependent()).map(l => l.id)
                    }
                    populate(n, l, p) {
                        this.hasPattern = Ih("line", this.layers, l);
                        const _ = this.layers[0].layout.get("line-sort-key")
                          , b = !_.isConstant()
                          , C = [];
                        for (const {feature: M, id: R, index: O, sourceLayerIndex: j} of n) {
                            const q = this.layers[0]._featureFilter.needGeometry
                              , Q = Dc(M, q);
                            if (!this.layers[0]._featureFilter.filter(new Mn(this.zoom,{
                                globalState: this.globalState
                            }), Q, p))
                                continue;
                            const ne = b ? _.evaluate(Q, {}, p) : void 0
                              , oe = {
                                id: R,
                                properties: M.properties,
                                type: M.type,
                                sourceLayerIndex: j,
                                index: O,
                                geometry: q ? Q.geometry : zc(M),
                                patterns: {},
                                sortKey: ne
                            };
                            C.push(oe)
                        }
                        b && C.sort( (M, R) => M.sortKey - R.sortKey);
                        for (const M of C) {
                            const {geometry: R, index: O, sourceLayerIndex: j} = M;
                            if (this.hasPattern) {
                                const q = zd("line", this.layers, M, this.zoom, l);
                                this.patternFeatures.push(q)
                            } else
                                this.addFeature(M, R, O, p, {}, l.subdivisionGranularity);
                            l.featureIndex.insert(n[O].feature, R, O, j, this.index)
                        }
                    }
                    update(n, l, p) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, l, this.stateDependentLayers, p)
                    }
                    addFeatures(n, l, p) {
                        for (const _ of this.patternFeatures)
                            this.addFeature(_, _.geometry, _.index, l, p, n.subdivisionGranularity)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(n) {
                        this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = n.createVertexBuffer(this.layoutVertexArray2, Yu)),
                        this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, Ry),
                        this.indexBuffer = n.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(n),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy())
                    }
                    lineFeatureClips(n) {
                        if (n.properties && Object.prototype.hasOwnProperty.call(n.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(n.properties, "mapbox_clip_end"))
                            return {
                                start: +n.properties.mapbox_clip_start,
                                end: +n.properties.mapbox_clip_end
                            }
                    }
                    addFeature(n, l, p, _, b, C) {
                        const M = this.layers[0].layout
                          , R = M.get("line-join").evaluate(n, {})
                          , O = M.get("line-cap")
                          , j = M.get("line-miter-limit")
                          , q = M.get("line-round-limit");
                        this.lineClips = this.lineFeatureClips(n);
                        for (const Q of l)
                            this.addLine(Q, n, R, O, j, q, _, C);
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, p, b, _)
                    }
                    addLine(n, l, p, _, b, C, M, R) {
                        if (this.distance = 0,
                        this.scaledDistance = 0,
                        this.totalDistance = 0,
                        n = nl(n, M ? R.line.getGranularityForZoomLevel(M.z) : 1),
                        this.lineClips) {
                            this.lineClipsArray.push(this.lineClips);
                            for (let Le = 0; Le < n.length - 1; Le++)
                                this.totalDistance += n[Le].dist(n[Le + 1]);
                            this.updateScaledDistance(),
                            this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
                        }
                        const O = Nv[l.type] === "Polygon";
                        let j = n.length;
                        for (; j >= 2 && n[j - 1].equals(n[j - 2]); )
                            j--;
                        let q = 0;
                        for (; q < j - 1 && n[q].equals(n[q + 1]); )
                            q++;
                        if (j < (O ? 3 : 2))
                            return;
                        p === "bevel" && (b = 1.05);
                        const Q = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0
                          , ne = this.segments.prepareSegment(10 * j, this.layoutVertexArray, this.indexArray);
                        let oe, de, we, Ie, Ye;
                        this.e1 = this.e2 = -1,
                        O && (oe = n[j - 2],
                        Ye = n[q].sub(oe)._unit()._perp());
                        for (let Le = q; Le < j; Le++) {
                            if (we = Le === j - 1 ? O ? n[q + 1] : void 0 : n[Le + 1],
                            we && n[Le].equals(we))
                                continue;
                            Ye && (Ie = Ye),
                            oe && (de = oe),
                            oe = n[Le],
                            Ye = we ? we.sub(oe)._unit()._perp() : Ie,
                            Ie = Ie || Ye;
                            let te = Ie.add(Ye);
                            te.x === 0 && te.y === 0 || te._unit();
                            const _e = Ie.x * Ye.x + Ie.y * Ye.y
                              , Oe = te.x * Ye.x + te.y * Ye.y
                              , ft = Oe !== 0 ? 1 / Oe : 1 / 0
                              , Rt = 2 * Math.sqrt(2 - 2 * Oe)
                              , yt = Oe < Fh && de && we
                              , bt = Ie.x * Ye.y - Ie.y * Ye.x > 0;
                            if (yt && Le > q) {
                                const Ft = oe.dist(de);
                                if (Ft > 2 * Q) {
                                    const Tt = oe.sub(oe.sub(de)._mult(Q / Ft)._round());
                                    this.updateDistance(de, Tt),
                                    this.addCurrentVertex(Tt, Ie, 0, 0, ne),
                                    de = Tt
                                }
                            }
                            const Dt = de && we;
                            let At = Dt ? p : O ? "butt" : _;
                            if (Dt && At === "round" && (ft < C ? At = "miter" : ft <= 2 && (At = "fakeround")),
                            At === "miter" && ft > b && (At = "bevel"),
                            At === "bevel" && (ft > 2 && (At = "flipbevel"),
                            ft < b && (At = "miter")),
                            de && this.updateDistance(de, oe),
                            At === "miter")
                                te._mult(ft),
                                this.addCurrentVertex(oe, te, 0, 0, ne);
                            else if (At === "flipbevel") {
                                if (ft > 100)
                                    te = Ye.mult(-1);
                                else {
                                    const Ft = ft * Ie.add(Ye).mag() / Ie.sub(Ye).mag();
                                    te._perp()._mult(Ft * (bt ? -1 : 1))
                                }
                                this.addCurrentVertex(oe, te, 0, 0, ne),
                                this.addCurrentVertex(oe, te.mult(-1), 0, 0, ne)
                            } else if (At === "bevel" || At === "fakeround") {
                                const Ft = -Math.sqrt(ft * ft - 1)
                                  , Tt = bt ? Ft : 0
                                  , ar = bt ? 0 : Ft;
                                if (de && this.addCurrentVertex(oe, Ie, Tt, ar, ne),
                                At === "fakeround") {
                                    const Mr = Math.round(180 * Rt / Math.PI / 20);
                                    for (let Tr = 1; Tr < Mr; Tr++) {
                                        let pr = Tr / Mr;
                                        if (pr !== .5) {
                                            const pi = pr - .5;
                                            pr += pr * pi * (pr - 1) * ((1.0904 + _e * (_e * (3.55645 - 1.43519 * _e) - 3.2452)) * pi * pi + (.848013 + _e * (.215638 * _e - 1.06021)))
                                        }
                                        const on = Ye.sub(Ie)._mult(pr)._add(Ie)._unit()._mult(bt ? -1 : 1);
                                        this.addHalfVertex(oe, on.x, on.y, !1, bt, 0, ne)
                                    }
                                }
                                we && this.addCurrentVertex(oe, Ye, -Tt, -ar, ne)
                            } else if (At === "butt")
                                this.addCurrentVertex(oe, te, 0, 0, ne);
                            else if (At === "square") {
                                const Ft = de ? 1 : -1;
                                this.addCurrentVertex(oe, te, Ft, Ft, ne)
                            } else
                                At === "round" && (de && (this.addCurrentVertex(oe, Ie, 0, 0, ne),
                                this.addCurrentVertex(oe, Ie, 1, 1, ne, !0)),
                                we && (this.addCurrentVertex(oe, Ye, -1, -1, ne, !0),
                                this.addCurrentVertex(oe, Ye, 0, 0, ne)));
                            if (yt && Le < j - 1) {
                                const Ft = oe.dist(we);
                                if (Ft > 2 * Q) {
                                    const Tt = oe.add(we.sub(oe)._mult(Q / Ft)._round());
                                    this.updateDistance(oe, Tt),
                                    this.addCurrentVertex(Tt, Ye, 0, 0, ne),
                                    oe = Tt
                                }
                            }
                        }
                    }
                    addCurrentVertex(n, l, p, _, b, C=!1) {
                        const M = l.y * _ - l.x
                          , R = -l.y - l.x * _;
                        this.addHalfVertex(n, l.x + l.y * p, l.y - l.x * p, C, !1, p, b),
                        this.addHalfVertex(n, M, R, C, !0, -_, b),
                        this.distance > Em / 2 && this.totalDistance === 0 && (this.distance = 0,
                        this.updateScaledDistance(),
                        this.addCurrentVertex(n, l, p, _, b, C))
                    }
                    addHalfVertex({x: n, y: l}, p, _, b, C, M, R) {
                        const O = .5 * (this.lineClips ? this.scaledDistance * (Em - 1) : this.scaledDistance);
                        this.layoutVertexArray.emplaceBack((n << 1) + (b ? 1 : 0), (l << 1) + (C ? 1 : 0), Math.round(63 * p) + 128, Math.round(63 * _) + 128, 1 + (M === 0 ? 0 : M < 0 ? -1 : 1) | (63 & O) << 2, O >> 6),
                        this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
                        const j = R.vertexLength++;
                        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, j, this.e2),
                        R.primitiveLength++),
                        C ? this.e2 = j : this.e1 = j
                    }
                    updateScaledDistance() {
                        this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
                    }
                    updateDistance(n, l) {
                        this.distance += n.dist(l),
                        this.updateScaledDistance()
                    }
                }
                let zy, Im;
                Kt("LineBucket", si, {
                    omit: ["layers", "patternFeatures"]
                });
                var Dy = {
                    get paint() {
                        return Im = Im || new Vn({
                            "line-opacity": new Cr(Ve.paint_line["line-opacity"]),
                            "line-color": new Cr(Ve.paint_line["line-color"]),
                            "line-translate": new ir(Ve.paint_line["line-translate"]),
                            "line-translate-anchor": new ir(Ve.paint_line["line-translate-anchor"]),
                            "line-width": new Cr(Ve.paint_line["line-width"]),
                            "line-gap-width": new Cr(Ve.paint_line["line-gap-width"]),
                            "line-offset": new Cr(Ve.paint_line["line-offset"]),
                            "line-blur": new Cr(Ve.paint_line["line-blur"]),
                            "line-dasharray": new Lu(Ve.paint_line["line-dasharray"]),
                            "line-pattern": new Mc(Ve.paint_line["line-pattern"]),
                            "line-gradient": new Zs(Ve.paint_line["line-gradient"])
                        })
                    },
                    get layout() {
                        return zy = zy || new Vn({
                            "line-cap": new ir(Ve.layout_line["line-cap"]),
                            "line-join": new Cr(Ve.layout_line["line-join"]),
                            "line-miter-limit": new ir(Ve.layout_line["line-miter-limit"]),
                            "line-round-limit": new ir(Ve.layout_line["line-round-limit"]),
                            "line-sort-key": new Cr(Ve.layout_line["line-sort-key"])
                        })
                    }
                };
                class $v extends Cr {
                    possiblyEvaluate(n, l) {
                        return l = new Mn(Math.floor(l.zoom),{
                            now: l.now,
                            fadeDuration: l.fadeDuration,
                            zoomHistory: l.zoomHistory,
                            transition: l.transition
                        }),
                        super.possiblyEvaluate(n, l)
                    }
                    evaluate(n, l, p, _) {
                        return l = xr({}, l, {
                            zoom: Math.floor(l.zoom)
                        }),
                        super.evaluate(n, l, p, _)
                    }
                }
                let Nd;
                class Ly extends Ci {
                    constructor(n) {
                        super(n, Dy),
                        this.gradientVersion = 0,
                        Nd || (Nd = new $v(Dy.paint.properties["line-width"].specification),
                        Nd.useIntegerZoom = !0)
                    }
                    _handleSpecialPaintPropertyUpdate(n) {
                        if (n === "line-gradient") {
                            const l = this.gradientExpression();
                            this.stepInterpolant = !!function(p) {
                                return p._styleExpression !== void 0
                            }(l) && l._styleExpression.expression instanceof lc,
                            this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
                        }
                    }
                    gradientExpression() {
                        return this._transitionablePaint._values["line-gradient"].value.expression
                    }
                    recalculate(n, l) {
                        super.recalculate(n, l),
                        this.paint._values["line-floorwidth"] = Nd.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, n)
                    }
                    createBucket(n) {
                        return new si(n)
                    }
                    queryRadius(n) {
                        const l = n
                          , p = Oy(Mh("line-width", this, l), Mh("line-gap-width", this, l))
                          , _ = Mh("line-offset", this, l);
                        return p / 2 + Math.abs(_) + kh(this.paint.get("line-translate"))
                    }
                    queryIntersectsFeature({queryGeometry: n, feature: l, featureState: p, geometry: _, transform: b, pixelsToTileUnits: C}) {
                        const M = Eh(n, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -b.bearingInRadians, C)
                          , R = C / 2 * Oy(this.paint.get("line-width").evaluate(l, p), this.paint.get("line-gap-width").evaluate(l, p))
                          , O = this.paint.get("line-offset").evaluate(l, p);
                        return O && (_ = function(j, q) {
                            const Q = [];
                            for (let ne = 0; ne < j.length; ne++) {
                                const oe = j[ne]
                                  , de = [];
                                for (let we = 0; we < oe.length; we++) {
                                    const Ie = oe[we - 1]
                                      , Ye = oe[we]
                                      , Le = oe[we + 1]
                                      , te = we === 0 ? new N(0,0) : Ye.sub(Ie)._unit()._perp()
                                      , _e = we === oe.length - 1 ? new N(0,0) : Le.sub(Ye)._unit()._perp()
                                      , Oe = te._add(_e)._unit()
                                      , ft = Oe.x * _e.x + Oe.y * _e.y;
                                    ft !== 0 && Oe._mult(1 / ft),
                                    de.push(Oe._mult(q)._add(Ye))
                                }
                                Q.push(de)
                            }
                            return Q
                        }(_, O * C)),
                        function(j, q, Q) {
                            for (let ne = 0; ne < q.length; ne++) {
                                const oe = q[ne];
                                if (j.length >= 3) {
                                    for (let de = 0; de < oe.length; de++)
                                        if (Lc(j, oe[de]))
                                            return !0
                                }
                                if (vy(j, oe, Q))
                                    return !0
                            }
                            return !1
                        }(M, _, R)
                    }
                    isTileClipped() {
                        return !0
                    }
                }
                function Oy(c, n) {
                    return n > 0 ? n + 2 * c : c
                }
                const Js = Yn([{
                    name: "a_pos_offset",
                    components: 4,
                    type: "Int16"
                }, {
                    name: "a_data",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pixeloffset",
                    components: 4,
                    type: "Int16"
                }], 4)
                  , Rm = Yn([{
                    name: "a_projected_pos",
                    components: 3,
                    type: "Float32"
                }], 4);
                Yn([{
                    name: "a_fade_opacity",
                    components: 1,
                    type: "Uint32"
                }], 4);
                const Vv = Yn([{
                    name: "a_placed",
                    components: 2,
                    type: "Uint8"
                }, {
                    name: "a_shift",
                    components: 2,
                    type: "Float32"
                }, {
                    name: "a_box_real",
                    components: 2,
                    type: "Int16"
                }]);
                Yn([{
                    type: "Int16",
                    name: "anchorPointX"
                }, {
                    type: "Int16",
                    name: "anchorPointY"
                }, {
                    type: "Int16",
                    name: "x1"
                }, {
                    type: "Int16",
                    name: "y1"
                }, {
                    type: "Int16",
                    name: "x2"
                }, {
                    type: "Int16",
                    name: "y2"
                }, {
                    type: "Uint32",
                    name: "featureIndex"
                }, {
                    type: "Uint16",
                    name: "sourceLayerIndex"
                }, {
                    type: "Uint16",
                    name: "bucketIndex"
                }]);
                const Gl = Yn([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_anchor_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_extrude",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , rp = Yn([{
                    name: "a_pos",
                    components: 2,
                    type: "Float32"
                }, {
                    name: "a_radius",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_flags",
                    components: 2,
                    type: "Int16"
                }], 4);
                function Ku(c, n, l) {
                    return c.sections.forEach(p => {
                        p.text = function(_, b, C) {
                            const M = b.layout.get("text-transform").evaluate(C, {});
                            return M === "uppercase" ? _ = _.toLocaleUpperCase() : M === "lowercase" && (_ = _.toLocaleLowerCase()),
                            Qa.applyArabicShaping && (_ = Qa.applyArabicShaping(_)),
                            _
                        }(p.text, n, l)
                    }
                    ),
                    c
                }
                Yn([{
                    name: "triangle",
                    components: 3,
                    type: "Uint16"
                }]),
                Yn([{
                    type: "Int16",
                    name: "anchorX"
                }, {
                    type: "Int16",
                    name: "anchorY"
                }, {
                    type: "Uint16",
                    name: "glyphStartIndex"
                }, {
                    type: "Uint16",
                    name: "numGlyphs"
                }, {
                    type: "Uint32",
                    name: "vertexStartIndex"
                }, {
                    type: "Uint32",
                    name: "lineStartIndex"
                }, {
                    type: "Uint32",
                    name: "lineLength"
                }, {
                    type: "Uint16",
                    name: "segment"
                }, {
                    type: "Uint16",
                    name: "lowerSize"
                }, {
                    type: "Uint16",
                    name: "upperSize"
                }, {
                    type: "Float32",
                    name: "lineOffsetX"
                }, {
                    type: "Float32",
                    name: "lineOffsetY"
                }, {
                    type: "Uint8",
                    name: "writingMode"
                }, {
                    type: "Uint8",
                    name: "placedOrientation"
                }, {
                    type: "Uint8",
                    name: "hidden"
                }, {
                    type: "Uint32",
                    name: "crossTileID"
                }, {
                    type: "Int16",
                    name: "associatedIconIndex"
                }]),
                Yn([{
                    type: "Int16",
                    name: "anchorX"
                }, {
                    type: "Int16",
                    name: "anchorY"
                }, {
                    type: "Int16",
                    name: "rightJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "centerJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "leftJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "verticalPlacedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "placedIconSymbolIndex"
                }, {
                    type: "Int16",
                    name: "verticalPlacedIconSymbolIndex"
                }, {
                    type: "Uint16",
                    name: "key"
                }, {
                    type: "Uint16",
                    name: "textBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "textBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "verticalTextBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "verticalTextBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "iconBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "iconBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "verticalIconBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "verticalIconBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "featureIndex"
                }, {
                    type: "Uint16",
                    name: "numHorizontalGlyphVertices"
                }, {
                    type: "Uint16",
                    name: "numVerticalGlyphVertices"
                }, {
                    type: "Uint16",
                    name: "numIconVertices"
                }, {
                    type: "Uint16",
                    name: "numVerticalIconVertices"
                }, {
                    type: "Uint16",
                    name: "useRuntimeCollisionCircles"
                }, {
                    type: "Uint32",
                    name: "crossTileID"
                }, {
                    type: "Float32",
                    name: "textBoxScale"
                }, {
                    type: "Float32",
                    name: "collisionCircleDiameter"
                }, {
                    type: "Uint16",
                    name: "textAnchorOffsetStartIndex"
                }, {
                    type: "Uint16",
                    name: "textAnchorOffsetEndIndex"
                }]),
                Yn([{
                    type: "Float32",
                    name: "offsetX"
                }]),
                Yn([{
                    type: "Int16",
                    name: "x"
                }, {
                    type: "Int16",
                    name: "y"
                }, {
                    type: "Int16",
                    name: "tileUnitDistanceFromAnchor"
                }]),
                Yn([{
                    type: "Uint16",
                    name: "textAnchor"
                }, {
                    type: "Float32",
                    components: 2,
                    name: "textOffset"
                }]);
                const Uc = {
                    "!": "︕",
                    "#": "＃",
                    $: "＄",
                    "%": "％",
                    "&": "＆",
                    "(": "︵",
                    ")": "︶",
                    "*": "＊",
                    "+": "＋",
                    ",": "︐",
                    "-": "︲",
                    ".": "・",
                    "/": "／",
                    ":": "︓",
                    ";": "︔",
                    "<": "︿",
                    "=": "＝",
                    ">": "﹀",
                    "?": "︖",
                    "@": "＠",
                    "[": "﹇",
                    "\\": "＼",
                    "]": "﹈",
                    "^": "＾",
                    _: "︳",
                    "`": "｀",
                    "{": "︷",
                    "|": "―",
                    "}": "︸",
                    "~": "～",
                    "¢": "￠",
                    "£": "￡",
                    "¥": "￥",
                    "¦": "￤",
                    "¬": "￢",
                    "¯": "￣",
                    "–": "︲",
                    "—": "︱",
                    "‘": "﹃",
                    "’": "﹄",
                    "“": "﹁",
                    "”": "﹂",
                    "…": "︙",
                    "‧": "・",
                    "₩": "￦",
                    "、": "︑",
                    "。": "︒",
                    "〈": "︿",
                    "〉": "﹀",
                    "《": "︽",
                    "》": "︾",
                    "「": "﹁",
                    "」": "﹂",
                    "『": "﹃",
                    "』": "﹄",
                    "【": "︻",
                    "】": "︼",
                    "〔": "︹",
                    "〕": "︺",
                    "〖": "︗",
                    "〗": "︘",
                    "！": "︕",
                    "（": "︵",
                    "）": "︶",
                    "，": "︐",
                    "－": "︲",
                    "．": "・",
                    "：": "︓",
                    "；": "︔",
                    "＜": "︿",
                    "＞": "﹀",
                    "？": "︖",
                    "［": "﹇",
                    "］": "﹈",
                    "＿": "︳",
                    "｛": "︷",
                    "｜": "―",
                    "｝": "︸",
                    "｟": "︵",
                    "｠": "︶",
                    "｡": "︒",
                    "｢": "﹁",
                    "｣": "﹂"
                };
                var np, $d, Fy, bi = 24, Am = {};
                function By() {
                    return np || (np = 1,
                    Am.read = function(c, n, l, p, _) {
                        var b, C, M = 8 * _ - p - 1, R = (1 << M) - 1, O = R >> 1, j = -7, q = l ? _ - 1 : 0, Q = l ? -1 : 1, ne = c[n + q];
                        for (q += Q,
                        b = ne & (1 << -j) - 1,
                        ne >>= -j,
                        j += M; j > 0; b = 256 * b + c[n + q],
                        q += Q,
                        j -= 8)
                            ;
                        for (C = b & (1 << -j) - 1,
                        b >>= -j,
                        j += p; j > 0; C = 256 * C + c[n + q],
                        q += Q,
                        j -= 8)
                            ;
                        if (b === 0)
                            b = 1 - O;
                        else {
                            if (b === R)
                                return C ? NaN : 1 / 0 * (ne ? -1 : 1);
                            C += Math.pow(2, p),
                            b -= O
                        }
                        return (ne ? -1 : 1) * C * Math.pow(2, b - p)
                    }
                    ,
                    Am.write = function(c, n, l, p, _, b) {
                        var C, M, R, O = 8 * b - _ - 1, j = (1 << O) - 1, q = j >> 1, Q = _ === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ne = p ? 0 : b - 1, oe = p ? 1 : -1, de = n < 0 || n === 0 && 1 / n < 0 ? 1 : 0;
                        for (n = Math.abs(n),
                        isNaN(n) || n === 1 / 0 ? (M = isNaN(n) ? 1 : 0,
                        C = j) : (C = Math.floor(Math.log(n) / Math.LN2),
                        n * (R = Math.pow(2, -C)) < 1 && (C--,
                        R *= 2),
                        (n += C + q >= 1 ? Q / R : Q * Math.pow(2, 1 - q)) * R >= 2 && (C++,
                        R /= 2),
                        C + q >= j ? (M = 0,
                        C = j) : C + q >= 1 ? (M = (n * R - 1) * Math.pow(2, _),
                        C += q) : (M = n * Math.pow(2, q - 1) * Math.pow(2, _),
                        C = 0)); _ >= 8; c[l + ne] = 255 & M,
                        ne += oe,
                        M /= 256,
                        _ -= 8)
                            ;
                        for (C = C << _ | M,
                        O += _; O > 0; c[l + ne] = 255 & C,
                        ne += oe,
                        C /= 256,
                        O -= 8)
                            ;
                        c[l + ne - oe] |= 128 * de
                    }
                    ),
                    Am
                }
                function zm() {
                    if (Fy)
                        return $d;
                    Fy = 1,
                    $d = n;
                    var c = By();
                    function n(te) {
                        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(te) ? te : new Uint8Array(te || 0),
                        this.pos = 0,
                        this.type = 0,
                        this.length = this.buf.length
                    }
                    n.Varint = 0,
                    n.Fixed64 = 1,
                    n.Bytes = 2,
                    n.Fixed32 = 5;
                    var l = 4294967296
                      , p = 1 / l
                      , _ = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
                    function b(te) {
                        return te.type === n.Bytes ? te.readVarint() + te.pos : te.pos + 1
                    }
                    function C(te, _e, Oe) {
                        return Oe ? 4294967296 * _e + (te >>> 0) : 4294967296 * (_e >>> 0) + (te >>> 0)
                    }
                    function M(te, _e, Oe) {
                        var ft = _e <= 16383 ? 1 : _e <= 2097151 ? 2 : _e <= 268435455 ? 3 : Math.floor(Math.log(_e) / (7 * Math.LN2));
                        Oe.realloc(ft);
                        for (var Rt = Oe.pos - 1; Rt >= te; Rt--)
                            Oe.buf[Rt + ft] = Oe.buf[Rt]
                    }
                    function R(te, _e) {
                        for (var Oe = 0; Oe < te.length; Oe++)
                            _e.writeVarint(te[Oe])
                    }
                    function O(te, _e) {
                        for (var Oe = 0; Oe < te.length; Oe++)
                            _e.writeSVarint(te[Oe])
                    }
                    function j(te, _e) {
                        for (var Oe = 0; Oe < te.length; Oe++)
                            _e.writeFloat(te[Oe])
                    }
                    function q(te, _e) {
                        for (var Oe = 0; Oe < te.length; Oe++)
                            _e.writeDouble(te[Oe])
                    }
                    function Q(te, _e) {
                        for (var Oe = 0; Oe < te.length; Oe++)
                            _e.writeBoolean(te[Oe])
                    }
                    function ne(te, _e) {
                        for (var Oe = 0; Oe < te.length; Oe++)
                            _e.writeFixed32(te[Oe])
                    }
                    function oe(te, _e) {
                        for (var Oe = 0; Oe < te.length; Oe++)
                            _e.writeSFixed32(te[Oe])
                    }
                    function de(te, _e) {
                        for (var Oe = 0; Oe < te.length; Oe++)
                            _e.writeFixed64(te[Oe])
                    }
                    function we(te, _e) {
                        for (var Oe = 0; Oe < te.length; Oe++)
                            _e.writeSFixed64(te[Oe])
                    }
                    function Ie(te, _e) {
                        return (te[_e] | te[_e + 1] << 8 | te[_e + 2] << 16) + 16777216 * te[_e + 3]
                    }
                    function Ye(te, _e, Oe) {
                        te[Oe] = _e,
                        te[Oe + 1] = _e >>> 8,
                        te[Oe + 2] = _e >>> 16,
                        te[Oe + 3] = _e >>> 24
                    }
                    function Le(te, _e) {
                        return (te[_e] | te[_e + 1] << 8 | te[_e + 2] << 16) + (te[_e + 3] << 24)
                    }
                    return n.prototype = {
                        destroy: function() {
                            this.buf = null
                        },
                        readFields: function(te, _e, Oe) {
                            for (Oe = Oe || this.length; this.pos < Oe; ) {
                                var ft = this.readVarint()
                                  , Rt = ft >> 3
                                  , yt = this.pos;
                                this.type = 7 & ft,
                                te(Rt, _e, this),
                                this.pos === yt && this.skip(ft)
                            }
                            return _e
                        },
                        readMessage: function(te, _e) {
                            return this.readFields(te, _e, this.readVarint() + this.pos)
                        },
                        readFixed32: function() {
                            var te = Ie(this.buf, this.pos);
                            return this.pos += 4,
                            te
                        },
                        readSFixed32: function() {
                            var te = Le(this.buf, this.pos);
                            return this.pos += 4,
                            te
                        },
                        readFixed64: function() {
                            var te = Ie(this.buf, this.pos) + Ie(this.buf, this.pos + 4) * l;
                            return this.pos += 8,
                            te
                        },
                        readSFixed64: function() {
                            var te = Ie(this.buf, this.pos) + Le(this.buf, this.pos + 4) * l;
                            return this.pos += 8,
                            te
                        },
                        readFloat: function() {
                            var te = c.read(this.buf, this.pos, !0, 23, 4);
                            return this.pos += 4,
                            te
                        },
                        readDouble: function() {
                            var te = c.read(this.buf, this.pos, !0, 52, 8);
                            return this.pos += 8,
                            te
                        },
                        readVarint: function(te) {
                            var _e, Oe, ft = this.buf;
                            return _e = 127 & (Oe = ft[this.pos++]),
                            Oe < 128 ? _e : (_e |= (127 & (Oe = ft[this.pos++])) << 7,
                            Oe < 128 ? _e : (_e |= (127 & (Oe = ft[this.pos++])) << 14,
                            Oe < 128 ? _e : (_e |= (127 & (Oe = ft[this.pos++])) << 21,
                            Oe < 128 ? _e : function(Rt, yt, bt) {
                                var Dt, At, Ft = bt.buf;
                                if (Dt = (112 & (At = Ft[bt.pos++])) >> 4,
                                At < 128 || (Dt |= (127 & (At = Ft[bt.pos++])) << 3,
                                At < 128) || (Dt |= (127 & (At = Ft[bt.pos++])) << 10,
                                At < 128) || (Dt |= (127 & (At = Ft[bt.pos++])) << 17,
                                At < 128) || (Dt |= (127 & (At = Ft[bt.pos++])) << 24,
                                At < 128) || (Dt |= (1 & (At = Ft[bt.pos++])) << 31,
                                At < 128))
                                    return C(Rt, Dt, yt);
                                throw new Error("Expected varint not more than 10 bytes")
                            }(_e |= (15 & (Oe = ft[this.pos])) << 28, te, this))))
                        },
                        readVarint64: function() {
                            return this.readVarint(!0)
                        },
                        readSVarint: function() {
                            var te = this.readVarint();
                            return te % 2 == 1 ? (te + 1) / -2 : te / 2
                        },
                        readBoolean: function() {
                            return !!this.readVarint()
                        },
                        readString: function() {
                            var te = this.readVarint() + this.pos
                              , _e = this.pos;
                            return this.pos = te,
                            te - _e >= 12 && _ ? function(Oe, ft, Rt) {
                                return _.decode(Oe.subarray(ft, Rt))
                            }(this.buf, _e, te) : function(Oe, ft, Rt) {
                                for (var yt = "", bt = ft; bt < Rt; ) {
                                    var Dt, At, Ft, Tt = Oe[bt], ar = null, Mr = Tt > 239 ? 4 : Tt > 223 ? 3 : Tt > 191 ? 2 : 1;
                                    if (bt + Mr > Rt)
                                        break;
                                    Mr === 1 ? Tt < 128 && (ar = Tt) : Mr === 2 ? (192 & (Dt = Oe[bt + 1])) == 128 && (ar = (31 & Tt) << 6 | 63 & Dt) <= 127 && (ar = null) : Mr === 3 ? (At = Oe[bt + 2],
                                    (192 & (Dt = Oe[bt + 1])) == 128 && (192 & At) == 128 && ((ar = (15 & Tt) << 12 | (63 & Dt) << 6 | 63 & At) <= 2047 || ar >= 55296 && ar <= 57343) && (ar = null)) : Mr === 4 && (At = Oe[bt + 2],
                                    Ft = Oe[bt + 3],
                                    (192 & (Dt = Oe[bt + 1])) == 128 && (192 & At) == 128 && (192 & Ft) == 128 && ((ar = (15 & Tt) << 18 | (63 & Dt) << 12 | (63 & At) << 6 | 63 & Ft) <= 65535 || ar >= 1114112) && (ar = null)),
                                    ar === null ? (ar = 65533,
                                    Mr = 1) : ar > 65535 && (ar -= 65536,
                                    yt += String.fromCharCode(ar >>> 10 & 1023 | 55296),
                                    ar = 56320 | 1023 & ar),
                                    yt += String.fromCharCode(ar),
                                    bt += Mr
                                }
                                return yt
                            }(this.buf, _e, te)
                        },
                        readBytes: function() {
                            var te = this.readVarint() + this.pos
                              , _e = this.buf.subarray(this.pos, te);
                            return this.pos = te,
                            _e
                        },
                        readPackedVarint: function(te, _e) {
                            if (this.type !== n.Bytes)
                                return te.push(this.readVarint(_e));
                            var Oe = b(this);
                            for (te = te || []; this.pos < Oe; )
                                te.push(this.readVarint(_e));
                            return te
                        },
                        readPackedSVarint: function(te) {
                            if (this.type !== n.Bytes)
                                return te.push(this.readSVarint());
                            var _e = b(this);
                            for (te = te || []; this.pos < _e; )
                                te.push(this.readSVarint());
                            return te
                        },
                        readPackedBoolean: function(te) {
                            if (this.type !== n.Bytes)
                                return te.push(this.readBoolean());
                            var _e = b(this);
                            for (te = te || []; this.pos < _e; )
                                te.push(this.readBoolean());
                            return te
                        },
                        readPackedFloat: function(te) {
                            if (this.type !== n.Bytes)
                                return te.push(this.readFloat());
                            var _e = b(this);
                            for (te = te || []; this.pos < _e; )
                                te.push(this.readFloat());
                            return te
                        },
                        readPackedDouble: function(te) {
                            if (this.type !== n.Bytes)
                                return te.push(this.readDouble());
                            var _e = b(this);
                            for (te = te || []; this.pos < _e; )
                                te.push(this.readDouble());
                            return te
                        },
                        readPackedFixed32: function(te) {
                            if (this.type !== n.Bytes)
                                return te.push(this.readFixed32());
                            var _e = b(this);
                            for (te = te || []; this.pos < _e; )
                                te.push(this.readFixed32());
                            return te
                        },
                        readPackedSFixed32: function(te) {
                            if (this.type !== n.Bytes)
                                return te.push(this.readSFixed32());
                            var _e = b(this);
                            for (te = te || []; this.pos < _e; )
                                te.push(this.readSFixed32());
                            return te
                        },
                        readPackedFixed64: function(te) {
                            if (this.type !== n.Bytes)
                                return te.push(this.readFixed64());
                            var _e = b(this);
                            for (te = te || []; this.pos < _e; )
                                te.push(this.readFixed64());
                            return te
                        },
                        readPackedSFixed64: function(te) {
                            if (this.type !== n.Bytes)
                                return te.push(this.readSFixed64());
                            var _e = b(this);
                            for (te = te || []; this.pos < _e; )
                                te.push(this.readSFixed64());
                            return te
                        },
                        skip: function(te) {
                            var _e = 7 & te;
                            if (_e === n.Varint)
                                for (; this.buf[this.pos++] > 127; )
                                    ;
                            else if (_e === n.Bytes)
                                this.pos = this.readVarint() + this.pos;
                            else if (_e === n.Fixed32)
                                this.pos += 4;
                            else {
                                if (_e !== n.Fixed64)
                                    throw new Error("Unimplemented type: " + _e);
                                this.pos += 8
                            }
                        },
                        writeTag: function(te, _e) {
                            this.writeVarint(te << 3 | _e)
                        },
                        realloc: function(te) {
                            for (var _e = this.length || 16; _e < this.pos + te; )
                                _e *= 2;
                            if (_e !== this.length) {
                                var Oe = new Uint8Array(_e);
                                Oe.set(this.buf),
                                this.buf = Oe,
                                this.length = _e
                            }
                        },
                        finish: function() {
                            return this.length = this.pos,
                            this.pos = 0,
                            this.buf.subarray(0, this.length)
                        },
                        writeFixed32: function(te) {
                            this.realloc(4),
                            Ye(this.buf, te, this.pos),
                            this.pos += 4
                        },
                        writeSFixed32: function(te) {
                            this.realloc(4),
                            Ye(this.buf, te, this.pos),
                            this.pos += 4
                        },
                        writeFixed64: function(te) {
                            this.realloc(8),
                            Ye(this.buf, -1 & te, this.pos),
                            Ye(this.buf, Math.floor(te * p), this.pos + 4),
                            this.pos += 8
                        },
                        writeSFixed64: function(te) {
                            this.realloc(8),
                            Ye(this.buf, -1 & te, this.pos),
                            Ye(this.buf, Math.floor(te * p), this.pos + 4),
                            this.pos += 8
                        },
                        writeVarint: function(te) {
                            (te = +te || 0) > 268435455 || te < 0 ? function(_e, Oe) {
                                var ft, Rt;
                                if (_e >= 0 ? (ft = _e % 4294967296 | 0,
                                Rt = _e / 4294967296 | 0) : (Rt = ~(-_e / 4294967296),
                                4294967295 ^ (ft = ~(-_e % 4294967296)) ? ft = ft + 1 | 0 : (ft = 0,
                                Rt = Rt + 1 | 0)),
                                _e >= 18446744073709552e3 || _e < -18446744073709552e3)
                                    throw new Error("Given varint doesn't fit into 10 bytes");
                                Oe.realloc(10),
                                function(yt, bt, Dt) {
                                    Dt.buf[Dt.pos++] = 127 & yt | 128,
                                    yt >>>= 7,
                                    Dt.buf[Dt.pos++] = 127 & yt | 128,
                                    yt >>>= 7,
                                    Dt.buf[Dt.pos++] = 127 & yt | 128,
                                    yt >>>= 7,
                                    Dt.buf[Dt.pos++] = 127 & yt | 128,
                                    Dt.buf[Dt.pos] = 127 & (yt >>>= 7)
                                }(ft, 0, Oe),
                                function(yt, bt) {
                                    var Dt = (7 & yt) << 4;
                                    bt.buf[bt.pos++] |= Dt | ((yt >>>= 3) ? 128 : 0),
                                    yt && (bt.buf[bt.pos++] = 127 & yt | ((yt >>>= 7) ? 128 : 0),
                                    yt && (bt.buf[bt.pos++] = 127 & yt | ((yt >>>= 7) ? 128 : 0),
                                    yt && (bt.buf[bt.pos++] = 127 & yt | ((yt >>>= 7) ? 128 : 0),
                                    yt && (bt.buf[bt.pos++] = 127 & yt | ((yt >>>= 7) ? 128 : 0),
                                    yt && (bt.buf[bt.pos++] = 127 & yt)))))
                                }(Rt, Oe)
                            }(te, this) : (this.realloc(4),
                            this.buf[this.pos++] = 127 & te | (te > 127 ? 128 : 0),
                            te <= 127 || (this.buf[this.pos++] = 127 & (te >>>= 7) | (te > 127 ? 128 : 0),
                            te <= 127 || (this.buf[this.pos++] = 127 & (te >>>= 7) | (te > 127 ? 128 : 0),
                            te <= 127 || (this.buf[this.pos++] = te >>> 7 & 127))))
                        },
                        writeSVarint: function(te) {
                            this.writeVarint(te < 0 ? 2 * -te - 1 : 2 * te)
                        },
                        writeBoolean: function(te) {
                            this.writeVarint(!!te)
                        },
                        writeString: function(te) {
                            te = String(te),
                            this.realloc(4 * te.length),
                            this.pos++;
                            var _e = this.pos;
                            this.pos = function(ft, Rt, yt) {
                                for (var bt, Dt, At = 0; At < Rt.length; At++) {
                                    if ((bt = Rt.charCodeAt(At)) > 55295 && bt < 57344) {
                                        if (!Dt) {
                                            bt > 56319 || At + 1 === Rt.length ? (ft[yt++] = 239,
                                            ft[yt++] = 191,
                                            ft[yt++] = 189) : Dt = bt;
                                            continue
                                        }
                                        if (bt < 56320) {
                                            ft[yt++] = 239,
                                            ft[yt++] = 191,
                                            ft[yt++] = 189,
                                            Dt = bt;
                                            continue
                                        }
                                        bt = Dt - 55296 << 10 | bt - 56320 | 65536,
                                        Dt = null
                                    } else
                                        Dt && (ft[yt++] = 239,
                                        ft[yt++] = 191,
                                        ft[yt++] = 189,
                                        Dt = null);
                                    bt < 128 ? ft[yt++] = bt : (bt < 2048 ? ft[yt++] = bt >> 6 | 192 : (bt < 65536 ? ft[yt++] = bt >> 12 | 224 : (ft[yt++] = bt >> 18 | 240,
                                    ft[yt++] = bt >> 12 & 63 | 128),
                                    ft[yt++] = bt >> 6 & 63 | 128),
                                    ft[yt++] = 63 & bt | 128)
                                }
                                return yt
                            }(this.buf, te, this.pos);
                            var Oe = this.pos - _e;
                            Oe >= 128 && M(_e, Oe, this),
                            this.pos = _e - 1,
                            this.writeVarint(Oe),
                            this.pos += Oe
                        },
                        writeFloat: function(te) {
                            this.realloc(4),
                            c.write(this.buf, te, this.pos, !0, 23, 4),
                            this.pos += 4
                        },
                        writeDouble: function(te) {
                            this.realloc(8),
                            c.write(this.buf, te, this.pos, !0, 52, 8),
                            this.pos += 8
                        },
                        writeBytes: function(te) {
                            var _e = te.length;
                            this.writeVarint(_e),
                            this.realloc(_e);
                            for (var Oe = 0; Oe < _e; Oe++)
                                this.buf[this.pos++] = te[Oe]
                        },
                        writeRawMessage: function(te, _e) {
                            this.pos++;
                            var Oe = this.pos;
                            te(_e, this);
                            var ft = this.pos - Oe;
                            ft >= 128 && M(Oe, ft, this),
                            this.pos = Oe - 1,
                            this.writeVarint(ft),
                            this.pos += ft
                        },
                        writeMessage: function(te, _e, Oe) {
                            this.writeTag(te, n.Bytes),
                            this.writeRawMessage(_e, Oe)
                        },
                        writePackedVarint: function(te, _e) {
                            _e.length && this.writeMessage(te, R, _e)
                        },
                        writePackedSVarint: function(te, _e) {
                            _e.length && this.writeMessage(te, O, _e)
                        },
                        writePackedBoolean: function(te, _e) {
                            _e.length && this.writeMessage(te, Q, _e)
                        },
                        writePackedFloat: function(te, _e) {
                            _e.length && this.writeMessage(te, j, _e)
                        },
                        writePackedDouble: function(te, _e) {
                            _e.length && this.writeMessage(te, q, _e)
                        },
                        writePackedFixed32: function(te, _e) {
                            _e.length && this.writeMessage(te, ne, _e)
                        },
                        writePackedSFixed32: function(te, _e) {
                            _e.length && this.writeMessage(te, oe, _e)
                        },
                        writePackedFixed64: function(te, _e) {
                            _e.length && this.writeMessage(te, de, _e)
                        },
                        writePackedSFixed64: function(te, _e) {
                            _e.length && this.writeMessage(te, we, _e)
                        },
                        writeBytesField: function(te, _e) {
                            this.writeTag(te, n.Bytes),
                            this.writeBytes(_e)
                        },
                        writeFixed32Field: function(te, _e) {
                            this.writeTag(te, n.Fixed32),
                            this.writeFixed32(_e)
                        },
                        writeSFixed32Field: function(te, _e) {
                            this.writeTag(te, n.Fixed32),
                            this.writeSFixed32(_e)
                        },
                        writeFixed64Field: function(te, _e) {
                            this.writeTag(te, n.Fixed64),
                            this.writeFixed64(_e)
                        },
                        writeSFixed64Field: function(te, _e) {
                            this.writeTag(te, n.Fixed64),
                            this.writeSFixed64(_e)
                        },
                        writeVarintField: function(te, _e) {
                            this.writeTag(te, n.Varint),
                            this.writeVarint(_e)
                        },
                        writeSVarintField: function(te, _e) {
                            this.writeTag(te, n.Varint),
                            this.writeSVarint(_e)
                        },
                        writeStringField: function(te, _e) {
                            this.writeTag(te, n.Bytes),
                            this.writeString(_e)
                        },
                        writeFloatField: function(te, _e) {
                            this.writeTag(te, n.Fixed32),
                            this.writeFloat(_e)
                        },
                        writeDoubleField: function(te, _e) {
                            this.writeTag(te, n.Fixed64),
                            this.writeDouble(_e)
                        },
                        writeBooleanField: function(te, _e) {
                            this.writeVarintField(te, !!_e)
                        }
                    },
                    $d
                }
                var wa, Bh = w(zm());
                function jy(c, n, l) {
                    c === 1 && l.readMessage(Dm, n)
                }
                function Dm(c, n, l) {
                    if (c === 3) {
                        const {id: p, bitmap: _, width: b, height: C, left: M, top: R, advance: O} = l.readMessage(Uv, {});
                        n.push({
                            id: p,
                            bitmap: new $u({
                                width: b + 6,
                                height: C + 6
                            },_),
                            metrics: {
                                width: b,
                                height: C,
                                left: M,
                                top: R,
                                advance: O
                            }
                        })
                    }
                }
                function Uv(c, n, l) {
                    c === 1 ? n.id = l.readVarint() : c === 2 ? n.bitmap = l.readBytes() : c === 3 ? n.width = l.readVarint() : c === 4 ? n.height = l.readVarint() : c === 5 ? n.left = l.readSVarint() : c === 6 ? n.top = l.readSVarint() : c === 7 && (n.advance = l.readVarint())
                }
                function Lm(c) {
                    let n = 0
                      , l = 0;
                    for (const C of c)
                        n += C.w * C.h,
                        l = Math.max(l, C.w);
                    c.sort( (C, M) => M.h - C.h);
                    const p = [{
                        x: 0,
                        y: 0,
                        w: Math.max(Math.ceil(Math.sqrt(n / .95)), l),
                        h: 1 / 0
                    }];
                    let _ = 0
                      , b = 0;
                    for (const C of c)
                        for (let M = p.length - 1; M >= 0; M--) {
                            const R = p[M];
                            if (!(C.w > R.w || C.h > R.h)) {
                                if (C.x = R.x,
                                C.y = R.y,
                                b = Math.max(b, C.y + C.h),
                                _ = Math.max(_, C.x + C.w),
                                C.w === R.w && C.h === R.h) {
                                    const O = p.pop();
                                    M < p.length && (p[M] = O)
                                } else
                                    C.h === R.h ? (R.x += C.w,
                                    R.w -= C.w) : C.w === R.w ? (R.y += C.h,
                                    R.h -= C.h) : (p.push({
                                        x: R.x + C.w,
                                        y: R.y,
                                        w: R.w - C.w,
                                        h: C.h
                                    }),
                                    R.y += C.h,
                                    R.h -= C.h);
                                break
                            }
                        }
                    return {
                        w: _,
                        h: b,
                        fill: n / (_ * b) || 0
                    }
                }
                class Vd {
                    constructor(n, {pixelRatio: l, version: p, stretchX: _, stretchY: b, content: C, textFitWidth: M, textFitHeight: R}) {
                        this.paddedRect = n,
                        this.pixelRatio = l,
                        this.stretchX = _,
                        this.stretchY = b,
                        this.content = C,
                        this.version = p,
                        this.textFitWidth = M,
                        this.textFitHeight = R
                    }
                    get tl() {
                        return [this.paddedRect.x + 1, this.paddedRect.y + 1]
                    }
                    get br() {
                        return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
                    }
                    get tlbr() {
                        return this.tl.concat(this.br)
                    }
                    get displaySize() {
                        return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
                    }
                }
                class Ud {
                    constructor(n, l) {
                        const p = {}
                          , _ = {};
                        this.haveRenderCallbacks = [];
                        const b = [];
                        this.addImages(n, p, b),
                        this.addImages(l, _, b);
                        const {w: C, h: M} = Lm(b)
                          , R = new Oo({
                            width: C || 1,
                            height: M || 1
                        });
                        for (const O in n) {
                            const j = n[O]
                              , q = p[O].paddedRect;
                            Oo.copy(j.data, R, {
                                x: 0,
                                y: 0
                            }, {
                                x: q.x + 1,
                                y: q.y + 1
                            }, j.data)
                        }
                        for (const O in l) {
                            const j = l[O]
                              , q = _[O].paddedRect
                              , Q = q.x + 1
                              , ne = q.y + 1
                              , oe = j.data.width
                              , de = j.data.height;
                            Oo.copy(j.data, R, {
                                x: 0,
                                y: 0
                            }, {
                                x: Q,
                                y: ne
                            }, j.data),
                            Oo.copy(j.data, R, {
                                x: 0,
                                y: de - 1
                            }, {
                                x: Q,
                                y: ne - 1
                            }, {
                                width: oe,
                                height: 1
                            }),
                            Oo.copy(j.data, R, {
                                x: 0,
                                y: 0
                            }, {
                                x: Q,
                                y: ne + de
                            }, {
                                width: oe,
                                height: 1
                            }),
                            Oo.copy(j.data, R, {
                                x: oe - 1,
                                y: 0
                            }, {
                                x: Q - 1,
                                y: ne
                            }, {
                                width: 1,
                                height: de
                            }),
                            Oo.copy(j.data, R, {
                                x: 0,
                                y: 0
                            }, {
                                x: Q + oe,
                                y: ne
                            }, {
                                width: 1,
                                height: de
                            })
                        }
                        this.image = R,
                        this.iconPositions = p,
                        this.patternPositions = _
                    }
                    addImages(n, l, p) {
                        for (const _ in n) {
                            const b = n[_]
                              , C = {
                                x: 0,
                                y: 0,
                                w: b.data.width + 2,
                                h: b.data.height + 2
                            };
                            p.push(C),
                            l[_] = new Vd(C,b),
                            b.hasRenderCallback && this.haveRenderCallbacks.push(_)
                        }
                    }
                    patchUpdatedImages(n, l) {
                        n.dispatchRenderCallbacks(this.haveRenderCallbacks);
                        for (const p in n.updatedImages)
                            this.patchUpdatedImage(this.iconPositions[p], n.getImage(p), l),
                            this.patchUpdatedImage(this.patternPositions[p], n.getImage(p), l)
                    }
                    patchUpdatedImage(n, l, p) {
                        if (!n || !l || n.version === l.version)
                            return;
                        n.version = l.version;
                        const [_,b] = n.tl;
                        p.update(l.data, void 0, {
                            x: _,
                            y: b
                        })
                    }
                }
                Kt("ImagePosition", Vd),
                Kt("ImageAtlas", Ud),
                f.an = void 0,
                (wa = f.an || (f.an = {}))[wa.none = 0] = "none",
                wa[wa.horizontal = 1] = "horizontal",
                wa[wa.vertical = 2] = "vertical",
                wa[wa.horizontalOnly = 3] = "horizontalOnly";
                class Qu {
                    constructor() {
                        this.scale = 1,
                        this.fontStack = "",
                        this.imageName = null,
                        this.verticalAlign = "bottom"
                    }
                    static forText(n, l, p) {
                        const _ = new Qu;
                        return _.scale = n || 1,
                        _.fontStack = l,
                        _.verticalAlign = p || "bottom",
                        _
                    }
                    static forImage(n, l) {
                        const p = new Qu;
                        return p.imageName = n,
                        p.verticalAlign = l || "bottom",
                        p
                    }
                }
                class Wl {
                    constructor() {
                        this.text = "",
                        this.sectionIndex = [],
                        this.sections = [],
                        this.imageSectionID = null
                    }
                    static fromFeature(n, l) {
                        const p = new Wl;
                        for (let _ = 0; _ < n.sections.length; _++) {
                            const b = n.sections[_];
                            b.image ? p.addImageSection(b) : p.addTextSection(b, l)
                        }
                        return p
                    }
                    length() {
                        return this.text.length
                    }
                    getSection(n) {
                        return this.sections[this.sectionIndex[n]]
                    }
                    getSectionIndex(n) {
                        return this.sectionIndex[n]
                    }
                    getCharCode(n) {
                        return this.text.charCodeAt(n)
                    }
                    verticalizePunctuation() {
                        this.text = function(n) {
                            let l = "";
                            for (let p = 0; p < n.length; p++) {
                                const _ = n.charCodeAt(p + 1) || null
                                  , b = n.charCodeAt(p - 1) || null;
                                l += _ && Ch(_) && !Uc[n[p + 1]] || b && Ch(b) && !Uc[n[p - 1]] || !Uc[n[p]] ? n[p] : Uc[n[p]]
                            }
                            return l
                        }(this.text)
                    }
                    trim() {
                        let n = 0;
                        for (let p = 0; p < this.text.length && ip[this.text.charCodeAt(p)]; p++)
                            n++;
                        let l = this.text.length;
                        for (let p = this.text.length - 1; p >= 0 && p >= n && ip[this.text.charCodeAt(p)]; p--)
                            l--;
                        this.text = this.text.substring(n, l),
                        this.sectionIndex = this.sectionIndex.slice(n, l)
                    }
                    substring(n, l) {
                        const p = new Wl;
                        return p.text = this.text.substring(n, l),
                        p.sectionIndex = this.sectionIndex.slice(n, l),
                        p.sections = this.sections,
                        p
                    }
                    toString() {
                        return this.text
                    }
                    getMaxScale() {
                        return this.sectionIndex.reduce( (n, l) => Math.max(n, this.sections[l].scale), 0)
                    }
                    getMaxImageSize(n) {
                        let l = 0
                          , p = 0;
                        for (let _ = 0; _ < this.length(); _++) {
                            const b = this.getSection(_);
                            if (b.imageName) {
                                const C = n[b.imageName];
                                if (!C)
                                    continue;
                                const M = C.displaySize;
                                l = Math.max(l, M[0]),
                                p = Math.max(p, M[1])
                            }
                        }
                        return {
                            maxImageWidth: l,
                            maxImageHeight: p
                        }
                    }
                    addTextSection(n, l) {
                        this.text += n.text,
                        this.sections.push(Qu.forText(n.scale, n.fontStack || l, n.verticalAlign));
                        const p = this.sections.length - 1;
                        for (let _ = 0; _ < n.text.length; ++_)
                            this.sectionIndex.push(p)
                    }
                    addImageSection(n) {
                        const l = n.image ? n.image.name : "";
                        if (l.length === 0)
                            return void Zr("Can't add FormattedSection with an empty image.");
                        const p = this.getNextImageSectionCharCode();
                        p ? (this.text += String.fromCharCode(p),
                        this.sections.push(Qu.forImage(l, n.verticalAlign)),
                        this.sectionIndex.push(this.sections.length - 1)) : Zr("Reached maximum number of images 6401")
                    }
                    getNextImageSectionCharCode() {
                        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344,
                        this.imageSectionID)
                    }
                }
                function Gd(c, n, l, p, _, b, C, M, R, O, j, q, Q, ne, oe) {
                    const de = Wl.fromFeature(c, _);
                    let we;
                    q === f.an.vertical && de.verticalizePunctuation();
                    const {processBidirectionalText: Ie, processStyledBidirectionalText: Ye} = Qa;
                    if (Ie && de.sections.length === 1) {
                        we = [];
                        const _e = Ie(de.toString(), S(de, O, b, n, p, ne));
                        for (const Oe of _e) {
                            const ft = new Wl;
                            ft.text = Oe,
                            ft.sections = de.sections;
                            for (let Rt = 0; Rt < Oe.length; Rt++)
                                ft.sectionIndex.push(0);
                            we.push(ft)
                        }
                    } else if (Ye) {
                        we = [];
                        const _e = Ye(de.text, de.sectionIndex, S(de, O, b, n, p, ne));
                        for (const Oe of _e) {
                            const ft = new Wl;
                            ft.text = Oe[0],
                            ft.sectionIndex = Oe[1],
                            ft.sections = de.sections,
                            we.push(ft)
                        }
                    } else
                        we = function(_e, Oe) {
                            const ft = []
                              , Rt = _e.text;
                            let yt = 0;
                            for (const bt of Oe)
                                ft.push(_e.substring(yt, bt)),
                                yt = bt;
                            return yt < Rt.length && ft.push(_e.substring(yt, Rt.length)),
                            ft
                        }(de, S(de, O, b, n, p, ne));
                    const Le = []
                      , te = {
                        positionedLines: Le,
                        text: de.toString(),
                        top: j[1],
                        bottom: j[1],
                        left: j[0],
                        right: j[0],
                        writingMode: q,
                        iconsInText: !1,
                        verticalizable: !1
                    };
                    return function(_e, Oe, ft, Rt, yt, bt, Dt, At, Ft, Tt, ar, Mr) {
                        let Tr = 0
                          , pr = 0
                          , on = 0
                          , pi = 0;
                        const Hi = At === "right" ? 1 : At === "left" ? 0 : .5
                          , $o = bi / Mr;
                        let Ca = 0;
                        for (const ai of yt) {
                            ai.trim();
                            const oo = ai.getMaxScale()
                              , Po = {
                                positionedGlyphs: [],
                                lineOffset: 0
                            };
                            _e.positionedLines[Ca] = Po;
                            const Mo = Po.positionedGlyphs;
                            let ms = 0;
                            if (!ai.length()) {
                                pr += bt,
                                ++Ca;
                                continue
                            }
                            const Ta = F(Rt, ai, $o);
                            for (let Ls = 0; Ls < ai.length(); Ls++) {
                                const Zi = ai.getSection(Ls)
                                  , ao = ai.getSectionIndex(Ls)
                                  , lo = ai.getCharCode(Ls)
                                  , Fi = pe(Ft, ar, lo);
                                let Jn;
                                if (Zi.imageName) {
                                    if (_e.iconsInText = !0,
                                    Zi.scale = Zi.scale * $o,
                                    Jn = Je(Zi, Fi, oo, Ta, Rt),
                                    !Jn)
                                        continue;
                                    ms = Math.max(ms, Jn.imageOffset)
                                } else if (Jn = Fe(Zi, lo, Fi, Ta, Oe, ft),
                                !Jn)
                                    continue;
                                const {rect: ql, metrics: cp, baselineOffset: Hl} = Jn;
                                Mo.push({
                                    glyph: lo,
                                    imageName: Zi.imageName,
                                    x: Tr,
                                    y: pr + Hl + -17,
                                    vertical: Fi,
                                    scale: Zi.scale,
                                    fontStack: Zi.fontStack,
                                    sectionIndex: ao,
                                    metrics: cp,
                                    rect: ql
                                }),
                                Fi ? (_e.verticalizable = !0,
                                Tr += (Zi.imageName ? cp.advance : bi) * Zi.scale + Tt) : Tr += cp.advance * Zi.scale + Tt
                            }
                            Mo.length !== 0 && (on = Math.max(Tr - Tt, on),
                            xt(Mo, 0, Mo.length - 1, Hi)),
                            Tr = 0,
                            Po.lineOffset = Math.max(ms, (oo - 1) * bi);
                            const so = bt * oo + ms;
                            pr += so,
                            pi = Math.max(so, pi),
                            ++Ca
                        }
                        const {horizontalAlign: Ds, verticalAlign: To} = E(Dt);
                        (function(ai, oo, Po, Mo, ms, Ta, so, Ls, Zi) {
                            const ao = (oo - Po) * ms;
                            let lo = 0;
                            lo = Ta !== so ? -Ls * Mo - -17 : -Mo * Zi * so + .5 * so;
                            for (const Fi of ai)
                                for (const Jn of Fi.positionedGlyphs)
                                    Jn.x += ao,
                                    Jn.y += lo
                        }
                        )(_e.positionedLines, Hi, Ds, To, on, pi, bt, pr, yt.length),
                        _e.top += -To * pr,
                        _e.bottom = _e.top + pr,
                        _e.left += -Ds * on,
                        _e.right = _e.left + on
                    }(te, n, l, p, we, C, M, R, q, O, Q, oe),
                    !function(_e) {
                        for (const Oe of _e)
                            if (Oe.positionedGlyphs.length !== 0)
                                return !1;
                        return !0
                    }(Le) && te
                }
                const ip = {
                    9: !0,
                    10: !0,
                    11: !0,
                    12: !0,
                    13: !0,
                    32: !0
                }
                  , op = {
                    10: !0,
                    32: !0,
                    38: !0,
                    41: !0,
                    43: !0,
                    45: !0,
                    47: !0,
                    173: !0,
                    183: !0,
                    8203: !0,
                    8208: !0,
                    8211: !0,
                    8231: !0
                }
                  , Gv = {
                    40: !0
                };
                function jh(c, n, l, p, _, b) {
                    if (n.imageName) {
                        const C = p[n.imageName];
                        return C ? C.displaySize[0] * n.scale * bi / b + _ : 0
                    }
                    {
                        const C = l[n.fontStack]
                          , M = C && C[c];
                        return M ? M.metrics.advance * n.scale + _ : 0
                    }
                }
                function Ny(c, n, l, p) {
                    const _ = Math.pow(c - n, 2);
                    return p ? c < n ? _ / 2 : 2 * _ : _ + Math.abs(l) * l
                }
                function sp(c, n, l) {
                    let p = 0;
                    return c === 10 && (p -= 1e4),
                    l && (p += 150),
                    c !== 40 && c !== 65288 || (p += 50),
                    n !== 41 && n !== 65289 || (p += 50),
                    p
                }
                function h(c, n, l, p, _, b) {
                    let C = null
                      , M = Ny(n, l, _, b);
                    for (const R of p) {
                        const O = Ny(n - R.x, l, _, b) + R.badness;
                        O <= M && (C = R,
                        M = O)
                    }
                    return {
                        index: c,
                        x: n,
                        priorBreak: C,
                        badness: M
                    }
                }
                function g(c) {
                    return c ? g(c.priorBreak).concat(c.index) : []
                }
                function S(c, n, l, p, _, b) {
                    if (!c)
                        return [];
                    const C = []
                      , M = function(q, Q, ne, oe, de, we) {
                        let Ie = 0;
                        for (let Ye = 0; Ye < q.length(); Ye++) {
                            const Le = q.getSection(Ye);
                            Ie += jh(q.getCharCode(Ye), Le, oe, de, Q, we)
                        }
                        return Ie / Math.max(1, Math.ceil(Ie / ne))
                    }(c, n, l, p, _, b)
                      , R = c.text.indexOf("​") >= 0;
                    let O = 0;
                    for (let q = 0; q < c.length(); q++) {
                        const Q = c.getSection(q)
                          , ne = c.getCharCode(q);
                        if (ip[ne] || (O += jh(ne, Q, p, _, n, b)),
                        q < c.length() - 1) {
                            const oe = !((j = ne) < 11904) && (!!Ir["CJK Compatibility Forms"](j) || !!Ir["CJK Compatibility"](j) || !!Ir["CJK Strokes"](j) || !!Ir["CJK Symbols and Punctuation"](j) || !!Ir["Enclosed CJK Letters and Months"](j) || !!Ir["Halfwidth and Fullwidth Forms"](j) || !!Ir["Ideographic Description Characters"](j) || !!Ir["Vertical Forms"](j) || Ru.test(String.fromCodePoint(j)));
                            (op[ne] || oe || Q.imageName || q !== c.length() - 2 && Gv[c.getCharCode(q + 1)]) && C.push(h(q + 1, O, M, C, sp(ne, c.getCharCode(q + 1), oe && R), !1))
                        }
                    }
                    var j;
                    return g(h(c.length(), O, M, C, 0, !0))
                }
                function E(c) {
                    let n = .5
                      , l = .5;
                    switch (c) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        n = 1;
                        break;
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        n = 0
                    }
                    switch (c) {
                    case "bottom":
                    case "bottom-right":
                    case "bottom-left":
                        l = 1;
                        break;
                    case "top":
                    case "top-right":
                    case "top-left":
                        l = 0
                    }
                    return {
                        horizontalAlign: n,
                        verticalAlign: l
                    }
                }
                function F(c, n, l) {
                    const p = n.getMaxScale() * bi
                      , {maxImageWidth: _, maxImageHeight: b} = n.getMaxImageSize(c)
                      , C = Math.max(p, b * l);
                    return {
                        verticalLineContentWidth: Math.max(p, _ * l),
                        horizontalLineContentHeight: C
                    }
                }
                function W(c) {
                    switch (c) {
                    case "top":
                        return 0;
                    case "center":
                        return .5;
                    default:
                        return 1
                    }
                }
                function pe(c, n, l) {
                    return !(c === f.an.horizontal || !n && !Cc(l) || n && (ip[l] || (p = l,
                    new RegExp("\\p{sc=Arab}","u").test(String.fromCodePoint(p)))));
                    var p
                }
                function Fe(c, n, l, p, _, b) {
                    const C = b[c.fontStack]
                      , M = function(O, j, q, Q) {
                        if (O && O.rect)
                            return O;
                        const ne = j[q.fontStack]
                          , oe = ne && ne[Q];
                        return oe ? {
                            rect: null,
                            metrics: oe.metrics
                        } : null
                    }(C && C[n], _, c, n);
                    if (M === null)
                        return null;
                    let R;
                    if (l)
                        R = p.verticalLineContentWidth - c.scale * bi;
                    else {
                        const O = W(c.verticalAlign);
                        R = (p.horizontalLineContentHeight - c.scale * bi) * O
                    }
                    return {
                        rect: M.rect,
                        metrics: M.metrics,
                        baselineOffset: R
                    }
                }
                function Je(c, n, l, p, _) {
                    const b = _[c.imageName];
                    if (!b)
                        return null;
                    const C = b.paddedRect
                      , M = b.displaySize
                      , R = {
                        width: M[0],
                        height: M[1],
                        left: 1,
                        top: -3,
                        advance: n ? M[1] : M[0]
                    };
                    let O;
                    if (n)
                        O = p.verticalLineContentWidth - M[1] * c.scale;
                    else {
                        const j = W(c.verticalAlign);
                        O = (p.horizontalLineContentHeight - M[1] * c.scale) * j
                    }
                    return {
                        rect: C,
                        metrics: R,
                        baselineOffset: O,
                        imageOffset: (n ? M[0] : M[1]) * c.scale - bi * l
                    }
                }
                function xt(c, n, l, p) {
                    if (p === 0)
                        return;
                    const _ = c[l]
                      , b = (c[l].x + _.metrics.advance * _.scale) * p;
                    for (let C = n; C <= l; C++)
                        c[C].x -= b
                }
                function Bt(c, n, l) {
                    const {horizontalAlign: p, verticalAlign: _} = E(l)
                      , b = n[0] - c.displaySize[0] * p
                      , C = n[1] - c.displaySize[1] * _;
                    return {
                        image: c,
                        top: C,
                        bottom: C + c.displaySize[1],
                        left: b,
                        right: b + c.displaySize[0]
                    }
                }
                function Vt(c) {
                    var n, l;
                    let p = c.left
                      , _ = c.top
                      , b = c.right - p
                      , C = c.bottom - _;
                    const M = (n = c.image.textFitWidth) !== null && n !== void 0 ? n : "stretchOrShrink"
                      , R = (l = c.image.textFitHeight) !== null && l !== void 0 ? l : "stretchOrShrink"
                      , O = (c.image.content[2] - c.image.content[0]) / (c.image.content[3] - c.image.content[1]);
                    if (R === "proportional") {
                        if (M === "stretchOnly" && b / C < O || M === "proportional") {
                            const j = Math.ceil(C * O);
                            p *= j / b,
                            b = j
                        }
                    } else if (M === "proportional" && R === "stretchOnly" && O !== 0 && b / C > O) {
                        const j = Math.ceil(b / O);
                        _ *= j / C,
                        C = j
                    }
                    return {
                        x1: p,
                        y1: _,
                        x2: p + b,
                        y2: _ + C
                    }
                }
                function Lt(c, n, l, p, _, b) {
                    const C = c.image;
                    let M;
                    if (C.content) {
                        const we = C.content
                          , Ie = C.pixelRatio || 1;
                        M = [we[0] / Ie, we[1] / Ie, C.displaySize[0] - we[2] / Ie, C.displaySize[1] - we[3] / Ie]
                    }
                    const R = n.left * b
                      , O = n.right * b;
                    let j, q, Q, ne;
                    l === "width" || l === "both" ? (ne = _[0] + R - p[3],
                    q = _[0] + O + p[1]) : (ne = _[0] + (R + O - C.displaySize[0]) / 2,
                    q = ne + C.displaySize[0]);
                    const oe = n.top * b
                      , de = n.bottom * b;
                    return l === "height" || l === "both" ? (j = _[1] + oe - p[0],
                    Q = _[1] + de + p[2]) : (j = _[1] + (oe + de - C.displaySize[1]) / 2,
                    Q = j + C.displaySize[1]),
                    {
                        image: C,
                        top: j,
                        right: q,
                        bottom: Q,
                        left: ne,
                        collisionPadding: M
                    }
                }
                const rr = 128
                  , hr = 32640;
                function wr(c, n) {
                    const {expression: l} = n;
                    if (l.kind === "constant")
                        return {
                            kind: "constant",
                            layoutSize: l.evaluate(new Mn(c + 1))
                        };
                    if (l.kind === "source")
                        return {
                            kind: "source"
                        };
                    {
                        const {zoomStops: p, interpolationType: _} = l;
                        let b = 0;
                        for (; b < p.length && p[b] <= c; )
                            b++;
                        b = Math.max(0, b - 1);
                        let C = b;
                        for (; C < p.length && p[C] < c + 1; )
                            C++;
                        C = Math.min(p.length - 1, C);
                        const M = p[b]
                          , R = p[C];
                        return l.kind === "composite" ? {
                            kind: "composite",
                            minZoom: M,
                            maxZoom: R,
                            interpolationType: _
                        } : {
                            kind: "camera",
                            minZoom: M,
                            maxZoom: R,
                            minSize: l.evaluate(new Mn(M)),
                            maxSize: l.evaluate(new Mn(R)),
                            interpolationType: _
                        }
                    }
                }
                function fi(c, n, l) {
                    let p = "never";
                    const _ = c.get(n);
                    return _ ? p = _ : c.get(l) && (p = "always"),
                    p
                }
                const pt = Zu.VectorTileFeature.types
                  , rt = [{
                    name: "a_fade_opacity",
                    components: 1,
                    type: "Uint8",
                    offset: 0
                }];
                function gt(c, n, l, p, _, b, C, M, R, O, j, q, Q) {
                    const ne = M ? Math.min(hr, Math.round(M[0])) : 0
                      , oe = M ? Math.min(hr, Math.round(M[1])) : 0;
                    c.emplaceBack(n, l, Math.round(32 * p), Math.round(32 * _), b, C, (ne << 1) + (R ? 1 : 0), oe, 16 * O, 16 * j, 256 * q, 256 * Q)
                }
                function Zt(c, n, l) {
                    c.emplaceBack(n.x, n.y, l),
                    c.emplaceBack(n.x, n.y, l),
                    c.emplaceBack(n.x, n.y, l),
                    c.emplaceBack(n.x, n.y, l)
                }
                function Pr(c) {
                    for (const n of c.sections)
                        if (zu(n.text))
                            return !0;
                    return !1
                }
                class Rr {
                    constructor(n) {
                        this.layoutVertexArray = new Vr,
                        this.indexArray = new kn,
                        this.programConfigurations = n,
                        this.segments = new rn,
                        this.dynamicLayoutVertexArray = new cn,
                        this.opacityVertexArray = new Kn,
                        this.hasVisibleVertices = !1,
                        this.placedSymbolArray = new Te
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
                    }
                    upload(n, l, p, _) {
                        this.isEmpty() || (p && (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, Js.members),
                        this.indexBuffer = n.createIndexBuffer(this.indexArray, l),
                        this.dynamicLayoutVertexBuffer = n.createVertexBuffer(this.dynamicLayoutVertexArray, Rm.members, !0),
                        this.opacityVertexBuffer = n.createVertexBuffer(this.opacityVertexArray, rt, !0),
                        this.opacityVertexBuffer.itemSize = 1),
                        (p || _) && this.programConfigurations.upload(n))
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.dynamicLayoutVertexBuffer.destroy(),
                        this.opacityVertexBuffer.destroy())
                    }
                }
                Kt("SymbolBuffers", Rr);
                class Ar {
                    constructor(n, l, p) {
                        this.layoutVertexArray = new n,
                        this.layoutAttributes = l,
                        this.indexArray = new p,
                        this.segments = new rn,
                        this.collisionVertexArray = new On
                    }
                    upload(n) {
                        this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes),
                        this.indexBuffer = n.createIndexBuffer(this.indexArray),
                        this.collisionVertexBuffer = n.createVertexBuffer(this.collisionVertexArray, Vv.members, !0)
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.segments.destroy(),
                        this.collisionVertexBuffer.destroy())
                    }
                }
                Kt("CollisionBuffers", Ar);
                class Lr {
                    constructor(n) {
                        this.collisionBoxArray = n.collisionBoxArray,
                        this.zoom = n.zoom,
                        this.globalState = n.globalState,
                        this.overscaling = n.overscaling,
                        this.layers = n.layers,
                        this.layerIds = this.layers.map(C => C.id),
                        this.index = n.index,
                        this.pixelRatio = n.pixelRatio,
                        this.sourceLayerIndex = n.sourceLayerIndex,
                        this.hasPattern = !1,
                        this.hasRTLText = !1,
                        this.sortKeyRanges = [],
                        this.collisionCircleArray = [];
                        const l = this.layers[0]._unevaluatedLayout._values;
                        this.textSizeData = wr(this.zoom, l["text-size"]),
                        this.iconSizeData = wr(this.zoom, l["icon-size"]);
                        const p = this.layers[0].layout
                          , _ = p.get("symbol-sort-key")
                          , b = p.get("symbol-z-order");
                        this.canOverlap = fi(p, "text-overlap", "text-allow-overlap") !== "never" || fi(p, "icon-overlap", "icon-allow-overlap") !== "never" || p.get("text-ignore-placement") || p.get("icon-ignore-placement"),
                        this.sortFeaturesByKey = b !== "viewport-y" && !_.isConstant(),
                        this.sortFeaturesByY = (b === "viewport-y" || b === "auto" && !this.sortFeaturesByKey) && this.canOverlap,
                        p.get("symbol-placement") === "point" && (this.writingModes = p.get("text-writing-mode").map(C => f.an[C])),
                        this.stateDependentLayerIds = this.layers.filter(C => C.isStateDependent()).map(C => C.id),
                        this.sourceID = n.sourceID
                    }
                    createArrays() {
                        this.text = new Rr(new ts(this.layers,this.zoom,n => /^text/.test(n))),
                        this.icon = new Rr(new ts(this.layers,this.zoom,n => /^icon/.test(n))),
                        this.glyphOffsetArray = new Ae,
                        this.lineVertexArray = new Be,
                        this.symbolInstances = new De,
                        this.textAnchorOffsets = new ze
                    }
                    calculateGlyphDependencies(n, l, p, _, b) {
                        for (let C = 0; C < n.length; C++)
                            if (l[n.charCodeAt(C)] = !0,
                            (p || _) && b) {
                                const M = Uc[n.charAt(C)];
                                M && (l[M.charCodeAt(0)] = !0)
                            }
                    }
                    populate(n, l, p) {
                        const _ = this.layers[0]
                          , b = _.layout
                          , C = b.get("text-font")
                          , M = b.get("text-field")
                          , R = b.get("icon-image")
                          , O = (M.value.kind !== "constant" || M.value.value instanceof ei && !M.value.value.isEmpty() || M.value.value.toString().length > 0) && (C.value.kind !== "constant" || C.value.value.length > 0)
                          , j = R.value.kind !== "constant" || !!R.value.value || Object.keys(R.parameters).length > 0
                          , q = b.get("symbol-sort-key");
                        if (this.features = [],
                        !O && !j)
                            return;
                        const Q = l.iconDependencies
                          , ne = l.glyphDependencies
                          , oe = l.availableImages
                          , de = new Mn(this.zoom,{
                            globalState: this.globalState
                        });
                        for (const {feature: we, id: Ie, index: Ye, sourceLayerIndex: Le} of n) {
                            const te = _._featureFilter.needGeometry
                              , _e = Dc(we, te);
                            if (!_._featureFilter.filter(de, _e, p))
                                continue;
                            let Oe, ft;
                            if (te || (_e.geometry = zc(we)),
                            O) {
                                const yt = _.getValueAndResolveTokens("text-field", _e, p, oe)
                                  , bt = ei.factory(yt)
                                  , Dt = this.hasRTLText = this.hasRTLText || Pr(bt);
                                (!Dt || Qa.getRTLTextPluginStatus() === "unavailable" || Dt && Qa.isParsed()) && (Oe = Ku(bt, _, _e))
                            }
                            if (j) {
                                const yt = _.getValueAndResolveTokens("icon-image", _e, p, oe);
                                ft = yt instanceof mo ? yt : mo.fromString(yt)
                            }
                            if (!Oe && !ft)
                                continue;
                            const Rt = this.sortFeaturesByKey ? q.evaluate(_e, {}, p) : void 0;
                            if (this.features.push({
                                id: Ie,
                                text: Oe,
                                icon: ft,
                                index: Ye,
                                sourceLayerIndex: Le,
                                geometry: _e.geometry,
                                properties: we.properties,
                                type: pt[we.type],
                                sortKey: Rt
                            }),
                            ft && (Q[ft.name] = !0),
                            Oe) {
                                const yt = C.evaluate(_e, {}, p).join(",")
                                  , bt = b.get("text-rotation-alignment") !== "viewport" && b.get("symbol-placement") !== "point";
                                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(f.an.vertical) >= 0;
                                for (const Dt of Oe.sections)
                                    if (Dt.image)
                                        Q[Dt.image.name] = !0;
                                    else {
                                        const At = vo(Oe.toString())
                                          , Ft = Dt.fontStack || yt
                                          , Tt = ne[Ft] = ne[Ft] || {};
                                        this.calculateGlyphDependencies(Dt.text, Tt, bt, this.allowVerticalPlacement, At)
                                    }
                            }
                        }
                        b.get("symbol-placement") === "line" && (this.features = function(we) {
                            const Ie = {}
                              , Ye = {}
                              , Le = [];
                            let te = 0;
                            function _e(yt) {
                                Le.push(we[yt]),
                                te++
                            }
                            function Oe(yt, bt, Dt) {
                                const At = Ye[yt];
                                return delete Ye[yt],
                                Ye[bt] = At,
                                Le[At].geometry[0].pop(),
                                Le[At].geometry[0] = Le[At].geometry[0].concat(Dt[0]),
                                At
                            }
                            function ft(yt, bt, Dt) {
                                const At = Ie[bt];
                                return delete Ie[bt],
                                Ie[yt] = At,
                                Le[At].geometry[0].shift(),
                                Le[At].geometry[0] = Dt[0].concat(Le[At].geometry[0]),
                                At
                            }
                            function Rt(yt, bt, Dt) {
                                const At = Dt ? bt[0][bt[0].length - 1] : bt[0][0];
                                return `${yt}:${At.x}:${At.y}`
                            }
                            for (let yt = 0; yt < we.length; yt++) {
                                const bt = we[yt]
                                  , Dt = bt.geometry
                                  , At = bt.text ? bt.text.toString() : null;
                                if (!At) {
                                    _e(yt);
                                    continue
                                }
                                const Ft = Rt(At, Dt)
                                  , Tt = Rt(At, Dt, !0);
                                if (Ft in Ye && Tt in Ie && Ye[Ft] !== Ie[Tt]) {
                                    const ar = ft(Ft, Tt, Dt)
                                      , Mr = Oe(Ft, Tt, Le[ar].geometry);
                                    delete Ie[Ft],
                                    delete Ye[Tt],
                                    Ye[Rt(At, Le[Mr].geometry, !0)] = Mr,
                                    Le[ar].geometry = null
                                } else
                                    Ft in Ye ? Oe(Ft, Tt, Dt) : Tt in Ie ? ft(Ft, Tt, Dt) : (_e(yt),
                                    Ie[Ft] = te - 1,
                                    Ye[Tt] = te - 1)
                            }
                            return Le.filter(yt => yt.geometry)
                        }(this.features)),
                        this.sortFeaturesByKey && this.features.sort( (we, Ie) => we.sortKey - Ie.sortKey)
                    }
                    update(n, l, p) {
                        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(n, l, this.layers, p),
                        this.icon.programConfigurations.updatePaintArrays(n, l, this.layers, p))
                    }
                    isEmpty() {
                        return this.symbolInstances.length === 0 && !this.hasRTLText
                    }
                    uploadPending() {
                        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
                    }
                    upload(n) {
                        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(n),
                        this.iconCollisionBox.upload(n)),
                        this.text.upload(n, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload),
                        this.icon.upload(n, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload),
                        this.uploaded = !0
                    }
                    destroyDebugData() {
                        this.textCollisionBox.destroy(),
                        this.iconCollisionBox.destroy()
                    }
                    destroy() {
                        this.text.destroy(),
                        this.icon.destroy(),
                        this.hasDebugData() && this.destroyDebugData()
                    }
                    addToLineVertexArray(n, l) {
                        const p = this.lineVertexArray.length;
                        if (n.segment !== void 0) {
                            let _ = n.dist(l[n.segment + 1])
                              , b = n.dist(l[n.segment]);
                            const C = {};
                            for (let M = n.segment + 1; M < l.length; M++)
                                C[M] = {
                                    x: l[M].x,
                                    y: l[M].y,
                                    tileUnitDistanceFromAnchor: _
                                },
                                M < l.length - 1 && (_ += l[M + 1].dist(l[M]));
                            for (let M = n.segment || 0; M >= 0; M--)
                                C[M] = {
                                    x: l[M].x,
                                    y: l[M].y,
                                    tileUnitDistanceFromAnchor: b
                                },
                                M > 0 && (b += l[M - 1].dist(l[M]));
                            for (let M = 0; M < l.length; M++) {
                                const R = C[M];
                                this.lineVertexArray.emplaceBack(R.x, R.y, R.tileUnitDistanceFromAnchor)
                            }
                        }
                        return {
                            lineStartIndex: p,
                            lineLength: this.lineVertexArray.length - p
                        }
                    }
                    addSymbols(n, l, p, _, b, C, M, R, O, j, q, Q) {
                        const ne = n.indexArray
                          , oe = n.layoutVertexArray
                          , de = n.segments.prepareSegment(4 * l.length, oe, ne, this.canOverlap ? C.sortKey : void 0)
                          , we = this.glyphOffsetArray.length
                          , Ie = de.vertexLength
                          , Ye = this.allowVerticalPlacement && M === f.an.vertical ? Math.PI / 2 : 0
                          , Le = C.text && C.text.sections;
                        for (let te = 0; te < l.length; te++) {
                            const {tl: _e, tr: Oe, bl: ft, br: Rt, tex: yt, pixelOffsetTL: bt, pixelOffsetBR: Dt, minFontScaleX: At, minFontScaleY: Ft, glyphOffset: Tt, isSDF: ar, sectionIndex: Mr} = l[te]
                              , Tr = de.vertexLength
                              , pr = Tt[1];
                            gt(oe, R.x, R.y, _e.x, pr + _e.y, yt.x, yt.y, p, ar, bt.x, bt.y, At, Ft),
                            gt(oe, R.x, R.y, Oe.x, pr + Oe.y, yt.x + yt.w, yt.y, p, ar, Dt.x, bt.y, At, Ft),
                            gt(oe, R.x, R.y, ft.x, pr + ft.y, yt.x, yt.y + yt.h, p, ar, bt.x, Dt.y, At, Ft),
                            gt(oe, R.x, R.y, Rt.x, pr + Rt.y, yt.x + yt.w, yt.y + yt.h, p, ar, Dt.x, Dt.y, At, Ft),
                            Zt(n.dynamicLayoutVertexArray, R, Ye),
                            ne.emplaceBack(Tr, Tr + 2, Tr + 1),
                            ne.emplaceBack(Tr + 1, Tr + 2, Tr + 3),
                            de.vertexLength += 4,
                            de.primitiveLength += 2,
                            this.glyphOffsetArray.emplaceBack(Tt[0]),
                            te !== l.length - 1 && Mr === l[te + 1].sectionIndex || n.programConfigurations.populatePaintArrays(oe.length, C, C.index, {}, Q, Le && Le[Mr])
                        }
                        n.placedSymbolArray.emplaceBack(R.x, R.y, we, this.glyphOffsetArray.length - we, Ie, O, j, R.segment, p ? p[0] : 0, p ? p[1] : 0, _[0], _[1], M, 0, !1, 0, q)
                    }
                    _addCollisionDebugVertex(n, l, p, _, b, C) {
                        return l.emplaceBack(0, 0),
                        n.emplaceBack(p.x, p.y, _, b, Math.round(C.x), Math.round(C.y))
                    }
                    addCollisionDebugVertices(n, l, p, _, b, C, M) {
                        const R = b.segments.prepareSegment(4, b.layoutVertexArray, b.indexArray)
                          , O = R.vertexLength
                          , j = b.layoutVertexArray
                          , q = b.collisionVertexArray
                          , Q = M.anchorX
                          , ne = M.anchorY;
                        this._addCollisionDebugVertex(j, q, C, Q, ne, new N(n,l)),
                        this._addCollisionDebugVertex(j, q, C, Q, ne, new N(p,l)),
                        this._addCollisionDebugVertex(j, q, C, Q, ne, new N(p,_)),
                        this._addCollisionDebugVertex(j, q, C, Q, ne, new N(n,_)),
                        R.vertexLength += 4;
                        const oe = b.indexArray;
                        oe.emplaceBack(O, O + 1),
                        oe.emplaceBack(O + 1, O + 2),
                        oe.emplaceBack(O + 2, O + 3),
                        oe.emplaceBack(O + 3, O),
                        R.primitiveLength += 4
                    }
                    addDebugCollisionBoxes(n, l, p, _) {
                        for (let b = n; b < l; b++) {
                            const C = this.collisionBoxArray.get(b);
                            this.addCollisionDebugVertices(C.x1, C.y1, C.x2, C.y2, _ ? this.textCollisionBox : this.iconCollisionBox, C.anchorPoint, p)
                        }
                    }
                    generateCollisionDebugBuffers() {
                        this.hasDebugData() && this.destroyDebugData(),
                        this.textCollisionBox = new Ar(Sn,Gl.members,pn),
                        this.iconCollisionBox = new Ar(Sn,Gl.members,pn);
                        for (let n = 0; n < this.symbolInstances.length; n++) {
                            const l = this.symbolInstances.get(n);
                            this.addDebugCollisionBoxes(l.textBoxStartIndex, l.textBoxEndIndex, l, !0),
                            this.addDebugCollisionBoxes(l.verticalTextBoxStartIndex, l.verticalTextBoxEndIndex, l, !0),
                            this.addDebugCollisionBoxes(l.iconBoxStartIndex, l.iconBoxEndIndex, l, !1),
                            this.addDebugCollisionBoxes(l.verticalIconBoxStartIndex, l.verticalIconBoxEndIndex, l, !1)
                        }
                    }
                    _deserializeCollisionBoxesForSymbol(n, l, p, _, b, C, M, R, O) {
                        const j = {};
                        for (let q = l; q < p; q++) {
                            const Q = n.get(q);
                            j.textBox = {
                                x1: Q.x1,
                                y1: Q.y1,
                                x2: Q.x2,
                                y2: Q.y2,
                                anchorPointX: Q.anchorPointX,
                                anchorPointY: Q.anchorPointY
                            },
                            j.textFeatureIndex = Q.featureIndex;
                            break
                        }
                        for (let q = _; q < b; q++) {
                            const Q = n.get(q);
                            j.verticalTextBox = {
                                x1: Q.x1,
                                y1: Q.y1,
                                x2: Q.x2,
                                y2: Q.y2,
                                anchorPointX: Q.anchorPointX,
                                anchorPointY: Q.anchorPointY
                            },
                            j.verticalTextFeatureIndex = Q.featureIndex;
                            break
                        }
                        for (let q = C; q < M; q++) {
                            const Q = n.get(q);
                            j.iconBox = {
                                x1: Q.x1,
                                y1: Q.y1,
                                x2: Q.x2,
                                y2: Q.y2,
                                anchorPointX: Q.anchorPointX,
                                anchorPointY: Q.anchorPointY
                            },
                            j.iconFeatureIndex = Q.featureIndex;
                            break
                        }
                        for (let q = R; q < O; q++) {
                            const Q = n.get(q);
                            j.verticalIconBox = {
                                x1: Q.x1,
                                y1: Q.y1,
                                x2: Q.x2,
                                y2: Q.y2,
                                anchorPointX: Q.anchorPointX,
                                anchorPointY: Q.anchorPointY
                            },
                            j.verticalIconFeatureIndex = Q.featureIndex;
                            break
                        }
                        return j
                    }
                    deserializeCollisionBoxes(n) {
                        this.collisionArrays = [];
                        for (let l = 0; l < this.symbolInstances.length; l++) {
                            const p = this.symbolInstances.get(l);
                            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(n, p.textBoxStartIndex, p.textBoxEndIndex, p.verticalTextBoxStartIndex, p.verticalTextBoxEndIndex, p.iconBoxStartIndex, p.iconBoxEndIndex, p.verticalIconBoxStartIndex, p.verticalIconBoxEndIndex))
                        }
                    }
                    hasTextData() {
                        return this.text.segments.get().length > 0
                    }
                    hasIconData() {
                        return this.icon.segments.get().length > 0
                    }
                    hasDebugData() {
                        return this.textCollisionBox && this.iconCollisionBox
                    }
                    hasTextCollisionBoxData() {
                        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
                    }
                    hasIconCollisionBoxData() {
                        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
                    }
                    addIndicesForPlacedSymbol(n, l) {
                        const p = n.placedSymbolArray.get(l)
                          , _ = p.vertexStartIndex + 4 * p.numGlyphs;
                        for (let b = p.vertexStartIndex; b < _; b += 4)
                            n.indexArray.emplaceBack(b, b + 2, b + 1),
                            n.indexArray.emplaceBack(b + 1, b + 2, b + 3)
                    }
                    getSortedSymbolIndexes(n) {
                        if (this.sortedAngle === n && this.symbolInstanceIndexes !== void 0)
                            return this.symbolInstanceIndexes;
                        const l = Math.sin(n)
                          , p = Math.cos(n)
                          , _ = []
                          , b = []
                          , C = [];
                        for (let M = 0; M < this.symbolInstances.length; ++M) {
                            C.push(M);
                            const R = this.symbolInstances.get(M);
                            _.push(0 | Math.round(l * R.anchorX + p * R.anchorY)),
                            b.push(R.featureIndex)
                        }
                        return C.sort( (M, R) => _[M] - _[R] || b[R] - b[M]),
                        C
                    }
                    addToSortKeyRanges(n, l) {
                        const p = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                        p && p.sortKey === l ? p.symbolInstanceEnd = n + 1 : this.sortKeyRanges.push({
                            sortKey: l,
                            symbolInstanceStart: n,
                            symbolInstanceEnd: n + 1
                        })
                    }
                    sortFeatures(n) {
                        if (this.sortFeaturesByY && this.sortedAngle !== n && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(n),
                            this.sortedAngle = n,
                            this.text.indexArray.clear(),
                            this.icon.indexArray.clear(),
                            this.featureSortOrder = [];
                            for (const l of this.symbolInstanceIndexes) {
                                const p = this.symbolInstances.get(l);
                                this.featureSortOrder.push(p.featureIndex),
                                [p.rightJustifiedTextSymbolIndex, p.centerJustifiedTextSymbolIndex, p.leftJustifiedTextSymbolIndex].forEach( (_, b, C) => {
                                    _ >= 0 && C.indexOf(_) === b && this.addIndicesForPlacedSymbol(this.text, _)
                                }
                                ),
                                p.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, p.verticalPlacedTextSymbolIndex),
                                p.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, p.placedIconSymbolIndex),
                                p.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, p.verticalPlacedIconSymbolIndex)
                            }
                            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray),
                            this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
                        }
                    }
                }
                let qi, xn;
                Kt("SymbolBucket", Lr, {
                    omit: ["layers", "collisionBoxArray", "features", "compareText"]
                }),
                Lr.MAX_GLYPHS = 65535,
                Lr.addDynamicAttributes = Zt;
                var sl = {
                    get paint() {
                        return xn = xn || new Vn({
                            "icon-opacity": new Cr(Ve.paint_symbol["icon-opacity"]),
                            "icon-color": new Cr(Ve.paint_symbol["icon-color"]),
                            "icon-halo-color": new Cr(Ve.paint_symbol["icon-halo-color"]),
                            "icon-halo-width": new Cr(Ve.paint_symbol["icon-halo-width"]),
                            "icon-halo-blur": new Cr(Ve.paint_symbol["icon-halo-blur"]),
                            "icon-translate": new ir(Ve.paint_symbol["icon-translate"]),
                            "icon-translate-anchor": new ir(Ve.paint_symbol["icon-translate-anchor"]),
                            "text-opacity": new Cr(Ve.paint_symbol["text-opacity"]),
                            "text-color": new Cr(Ve.paint_symbol["text-color"],{
                                runtimeType: Gt,
                                getOverride: c => c.textColor,
                                hasOverride: c => !!c.textColor
                            }),
                            "text-halo-color": new Cr(Ve.paint_symbol["text-halo-color"]),
                            "text-halo-width": new Cr(Ve.paint_symbol["text-halo-width"]),
                            "text-halo-blur": new Cr(Ve.paint_symbol["text-halo-blur"]),
                            "text-translate": new ir(Ve.paint_symbol["text-translate"]),
                            "text-translate-anchor": new ir(Ve.paint_symbol["text-translate-anchor"])
                        })
                    },
                    get layout() {
                        return qi = qi || new Vn({
                            "symbol-placement": new ir(Ve.layout_symbol["symbol-placement"]),
                            "symbol-spacing": new ir(Ve.layout_symbol["symbol-spacing"]),
                            "symbol-avoid-edges": new ir(Ve.layout_symbol["symbol-avoid-edges"]),
                            "symbol-sort-key": new Cr(Ve.layout_symbol["symbol-sort-key"]),
                            "symbol-z-order": new ir(Ve.layout_symbol["symbol-z-order"]),
                            "icon-allow-overlap": new ir(Ve.layout_symbol["icon-allow-overlap"]),
                            "icon-overlap": new ir(Ve.layout_symbol["icon-overlap"]),
                            "icon-ignore-placement": new ir(Ve.layout_symbol["icon-ignore-placement"]),
                            "icon-optional": new ir(Ve.layout_symbol["icon-optional"]),
                            "icon-rotation-alignment": new ir(Ve.layout_symbol["icon-rotation-alignment"]),
                            "icon-size": new Cr(Ve.layout_symbol["icon-size"]),
                            "icon-text-fit": new ir(Ve.layout_symbol["icon-text-fit"]),
                            "icon-text-fit-padding": new ir(Ve.layout_symbol["icon-text-fit-padding"]),
                            "icon-image": new Cr(Ve.layout_symbol["icon-image"]),
                            "icon-rotate": new Cr(Ve.layout_symbol["icon-rotate"]),
                            "icon-padding": new Cr(Ve.layout_symbol["icon-padding"]),
                            "icon-keep-upright": new ir(Ve.layout_symbol["icon-keep-upright"]),
                            "icon-offset": new Cr(Ve.layout_symbol["icon-offset"]),
                            "icon-anchor": new Cr(Ve.layout_symbol["icon-anchor"]),
                            "icon-pitch-alignment": new ir(Ve.layout_symbol["icon-pitch-alignment"]),
                            "text-pitch-alignment": new ir(Ve.layout_symbol["text-pitch-alignment"]),
                            "text-rotation-alignment": new ir(Ve.layout_symbol["text-rotation-alignment"]),
                            "text-field": new Cr(Ve.layout_symbol["text-field"]),
                            "text-font": new Cr(Ve.layout_symbol["text-font"]),
                            "text-size": new Cr(Ve.layout_symbol["text-size"]),
                            "text-max-width": new Cr(Ve.layout_symbol["text-max-width"]),
                            "text-line-height": new ir(Ve.layout_symbol["text-line-height"]),
                            "text-letter-spacing": new Cr(Ve.layout_symbol["text-letter-spacing"]),
                            "text-justify": new Cr(Ve.layout_symbol["text-justify"]),
                            "text-radial-offset": new Cr(Ve.layout_symbol["text-radial-offset"]),
                            "text-variable-anchor": new ir(Ve.layout_symbol["text-variable-anchor"]),
                            "text-variable-anchor-offset": new Cr(Ve.layout_symbol["text-variable-anchor-offset"]),
                            "text-anchor": new Cr(Ve.layout_symbol["text-anchor"]),
                            "text-max-angle": new ir(Ve.layout_symbol["text-max-angle"]),
                            "text-writing-mode": new ir(Ve.layout_symbol["text-writing-mode"]),
                            "text-rotate": new Cr(Ve.layout_symbol["text-rotate"]),
                            "text-padding": new ir(Ve.layout_symbol["text-padding"]),
                            "text-keep-upright": new ir(Ve.layout_symbol["text-keep-upright"]),
                            "text-transform": new Cr(Ve.layout_symbol["text-transform"]),
                            "text-offset": new Cr(Ve.layout_symbol["text-offset"]),
                            "text-allow-overlap": new ir(Ve.layout_symbol["text-allow-overlap"]),
                            "text-overlap": new ir(Ve.layout_symbol["text-overlap"]),
                            "text-ignore-placement": new ir(Ve.layout_symbol["text-ignore-placement"]),
                            "text-optional": new ir(Ve.layout_symbol["text-optional"])
                        })
                    }
                };
                class $y {
                    constructor(n) {
                        if (n.property.overrides === void 0)
                            throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
                        this.type = n.property.overrides ? n.property.overrides.runtimeType : it,
                        this.defaultValue = n
                    }
                    evaluate(n) {
                        if (n.formattedSection) {
                            const l = this.defaultValue.property.overrides;
                            if (l && l.hasOverride(n.formattedSection))
                                return l.getOverride(n.formattedSection)
                        }
                        return n.feature && n.featureState ? this.defaultValue.evaluate(n.feature, n.featureState) : this.defaultValue.property.specification.default
                    }
                    eachChild(n) {
                        this.defaultValue.isConstant() || n(this.defaultValue.value._styleExpression.expression)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        return null
                    }
                }
                Kt("FormatSectionOverride", $y, {
                    omit: ["defaultValue"]
                });
                class Vy extends Ci {
                    constructor(n) {
                        super(n, sl)
                    }
                    recalculate(n, l) {
                        if (super.recalculate(n, l),
                        this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"),
                        this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"),
                        this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"),
                        this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")),
                        this.layout.get("symbol-placement") === "point") {
                            const p = this.layout.get("text-writing-mode");
                            if (p) {
                                const _ = [];
                                for (const b of p)
                                    _.indexOf(b) < 0 && _.push(b);
                                this.layout._values["text-writing-mode"] = _
                            } else
                                this.layout._values["text-writing-mode"] = ["horizontal"]
                        }
                        this._setPaintOverrides()
                    }
                    getValueAndResolveTokens(n, l, p, _) {
                        const b = this.layout.get(n).evaluate(l, {}, p, _)
                          , C = this._unevaluatedLayout._values[n];
                        return C.isDataDriven() || qa(C.value) || !b ? b : function(M, R) {
                            return R.replace(/{([^{}]+)}/g, (O, j) => M && j in M ? String(M[j]) : "")
                        }(l.properties, b)
                    }
                    createBucket(n) {
                        return new Lr(n)
                    }
                    queryRadius() {
                        return 0
                    }
                    queryIntersectsFeature() {
                        throw new Error("Should take a different path in FeatureIndex")
                    }
                    _setPaintOverrides() {
                        for (const n of sl.paint.overridableProperties) {
                            if (!Vy.hasPaintOverride(this.layout, n))
                                continue;
                            const l = this.paint.get(n)
                              , p = new $y(l)
                              , _ = new gc(p,l.property.specification);
                            let b = null;
                            b = l.value.kind === "constant" || l.value.kind === "source" ? new Ws("source",_) : new Cu("composite",_,l.value.zoomStops),
                            this.paint._values[n] = new Qo(l.property,b,l.parameters)
                        }
                    }
                    _handleOverridablePaintPropertyUpdate(n, l, p) {
                        return !(!this.layout || l.isDataDriven() || p.isDataDriven()) && Vy.hasPaintOverride(this.layout, n)
                    }
                    static hasPaintOverride(n, l) {
                        const p = n.get("text-field")
                          , _ = sl.paint.properties[l];
                        let b = !1;
                        const C = M => {
                            for (const R of M)
                                if (_.overrides && _.overrides.hasOverride(R))
                                    return void (b = !0)
                        }
                        ;
                        if (p.value.kind === "constant" && p.value.value instanceof ei)
                            C(p.value.value.sections);
                        else if (p.value.kind === "source") {
                            const M = O => {
                                b || (O instanceof go && Sr(O.value) === ni ? C(O.value.sections) : O instanceof uu ? C(O.sections) : O.eachChild(M))
                            }
                              , R = p.value;
                            R._styleExpression && M(R._styleExpression.expression)
                        }
                        return b
                    }
                }
                let Ib;
                var AM = {
                    get paint() {
                        return Ib = Ib || new Vn({
                            "background-color": new ir(Ve.paint_background["background-color"]),
                            "background-pattern": new Lu(Ve.paint_background["background-pattern"]),
                            "background-opacity": new ir(Ve.paint_background["background-opacity"])
                        })
                    }
                };
                class zM extends Ci {
                    constructor(n) {
                        super(n, AM)
                    }
                }
                let Rb;
                var DM = {
                    get paint() {
                        return Rb = Rb || new Vn({
                            "raster-opacity": new ir(Ve.paint_raster["raster-opacity"]),
                            "raster-hue-rotate": new ir(Ve.paint_raster["raster-hue-rotate"]),
                            "raster-brightness-min": new ir(Ve.paint_raster["raster-brightness-min"]),
                            "raster-brightness-max": new ir(Ve.paint_raster["raster-brightness-max"]),
                            "raster-saturation": new ir(Ve.paint_raster["raster-saturation"]),
                            "raster-contrast": new ir(Ve.paint_raster["raster-contrast"]),
                            "raster-resampling": new ir(Ve.paint_raster["raster-resampling"]),
                            "raster-fade-duration": new ir(Ve.paint_raster["raster-fade-duration"])
                        })
                    }
                };
                class LM extends Ci {
                    constructor(n) {
                        super(n, DM)
                    }
                }
                class OM extends Ci {
                    constructor(n) {
                        super(n, {}),
                        this.onAdd = l => {
                            this.implementation.onAdd && this.implementation.onAdd(l, l.painter.context.gl)
                        }
                        ,
                        this.onRemove = l => {
                            this.implementation.onRemove && this.implementation.onRemove(l, l.painter.context.gl)
                        }
                        ,
                        this.implementation = n
                    }
                    is3D() {
                        return this.implementation.renderingMode === "3d"
                    }
                    hasOffscreenPass() {
                        return this.implementation.prerender !== void 0
                    }
                    recalculate() {}
                    updateTransitions() {}
                    hasTransition() {
                        return !1
                    }
                    serialize() {
                        throw new Error("Custom layers cannot be serialized")
                    }
                }
                class FM {
                    constructor(n) {
                        this._methodToThrottle = n,
                        this._triggered = !1,
                        typeof MessageChannel < "u" && (this._channel = new MessageChannel,
                        this._channel.port2.onmessage = () => {
                            this._triggered = !1,
                            this._methodToThrottle()
                        }
                        )
                    }
                    trigger() {
                        this._triggered || (this._triggered = !0,
                        this._channel ? this._channel.port1.postMessage(!0) : setTimeout( () => {
                            this._triggered = !1,
                            this._methodToThrottle()
                        }
                        , 0))
                    }
                    remove() {
                        delete this._channel,
                        this._methodToThrottle = () => {}
                    }
                }
                const BM = {
                    once: !0
                }
                  , Wv = 63710088e-1;
                class Nh {
                    constructor(n, l) {
                        if (isNaN(n) || isNaN(l))
                            throw new Error(`Invalid LngLat object: (${n}, ${l})`);
                        if (this.lng = +n,
                        this.lat = +l,
                        this.lat > 90 || this.lat < -90)
                            throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
                    }
                    wrap() {
                        return new Nh(Gr(this.lng, -180, 180),this.lat)
                    }
                    toArray() {
                        return [this.lng, this.lat]
                    }
                    toString() {
                        return `LngLat(${this.lng}, ${this.lat})`
                    }
                    distanceTo(n) {
                        const l = Math.PI / 180
                          , p = this.lat * l
                          , _ = n.lat * l
                          , b = Math.sin(p) * Math.sin(_) + Math.cos(p) * Math.cos(_) * Math.cos((n.lng - this.lng) * l);
                        return Wv * Math.acos(Math.min(b, 1))
                    }
                    static convert(n) {
                        if (n instanceof Nh)
                            return n;
                        if (Array.isArray(n) && (n.length === 2 || n.length === 3))
                            return new Nh(Number(n[0]),Number(n[1]));
                        if (!Array.isArray(n) && typeof n == "object" && n !== null)
                            return new Nh(Number("lng"in n ? n.lng : n.lon),Number(n.lat));
                        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
                    }
                }
                const Ab = 2 * Math.PI * Wv;
                function zb(c) {
                    return Ab * Math.cos(c * Math.PI / 180)
                }
                function Db(c) {
                    return (180 + c) / 360
                }
                function Lb(c) {
                    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + c * Math.PI / 360))) / 360
                }
                function Ob(c, n) {
                    return c / zb(n)
                }
                function qv(c) {
                    return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * c) * Math.PI / 180)) - 90
                }
                function Fb(c, n) {
                    return c * zb(qv(n))
                }
                class Om {
                    constructor(n, l, p=0) {
                        this.x = +n,
                        this.y = +l,
                        this.z = +p
                    }
                    static fromLngLat(n, l=0) {
                        const p = Nh.convert(n);
                        return new Om(Db(p.lng),Lb(p.lat),Ob(l, p.lat))
                    }
                    toLngLat() {
                        return new Nh(360 * this.x - 180,qv(this.y))
                    }
                    toAltitude() {
                        return Fb(this.z, this.y)
                    }
                    meterInMercatorCoordinateUnits() {
                        return 1 / Ab * (n = qv(this.y),
                        1 / Math.cos(n * Math.PI / 180));
                        var n
                    }
                }
                function Bb(c, n, l) {
                    var p = 2 * Math.PI * 6378137 / 256 / Math.pow(2, l);
                    return [c * p - 2 * Math.PI * 6378137 / 2, n * p - 2 * Math.PI * 6378137 / 2]
                }
                class Hv {
                    constructor(n, l, p) {
                        if (!function(_, b, C) {
                            return !(_ < 0 || _ > 25 || C < 0 || C >= Math.pow(2, _) || b < 0 || b >= Math.pow(2, _))
                        }(n, l, p))
                            throw new Error(`x=${l}, y=${p}, z=${n} outside of bounds. 0<=x<${Math.pow(2, n)}, 0<=y<${Math.pow(2, n)} 0<=z<=25 `);
                        this.z = n,
                        this.x = l,
                        this.y = p,
                        this.key = ap(0, n, n, l, p)
                    }
                    equals(n) {
                        return this.z === n.z && this.x === n.x && this.y === n.y
                    }
                    url(n, l, p) {
                        const _ = (C = this.y,
                        M = this.z,
                        R = Bb(256 * (b = this.x), 256 * (C = Math.pow(2, M) - C - 1), M),
                        O = Bb(256 * (b + 1), 256 * (C + 1), M),
                        R[0] + "," + R[1] + "," + O[0] + "," + O[1]);
                        var b, C, M, R, O;
                        const j = function(q, Q, ne) {
                            let oe, de = "";
                            for (let we = q; we > 0; we--)
                                oe = 1 << we - 1,
                                de += (Q & oe ? 1 : 0) + (ne & oe ? 2 : 0);
                            return de
                        }(this.z, this.x, this.y);
                        return n[(this.x + this.y) % n.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(p === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, l > 1 ? "@2x" : "").replace(/{quadkey}/g, j).replace(/{bbox-epsg-3857}/g, _)
                    }
                    isChildOf(n) {
                        const l = this.z - n.z;
                        return l > 0 && n.x === this.x >> l && n.y === this.y >> l
                    }
                    getTilePoint(n) {
                        const l = Math.pow(2, this.z);
                        return new N((n.x * l - this.x) * st,(n.y * l - this.y) * st)
                    }
                    toString() {
                        return `${this.z}/${this.x}/${this.y}`
                    }
                }
                class jb {
                    constructor(n, l) {
                        this.wrap = n,
                        this.canonical = l,
                        this.key = ap(n, l.z, l.z, l.x, l.y)
                    }
                }
                class Sa {
                    constructor(n, l, p, _, b) {
                        if (this.terrainRttPosMatrix32f = null,
                        n < p)
                            throw new Error(`overscaledZ should be >= z; overscaledZ = ${n}; z = ${p}`);
                        this.overscaledZ = n,
                        this.wrap = l,
                        this.canonical = new Hv(p,+_,+b),
                        this.key = ap(l, n, p, _, b)
                    }
                    clone() {
                        return new Sa(this.overscaledZ,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    equals(n) {
                        return this.overscaledZ === n.overscaledZ && this.wrap === n.wrap && this.canonical.equals(n.canonical)
                    }
                    scaledTo(n) {
                        if (n > this.overscaledZ)
                            throw new Error(`targetZ > this.overscaledZ; targetZ = ${n}; overscaledZ = ${this.overscaledZ}`);
                        const l = this.canonical.z - n;
                        return n > this.canonical.z ? new Sa(n,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y) : new Sa(n,this.wrap,n,this.canonical.x >> l,this.canonical.y >> l)
                    }
                    calculateScaledKey(n, l) {
                        if (n > this.overscaledZ)
                            throw new Error(`targetZ > this.overscaledZ; targetZ = ${n}; overscaledZ = ${this.overscaledZ}`);
                        const p = this.canonical.z - n;
                        return n > this.canonical.z ? ap(this.wrap * +l, n, this.canonical.z, this.canonical.x, this.canonical.y) : ap(this.wrap * +l, n, n, this.canonical.x >> p, this.canonical.y >> p)
                    }
                    isChildOf(n) {
                        if (n.wrap !== this.wrap)
                            return !1;
                        const l = this.canonical.z - n.canonical.z;
                        return n.overscaledZ === 0 || n.overscaledZ < this.overscaledZ && n.canonical.x === this.canonical.x >> l && n.canonical.y === this.canonical.y >> l
                    }
                    children(n) {
                        if (this.overscaledZ >= n)
                            return [new Sa(this.overscaledZ + 1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];
                        const l = this.canonical.z + 1
                          , p = 2 * this.canonical.x
                          , _ = 2 * this.canonical.y;
                        return [new Sa(l,this.wrap,l,p,_), new Sa(l,this.wrap,l,p + 1,_), new Sa(l,this.wrap,l,p,_ + 1), new Sa(l,this.wrap,l,p + 1,_ + 1)]
                    }
                    isLessThan(n) {
                        return this.wrap < n.wrap || !(this.wrap > n.wrap) && (this.overscaledZ < n.overscaledZ || !(this.overscaledZ > n.overscaledZ) && (this.canonical.x < n.canonical.x || !(this.canonical.x > n.canonical.x) && this.canonical.y < n.canonical.y))
                    }
                    wrapped() {
                        return new Sa(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    unwrapTo(n) {
                        return new Sa(this.overscaledZ,n,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    overscaleFactor() {
                        return Math.pow(2, this.overscaledZ - this.canonical.z)
                    }
                    toUnwrapped() {
                        return new jb(this.wrap,this.canonical)
                    }
                    toString() {
                        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
                    }
                    getTilePoint(n) {
                        return this.canonical.getTilePoint(new Om(n.x - this.wrap,n.y))
                    }
                }
                function ap(c, n, l, p, _) {
                    (c *= 2) < 0 && (c = -1 * c - 1);
                    const b = 1 << l;
                    return (b * b * c + b * _ + p).toString(36) + l.toString(36) + n.toString(36)
                }
                Kt("CanonicalTileID", Hv),
                Kt("OverscaledTileID", Sa, {
                    omit: ["terrainRttPosMatrix32f"]
                });
                class Wd {
                    constructor() {
                        this.minX = 1 / 0,
                        this.maxX = -1 / 0,
                        this.minY = 1 / 0,
                        this.maxY = -1 / 0
                    }
                    extend(n) {
                        return this.minX = Math.min(this.minX, n.x),
                        this.minY = Math.min(this.minY, n.y),
                        this.maxX = Math.max(this.maxX, n.x),
                        this.maxY = Math.max(this.maxY, n.y),
                        this
                    }
                    expandBy(n) {
                        return this.minX -= n,
                        this.minY -= n,
                        this.maxX += n,
                        this.maxY += n,
                        (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0,
                        this.maxX = -1 / 0,
                        this.minY = 1 / 0,
                        this.maxY = -1 / 0),
                        this
                    }
                    shrinkBy(n) {
                        return this.expandBy(-n)
                    }
                    map(n) {
                        const l = new Wd;
                        return l.extend(n(new N(this.minX,this.minY))),
                        l.extend(n(new N(this.maxX,this.minY))),
                        l.extend(n(new N(this.minX,this.maxY))),
                        l.extend(n(new N(this.maxX,this.maxY))),
                        l
                    }
                    static fromPoints(n) {
                        const l = new Wd;
                        for (const p of n)
                            l.extend(p);
                        return l
                    }
                    contains(n) {
                        return n.x >= this.minX && n.x <= this.maxX && n.y >= this.minY && n.y <= this.maxY
                    }
                    empty() {
                        return this.minX > this.maxX
                    }
                    width() {
                        return this.maxX - this.minX
                    }
                    height() {
                        return this.maxY - this.minY
                    }
                    covers(n) {
                        return !this.empty() && !n.empty() && n.minX >= this.minX && n.maxX <= this.maxX && n.minY >= this.minY && n.maxY <= this.maxY
                    }
                    intersects(n) {
                        return !this.empty() && !n.empty() && n.minX <= this.maxX && n.maxX >= this.minX && n.minY <= this.maxY && n.maxY >= this.minY
                    }
                }
                class Nb {
                    constructor(n) {
                        this._stringToNumber = {},
                        this._numberToString = [];
                        for (let l = 0; l < n.length; l++) {
                            const p = n[l];
                            this._stringToNumber[p] = l,
                            this._numberToString[l] = p
                        }
                    }
                    encode(n) {
                        return this._stringToNumber[n]
                    }
                    decode(n) {
                        if (n >= this._numberToString.length)
                            throw new Error(`Out of bounds. Index requested n=${n} can't be >= this._numberToString.length ${this._numberToString.length}`);
                        return this._numberToString[n]
                    }
                }
                class $b {
                    constructor(n, l, p, _, b) {
                        this.type = "Feature",
                        this._vectorTileFeature = n,
                        n._z = l,
                        n._x = p,
                        n._y = _,
                        this.properties = n.properties,
                        this.id = b
                    }
                    get geometry() {
                        return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry),
                        this._geometry
                    }
                    set geometry(n) {
                        this._geometry = n
                    }
                    toJSON() {
                        const n = {
                            geometry: this.geometry
                        };
                        for (const l in this)
                            l !== "_geometry" && l !== "_vectorTileFeature" && (n[l] = this[l]);
                        return n
                    }
                }
                class Vb {
                    constructor(n, l) {
                        this.tileID = n,
                        this.x = n.canonical.x,
                        this.y = n.canonical.y,
                        this.z = n.canonical.z,
                        this.grid = new Wi(st,16,0),
                        this.grid3D = new Wi(st,16,0),
                        this.featureIndexArray = new ht,
                        this.promoteId = l
                    }
                    insert(n, l, p, _, b, C) {
                        const M = this.featureIndexArray.length;
                        this.featureIndexArray.emplaceBack(p, _, b);
                        const R = C ? this.grid3D : this.grid;
                        for (let O = 0; O < l.length; O++) {
                            const j = l[O]
                              , q = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                            for (let Q = 0; Q < j.length; Q++) {
                                const ne = j[Q];
                                q[0] = Math.min(q[0], ne.x),
                                q[1] = Math.min(q[1], ne.y),
                                q[2] = Math.max(q[2], ne.x),
                                q[3] = Math.max(q[3], ne.y)
                            }
                            q[0] < st && q[1] < st && q[2] >= 0 && q[3] >= 0 && R.insert(M, q[0], q[1], q[2], q[3])
                        }
                    }
                    loadVTLayers() {
                        return this.vtLayers || (this.vtLayers = new Zu.VectorTile(new Bh(this.rawTileData)).layers,
                        this.sourceLayerCoder = new Nb(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])),
                        this.vtLayers
                    }
                    query(n, l, p, _) {
                        this.loadVTLayers();
                        const b = n.params
                          , C = st / n.tileSize / n.scale
                          , M = qs(b.filter)
                          , R = n.queryGeometry
                          , O = n.queryPadding * C
                          , j = Wd.fromPoints(R)
                          , q = this.grid.query(j.minX - O, j.minY - O, j.maxX + O, j.maxY + O)
                          , Q = Wd.fromPoints(n.cameraQueryGeometry).expandBy(O)
                          , ne = this.grid3D.query(Q.minX, Q.minY, Q.maxX, Q.maxY, (we, Ie, Ye, Le) => function(te, _e, Oe, ft, Rt) {
                            for (const bt of te)
                                if (_e <= bt.x && Oe <= bt.y && ft >= bt.x && Rt >= bt.y)
                                    return !0;
                            const yt = [new N(_e,Oe), new N(_e,Rt), new N(ft,Rt), new N(ft,Oe)];
                            if (te.length > 2) {
                                for (const bt of yt)
                                    if (Lc(te, bt))
                                        return !0
                            }
                            for (let bt = 0; bt < te.length - 1; bt++)
                                if (by(te[bt], te[bt + 1], yt))
                                    return !0;
                            return !1
                        }(n.cameraQueryGeometry, we - O, Ie - O, Ye + O, Le + O));
                        for (const we of ne)
                            q.push(we);
                        q.sort(jM);
                        const oe = {};
                        let de;
                        for (let we = 0; we < q.length; we++) {
                            const Ie = q[we];
                            if (Ie === de)
                                continue;
                            de = Ie;
                            const Ye = this.featureIndexArray.get(Ie);
                            let Le = null;
                            this.loadMatchingFeature(oe, Ye.bucketIndex, Ye.sourceLayerIndex, Ye.featureIndex, M, b.layers, b.availableImages, l, p, _, (te, _e, Oe) => (Le || (Le = zc(te)),
                            _e.queryIntersectsFeature({
                                queryGeometry: R,
                                feature: te,
                                featureState: Oe,
                                geometry: Le,
                                zoom: this.z,
                                transform: n.transform,
                                pixelsToTileUnits: C,
                                pixelPosMatrix: n.pixelPosMatrix,
                                unwrappedTileID: this.tileID.toUnwrapped(),
                                getElevation: n.getElevation
                            })))
                        }
                        return oe
                    }
                    loadMatchingFeature(n, l, p, _, b, C, M, R, O, j, q) {
                        const Q = this.bucketLayerIDs[l];
                        if (C && !Q.some(we => C.has(we)))
                            return;
                        const ne = this.sourceLayerCoder.decode(p)
                          , oe = this.vtLayers[ne].feature(_);
                        if (b.needGeometry) {
                            const we = Dc(oe, !0);
                            if (!b.filter(new Mn(this.tileID.overscaledZ), we, this.tileID.canonical))
                                return
                        } else if (!b.filter(new Mn(this.tileID.overscaledZ), oe))
                            return;
                        const de = this.getId(oe, ne);
                        for (let we = 0; we < Q.length; we++) {
                            const Ie = Q[we];
                            if (C && !C.has(Ie))
                                continue;
                            const Ye = R[Ie];
                            if (!Ye)
                                continue;
                            let Le = {};
                            de && j && (Le = j.getState(Ye.sourceLayer || "_geojsonTileLayer", de));
                            const te = xr({}, O[Ie]);
                            te.paint = Ub(te.paint, Ye.paint, oe, Le, M),
                            te.layout = Ub(te.layout, Ye.layout, oe, Le, M);
                            const _e = !q || q(oe, Ye, Le);
                            if (!_e)
                                continue;
                            const Oe = new $b(oe,this.z,this.x,this.y,de);
                            Oe.layer = te;
                            let ft = n[Ie];
                            ft === void 0 && (ft = n[Ie] = []),
                            ft.push({
                                featureIndex: _,
                                feature: Oe,
                                intersectionZ: _e
                            })
                        }
                    }
                    lookupSymbolFeatures(n, l, p, _, b, C, M, R) {
                        const O = {};
                        this.loadVTLayers();
                        const j = qs(b);
                        for (const q of n)
                            this.loadMatchingFeature(O, p, _, q, j, C, M, R, l);
                        return O
                    }
                    hasLayer(n) {
                        for (const l of this.bucketLayerIDs)
                            for (const p of l)
                                if (n === p)
                                    return !0;
                        return !1
                    }
                    getId(n, l) {
                        var p;
                        let _ = n.id;
                        return this.promoteId && (_ = n.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[l]],
                        typeof _ == "boolean" && (_ = Number(_)),
                        _ === void 0 && (!((p = n.properties) === null || p === void 0) && p.cluster) && this.promoteId && (_ = Number(n.properties.cluster_id))),
                        _
                    }
                }
                function Ub(c, n, l, p, _) {
                    return ur(c, (b, C) => {
                        const M = n instanceof pa ? n.get(C) : null;
                        return M && M.evaluate ? M.evaluate(l, p, _) : M
                    }
                    )
                }
                function jM(c, n) {
                    return n - c
                }
                function Gb(c, n, l, p, _) {
                    const b = [];
                    for (let C = 0; C < c.length; C++) {
                        const M = c[C];
                        let R;
                        for (let O = 0; O < M.length - 1; O++) {
                            let j = M[O]
                              , q = M[O + 1];
                            j.x < n && q.x < n || (j.x < n ? j = new N(n,j.y + (n - j.x) / (q.x - j.x) * (q.y - j.y))._round() : q.x < n && (q = new N(n,j.y + (n - j.x) / (q.x - j.x) * (q.y - j.y))._round()),
                            j.y < l && q.y < l || (j.y < l ? j = new N(j.x + (l - j.y) / (q.y - j.y) * (q.x - j.x),l)._round() : q.y < l && (q = new N(j.x + (l - j.y) / (q.y - j.y) * (q.x - j.x),l)._round()),
                            j.x >= p && q.x >= p || (j.x >= p ? j = new N(p,j.y + (p - j.x) / (q.x - j.x) * (q.y - j.y))._round() : q.x >= p && (q = new N(p,j.y + (p - j.x) / (q.x - j.x) * (q.y - j.y))._round()),
                            j.y >= _ && q.y >= _ || (j.y >= _ ? j = new N(j.x + (_ - j.y) / (q.y - j.y) * (q.x - j.x),_)._round() : q.y >= _ && (q = new N(j.x + (_ - j.y) / (q.y - j.y) * (q.x - j.x),_)._round()),
                            R && j.equals(R[R.length - 1]) || (R = [j],
                            b.push(R)),
                            R.push(q)))))
                        }
                    }
                    return b
                }
                Kt("FeatureIndex", Vb, {
                    omit: ["rawTileData", "sourceLayerCoder"]
                });
                class $h extends N {
                    constructor(n, l, p, _) {
                        super(n, l),
                        this.angle = p,
                        _ !== void 0 && (this.segment = _)
                    }
                    clone() {
                        return new $h(this.x,this.y,this.angle,this.segment)
                    }
                }
                function Wb(c, n, l, p, _) {
                    if (n.segment === void 0 || l === 0)
                        return !0;
                    let b = n
                      , C = n.segment + 1
                      , M = 0;
                    for (; M > -l / 2; ) {
                        if (C--,
                        C < 0)
                            return !1;
                        M -= c[C].dist(b),
                        b = c[C]
                    }
                    M += c[C].dist(c[C + 1]),
                    C++;
                    const R = [];
                    let O = 0;
                    for (; M < l / 2; ) {
                        const j = c[C]
                          , q = c[C + 1];
                        if (!q)
                            return !1;
                        let Q = c[C - 1].angleTo(j) - j.angleTo(q);
                        for (Q = Math.abs((Q + 3 * Math.PI) % (2 * Math.PI) - Math.PI),
                        R.push({
                            distance: M,
                            angleDelta: Q
                        }),
                        O += Q; M - R[0].distance > p; )
                            O -= R.shift().angleDelta;
                        if (O > _)
                            return !1;
                        C++,
                        M += j.dist(q)
                    }
                    return !0
                }
                function qb(c) {
                    let n = 0;
                    for (let l = 0; l < c.length - 1; l++)
                        n += c[l].dist(c[l + 1]);
                    return n
                }
                function Hb(c, n, l) {
                    return c ? .6 * n * l : 0
                }
                function Zb(c, n) {
                    return Math.max(c ? c.right - c.left : 0, n ? n.right - n.left : 0)
                }
                function NM(c, n, l, p, _, b) {
                    const C = Hb(l, _, b)
                      , M = Zb(l, p) * b;
                    let R = 0;
                    const O = qb(c) / 2;
                    for (let j = 0; j < c.length - 1; j++) {
                        const q = c[j]
                          , Q = c[j + 1]
                          , ne = q.dist(Q);
                        if (R + ne > O) {
                            const oe = (O - R) / ne
                              , de = Xo.number(q.x, Q.x, oe)
                              , we = Xo.number(q.y, Q.y, oe)
                              , Ie = new $h(de,we,Q.angleTo(q),j);
                            return Ie._round(),
                            !C || Wb(c, Ie, M, C, n) ? Ie : void 0
                        }
                        R += ne
                    }
                }
                function $M(c, n, l, p, _, b, C, M, R) {
                    const O = Hb(p, b, C)
                      , j = Zb(p, _)
                      , q = j * C
                      , Q = c[0].x === 0 || c[0].x === R || c[0].y === 0 || c[0].y === R;
                    return n - q < n / 4 && (n = q + n / 4),
                    Xb(c, Q ? n / 2 * M % n : (j / 2 + 2 * b) * C * M % n, n, O, l, q, Q, !1, R)
                }
                function Xb(c, n, l, p, _, b, C, M, R) {
                    const O = b / 2
                      , j = qb(c);
                    let q = 0
                      , Q = n - l
                      , ne = [];
                    for (let oe = 0; oe < c.length - 1; oe++) {
                        const de = c[oe]
                          , we = c[oe + 1]
                          , Ie = de.dist(we)
                          , Ye = we.angleTo(de);
                        for (; Q + l < q + Ie; ) {
                            Q += l;
                            const Le = (Q - q) / Ie
                              , te = Xo.number(de.x, we.x, Le)
                              , _e = Xo.number(de.y, we.y, Le);
                            if (te >= 0 && te < R && _e >= 0 && _e < R && Q - O >= 0 && Q + O <= j) {
                                const Oe = new $h(te,_e,Ye,oe);
                                Oe._round(),
                                p && !Wb(c, Oe, b, p, _) || ne.push(Oe)
                            }
                        }
                        q += Ie
                    }
                    return M || ne.length || C || (ne = Xb(c, q / 2, l, p, _, b, C, !0, R)),
                    ne
                }
                function Yb(c, n, l, p) {
                    const _ = []
                      , b = c.image
                      , C = b.pixelRatio
                      , M = b.paddedRect.w - 2
                      , R = b.paddedRect.h - 2;
                    let O = {
                        x1: c.left,
                        y1: c.top,
                        x2: c.right,
                        y2: c.bottom
                    };
                    const j = b.stretchX || [[0, M]]
                      , q = b.stretchY || [[0, R]]
                      , Q = (Tt, ar) => Tt + ar[1] - ar[0]
                      , ne = j.reduce(Q, 0)
                      , oe = q.reduce(Q, 0)
                      , de = M - ne
                      , we = R - oe;
                    let Ie = 0
                      , Ye = ne
                      , Le = 0
                      , te = oe
                      , _e = 0
                      , Oe = de
                      , ft = 0
                      , Rt = we;
                    if (b.content && p) {
                        const Tt = b.content
                          , ar = Tt[2] - Tt[0]
                          , Mr = Tt[3] - Tt[1];
                        (b.textFitWidth || b.textFitHeight) && (O = Vt(c)),
                        Ie = Uy(j, 0, Tt[0]),
                        Le = Uy(q, 0, Tt[1]),
                        Ye = Uy(j, Tt[0], Tt[2]),
                        te = Uy(q, Tt[1], Tt[3]),
                        _e = Tt[0] - Ie,
                        ft = Tt[1] - Le,
                        Oe = ar - Ye,
                        Rt = Mr - te
                    }
                    const yt = O.x1
                      , bt = O.y1
                      , Dt = O.x2 - yt
                      , At = O.y2 - bt
                      , Ft = (Tt, ar, Mr, Tr) => {
                        const pr = Gy(Tt.stretch - Ie, Ye, Dt, yt)
                          , on = Wy(Tt.fixed - _e, Oe, Tt.stretch, ne)
                          , pi = Gy(ar.stretch - Le, te, At, bt)
                          , Hi = Wy(ar.fixed - ft, Rt, ar.stretch, oe)
                          , $o = Gy(Mr.stretch - Ie, Ye, Dt, yt)
                          , Ca = Wy(Mr.fixed - _e, Oe, Mr.stretch, ne)
                          , Ds = Gy(Tr.stretch - Le, te, At, bt)
                          , To = Wy(Tr.fixed - ft, Rt, Tr.stretch, oe)
                          , ai = new N(pr,pi)
                          , oo = new N($o,pi)
                          , Po = new N($o,Ds)
                          , Mo = new N(pr,Ds)
                          , ms = new N(on / C,Hi / C)
                          , Ta = new N(Ca / C,To / C)
                          , so = n * Math.PI / 180;
                        if (so) {
                            const ao = Math.sin(so)
                              , lo = Math.cos(so)
                              , Fi = [lo, -ao, ao, lo];
                            ai._matMult(Fi),
                            oo._matMult(Fi),
                            Mo._matMult(Fi),
                            Po._matMult(Fi)
                        }
                        const Ls = Tt.stretch + Tt.fixed
                          , Zi = ar.stretch + ar.fixed;
                        return {
                            tl: ai,
                            tr: oo,
                            bl: Mo,
                            br: Po,
                            tex: {
                                x: b.paddedRect.x + 1 + Ls,
                                y: b.paddedRect.y + 1 + Zi,
                                w: Mr.stretch + Mr.fixed - Ls,
                                h: Tr.stretch + Tr.fixed - Zi
                            },
                            writingMode: void 0,
                            glyphOffset: [0, 0],
                            sectionIndex: 0,
                            pixelOffsetTL: ms,
                            pixelOffsetBR: Ta,
                            minFontScaleX: Oe / C / Dt,
                            minFontScaleY: Rt / C / At,
                            isSDF: l
                        }
                    }
                    ;
                    if (p && (b.stretchX || b.stretchY)) {
                        const Tt = Kb(j, de, ne)
                          , ar = Kb(q, we, oe);
                        for (let Mr = 0; Mr < Tt.length - 1; Mr++) {
                            const Tr = Tt[Mr]
                              , pr = Tt[Mr + 1];
                            for (let on = 0; on < ar.length - 1; on++)
                                _.push(Ft(Tr, ar[on], pr, ar[on + 1]))
                        }
                    } else
                        _.push(Ft({
                            fixed: 0,
                            stretch: -1
                        }, {
                            fixed: 0,
                            stretch: -1
                        }, {
                            fixed: 0,
                            stretch: M + 1
                        }, {
                            fixed: 0,
                            stretch: R + 1
                        }));
                    return _
                }
                function Uy(c, n, l) {
                    let p = 0;
                    for (const _ of c)
                        p += Math.max(n, Math.min(l, _[1])) - Math.max(n, Math.min(l, _[0]));
                    return p
                }
                function Kb(c, n, l) {
                    const p = [{
                        fixed: -1,
                        stretch: 0
                    }];
                    for (const [_,b] of c) {
                        const C = p[p.length - 1];
                        p.push({
                            fixed: _ - C.stretch,
                            stretch: C.stretch
                        }),
                        p.push({
                            fixed: _ - C.stretch,
                            stretch: C.stretch + (b - _)
                        })
                    }
                    return p.push({
                        fixed: n + 1,
                        stretch: l
                    }),
                    p
                }
                function Gy(c, n, l, p) {
                    return c / n * l + p
                }
                function Wy(c, n, l, p) {
                    return c - n * l / p
                }
                Kt("Anchor", $h);
                class qy {
                    constructor(n, l, p, _, b, C, M, R, O, j) {
                        var q;
                        if (this.boxStartIndex = n.length,
                        O) {
                            let Q = C.top
                              , ne = C.bottom;
                            const oe = C.collisionPadding;
                            oe && (Q -= oe[1],
                            ne += oe[3]);
                            let de = ne - Q;
                            de > 0 && (de = Math.max(10, de),
                            this.circleDiameter = de)
                        } else {
                            const Q = !((q = C.image) === null || q === void 0) && q.content && (C.image.textFitWidth || C.image.textFitHeight) ? Vt(C) : {
                                x1: C.left,
                                y1: C.top,
                                x2: C.right,
                                y2: C.bottom
                            };
                            Q.y1 = Q.y1 * M - R[0],
                            Q.y2 = Q.y2 * M + R[2],
                            Q.x1 = Q.x1 * M - R[3],
                            Q.x2 = Q.x2 * M + R[1];
                            const ne = C.collisionPadding;
                            if (ne && (Q.x1 -= ne[0] * M,
                            Q.y1 -= ne[1] * M,
                            Q.x2 += ne[2] * M,
                            Q.y2 += ne[3] * M),
                            j) {
                                const oe = new N(Q.x1,Q.y1)
                                  , de = new N(Q.x2,Q.y1)
                                  , we = new N(Q.x1,Q.y2)
                                  , Ie = new N(Q.x2,Q.y2)
                                  , Ye = j * Math.PI / 180;
                                oe._rotate(Ye),
                                de._rotate(Ye),
                                we._rotate(Ye),
                                Ie._rotate(Ye),
                                Q.x1 = Math.min(oe.x, de.x, we.x, Ie.x),
                                Q.x2 = Math.max(oe.x, de.x, we.x, Ie.x),
                                Q.y1 = Math.min(oe.y, de.y, we.y, Ie.y),
                                Q.y2 = Math.max(oe.y, de.y, we.y, Ie.y)
                            }
                            n.emplaceBack(l.x, l.y, Q.x1, Q.y1, Q.x2, Q.y2, p, _, b)
                        }
                        this.boxEndIndex = n.length
                    }
                }
                class VM {
                    constructor(n=[], l= (p, _) => p < _ ? -1 : p > _ ? 1 : 0) {
                        if (this.data = n,
                        this.length = this.data.length,
                        this.compare = l,
                        this.length > 0)
                            for (let p = (this.length >> 1) - 1; p >= 0; p--)
                                this._down(p)
                    }
                    push(n) {
                        this.data.push(n),
                        this._up(this.length++)
                    }
                    pop() {
                        if (this.length === 0)
                            return;
                        const n = this.data[0]
                          , l = this.data.pop();
                        return --this.length > 0 && (this.data[0] = l,
                        this._down(0)),
                        n
                    }
                    peek() {
                        return this.data[0]
                    }
                    _up(n) {
                        const {data: l, compare: p} = this
                          , _ = l[n];
                        for (; n > 0; ) {
                            const b = n - 1 >> 1
                              , C = l[b];
                            if (p(_, C) >= 0)
                                break;
                            l[n] = C,
                            n = b
                        }
                        l[n] = _
                    }
                    _down(n) {
                        const {data: l, compare: p} = this
                          , _ = this.length >> 1
                          , b = l[n];
                        for (; n < _; ) {
                            let C = 1 + (n << 1);
                            const M = C + 1;
                            if (M < this.length && p(l[M], l[C]) < 0 && (C = M),
                            p(l[C], b) >= 0)
                                break;
                            l[n] = l[C],
                            n = C
                        }
                        l[n] = b
                    }
                }
                function UM(c, n=1, l=!1) {
                    const p = Wd.fromPoints(c[0])
                      , _ = Math.min(p.width(), p.height());
                    let b = _ / 2;
                    const C = new VM([],GM)
                      , {minX: M, minY: R, maxX: O, maxY: j} = p;
                    if (_ === 0)
                        return new N(M,R);
                    for (let ne = M; ne < O; ne += _)
                        for (let oe = R; oe < j; oe += _)
                            C.push(new lp(ne + b,oe + b,b,c));
                    let q = function(ne) {
                        let oe = 0
                          , de = 0
                          , we = 0;
                        const Ie = ne[0];
                        for (let Ye = 0, Le = Ie.length, te = Le - 1; Ye < Le; te = Ye++) {
                            const _e = Ie[Ye]
                              , Oe = Ie[te]
                              , ft = _e.x * Oe.y - Oe.x * _e.y;
                            de += (_e.x + Oe.x) * ft,
                            we += (_e.y + Oe.y) * ft,
                            oe += 3 * ft
                        }
                        return new lp(de / oe,we / oe,0,ne)
                    }(c)
                      , Q = C.length;
                    for (; C.length; ) {
                        const ne = C.pop();
                        (ne.d > q.d || !q.d) && (q = ne,
                        l && console.log("found best %d after %d probes", Math.round(1e4 * ne.d) / 1e4, Q)),
                        ne.max - q.d <= n || (b = ne.h / 2,
                        C.push(new lp(ne.p.x - b,ne.p.y - b,b,c)),
                        C.push(new lp(ne.p.x + b,ne.p.y - b,b,c)),
                        C.push(new lp(ne.p.x - b,ne.p.y + b,b,c)),
                        C.push(new lp(ne.p.x + b,ne.p.y + b,b,c)),
                        Q += 4)
                    }
                    return l && (console.log(`num probes: ${Q}`),
                    console.log(`best distance: ${q.d}`)),
                    q.p
                }
                function GM(c, n) {
                    return n.max - c.max
                }
                function lp(c, n, l, p) {
                    this.p = new N(c,n),
                    this.h = l,
                    this.d = function(_, b) {
                        let C = !1
                          , M = 1 / 0;
                        for (let R = 0; R < b.length; R++) {
                            const O = b[R];
                            for (let j = 0, q = O.length, Q = q - 1; j < q; Q = j++) {
                                const ne = O[j]
                                  , oe = O[Q];
                                ne.y > _.y != oe.y > _.y && _.x < (oe.x - ne.x) * (_.y - ne.y) / (oe.y - ne.y) + ne.x && (C = !C),
                                M = Math.min(M, Gf(_, ne, oe))
                            }
                        }
                        return (C ? 1 : -1) * Math.sqrt(M)
                    }(this.p, p),
                    this.max = this.d + this.h * Math.SQRT2
                }
                var No;
                f.aD = void 0,
                (No = f.aD || (f.aD = {}))[No.center = 1] = "center",
                No[No.left = 2] = "left",
                No[No.right = 3] = "right",
                No[No.top = 4] = "top",
                No[No.bottom = 5] = "bottom",
                No[No["top-left"] = 6] = "top-left",
                No[No["top-right"] = 7] = "top-right",
                No[No["bottom-left"] = 8] = "bottom-left",
                No[No["bottom-right"] = 9] = "bottom-right";
                const Zv = Number.POSITIVE_INFINITY;
                function Qb(c, n) {
                    return n[1] !== Zv ? function(l, p, _) {
                        let b = 0
                          , C = 0;
                        switch (p = Math.abs(p),
                        _ = Math.abs(_),
                        l) {
                        case "top-right":
                        case "top-left":
                        case "top":
                            C = _ - 7;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                        case "bottom":
                            C = 7 - _
                        }
                        switch (l) {
                        case "top-right":
                        case "bottom-right":
                        case "right":
                            b = -p;
                            break;
                        case "top-left":
                        case "bottom-left":
                        case "left":
                            b = p
                        }
                        return [b, C]
                    }(c, n[0], n[1]) : function(l, p) {
                        let _ = 0
                          , b = 0;
                        p < 0 && (p = 0);
                        const C = p / Math.SQRT2;
                        switch (l) {
                        case "top-right":
                        case "top-left":
                            b = C - 7;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                            b = 7 - C;
                            break;
                        case "bottom":
                            b = 7 - p;
                            break;
                        case "top":
                            b = p - 7
                        }
                        switch (l) {
                        case "top-right":
                        case "bottom-right":
                            _ = -C;
                            break;
                        case "top-left":
                        case "bottom-left":
                            _ = C;
                            break;
                        case "left":
                            _ = p;
                            break;
                        case "right":
                            _ = -p
                        }
                        return [_, b]
                    }(c, n[0])
                }
                function Jb(c, n, l) {
                    var p;
                    const _ = c.layout
                      , b = (p = _.get("text-variable-anchor-offset")) === null || p === void 0 ? void 0 : p.evaluate(n, {}, l);
                    if (b) {
                        const M = b.values
                          , R = [];
                        for (let O = 0; O < M.length; O += 2) {
                            const j = R[O] = M[O]
                              , q = M[O + 1].map(Q => Q * bi);
                            j.startsWith("top") ? q[1] -= 7 : j.startsWith("bottom") && (q[1] += 7),
                            R[O + 1] = q
                        }
                        return new Yr(R)
                    }
                    const C = _.get("text-variable-anchor");
                    if (C) {
                        let M;
                        M = c._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [_.get("text-radial-offset").evaluate(n, {}, l) * bi, Zv] : _.get("text-offset").evaluate(n, {}, l).map(O => O * bi);
                        const R = [];
                        for (const O of C)
                            R.push(O, Qb(O, M));
                        return new Yr(R)
                    }
                    return null
                }
                function Xv(c) {
                    switch (c) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        return "right";
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        return "left"
                    }
                    return "center"
                }
                function WM(c, n, l, p, _, b, C, M, R, O, j, q) {
                    let Q = b.textMaxSize.evaluate(n, {});
                    Q === void 0 && (Q = C);
                    const ne = c.layers[0].layout
                      , oe = ne.get("icon-offset").evaluate(n, {}, j)
                      , de = t1(l.horizontal)
                      , we = C / 24
                      , Ie = c.tilePixelRatio * we
                      , Ye = c.tilePixelRatio * Q / 24
                      , Le = c.tilePixelRatio * M
                      , te = c.tilePixelRatio * ne.get("symbol-spacing")
                      , _e = ne.get("text-padding") * c.tilePixelRatio
                      , Oe = function(Mr, Tr, pr, on=1) {
                        const pi = Mr.get("icon-padding").evaluate(Tr, {}, pr)
                          , Hi = pi && pi.values;
                        return [Hi[0] * on, Hi[1] * on, Hi[2] * on, Hi[3] * on]
                    }(ne, n, j, c.tilePixelRatio)
                      , ft = ne.get("text-max-angle") / 180 * Math.PI
                      , Rt = ne.get("text-rotation-alignment") !== "viewport" && ne.get("symbol-placement") !== "point"
                      , yt = ne.get("icon-rotation-alignment") === "map" && ne.get("symbol-placement") !== "point"
                      , bt = ne.get("symbol-placement")
                      , Dt = te / 2
                      , At = ne.get("icon-text-fit");
                    let Ft;
                    p && At !== "none" && (c.allowVerticalPlacement && l.vertical && (Ft = Lt(p, l.vertical, At, ne.get("icon-text-fit-padding"), oe, we)),
                    de && (p = Lt(p, de, At, ne.get("icon-text-fit-padding"), oe, we)));
                    const Tt = j ? q.line.getGranularityForZoomLevel(j.z) : 1
                      , ar = (Mr, Tr) => {
                        Tr.x < 0 || Tr.x >= st || Tr.y < 0 || Tr.y >= st || function(pr, on, pi, Hi, $o, Ca, Ds, To, ai, oo, Po, Mo, ms, Ta, so, Ls, Zi, ao, lo, Fi, Jn, ql, cp, Hl, ZM) {
                            const up = pr.addToLineVertexArray(on, pi);
                            let qd, hp, dp, fp, o1 = 0, s1 = 0, a1 = 0, l1 = 0, n0 = -1, i0 = -1;
                            const Ju = {};
                            let c1 = wo("");
                            if (pr.allowVerticalPlacement && Hi.vertical) {
                                const os = To.layout.get("text-rotate").evaluate(Jn, {}, Hl) + 90;
                                dp = new qy(ai,on,oo,Po,Mo,Hi.vertical,ms,Ta,so,os),
                                Ds && (fp = new qy(ai,on,oo,Po,Mo,Ds,Zi,ao,so,os))
                            }
                            if ($o) {
                                const os = To.layout.get("icon-rotate").evaluate(Jn, {})
                                  , Pa = To.layout.get("icon-text-fit") !== "none"
                                  , Hd = Yb($o, os, cp, Pa)
                                  , Xl = Ds ? Yb(Ds, os, cp, Pa) : void 0;
                                hp = new qy(ai,on,oo,Po,Mo,$o,Zi,ao,!1,os),
                                o1 = 4 * Hd.length;
                                const Zd = pr.iconSizeData;
                                let Gc = null;
                                Zd.kind === "source" ? (Gc = [rr * To.layout.get("icon-size").evaluate(Jn, {})],
                                Gc[0] > hr && Zr(`${pr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : Zd.kind === "composite" && (Gc = [rr * ql.compositeIconSizes[0].evaluate(Jn, {}, Hl), rr * ql.compositeIconSizes[1].evaluate(Jn, {}, Hl)],
                                (Gc[0] > hr || Gc[1] > hr) && Zr(`${pr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)),
                                pr.addSymbols(pr.icon, Hd, Gc, Fi, lo, Jn, f.an.none, on, up.lineStartIndex, up.lineLength, -1, Hl),
                                n0 = pr.icon.placedSymbolArray.length - 1,
                                Xl && (s1 = 4 * Xl.length,
                                pr.addSymbols(pr.icon, Xl, Gc, Fi, lo, Jn, f.an.vertical, on, up.lineStartIndex, up.lineLength, -1, Hl),
                                i0 = pr.icon.placedSymbolArray.length - 1)
                            }
                            const u1 = Object.keys(Hi.horizontal);
                            for (const os of u1) {
                                const Pa = Hi.horizontal[os];
                                if (!qd) {
                                    c1 = wo(Pa.text);
                                    const Xl = To.layout.get("text-rotate").evaluate(Jn, {}, Hl);
                                    qd = new qy(ai,on,oo,Po,Mo,Pa,ms,Ta,so,Xl)
                                }
                                const Hd = Pa.positionedLines.length === 1;
                                if (a1 += e1(pr, on, Pa, Ca, To, so, Jn, Ls, up, Hi.vertical ? f.an.horizontal : f.an.horizontalOnly, Hd ? u1 : [os], Ju, n0, ql, Hl),
                                Hd)
                                    break
                            }
                            Hi.vertical && (l1 += e1(pr, on, Hi.vertical, Ca, To, so, Jn, Ls, up, f.an.vertical, ["vertical"], Ju, i0, ql, Hl));
                            const XM = qd ? qd.boxStartIndex : pr.collisionBoxArray.length
                              , YM = qd ? qd.boxEndIndex : pr.collisionBoxArray.length
                              , KM = dp ? dp.boxStartIndex : pr.collisionBoxArray.length
                              , QM = dp ? dp.boxEndIndex : pr.collisionBoxArray.length
                              , JM = hp ? hp.boxStartIndex : pr.collisionBoxArray.length
                              , ek = hp ? hp.boxEndIndex : pr.collisionBoxArray.length
                              , tk = fp ? fp.boxStartIndex : pr.collisionBoxArray.length
                              , rk = fp ? fp.boxEndIndex : pr.collisionBoxArray.length;
                            let Zl = -1;
                            const Zy = (os, Pa) => os && os.circleDiameter ? Math.max(os.circleDiameter, Pa) : Pa;
                            Zl = Zy(qd, Zl),
                            Zl = Zy(dp, Zl),
                            Zl = Zy(hp, Zl),
                            Zl = Zy(fp, Zl);
                            const h1 = Zl > -1 ? 1 : 0;
                            h1 && (Zl *= ZM / bi),
                            pr.glyphOffsetArray.length >= Lr.MAX_GLYPHS && Zr("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),
                            Jn.sortKey !== void 0 && pr.addToSortKeyRanges(pr.symbolInstances.length, Jn.sortKey);
                            const nk = Jb(To, Jn, Hl)
                              , [ik,ok] = function(os, Pa) {
                                const Hd = os.length
                                  , Xl = Pa?.values;
                                if (Xl?.length > 0)
                                    for (let Zd = 0; Zd < Xl.length; Zd += 2) {
                                        const Gc = Xl[Zd + 1];
                                        os.emplaceBack(f.aD[Xl[Zd]], Gc[0], Gc[1])
                                    }
                                return [Hd, os.length]
                            }(pr.textAnchorOffsets, nk);
                            pr.symbolInstances.emplaceBack(on.x, on.y, Ju.right >= 0 ? Ju.right : -1, Ju.center >= 0 ? Ju.center : -1, Ju.left >= 0 ? Ju.left : -1, Ju.vertical || -1, n0, i0, c1, XM, YM, KM, QM, JM, ek, tk, rk, oo, a1, l1, o1, s1, h1, 0, ms, Zl, ik, ok)
                        }(c, Tr, Mr, l, p, _, Ft, c.layers[0], c.collisionBoxArray, n.index, n.sourceLayerIndex, c.index, Ie, [_e, _e, _e, _e], Rt, R, Le, Oe, yt, oe, n, b, O, j, C)
                    }
                    ;
                    if (bt === "line")
                        for (const Mr of Gb(n.geometry, 0, 0, st, st)) {
                            const Tr = nl(Mr, Tt)
                              , pr = $M(Tr, te, ft, l.vertical || de, p, 24, Ye, c.overscaling, st);
                            for (const on of pr)
                                de && qM(c, de.text, Dt, on) || ar(Tr, on)
                        }
                    else if (bt === "line-center") {
                        for (const Mr of n.geometry)
                            if (Mr.length > 1) {
                                const Tr = nl(Mr, Tt)
                                  , pr = NM(Tr, ft, l.vertical || de, p, 24, Ye);
                                pr && ar(Tr, pr)
                            }
                    } else if (n.type === "Polygon")
                        for (const Mr of ja(n.geometry, 0)) {
                            const Tr = UM(Mr, 16);
                            ar(nl(Mr[0], Tt, !0), new $h(Tr.x,Tr.y,0))
                        }
                    else if (n.type === "LineString")
                        for (const Mr of n.geometry) {
                            const Tr = nl(Mr, Tt);
                            ar(Tr, new $h(Tr[0].x,Tr[0].y,0))
                        }
                    else if (n.type === "Point")
                        for (const Mr of n.geometry)
                            for (const Tr of Mr)
                                ar([Tr], new $h(Tr.x,Tr.y,0))
                }
                function e1(c, n, l, p, _, b, C, M, R, O, j, q, Q, ne, oe) {
                    const de = function(Ye, Le, te, _e, Oe, ft, Rt, yt) {
                        const bt = _e.layout.get("text-rotate").evaluate(ft, {}) * Math.PI / 180
                          , Dt = [];
                        for (const At of Le.positionedLines)
                            for (const Ft of At.positionedGlyphs) {
                                if (!Ft.rect)
                                    continue;
                                const Tt = Ft.rect || {};
                                let ar = 4
                                  , Mr = !0
                                  , Tr = 1
                                  , pr = 0;
                                const on = (Oe || yt) && Ft.vertical
                                  , pi = Ft.metrics.advance * Ft.scale / 2;
                                if (yt && Le.verticalizable && (pr = At.lineOffset / 2 - (Ft.imageName ? -(bi - Ft.metrics.width * Ft.scale) / 2 : (Ft.scale - 1) * bi)),
                                Ft.imageName) {
                                    const ao = Rt[Ft.imageName];
                                    Mr = ao.sdf,
                                    Tr = ao.pixelRatio,
                                    ar = 1 / Tr
                                }
                                const Hi = Oe ? [Ft.x + pi, Ft.y] : [0, 0];
                                let $o = Oe ? [0, 0] : [Ft.x + pi + te[0], Ft.y + te[1] - pr]
                                  , Ca = [0, 0];
                                on && (Ca = $o,
                                $o = [0, 0]);
                                const Ds = Ft.metrics.isDoubleResolution ? 2 : 1
                                  , To = (Ft.metrics.left - ar) * Ft.scale - pi + $o[0]
                                  , ai = (-Ft.metrics.top - ar) * Ft.scale + $o[1]
                                  , oo = To + Tt.w / Ds * Ft.scale / Tr
                                  , Po = ai + Tt.h / Ds * Ft.scale / Tr
                                  , Mo = new N(To,ai)
                                  , ms = new N(oo,ai)
                                  , Ta = new N(To,Po)
                                  , so = new N(oo,Po);
                                if (on) {
                                    const ao = new N(-pi,pi - -17)
                                      , lo = -Math.PI / 2
                                      , Fi = 12 - pi
                                      , Jn = new N(22 - Fi,-(Ft.imageName ? Fi : 0))
                                      , ql = new N(...Ca);
                                    Mo._rotateAround(lo, ao)._add(Jn)._add(ql),
                                    ms._rotateAround(lo, ao)._add(Jn)._add(ql),
                                    Ta._rotateAround(lo, ao)._add(Jn)._add(ql),
                                    so._rotateAround(lo, ao)._add(Jn)._add(ql)
                                }
                                if (bt) {
                                    const ao = Math.sin(bt)
                                      , lo = Math.cos(bt)
                                      , Fi = [lo, -ao, ao, lo];
                                    Mo._matMult(Fi),
                                    ms._matMult(Fi),
                                    Ta._matMult(Fi),
                                    so._matMult(Fi)
                                }
                                const Ls = new N(0,0)
                                  , Zi = new N(0,0);
                                Dt.push({
                                    tl: Mo,
                                    tr: ms,
                                    bl: Ta,
                                    br: so,
                                    tex: Tt,
                                    writingMode: Le.writingMode,
                                    glyphOffset: Hi,
                                    sectionIndex: Ft.sectionIndex,
                                    isSDF: Mr,
                                    pixelOffsetTL: Ls,
                                    pixelOffsetBR: Zi,
                                    minFontScaleX: 0,
                                    minFontScaleY: 0
                                })
                            }
                        return Dt
                    }(0, l, M, _, b, C, p, c.allowVerticalPlacement)
                      , we = c.textSizeData;
                    let Ie = null;
                    we.kind === "source" ? (Ie = [rr * _.layout.get("text-size").evaluate(C, {})],
                    Ie[0] > hr && Zr(`${c.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : we.kind === "composite" && (Ie = [rr * ne.compositeTextSizes[0].evaluate(C, {}, oe), rr * ne.compositeTextSizes[1].evaluate(C, {}, oe)],
                    (Ie[0] > hr || Ie[1] > hr) && Zr(`${c.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)),
                    c.addSymbols(c.text, de, Ie, M, b, C, O, n, R.lineStartIndex, R.lineLength, Q, oe);
                    for (const Ye of j)
                        q[Ye] = c.text.placedSymbolArray.length - 1;
                    return 4 * de.length
                }
                function t1(c) {
                    for (const n in c)
                        return c[n];
                    return null
                }
                function qM(c, n, l, p) {
                    const _ = c.compareText;
                    if (n in _) {
                        const b = _[n];
                        for (let C = b.length - 1; C >= 0; C--)
                            if (p.dist(b[C]) < l)
                                return !0
                    } else
                        _[n] = [];
                    return _[n].push(p),
                    !1
                }
                const r1 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
                class Yv {
                    static from(n) {
                        if (!(n instanceof ArrayBuffer))
                            throw new Error("Data must be an instance of ArrayBuffer.");
                        const [l,p] = new Uint8Array(n,0,2);
                        if (l !== 219)
                            throw new Error("Data does not appear to be in a KDBush format.");
                        const _ = p >> 4;
                        if (_ !== 1)
                            throw new Error(`Got v${_} data when expected v1.`);
                        const b = r1[15 & p];
                        if (!b)
                            throw new Error("Unrecognized array type.");
                        const [C] = new Uint16Array(n,2,1)
                          , [M] = new Uint32Array(n,4,1);
                        return new Yv(M,C,b,n)
                    }
                    constructor(n, l=64, p=Float64Array, _) {
                        if (isNaN(n) || n < 0)
                            throw new Error(`Unpexpected numItems value: ${n}.`);
                        this.numItems = +n,
                        this.nodeSize = Math.min(Math.max(+l, 2), 65535),
                        this.ArrayType = p,
                        this.IndexArrayType = n < 65536 ? Uint16Array : Uint32Array;
                        const b = r1.indexOf(this.ArrayType)
                          , C = 2 * n * this.ArrayType.BYTES_PER_ELEMENT
                          , M = n * this.IndexArrayType.BYTES_PER_ELEMENT
                          , R = (8 - M % 8) % 8;
                        if (b < 0)
                            throw new Error(`Unexpected typed array class: ${p}.`);
                        _ && _ instanceof ArrayBuffer ? (this.data = _,
                        this.ids = new this.IndexArrayType(this.data,8,n),
                        this.coords = new this.ArrayType(this.data,8 + M + R,2 * n),
                        this._pos = 2 * n,
                        this._finished = !0) : (this.data = new ArrayBuffer(8 + C + M + R),
                        this.ids = new this.IndexArrayType(this.data,8,n),
                        this.coords = new this.ArrayType(this.data,8 + M + R,2 * n),
                        this._pos = 0,
                        this._finished = !1,
                        new Uint8Array(this.data,0,2).set([219, 16 + b]),
                        new Uint16Array(this.data,2,1)[0] = l,
                        new Uint32Array(this.data,4,1)[0] = n)
                    }
                    add(n, l) {
                        const p = this._pos >> 1;
                        return this.ids[p] = p,
                        this.coords[this._pos++] = n,
                        this.coords[this._pos++] = l,
                        p
                    }
                    finish() {
                        const n = this._pos >> 1;
                        if (n !== this.numItems)
                            throw new Error(`Added ${n} items when expected ${this.numItems}.`);
                        return Kv(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0),
                        this._finished = !0,
                        this
                    }
                    range(n, l, p, _) {
                        if (!this._finished)
                            throw new Error("Data not yet indexed - call index.finish().");
                        const {ids: b, coords: C, nodeSize: M} = this
                          , R = [0, b.length - 1, 0]
                          , O = [];
                        for (; R.length; ) {
                            const j = R.pop() || 0
                              , q = R.pop() || 0
                              , Q = R.pop() || 0;
                            if (q - Q <= M) {
                                for (let we = Q; we <= q; we++) {
                                    const Ie = C[2 * we]
                                      , Ye = C[2 * we + 1];
                                    Ie >= n && Ie <= p && Ye >= l && Ye <= _ && O.push(b[we])
                                }
                                continue
                            }
                            const ne = Q + q >> 1
                              , oe = C[2 * ne]
                              , de = C[2 * ne + 1];
                            oe >= n && oe <= p && de >= l && de <= _ && O.push(b[ne]),
                            (j === 0 ? n <= oe : l <= de) && (R.push(Q),
                            R.push(ne - 1),
                            R.push(1 - j)),
                            (j === 0 ? p >= oe : _ >= de) && (R.push(ne + 1),
                            R.push(q),
                            R.push(1 - j))
                        }
                        return O
                    }
                    within(n, l, p) {
                        if (!this._finished)
                            throw new Error("Data not yet indexed - call index.finish().");
                        const {ids: _, coords: b, nodeSize: C} = this
                          , M = [0, _.length - 1, 0]
                          , R = []
                          , O = p * p;
                        for (; M.length; ) {
                            const j = M.pop() || 0
                              , q = M.pop() || 0
                              , Q = M.pop() || 0;
                            if (q - Q <= C) {
                                for (let we = Q; we <= q; we++)
                                    i1(b[2 * we], b[2 * we + 1], n, l) <= O && R.push(_[we]);
                                continue
                            }
                            const ne = Q + q >> 1
                              , oe = b[2 * ne]
                              , de = b[2 * ne + 1];
                            i1(oe, de, n, l) <= O && R.push(_[ne]),
                            (j === 0 ? n - p <= oe : l - p <= de) && (M.push(Q),
                            M.push(ne - 1),
                            M.push(1 - j)),
                            (j === 0 ? n + p >= oe : l + p >= de) && (M.push(ne + 1),
                            M.push(q),
                            M.push(1 - j))
                        }
                        return R
                    }
                }
                function Kv(c, n, l, p, _, b) {
                    if (_ - p <= l)
                        return;
                    const C = p + _ >> 1;
                    n1(c, n, C, p, _, b),
                    Kv(c, n, l, p, C - 1, 1 - b),
                    Kv(c, n, l, C + 1, _, 1 - b)
                }
                function n1(c, n, l, p, _, b) {
                    for (; _ > p; ) {
                        if (_ - p > 600) {
                            const O = _ - p + 1
                              , j = l - p + 1
                              , q = Math.log(O)
                              , Q = .5 * Math.exp(2 * q / 3)
                              , ne = .5 * Math.sqrt(q * Q * (O - Q) / O) * (j - O / 2 < 0 ? -1 : 1);
                            n1(c, n, l, Math.max(p, Math.floor(l - j * Q / O + ne)), Math.min(_, Math.floor(l + (O - j) * Q / O + ne)), b)
                        }
                        const C = n[2 * l + b];
                        let M = p
                          , R = _;
                        for (Fm(c, n, p, l),
                        n[2 * _ + b] > C && Fm(c, n, p, _); M < R; ) {
                            for (Fm(c, n, M, R),
                            M++,
                            R--; n[2 * M + b] < C; )
                                M++;
                            for (; n[2 * R + b] > C; )
                                R--
                        }
                        n[2 * p + b] === C ? Fm(c, n, p, R) : (R++,
                        Fm(c, n, R, _)),
                        R <= l && (p = R + 1),
                        l <= R && (_ = R - 1)
                    }
                }
                function Fm(c, n, l, p) {
                    Qv(c, l, p),
                    Qv(n, 2 * l, 2 * p),
                    Qv(n, 2 * l + 1, 2 * p + 1)
                }
                function Qv(c, n, l) {
                    const p = c[n];
                    c[n] = c[l],
                    c[l] = p
                }
                function i1(c, n, l, p) {
                    const _ = c - l
                      , b = n - p;
                    return _ * _ + b * b
                }
                var Jv;
                f.cw = void 0,
                (Jv = f.cw || (f.cw = {})).create = "create",
                Jv.load = "load",
                Jv.fullLoad = "fullLoad";
                let Hy = null
                  , Bm = [];
                const e0 = 1e3 / 60
                  , t0 = "loadTime"
                  , r0 = "fullLoadTime"
                  , HM = {
                    mark(c) {
                        performance.mark(c)
                    },
                    frame(c) {
                        const n = c;
                        Hy != null && Bm.push(n - Hy),
                        Hy = n
                    },
                    clearMetrics() {
                        Hy = null,
                        Bm = [],
                        performance.clearMeasures(t0),
                        performance.clearMeasures(r0);
                        for (const c in f.cw)
                            performance.clearMarks(f.cw[c])
                    },
                    getPerformanceMetrics() {
                        performance.measure(t0, f.cw.create, f.cw.load),
                        performance.measure(r0, f.cw.create, f.cw.fullLoad);
                        const c = performance.getEntriesByName(t0)[0].duration
                          , n = performance.getEntriesByName(r0)[0].duration
                          , l = Bm.length
                          , p = 1 / (Bm.reduce( (b, C) => b + C, 0) / l / 1e3)
                          , _ = Bm.filter(b => b > e0).reduce( (b, C) => b + (C - e0) / e0, 0);
                        return {
                            loadTime: c,
                            fullLoadTime: n,
                            fps: p,
                            percentDroppedFrames: _ / (l + _) * 100,
                            totalFrames: l
                        }
                    }
                };
                f.$ = st,
                f.A = me,
                f.B = function([c,n,l]) {
                    return n += 90,
                    n *= Math.PI / 180,
                    l *= Math.PI / 180,
                    {
                        x: c * Math.cos(n) * Math.sin(l),
                        y: c * Math.sin(n) * Math.sin(l),
                        z: c * Math.cos(l)
                    }
                }
                ,
                f.C = Xo,
                f.D = ir,
                f.E = St,
                f.F = Mn,
                f.G = da,
                f.H = function(c) {
                    if (zr == null) {
                        const n = c.navigator ? c.navigator.userAgent : null;
                        zr = !!c.safari || !(!n || !(/\b(iPad|iPhone|iPod)\b/.test(n) || n.match("Safari") && !n.match("Chrome")))
                    }
                    return zr
                }
                ,
                f.I = Vd,
                f.J = class {
                    constructor(c, n) {
                        this.target = c,
                        this.mapId = n,
                        this.resolveRejects = {},
                        this.tasks = {},
                        this.taskQueue = [],
                        this.abortControllers = {},
                        this.messageHandlers = {},
                        this.invoker = new FM( () => this.process()),
                        this.subscription = bn(this.target, "message", l => this.receive(l), !1),
                        this.globalScope = gn(self) ? c : window
                    }
                    registerMessageHandler(c, n) {
                        this.messageHandlers[c] = n
                    }
                    sendAsync(c, n) {
                        return new Promise( (l, p) => {
                            const _ = Math.round(1e18 * Math.random()).toString(36).substring(0, 10)
                              , b = n ? bn(n.signal, "abort", () => {
                                b?.unsubscribe(),
                                delete this.resolveRejects[_];
                                const R = {
                                    id: _,
                                    type: "<cancel>",
                                    origin: location.origin,
                                    targetMapId: c.targetMapId,
                                    sourceMapId: this.mapId
                                };
                                this.target.postMessage(R)
                            }
                            , BM) : null;
                            this.resolveRejects[_] = {
                                resolve: R => {
                                    b?.unsubscribe(),
                                    l(R)
                                }
                                ,
                                reject: R => {
                                    b?.unsubscribe(),
                                    p(R)
                                }
                            };
                            const C = []
                              , M = Object.assign(Object.assign({}, c), {
                                id: _,
                                sourceMapId: this.mapId,
                                origin: location.origin,
                                data: Sc(c.data, C)
                            });
                            this.target.postMessage(M, {
                                transfer: C
                            })
                        }
                        )
                    }
                    receive(c) {
                        const n = c.data
                          , l = n.id;
                        if (!(n.origin !== "file://" && location.origin !== "file://" && n.origin !== "resource://android" && location.origin !== "resource://android" && n.origin !== location.origin || n.targetMapId && this.mapId !== n.targetMapId)) {
                            if (n.type === "<cancel>") {
                                delete this.tasks[l];
                                const p = this.abortControllers[l];
                                return delete this.abortControllers[l],
                                void (p && p.abort())
                            }
                            if (gn(self) || n.mustQueue)
                                return this.tasks[l] = n,
                                this.taskQueue.push(l),
                                void this.invoker.trigger();
                            this.processTask(l, n)
                        }
                    }
                    process() {
                        if (this.taskQueue.length === 0)
                            return;
                        const c = this.taskQueue.shift()
                          , n = this.tasks[c];
                        delete this.tasks[c],
                        this.taskQueue.length > 0 && this.invoker.trigger(),
                        n && this.processTask(c, n)
                    }
                    processTask(c, n) {
                        return o(this, void 0, void 0, function*() {
                            if (n.type === "<response>") {
                                const _ = this.resolveRejects[c];
                                return delete this.resolveRejects[c],
                                _ ? void (n.error ? _.reject(Ka(n.error)) : _.resolve(Ka(n.data))) : void 0
                            }
                            if (!this.messageHandlers[n.type])
                                return void this.completeTask(c, new Error(`Could not find a registered handler for ${n.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
                            const l = Ka(n.data)
                              , p = new AbortController;
                            this.abortControllers[c] = p;
                            try {
                                const _ = yield this.messageHandlers[n.type](n.sourceMapId, l, p);
                                this.completeTask(c, null, _)
                            } catch (_) {
                                this.completeTask(c, _)
                            }
                        })
                    }
                    completeTask(c, n, l) {
                        const p = [];
                        delete this.abortControllers[c];
                        const _ = {
                            id: c,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            origin: location.origin,
                            error: n ? Sc(n) : null,
                            data: Sc(l, p)
                        };
                        this.target.postMessage(_, {
                            transfer: p
                        })
                    }
                    remove() {
                        this.invoker.remove(),
                        this.subscription.unsubscribe()
                    }
                }
                ,
                f.K = ge,
                f.L = function() {
                    var c = new me(16);
                    return me != Float32Array && (c[1] = 0,
                    c[2] = 0,
                    c[3] = 0,
                    c[4] = 0,
                    c[6] = 0,
                    c[7] = 0,
                    c[8] = 0,
                    c[9] = 0,
                    c[11] = 0,
                    c[12] = 0,
                    c[13] = 0,
                    c[14] = 0),
                    c[0] = 1,
                    c[5] = 1,
                    c[10] = 1,
                    c[15] = 1,
                    c
                }
                ,
                f.M = function(c, n, l) {
                    var p, _, b, C, M, R, O, j, q, Q, ne, oe, de = l[0], we = l[1], Ie = l[2];
                    return n === c ? (c[12] = n[0] * de + n[4] * we + n[8] * Ie + n[12],
                    c[13] = n[1] * de + n[5] * we + n[9] * Ie + n[13],
                    c[14] = n[2] * de + n[6] * we + n[10] * Ie + n[14],
                    c[15] = n[3] * de + n[7] * we + n[11] * Ie + n[15]) : (_ = n[1],
                    b = n[2],
                    C = n[3],
                    M = n[4],
                    R = n[5],
                    O = n[6],
                    j = n[7],
                    q = n[8],
                    Q = n[9],
                    ne = n[10],
                    oe = n[11],
                    c[0] = p = n[0],
                    c[1] = _,
                    c[2] = b,
                    c[3] = C,
                    c[4] = M,
                    c[5] = R,
                    c[6] = O,
                    c[7] = j,
                    c[8] = q,
                    c[9] = Q,
                    c[10] = ne,
                    c[11] = oe,
                    c[12] = p * de + M * we + q * Ie + n[12],
                    c[13] = _ * de + R * we + Q * Ie + n[13],
                    c[14] = b * de + O * we + ne * Ie + n[14],
                    c[15] = C * de + j * we + oe * Ie + n[15]),
                    c
                }
                ,
                f.N = function(c, n, l) {
                    var p = l[0]
                      , _ = l[1]
                      , b = l[2];
                    return c[0] = n[0] * p,
                    c[1] = n[1] * p,
                    c[2] = n[2] * p,
                    c[3] = n[3] * p,
                    c[4] = n[4] * _,
                    c[5] = n[5] * _,
                    c[6] = n[6] * _,
                    c[7] = n[7] * _,
                    c[8] = n[8] * b,
                    c[9] = n[9] * b,
                    c[10] = n[10] * b,
                    c[11] = n[11] * b,
                    c[12] = n[12],
                    c[13] = n[13],
                    c[14] = n[14],
                    c[15] = n[15],
                    c
                }
                ,
                f.O = function(c, n, l) {
                    var p = n[0]
                      , _ = n[1]
                      , b = n[2]
                      , C = n[3]
                      , M = n[4]
                      , R = n[5]
                      , O = n[6]
                      , j = n[7]
                      , q = n[8]
                      , Q = n[9]
                      , ne = n[10]
                      , oe = n[11]
                      , de = n[12]
                      , we = n[13]
                      , Ie = n[14]
                      , Ye = n[15]
                      , Le = l[0]
                      , te = l[1]
                      , _e = l[2]
                      , Oe = l[3];
                    return c[0] = Le * p + te * M + _e * q + Oe * de,
                    c[1] = Le * _ + te * R + _e * Q + Oe * we,
                    c[2] = Le * b + te * O + _e * ne + Oe * Ie,
                    c[3] = Le * C + te * j + _e * oe + Oe * Ye,
                    c[4] = (Le = l[4]) * p + (te = l[5]) * M + (_e = l[6]) * q + (Oe = l[7]) * de,
                    c[5] = Le * _ + te * R + _e * Q + Oe * we,
                    c[6] = Le * b + te * O + _e * ne + Oe * Ie,
                    c[7] = Le * C + te * j + _e * oe + Oe * Ye,
                    c[8] = (Le = l[8]) * p + (te = l[9]) * M + (_e = l[10]) * q + (Oe = l[11]) * de,
                    c[9] = Le * _ + te * R + _e * Q + Oe * we,
                    c[10] = Le * b + te * O + _e * ne + Oe * Ie,
                    c[11] = Le * C + te * j + _e * oe + Oe * Ye,
                    c[12] = (Le = l[12]) * p + (te = l[13]) * M + (_e = l[14]) * q + (Oe = l[15]) * de,
                    c[13] = Le * _ + te * R + _e * Q + Oe * we,
                    c[14] = Le * b + te * O + _e * ne + Oe * Ie,
                    c[15] = Le * C + te * j + _e * oe + Oe * Ye,
                    c
                }
                ,
                f.P = N,
                f.Q = function(c, n) {
                    const l = {};
                    for (let p = 0; p < n.length; p++) {
                        const _ = n[p];
                        _ in c && (l[_] = c[_])
                    }
                    return l
                }
                ,
                f.R = Oo,
                f.S = Nh,
                f.T = mr,
                f.U = Lb,
                f.V = Db,
                f.W = ue,
                f.X = ce,
                f.Y = Dn,
                f.Z = Sa,
                f._ = o,
                f.a = se,
                f.a$ = function(c, n, l) {
                    return c[0] = n[0] * l,
                    c[1] = n[1] * l,
                    c[2] = n[2] * l,
                    c[3] = n[3] * l,
                    c
                }
                ,
                f.a0 = Om,
                f.a1 = Wd,
                f.a2 = 25,
                f.a3 = Hv,
                f.a4 = c => {
                    const n = window.document.createElement("video");
                    return n.muted = !0,
                    new Promise(l => {
                        n.onloadstart = () => {
                            l(n)
                        }
                        ;
                        for (const p of c) {
                            const _ = window.document.createElement("source");
                            at(p) || (n.crossOrigin = "Anonymous"),
                            _.src = p,
                            n.appendChild(_)
                        }
                    }
                    )
                }
                ,
                f.a5 = ee,
                f.a6 = function() {
                    return Nr++
                }
                ,
                f.a7 = ye,
                f.a8 = Lr,
                f.a9 = qs,
                f.aA = bi,
                f.aB = Nt,
                f.aC = function(c, n, l, p, _=!1) {
                    if (!l[0] && !l[1])
                        return [0, 0];
                    const b = _ ? p === "map" ? -c.bearingInRadians : 0 : p === "viewport" ? c.bearingInRadians : 0;
                    if (b) {
                        const C = Math.sin(b)
                          , M = Math.cos(b);
                        l = [l[0] * M - l[1] * C, l[0] * C + l[1] * M]
                    }
                    return [_ ? l[0] : Nt(n, l[0], c.zoom), _ ? l[1] : Nt(n, l[1], c.zoom)]
                }
                ,
                f.aE = fi,
                f.aF = Xv,
                f.aG = E,
                f.aH = Yv,
                f.aI = Yn,
                f.aJ = Bo,
                f.aK = ot,
                f.aL = rn,
                f.aM = kn,
                f.aN = Gr,
                f.aO = Mt,
                f.aP = Fb,
                f.aQ = nt,
                f.aR = ct,
                f.aS = function(c) {
                    var n = new me(3);
                    return n[0] = c[0],
                    n[1] = c[1],
                    n[2] = c[2],
                    n
                }
                ,
                f.aT = function(c, n, l) {
                    return c[0] = n[0] - l[0],
                    c[1] = n[1] - l[1],
                    c[2] = n[2] - l[2],
                    c
                }
                ,
                f.aU = function(c, n) {
                    var l = n[0]
                      , p = n[1]
                      , _ = n[2]
                      , b = l * l + p * p + _ * _;
                    return b > 0 && (b = 1 / Math.sqrt(b)),
                    c[0] = n[0] * b,
                    c[1] = n[1] * b,
                    c[2] = n[2] * b,
                    c
                }
                ,
                f.aV = J,
                f.aW = function(c, n) {
                    return c[0] * n[0] + c[1] * n[1] + c[2] * n[2]
                }
                ,
                f.aX = function(c, n, l) {
                    return c[0] = n[0] * l[0],
                    c[1] = n[1] * l[1],
                    c[2] = n[2] * l[2],
                    c[3] = n[3] * l[3],
                    c
                }
                ,
                f.aY = Ce,
                f.aZ = function(c, n, l) {
                    const p = n[0] * l[0] + n[1] * l[1] + n[2] * l[2];
                    return p === 0 ? null : (-(c[0] * l[0] + c[1] * l[1] + c[2] * l[2]) - l[3]) / p
                }
                ,
                f.a_ = ve,
                f.aa = Dc,
                f.ab = $b,
                f.ac = function(c) {
                    const n = {};
                    if (c.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (l, p, _, b) => {
                        const C = _ || b;
                        return n[p] = !C || C.toLowerCase(),
                        ""
                    }
                    ),
                    n["max-age"]) {
                        const l = parseInt(n["max-age"], 10);
                        isNaN(l) ? delete n["max-age"] : n["max-age"] = l
                    }
                    return n
                }
                ,
                f.ad = sn,
                f.ae = function(c) {
                    return Math.pow(2, c)
                }
                ,
                f.af = be,
                f.ag = Yt,
                f.ah = 85.051129,
                f.ai = Ob,
                f.aj = function(c) {
                    return Math.log(c) / Math.LN2
                }
                ,
                f.ak = function(c) {
                    var n = c[0]
                      , l = c[1];
                    return n * n + l * l
                }
                ,
                f.al = function(c, n) {
                    const l = [];
                    for (const p in c)
                        p in n || l.push(p);
                    return l
                }
                ,
                f.am = function(c, n) {
                    let l = 0
                      , p = 0;
                    if (c.kind === "constant")
                        p = c.layoutSize;
                    else if (c.kind !== "source") {
                        const {interpolationType: _, minZoom: b, maxZoom: C} = c
                          , M = _ ? Yt(yo.interpolationFactor(_, n, b, C), 0, 1) : 0;
                        c.kind === "camera" ? p = Xo.number(c.minSize, c.maxSize, M) : l = M
                    }
                    return {
                        uSizeT: l,
                        uSize: p
                    }
                }
                ,
                f.ao = function(c, {uSize: n, uSizeT: l}, {lowerSize: p, upperSize: _}) {
                    return c.kind === "source" ? p / rr : c.kind === "composite" ? Xo.number(p / rr, _ / rr, l) : n
                }
                ,
                f.ap = function(c, n) {
                    var l = n[0]
                      , p = n[1]
                      , _ = n[2]
                      , b = n[3]
                      , C = n[4]
                      , M = n[5]
                      , R = n[6]
                      , O = n[7]
                      , j = n[8]
                      , q = n[9]
                      , Q = n[10]
                      , ne = n[11]
                      , oe = n[12]
                      , de = n[13]
                      , we = n[14]
                      , Ie = n[15]
                      , Ye = l * M - p * C
                      , Le = l * R - _ * C
                      , te = l * O - b * C
                      , _e = p * R - _ * M
                      , Oe = p * O - b * M
                      , ft = _ * O - b * R
                      , Rt = j * de - q * oe
                      , yt = j * we - Q * oe
                      , bt = j * Ie - ne * oe
                      , Dt = q * we - Q * de
                      , At = q * Ie - ne * de
                      , Ft = Q * Ie - ne * we
                      , Tt = Ye * Ft - Le * At + te * Dt + _e * bt - Oe * yt + ft * Rt;
                    return Tt ? (c[0] = (M * Ft - R * At + O * Dt) * (Tt = 1 / Tt),
                    c[1] = (_ * At - p * Ft - b * Dt) * Tt,
                    c[2] = (de * ft - we * Oe + Ie * _e) * Tt,
                    c[3] = (Q * Oe - q * ft - ne * _e) * Tt,
                    c[4] = (R * bt - C * Ft - O * yt) * Tt,
                    c[5] = (l * Ft - _ * bt + b * yt) * Tt,
                    c[6] = (we * te - oe * ft - Ie * Le) * Tt,
                    c[7] = (j * ft - Q * te + ne * Le) * Tt,
                    c[8] = (C * At - M * bt + O * Rt) * Tt,
                    c[9] = (p * bt - l * At - b * Rt) * Tt,
                    c[10] = (oe * Oe - de * te + Ie * Ye) * Tt,
                    c[11] = (q * te - j * Oe - ne * Ye) * Tt,
                    c[12] = (M * yt - C * Dt - R * Rt) * Tt,
                    c[13] = (l * Dt - p * yt + _ * Rt) * Tt,
                    c[14] = (de * Le - oe * _e - we * Ye) * Tt,
                    c[15] = (j * _e - q * Le + Q * Ye) * Tt,
                    c) : null
                }
                ,
                f.aq = Pt,
                f.ar = function(c) {
                    return Math.hypot(c[0], c[1])
                }
                ,
                f.as = function(c) {
                    return c[0] = 0,
                    c[1] = 0,
                    c
                }
                ,
                f.at = function(c, n, l) {
                    return c[0] = n[0] * l,
                    c[1] = n[1] * l,
                    c
                }
                ,
                f.au = Zt,
                f.av = Ne,
                f.aw = function(c, n, l, p) {
                    const _ = n.y - c.y
                      , b = n.x - c.x
                      , C = p.y - l.y
                      , M = p.x - l.x
                      , R = C * b - M * _;
                    if (R === 0)
                        return null;
                    const O = (M * (c.y - l.y) - C * (c.x - l.x)) / R;
                    return new N(c.x + O * b,c.y + O * _)
                }
                ,
                f.ax = Gb,
                f.ay = rs,
                f.az = function(c) {
                    let n = 1 / 0
                      , l = 1 / 0
                      , p = -1 / 0
                      , _ = -1 / 0;
                    for (const b of c)
                        n = Math.min(n, b.x),
                        l = Math.min(l, b.y),
                        p = Math.max(p, b.x),
                        _ = Math.max(_, b.y);
                    return [n, l, p, _]
                }
                ,
                f.b = Wr,
                f.b$ = rp,
                f.b0 = function(c, n) {
                    return c[0] * n[0] + c[1] * n[1] + c[2] * n[2] + c[3]
                }
                ,
                f.b1 = jb,
                f.b2 = ap,
                f.b3 = function(c, n, l, p, _) {
                    var b, C = 1 / Math.tan(n / 2);
                    return c[0] = C / l,
                    c[1] = 0,
                    c[2] = 0,
                    c[3] = 0,
                    c[4] = 0,
                    c[5] = C,
                    c[6] = 0,
                    c[7] = 0,
                    c[8] = 0,
                    c[9] = 0,
                    c[11] = -1,
                    c[12] = 0,
                    c[13] = 0,
                    c[15] = 0,
                    _ != null && _ !== 1 / 0 ? (c[10] = (_ + p) * (b = 1 / (p - _)),
                    c[14] = 2 * _ * p * b) : (c[10] = -1,
                    c[14] = -2 * p),
                    c
                }
                ,
                f.b4 = function(c) {
                    var n = new me(16);
                    return n[0] = c[0],
                    n[1] = c[1],
                    n[2] = c[2],
                    n[3] = c[3],
                    n[4] = c[4],
                    n[5] = c[5],
                    n[6] = c[6],
                    n[7] = c[7],
                    n[8] = c[8],
                    n[9] = c[9],
                    n[10] = c[10],
                    n[11] = c[11],
                    n[12] = c[12],
                    n[13] = c[13],
                    n[14] = c[14],
                    n[15] = c[15],
                    n
                }
                ,
                f.b5 = function(c, n, l) {
                    var p = Math.sin(l)
                      , _ = Math.cos(l)
                      , b = n[0]
                      , C = n[1]
                      , M = n[2]
                      , R = n[3]
                      , O = n[4]
                      , j = n[5]
                      , q = n[6]
                      , Q = n[7];
                    return n !== c && (c[8] = n[8],
                    c[9] = n[9],
                    c[10] = n[10],
                    c[11] = n[11],
                    c[12] = n[12],
                    c[13] = n[13],
                    c[14] = n[14],
                    c[15] = n[15]),
                    c[0] = b * _ + O * p,
                    c[1] = C * _ + j * p,
                    c[2] = M * _ + q * p,
                    c[3] = R * _ + Q * p,
                    c[4] = O * _ - b * p,
                    c[5] = j * _ - C * p,
                    c[6] = q * _ - M * p,
                    c[7] = Q * _ - R * p,
                    c
                }
                ,
                f.b6 = function(c, n, l) {
                    var p = Math.sin(l)
                      , _ = Math.cos(l)
                      , b = n[4]
                      , C = n[5]
                      , M = n[6]
                      , R = n[7]
                      , O = n[8]
                      , j = n[9]
                      , q = n[10]
                      , Q = n[11];
                    return n !== c && (c[0] = n[0],
                    c[1] = n[1],
                    c[2] = n[2],
                    c[3] = n[3],
                    c[12] = n[12],
                    c[13] = n[13],
                    c[14] = n[14],
                    c[15] = n[15]),
                    c[4] = b * _ + O * p,
                    c[5] = C * _ + j * p,
                    c[6] = M * _ + q * p,
                    c[7] = R * _ + Q * p,
                    c[8] = O * _ - b * p,
                    c[9] = j * _ - C * p,
                    c[10] = q * _ - M * p,
                    c[11] = Q * _ - R * p,
                    c
                }
                ,
                f.b7 = function() {
                    const c = new Float32Array(16);
                    return be(c),
                    c
                }
                ,
                f.b8 = function() {
                    const c = new Float64Array(16);
                    return be(c),
                    c
                }
                ,
                f.b9 = function() {
                    return new Float64Array(16)
                }
                ,
                f.bA = function(c) {
                    return c[0] = 0,
                    c[1] = 0,
                    c[2] = 0,
                    c
                }
                ,
                f.bB = function(c, n, l, p) {
                    const _ = Math.sqrt(c * c + n * n)
                      , b = Math.sqrt(l * l + p * p);
                    c /= _,
                    n /= _,
                    l /= b,
                    p /= b;
                    const C = Math.acos(c * l + n * p);
                    return -n * l + c * p > 0 ? C : -C
                }
                ,
                f.bC = function(c, n) {
                    const l = zt(c, 2 * Math.PI)
                      , p = zt(n, 2 * Math.PI);
                    return Math.min(Math.abs(l - p), Math.abs(l - p + 2 * Math.PI), Math.abs(l - p - 2 * Math.PI))
                }
                ,
                f.bD = function() {
                    const c = {}
                      , n = Ve.$version;
                    for (const l in Ve.$root) {
                        const p = Ve.$root[l];
                        if (p.required) {
                            let _ = null;
                            _ = l === "version" ? n : p.type === "array" ? [] : {},
                            _ != null && (c[l] = _)
                        }
                    }
                    return c
                }
                ,
                f.bE = Iu,
                f.bF = $e,
                f.bG = function c(n, l) {
                    if (Array.isArray(n)) {
                        if (!Array.isArray(l) || n.length !== l.length)
                            return !1;
                        for (let p = 0; p < n.length; p++)
                            if (!c(n[p], l[p]))
                                return !1;
                        return !0
                    }
                    if (typeof n == "object" && n !== null && l !== null) {
                        if (typeof l != "object" || Object.keys(n).length !== Object.keys(l).length)
                            return !1;
                        for (const p in n)
                            if (!c(n[p], l[p]))
                                return !1;
                        return !0
                    }
                    return n === l
                }
                ,
                f.bH = function(c) {
                    c = c.slice();
                    const n = Object.create(null);
                    for (let l = 0; l < c.length; l++)
                        n[c[l].id] = c[l];
                    for (let l = 0; l < c.length; l++)
                        "ref"in c[l] && (c[l] = yr(c[l], n[c[l].ref]));
                    return c
                }
                ,
                f.bI = function(c) {
                    if (c.type === "custom")
                        return new OM(c);
                    switch (c.type) {
                    case "background":
                        return new zM(c);
                    case "circle":
                        return new Dv(c);
                    case "color-relief":
                        return new Cy(c);
                    case "fill":
                        return new Cm(c);
                    case "fill-extrusion":
                        return new km(c);
                    case "heatmap":
                        return new Fo(c);
                    case "hillshade":
                        return new Yf(c);
                    case "line":
                        return new Ly(c);
                    case "raster":
                        return new LM(c);
                    case "symbol":
                        return new Vy(c)
                    }
                }
                ,
                f.bJ = gr,
                f.bK = function(c, n) {
                    if (!c)
                        return [{
                            command: "setStyle",
                            args: [n]
                        }];
                    let l = [];
                    try {
                        if (!Ht(c.version, n.version))
                            return [{
                                command: "setStyle",
                                args: [n]
                            }];
                        Ht(c.center, n.center) || l.push({
                            command: "setCenter",
                            args: [n.center]
                        }),
                        Ht(c.state, n.state) || l.push({
                            command: "setGlobalState",
                            args: [n.state]
                        }),
                        Ht(c.centerAltitude, n.centerAltitude) || l.push({
                            command: "setCenterAltitude",
                            args: [n.centerAltitude]
                        }),
                        Ht(c.zoom, n.zoom) || l.push({
                            command: "setZoom",
                            args: [n.zoom]
                        }),
                        Ht(c.bearing, n.bearing) || l.push({
                            command: "setBearing",
                            args: [n.bearing]
                        }),
                        Ht(c.pitch, n.pitch) || l.push({
                            command: "setPitch",
                            args: [n.pitch]
                        }),
                        Ht(c.roll, n.roll) || l.push({
                            command: "setRoll",
                            args: [n.roll]
                        }),
                        Ht(c.sprite, n.sprite) || l.push({
                            command: "setSprite",
                            args: [n.sprite]
                        }),
                        Ht(c.glyphs, n.glyphs) || l.push({
                            command: "setGlyphs",
                            args: [n.glyphs]
                        }),
                        Ht(c.transition, n.transition) || l.push({
                            command: "setTransition",
                            args: [n.transition]
                        }),
                        Ht(c.light, n.light) || l.push({
                            command: "setLight",
                            args: [n.light]
                        }),
                        Ht(c.terrain, n.terrain) || l.push({
                            command: "setTerrain",
                            args: [n.terrain]
                        }),
                        Ht(c.sky, n.sky) || l.push({
                            command: "setSky",
                            args: [n.sky]
                        }),
                        Ht(c.projection, n.projection) || l.push({
                            command: "setProjection",
                            args: [n.projection]
                        });
                        const p = {}
                          , _ = [];
                        (function(C, M, R, O) {
                            let j;
                            for (j in M = M || {},
                            C = C || {})
                                Object.prototype.hasOwnProperty.call(C, j) && (Object.prototype.hasOwnProperty.call(M, j) || en(j, R, O));
                            for (j in M)
                                Object.prototype.hasOwnProperty.call(M, j) && (Object.prototype.hasOwnProperty.call(C, j) ? Ht(C[j], M[j]) || (C[j].type === "geojson" && M[j].type === "geojson" && Dr(C, M, j) ? sr(R, {
                                    command: "setGeoJSONSourceData",
                                    args: [j, M[j].data]
                                }) : qr(j, M, R, O)) : br(j, M, R))
                        }
                        )(c.sources, n.sources, _, p);
                        const b = [];
                        c.layers && c.layers.forEach(C => {
                            "source"in C && p[C.source] ? l.push({
                                command: "removeLayer",
                                args: [C.id]
                            }) : b.push(C)
                        }
                        ),
                        l = l.concat(_),
                        function(C, M, R) {
                            M = M || [];
                            const O = (C = C || []).map(ke)
                              , j = M.map(ke)
                              , q = C.reduce(le, {})
                              , Q = M.reduce(le, {})
                              , ne = O.slice()
                              , oe = Object.create(null);
                            let de, we, Ie, Ye, Le;
                            for (let te = 0, _e = 0; te < O.length; te++)
                                de = O[te],
                                Object.prototype.hasOwnProperty.call(Q, de) ? _e++ : (sr(R, {
                                    command: "removeLayer",
                                    args: [de]
                                }),
                                ne.splice(ne.indexOf(de, _e), 1));
                            for (let te = 0, _e = 0; te < j.length; te++)
                                de = j[j.length - 1 - te],
                                ne[ne.length - 1 - te] !== de && (Object.prototype.hasOwnProperty.call(q, de) ? (sr(R, {
                                    command: "removeLayer",
                                    args: [de]
                                }),
                                ne.splice(ne.lastIndexOf(de, ne.length - _e), 1)) : _e++,
                                Ye = ne[ne.length - te],
                                sr(R, {
                                    command: "addLayer",
                                    args: [Q[de], Ye]
                                }),
                                ne.splice(ne.length - te, 0, de),
                                oe[de] = !0);
                            for (let te = 0; te < j.length; te++)
                                if (de = j[te],
                                we = q[de],
                                Ie = Q[de],
                                !oe[de] && !Ht(we, Ie))
                                    if (Ht(we.source, Ie.source) && Ht(we["source-layer"], Ie["source-layer"]) && Ht(we.type, Ie.type)) {
                                        for (Le in fr(we.layout, Ie.layout, R, de, null, "setLayoutProperty"),
                                        fr(we.paint, Ie.paint, R, de, null, "setPaintProperty"),
                                        Ht(we.filter, Ie.filter) || sr(R, {
                                            command: "setFilter",
                                            args: [de, Ie.filter]
                                        }),
                                        Ht(we.minzoom, Ie.minzoom) && Ht(we.maxzoom, Ie.maxzoom) || sr(R, {
                                            command: "setLayerZoomRange",
                                            args: [de, Ie.minzoom, Ie.maxzoom]
                                        }),
                                        we)
                                            Object.prototype.hasOwnProperty.call(we, Le) && Le !== "layout" && Le !== "paint" && Le !== "filter" && Le !== "metadata" && Le !== "minzoom" && Le !== "maxzoom" && (Le.indexOf("paint.") === 0 ? fr(we[Le], Ie[Le], R, de, Le.slice(6), "setPaintProperty") : Ht(we[Le], Ie[Le]) || sr(R, {
                                                command: "setLayerProperty",
                                                args: [de, Le, Ie[Le]]
                                            }));
                                        for (Le in Ie)
                                            Object.prototype.hasOwnProperty.call(Ie, Le) && !Object.prototype.hasOwnProperty.call(we, Le) && Le !== "layout" && Le !== "paint" && Le !== "filter" && Le !== "metadata" && Le !== "minzoom" && Le !== "maxzoom" && (Le.indexOf("paint.") === 0 ? fr(we[Le], Ie[Le], R, de, Le.slice(6), "setPaintProperty") : Ht(we[Le], Ie[Le]) || sr(R, {
                                                command: "setLayerProperty",
                                                args: [de, Le, Ie[Le]]
                                            }))
                                    } else
                                        sr(R, {
                                            command: "removeLayer",
                                            args: [de]
                                        }),
                                        Ye = ne[ne.lastIndexOf(de) + 1],
                                        sr(R, {
                                            command: "addLayer",
                                            args: [Ie, Ye]
                                        })
                        }(b, n.layers, l)
                    } catch (p) {
                        console.warn("Unable to compute style diff:", p),
                        l = [{
                            command: "setStyle",
                            args: [n]
                        }]
                    }
                    return l
                }
                ,
                f.bL = function(c) {
                    const n = []
                      , l = c.id;
                    return l === void 0 && n.push({
                        message: `layers.${l}: missing required property "id"`
                    }),
                    c.render === void 0 && n.push({
                        message: `layers.${l}: missing required method "render"`
                    }),
                    c.renderingMode && c.renderingMode !== "2d" && c.renderingMode !== "3d" && n.push({
                        message: `layers.${l}: property "renderingMode" must be either "2d" or "3d"`
                    }),
                    n
                }
                ,
                f.bM = ur,
                f.bN = vr,
                f.bO = class extends Bn {
                    constructor(c, n) {
                        super(c, n),
                        this.current = 0
                    }
                    set(c) {
                        this.current !== c && (this.current = c,
                        this.gl.uniform1i(this.location, c))
                    }
                }
                ,
                f.bP = $f,
                f.bQ = class extends Bn {
                    constructor(c, n) {
                        super(c, n),
                        this.current = cm
                    }
                    set(c) {
                        if (c[12] !== this.current[12] || c[0] !== this.current[0])
                            return this.current = c,
                            void this.gl.uniformMatrix4fv(this.location, !1, c);
                        for (let n = 1; n < 16; n++)
                            if (c[n] !== this.current[n]) {
                                this.current = c,
                                this.gl.uniformMatrix4fv(this.location, !1, c);
                                break
                            }
                    }
                }
                ,
                f.bR = Pi,
                f.bS = class extends Bn {
                    constructor(c, n) {
                        super(c, n),
                        this.current = [0, 0, 0]
                    }
                    set(c) {
                        c[0] === this.current[0] && c[1] === this.current[1] && c[2] === this.current[2] || (this.current = c,
                        this.gl.uniform3f(this.location, c[0], c[1], c[2]))
                    }
                }
                ,
                f.bT = class extends Bn {
                    constructor(c, n) {
                        super(c, n),
                        this.current = [0, 0]
                    }
                    set(c) {
                        c[0] === this.current[0] && c[1] === this.current[1] || (this.current = c,
                        this.gl.uniform2f(this.location, c[0], c[1]))
                    }
                }
                ,
                f.bU = K,
                f.bV = function(c, n) {
                    var l = Math.sin(n)
                      , p = Math.cos(n);
                    return c[0] = p,
                    c[1] = l,
                    c[2] = 0,
                    c[3] = -l,
                    c[4] = p,
                    c[5] = 0,
                    c[6] = 0,
                    c[7] = 0,
                    c[8] = 1,
                    c
                }
                ,
                f.bW = function(c, n, l) {
                    var p = n[0]
                      , _ = n[1]
                      , b = n[2];
                    return c[0] = p * l[0] + _ * l[3] + b * l[6],
                    c[1] = p * l[1] + _ * l[4] + b * l[7],
                    c[2] = p * l[2] + _ * l[5] + b * l[8],
                    c
                }
                ,
                f.bX = function(c, n, l, p, _, b, C) {
                    var M = 1 / (n - l)
                      , R = 1 / (p - _)
                      , O = 1 / (b - C);
                    return c[0] = -2 * M,
                    c[1] = 0,
                    c[2] = 0,
                    c[3] = 0,
                    c[4] = 0,
                    c[5] = -2 * R,
                    c[6] = 0,
                    c[7] = 0,
                    c[8] = 0,
                    c[9] = 0,
                    c[10] = 2 * O,
                    c[11] = 0,
                    c[12] = (n + l) * M,
                    c[13] = (_ + p) * R,
                    c[14] = (C + b) * O,
                    c[15] = 1,
                    c
                }
                ,
                f.bY = class extends Bn {
                    constructor(c, n) {
                        super(c, n),
                        this.current = new Array
                    }
                    set(c) {
                        if (c != this.current) {
                            this.current = c;
                            const n = new Float32Array(4 * c.length);
                            for (let l = 0; l < c.length; l++)
                                n[4 * l] = c[l].r,
                                n[4 * l + 1] = c[l].g,
                                n[4 * l + 2] = c[l].b,
                                n[4 * l + 3] = c[l].a;
                            this.gl.uniform4fv(this.location, n)
                        }
                    }
                }
                ,
                f.bZ = class extends Bn {
                    constructor(c, n) {
                        super(c, n),
                        this.current = new Array
                    }
                    set(c) {
                        if (c != this.current) {
                            this.current = c;
                            const n = new Float32Array(c);
                            this.gl.uniform1fv(this.location, n)
                        }
                    }
                }
                ,
                f.b_ = class extends m {
                }
                ,
                f.ba = function(c, n, l) {
                    const p = new Float64Array(4);
                    return lt(p, c, n - 90, l),
                    p
                }
                ,
                f.bb = function(c, n, l, p) {
                    var _, b, C, M, R, O = n[0], j = n[1], q = n[2], Q = n[3], ne = l[0], oe = l[1], de = l[2], we = l[3];
                    return (b = O * ne + j * oe + q * de + Q * we) < 0 && (b = -b,
                    ne = -ne,
                    oe = -oe,
                    de = -de,
                    we = -we),
                    1 - b > X ? (_ = Math.acos(b),
                    C = Math.sin(_),
                    M = Math.sin((1 - p) * _) / C,
                    R = Math.sin(p * _) / C) : (M = 1 - p,
                    R = p),
                    c[0] = M * O + R * ne,
                    c[1] = M * j + R * oe,
                    c[2] = M * q + R * de,
                    c[3] = M * Q + R * we,
                    c
                }
                ,
                f.bc = function(c) {
                    const n = new Float64Array(9);
                    var l, p, _, b, C, M, R, O, j, q, Q, ne, oe, de, we, Ie, Ye, Le;
                    q = (_ = (p = c)[0]) * (R = _ + _),
                    Q = (b = p[1]) * R,
                    oe = (C = p[2]) * R,
                    de = C * (O = b + b),
                    Ie = (M = p[3]) * R,
                    Ye = M * O,
                    Le = M * (j = C + C),
                    (l = n)[0] = 1 - (ne = b * O) - (we = C * j),
                    l[3] = Q - Le,
                    l[6] = oe + Ye,
                    l[1] = Q + Le,
                    l[4] = 1 - q - we,
                    l[7] = de - Ie,
                    l[2] = oe - Ye,
                    l[5] = de + Ie,
                    l[8] = 1 - q - ne;
                    const te = Mt(-Math.asin(Yt(n[2], -1, 1)));
                    let _e, Oe;
                    return Math.hypot(n[5], n[8]) < .001 ? (_e = 0,
                    Oe = -Mt(Math.atan2(n[3], n[4]))) : (_e = Mt(n[5] === 0 && n[8] === 0 ? 0 : Math.atan2(n[5], n[8])),
                    Oe = Mt(n[1] === 0 && n[0] === 0 ? 0 : Math.atan2(n[1], n[0]))),
                    {
                        roll: _e,
                        pitch: te + 90,
                        bearing: Oe
                    }
                }
                ,
                f.bd = function(c, n) {
                    return c.roll == n.roll && c.pitch == n.pitch && c.bearing == n.bearing
                }
                ,
                f.be = Br,
                f.bf = Li,
                f.bg = ba,
                f.bh = di,
                f.bi = xi,
                f.bj = Qt,
                f.bk = Wt,
                f.bl = jr,
                f.bm = function(c, n, l, p, _) {
                    return Qt(p, _, Yt((c - n) / (l - n), 0, 1))
                }
                ,
                f.bn = zt,
                f.bo = function() {
                    return new Float64Array(3)
                }
                ,
                f.bp = function(c, n, l, p) {
                    return c[0] = n[0] + l[0] * p,
                    c[1] = n[1] + l[1] * p,
                    c[2] = n[2] + l[2] * p,
                    c
                }
                ,
                f.bq = lt,
                f.br = function(c, n, l) {
                    var p = l[0]
                      , _ = l[1]
                      , b = l[2]
                      , C = n[0]
                      , M = n[1]
                      , R = n[2]
                      , O = _ * R - b * M
                      , j = b * C - p * R
                      , q = p * M - _ * C
                      , Q = _ * q - b * j
                      , ne = b * O - p * q
                      , oe = p * j - _ * O
                      , de = 2 * l[3];
                    return j *= de,
                    q *= de,
                    ne *= 2,
                    oe *= 2,
                    c[0] = C + (O *= de) + (Q *= 2),
                    c[1] = M + j + ne,
                    c[2] = R + q + oe,
                    c
                }
                ,
                f.bs = function(c, n, l) {
                    const p = (_ = [c[0], c[1], c[2], n[0], n[1], n[2], l[0], l[1], l[2]])[0] * ((j = _[8]) * (C = _[4]) - (M = _[5]) * (O = _[7])) + _[1] * (-j * (b = _[3]) + M * (R = _[6])) + _[2] * (O * b - C * R);
                    var _, b, C, M, R, O, j;
                    if (p === 0)
                        return null;
                    const q = J([], [n[0], n[1], n[2]], [l[0], l[1], l[2]])
                      , Q = J([], [l[0], l[1], l[2]], [c[0], c[1], c[2]])
                      , ne = J([], [c[0], c[1], c[2]], [n[0], n[1], n[2]])
                      , oe = nt([], q, -c[3]);
                    return ct(oe, oe, nt([], Q, -n[3])),
                    ct(oe, oe, nt([], ne, -l[3])),
                    nt(oe, oe, 1 / p),
                    oe
                }
                ,
                f.bt = Wv,
                f.bu = function() {
                    return new Float64Array(4)
                }
                ,
                f.bv = function(c, n, l, p) {
                    var _ = []
                      , b = [];
                    return _[0] = n[0] - l[0],
                    _[1] = n[1] - l[1],
                    _[2] = n[2] - l[2],
                    b[0] = _[0] * Math.cos(p) - _[1] * Math.sin(p),
                    b[1] = _[0] * Math.sin(p) + _[1] * Math.cos(p),
                    b[2] = _[2],
                    c[0] = b[0] + l[0],
                    c[1] = b[1] + l[1],
                    c[2] = b[2] + l[2],
                    c
                }
                ,
                f.bw = function(c, n, l, p) {
                    var _ = []
                      , b = [];
                    return _[0] = n[0] - l[0],
                    _[1] = n[1] - l[1],
                    _[2] = n[2] - l[2],
                    b[0] = _[0],
                    b[1] = _[1] * Math.cos(p) - _[2] * Math.sin(p),
                    b[2] = _[1] * Math.sin(p) + _[2] * Math.cos(p),
                    c[0] = b[0] + l[0],
                    c[1] = b[1] + l[1],
                    c[2] = b[2] + l[2],
                    c
                }
                ,
                f.bx = function(c, n, l, p) {
                    var _ = []
                      , b = [];
                    return _[0] = n[0] - l[0],
                    _[1] = n[1] - l[1],
                    _[2] = n[2] - l[2],
                    b[0] = _[2] * Math.sin(p) + _[0] * Math.cos(p),
                    b[1] = _[1],
                    b[2] = _[2] * Math.cos(p) - _[0] * Math.sin(p),
                    c[0] = b[0] + l[0],
                    c[1] = b[1] + l[1],
                    c[2] = b[2] + l[2],
                    c
                }
                ,
                f.by = function(c, n, l) {
                    var p = Math.sin(l)
                      , _ = Math.cos(l)
                      , b = n[0]
                      , C = n[1]
                      , M = n[2]
                      , R = n[3]
                      , O = n[8]
                      , j = n[9]
                      , q = n[10]
                      , Q = n[11];
                    return n !== c && (c[4] = n[4],
                    c[5] = n[5],
                    c[6] = n[6],
                    c[7] = n[7],
                    c[12] = n[12],
                    c[13] = n[13],
                    c[14] = n[14],
                    c[15] = n[15]),
                    c[0] = b * _ - O * p,
                    c[1] = C * _ - j * p,
                    c[2] = M * _ - q * p,
                    c[3] = R * _ - Q * p,
                    c[8] = b * p + O * _,
                    c[9] = C * p + j * _,
                    c[10] = M * p + q * _,
                    c[11] = R * p + Q * _,
                    c
                }
                ,
                f.bz = function(c, n) {
                    const l = zt(c, 360)
                      , p = zt(n, 360)
                      , _ = p - l
                      , b = p > l ? _ - 360 : _ + 360;
                    return Math.abs(_) < Math.abs(b) ? _ : b
                }
                ,
                f.c = Ue,
                f.c0 = class extends x {
                }
                ,
                f.c1 = Vu,
                f.c2 = function(c) {
                    return c <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(c) / Math.LN2))
                }
                ,
                f.c3 = _m,
                f.c4 = function(c, n, l) {
                    var p = n[0]
                      , _ = n[1]
                      , b = n[2]
                      , C = l[3] * p + l[7] * _ + l[11] * b + l[15];
                    return c[0] = (l[0] * p + l[4] * _ + l[8] * b + l[12]) / (C = C || 1),
                    c[1] = (l[1] * p + l[5] * _ + l[9] * b + l[13]) / C,
                    c[2] = (l[2] * p + l[6] * _ + l[10] * b + l[14]) / C,
                    c
                }
                ,
                f.c5 = class extends kc {
                }
                ,
                f.c6 = class extends H {
                }
                ,
                f.c7 = function(c, n) {
                    return c[0] === n[0] && c[1] === n[1] && c[2] === n[2] && c[3] === n[3] && c[4] === n[4] && c[5] === n[5] && c[6] === n[6] && c[7] === n[7] && c[8] === n[8] && c[9] === n[9] && c[10] === n[10] && c[11] === n[11] && c[12] === n[12] && c[13] === n[13] && c[14] === n[14] && c[15] === n[15]
                }
                ,
                f.c8 = function(c, n) {
                    var l = c[0]
                      , p = c[1]
                      , _ = c[2]
                      , b = c[3]
                      , C = c[4]
                      , M = c[5]
                      , R = c[6]
                      , O = c[7]
                      , j = c[8]
                      , q = c[9]
                      , Q = c[10]
                      , ne = c[11]
                      , oe = c[12]
                      , de = c[13]
                      , we = c[14]
                      , Ie = c[15]
                      , Ye = n[0]
                      , Le = n[1]
                      , te = n[2]
                      , _e = n[3]
                      , Oe = n[4]
                      , ft = n[5]
                      , Rt = n[6]
                      , yt = n[7]
                      , bt = n[8]
                      , Dt = n[9]
                      , At = n[10]
                      , Ft = n[11]
                      , Tt = n[12]
                      , ar = n[13]
                      , Mr = n[14]
                      , Tr = n[15];
                    return Math.abs(l - Ye) <= X * Math.max(1, Math.abs(l), Math.abs(Ye)) && Math.abs(p - Le) <= X * Math.max(1, Math.abs(p), Math.abs(Le)) && Math.abs(_ - te) <= X * Math.max(1, Math.abs(_), Math.abs(te)) && Math.abs(b - _e) <= X * Math.max(1, Math.abs(b), Math.abs(_e)) && Math.abs(C - Oe) <= X * Math.max(1, Math.abs(C), Math.abs(Oe)) && Math.abs(M - ft) <= X * Math.max(1, Math.abs(M), Math.abs(ft)) && Math.abs(R - Rt) <= X * Math.max(1, Math.abs(R), Math.abs(Rt)) && Math.abs(O - yt) <= X * Math.max(1, Math.abs(O), Math.abs(yt)) && Math.abs(j - bt) <= X * Math.max(1, Math.abs(j), Math.abs(bt)) && Math.abs(q - Dt) <= X * Math.max(1, Math.abs(q), Math.abs(Dt)) && Math.abs(Q - At) <= X * Math.max(1, Math.abs(Q), Math.abs(At)) && Math.abs(ne - Ft) <= X * Math.max(1, Math.abs(ne), Math.abs(Ft)) && Math.abs(oe - Tt) <= X * Math.max(1, Math.abs(oe), Math.abs(Tt)) && Math.abs(de - ar) <= X * Math.max(1, Math.abs(de), Math.abs(ar)) && Math.abs(we - Mr) <= X * Math.max(1, Math.abs(we), Math.abs(Mr)) && Math.abs(Ie - Tr) <= X * Math.max(1, Math.abs(Ie), Math.abs(Tr))
                }
                ,
                f.c9 = function(c, n) {
                    return c[0] = n[0],
                    c[1] = n[1],
                    c[2] = n[2],
                    c[3] = n[3],
                    c[4] = n[4],
                    c[5] = n[5],
                    c[6] = n[6],
                    c[7] = n[7],
                    c[8] = n[8],
                    c[9] = n[9],
                    c[10] = n[10],
                    c[11] = n[11],
                    c[12] = n[12],
                    c[13] = n[13],
                    c[14] = n[14],
                    c[15] = n[15],
                    c
                }
                ,
                f.cA = function(c) {
                    delete se.REGISTERED_PROTOCOLS[c]
                }
                ,
                f.cB = function(c, n) {
                    const l = {};
                    for (let _ = 0; _ < c.length; _++) {
                        const b = n && n[c[_].id] || Mu(c[_]);
                        n && (n[c[_].id] = b);
                        let C = l[b];
                        C || (C = l[b] = []),
                        C.push(c[_])
                    }
                    const p = [];
                    for (const _ in l)
                        p.push(l[_]);
                    return p
                }
                ,
                f.cC = Kt,
                f.cD = Nb,
                f.cE = Vb,
                f.cF = Ud,
                f.cG = function(c) {
                    c.bucket.createArrays(),
                    c.bucket.tilePixelRatio = st / (512 * c.bucket.overscaling),
                    c.bucket.compareText = {},
                    c.bucket.iconsNeedLinear = !1;
                    const n = c.bucket.layers[0]
                      , l = n.layout
                      , p = n._unevaluatedLayout._values
                      , _ = {
                        layoutIconSize: p["icon-size"].possiblyEvaluate(new Mn(c.bucket.zoom + 1), c.canonical),
                        layoutTextSize: p["text-size"].possiblyEvaluate(new Mn(c.bucket.zoom + 1), c.canonical),
                        textMaxSize: p["text-size"].possiblyEvaluate(new Mn(18))
                    };
                    if (c.bucket.textSizeData.kind === "composite") {
                        const {minZoom: O, maxZoom: j} = c.bucket.textSizeData;
                        _.compositeTextSizes = [p["text-size"].possiblyEvaluate(new Mn(O), c.canonical), p["text-size"].possiblyEvaluate(new Mn(j), c.canonical)]
                    }
                    if (c.bucket.iconSizeData.kind === "composite") {
                        const {minZoom: O, maxZoom: j} = c.bucket.iconSizeData;
                        _.compositeIconSizes = [p["icon-size"].possiblyEvaluate(new Mn(O), c.canonical), p["icon-size"].possiblyEvaluate(new Mn(j), c.canonical)]
                    }
                    const b = l.get("text-line-height") * bi
                      , C = l.get("text-rotation-alignment") !== "viewport" && l.get("symbol-placement") !== "point"
                      , M = l.get("text-keep-upright")
                      , R = l.get("text-size");
                    for (const O of c.bucket.features) {
                        const j = l.get("text-font").evaluate(O, {}, c.canonical).join(",")
                          , q = R.evaluate(O, {}, c.canonical)
                          , Q = _.layoutTextSize.evaluate(O, {}, c.canonical)
                          , ne = _.layoutIconSize.evaluate(O, {}, c.canonical)
                          , oe = {
                            horizontal: {},
                            vertical: void 0
                        }
                          , de = O.text;
                        let we, Ie = [0, 0];
                        if (de) {
                            const te = de.toString()
                              , _e = l.get("text-letter-spacing").evaluate(O, {}, c.canonical) * bi
                              , Oe = Xn(te) ? _e : 0
                              , ft = l.get("text-anchor").evaluate(O, {}, c.canonical)
                              , Rt = Jb(n, O, c.canonical);
                            if (!Rt) {
                                const At = l.get("text-radial-offset").evaluate(O, {}, c.canonical);
                                Ie = At ? Qb(ft, [At * bi, Zv]) : l.get("text-offset").evaluate(O, {}, c.canonical).map(Ft => Ft * bi)
                            }
                            let yt = C ? "center" : l.get("text-justify").evaluate(O, {}, c.canonical);
                            const bt = l.get("symbol-placement") === "point" ? l.get("text-max-width").evaluate(O, {}, c.canonical) * bi : 1 / 0
                              , Dt = () => {
                                c.bucket.allowVerticalPlacement && vo(te) && (oe.vertical = Gd(de, c.glyphMap, c.glyphPositions, c.imagePositions, j, bt, b, ft, "left", Oe, Ie, f.an.vertical, !0, Q, q))
                            }
                            ;
                            if (!C && Rt) {
                                const At = new Set;
                                if (yt === "auto")
                                    for (let Tt = 0; Tt < Rt.values.length; Tt += 2)
                                        At.add(Xv(Rt.values[Tt]));
                                else
                                    At.add(yt);
                                let Ft = !1;
                                for (const Tt of At)
                                    if (!oe.horizontal[Tt])
                                        if (Ft)
                                            oe.horizontal[Tt] = oe.horizontal[0];
                                        else {
                                            const ar = Gd(de, c.glyphMap, c.glyphPositions, c.imagePositions, j, bt, b, "center", Tt, Oe, Ie, f.an.horizontal, !1, Q, q);
                                            ar && (oe.horizontal[Tt] = ar,
                                            Ft = ar.positionedLines.length === 1)
                                        }
                                Dt()
                            } else {
                                yt === "auto" && (yt = Xv(ft));
                                const At = Gd(de, c.glyphMap, c.glyphPositions, c.imagePositions, j, bt, b, ft, yt, Oe, Ie, f.an.horizontal, !1, Q, q);
                                At && (oe.horizontal[yt] = At),
                                Dt(),
                                vo(te) && C && M && (oe.vertical = Gd(de, c.glyphMap, c.glyphPositions, c.imagePositions, j, bt, b, ft, yt, Oe, Ie, f.an.vertical, !1, Q, q))
                            }
                        }
                        let Ye = !1;
                        if (O.icon && O.icon.name) {
                            const te = c.imageMap[O.icon.name];
                            te && (we = Bt(c.imagePositions[O.icon.name], l.get("icon-offset").evaluate(O, {}, c.canonical), l.get("icon-anchor").evaluate(O, {}, c.canonical)),
                            Ye = !!te.sdf,
                            c.bucket.sdfIcons === void 0 ? c.bucket.sdfIcons = Ye : c.bucket.sdfIcons !== Ye && Zr("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),
                            (te.pixelRatio !== c.bucket.pixelRatio || l.get("icon-rotate").constantOr(1) !== 0) && (c.bucket.iconsNeedLinear = !0))
                        }
                        const Le = t1(oe.horizontal) || oe.vertical;
                        c.bucket.iconsInText = !!Le && Le.iconsInText,
                        (Le || we) && WM(c.bucket, O, oe, we, c.imageMap, _, Q, ne, Ie, Ye, c.canonical, c.subdivisionGranularity)
                    }
                    c.showCollisionBoxes && c.bucket.generateCollisionDebugBuffers()
                }
                ,
                f.cH = si,
                f.cI = Od,
                f.cJ = jd,
                f.cK = Zu,
                f.cL = Bh,
                f.cM = class {
                    constructor(c) {
                        this._marks = {
                            start: [c.url, "start"].join("#"),
                            end: [c.url, "end"].join("#"),
                            measure: c.url.toString()
                        },
                        performance.mark(this._marks.start)
                    }
                    finish() {
                        performance.mark(this._marks.end);
                        let c = performance.getEntriesByName(this._marks.measure);
                        return c.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end),
                        c = performance.getEntriesByName(this._marks.measure),
                        performance.clearMarks(this._marks.start),
                        performance.clearMarks(this._marks.end),
                        performance.clearMeasures(this._marks.measure)),
                        c
                    }
                }
                ,
                f.cN = function(c, n, l, p, _) {
                    return o(this, void 0, void 0, function*() {
                        if (ce())
                            try {
                                return yield Dn(c, n, l, p, _)
                            } catch {}
                        return function(b, C, M, R, O) {
                            const j = b.width
                              , q = b.height;
                            yn && Tn || (yn = new OffscreenCanvas(j,q),
                            Tn = yn.getContext("2d", {
                                willReadFrequently: !0
                            })),
                            yn.width = j,
                            yn.height = q,
                            Tn.drawImage(b, 0, 0, j, q);
                            const Q = Tn.getImageData(C, M, R, O);
                            return Tn.clearRect(0, 0, j, q),
                            Q.data
                        }(c, n, l, p, _)
                    })
                }
                ,
                f.cO = Uu,
                f.cP = w,
                f.cQ = L,
                f.cR = tp,
                f.cS = zm,
                f.cT = Il,
                f.cU = Qa,
                f.ca = c => c.type === "symbol",
                f.cb = c => c.type === "circle",
                f.cc = c => c.type === "heatmap",
                f.cd = c => c.type === "line",
                f.ce = c => c.type === "fill",
                f.cf = c => c.type === "fill-extrusion",
                f.cg = c => c.type === "hillshade",
                f.ch = c => c.type === "color-relief",
                f.ci = c => c.type === "raster",
                f.cj = c => c.type === "background",
                f.ck = c => c.type === "custom",
                f.cl = tr,
                f.cm = function(c, n, l) {
                    const p = We(n.x - l.x, n.y - l.y)
                      , _ = We(c.x - l.x, c.y - l.y);
                    var b, C;
                    return Mt(Math.atan2(p[0] * _[1] - p[1] * _[0], (b = p)[0] * (C = _)[0] + b[1] * C[1]))
                }
                ,
                f.cn = cr,
                f.co = function(c, n) {
                    return er[n] && (c instanceof MouseEvent || c instanceof WheelEvent)
                }
                ,
                f.cp = function(c, n) {
                    return kt[n] && "touches"in c
                }
                ,
                f.cq = function(c) {
                    return kt[c] || er[c]
                }
                ,
                f.cr = function(c, n, l) {
                    var p = n[0]
                      , _ = n[1];
                    return c[0] = l[0] * p + l[4] * _ + l[12],
                    c[1] = l[1] * p + l[5] * _ + l[13],
                    c
                }
                ,
                f.cs = function(c, n) {
                    const {x: l, y: p} = Om.fromLngLat(n);
                    return !(c < 0 || c > 25 || p < 0 || p >= 1 || l < 0 || l >= 1)
                }
                ,
                f.ct = function(c, n) {
                    return c[0] = n[0],
                    c[1] = 0,
                    c[2] = 0,
                    c[3] = 0,
                    c[4] = 0,
                    c[5] = n[1],
                    c[6] = 0,
                    c[7] = 0,
                    c[8] = 0,
                    c[9] = 0,
                    c[10] = n[2],
                    c[11] = 0,
                    c[12] = 0,
                    c[13] = 0,
                    c[14] = 0,
                    c[15] = 1,
                    c
                }
                ,
                f.cu = class extends bo {
                }
                ,
                f.cv = HM,
                f.cx = function(c) {
                    return c.message === Er
                }
                ,
                f.cy = Me,
                f.cz = function(c, n) {
                    se.REGISTERED_PROTOCOLS[c] = n
                }
                ,
                f.d = at,
                f.e = xr,
                f.f = c => o(void 0, void 0, void 0, function*() {
                    if (c.byteLength === 0)
                        return createImageBitmap(new ImageData(1,1));
                    const n = new Blob([new Uint8Array(c)],{
                        type: "image/png"
                    });
                    try {
                        return createImageBitmap(n)
                    } catch (l) {
                        throw new Error(`Could not load image because of ${l.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
                    }
                }),
                f.g = fe,
                f.h = c => new Promise( (n, l) => {
                    const p = new Image;
                    p.onload = () => {
                        n(p),
                        URL.revokeObjectURL(p.src),
                        p.onload = null,
                        window.requestAnimationFrame( () => {
                            p.src = $n
                        }
                        )
                    }
                    ,
                    p.onerror = () => l(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                    const _ = new Blob([new Uint8Array(c)],{
                        type: "image/png"
                    });
                    p.src = c.byteLength ? URL.createObjectURL(_) : $n
                }
                ),
                f.i = gn,
                f.j = (c, n) => et(xr(c, {
                    type: "json"
                }), n),
                f.k = tt,
                f.l = dt,
                f.m = et,
                f.n = (c, n) => et(xr(c, {
                    type: "arrayBuffer"
                }), n),
                f.o = function(c) {
                    return new Bh(c).readFields(jy, [])
                }
                ,
                f.p = Lm,
                f.q = $u,
                f.r = Vn,
                f.s = bn,
                f.t = Th,
                f.u = Ir,
                f.v = Ve,
                f.w = Zr,
                f.x = Xa,
                f.y = Ya,
                f.z = xc
            }),
            u("worker", ["./shared"], function(f) {
                class o {
                    constructor(se) {
                        this.keyCache = {},
                        se && this.replace(se)
                    }
                    replace(se) {
                        this._layerConfigs = {},
                        this._layers = {},
                        this.update(se, [])
                    }
                    update(se, fe) {
                        for (const Me of se) {
                            this._layerConfigs[Me.id] = Me;
                            const $e = this._layers[Me.id] = f.bI(Me);
                            $e._featureFilter = f.a9($e.filter),
                            this.keyCache[Me.id] && delete this.keyCache[Me.id]
                        }
                        for (const Me of fe)
                            delete this.keyCache[Me],
                            delete this._layerConfigs[Me],
                            delete this._layers[Me];
                        this.familiesBySource = {};
                        const ge = f.cB(Object.values(this._layerConfigs), this.keyCache);
                        for (const Me of ge) {
                            const $e = Me.map(tt => this._layers[tt.id])
                              , et = $e[0];
                            if (et.visibility === "none")
                                continue;
                            const at = et.source || "";
                            let Qe = this.familiesBySource[at];
                            Qe || (Qe = this.familiesBySource[at] = {});
                            const _t = et.sourceLayer || "_geojsonTileLayer";
                            let dt = Qe[_t];
                            dt || (dt = Qe[_t] = []),
                            dt.push($e)
                        }
                    }
                }
                class w {
                    constructor(se) {
                        const fe = {}
                          , ge = [];
                        for (const at in se) {
                            const Qe = se[at]
                              , _t = fe[at] = {};
                            for (const dt in Qe) {
                                const tt = Qe[+dt];
                                if (!tt || tt.bitmap.width === 0 || tt.bitmap.height === 0)
                                    continue;
                                const St = {
                                    x: 0,
                                    y: 0,
                                    w: tt.bitmap.width + 2,
                                    h: tt.bitmap.height + 2
                                };
                                ge.push(St),
                                _t[dt] = {
                                    rect: St,
                                    metrics: tt.metrics
                                }
                            }
                        }
                        const {w: Me, h: $e} = f.p(ge)
                          , et = new f.q({
                            width: Me || 1,
                            height: $e || 1
                        });
                        for (const at in se) {
                            const Qe = se[at];
                            for (const _t in Qe) {
                                const dt = Qe[+_t];
                                if (!dt || dt.bitmap.width === 0 || dt.bitmap.height === 0)
                                    continue;
                                const tt = fe[at][_t].rect;
                                f.q.copy(dt.bitmap, et, {
                                    x: 0,
                                    y: 0
                                }, {
                                    x: tt.x + 1,
                                    y: tt.y + 1
                                }, dt.bitmap)
                            }
                        }
                        this.image = et,
                        this.positions = fe
                    }
                }
                f.cC("GlyphAtlas", w);
                class T {
                    constructor(se) {
                        this.tileID = new f.Z(se.tileID.overscaledZ,se.tileID.wrap,se.tileID.canonical.z,se.tileID.canonical.x,se.tileID.canonical.y),
                        this.uid = se.uid,
                        this.zoom = se.zoom,
                        this.pixelRatio = se.pixelRatio,
                        this.tileSize = se.tileSize,
                        this.source = se.source,
                        this.overscaling = this.tileID.overscaleFactor(),
                        this.showCollisionBoxes = se.showCollisionBoxes,
                        this.collectResourceTiming = !!se.collectResourceTiming,
                        this.returnDependencies = !!se.returnDependencies,
                        this.promoteId = se.promoteId,
                        this.inFlightDependencies = [],
                        this.globalState = se.globalState
                    }
                    parse(se, fe, ge, Me, $e) {
                        return f._(this, void 0, void 0, function*() {
                            this.status = "parsing",
                            this.data = se,
                            this.collisionBoxArray = new f.a7;
                            const et = new f.cD(Object.keys(se.layers).sort())
                              , at = new f.cE(this.tileID,this.promoteId);
                            at.bucketLayerIDs = [];
                            const Qe = {}
                              , _t = {
                                featureIndex: at,
                                iconDependencies: {},
                                patternDependencies: {},
                                glyphDependencies: {},
                                availableImages: ge,
                                subdivisionGranularity: $e
                            }
                              , dt = fe.familiesBySource[this.source];
                            for (const fr in dt) {
                                const ke = se.layers[fr];
                                if (!ke)
                                    continue;
                                ke.version === 1 && f.w(`Vector tile source "${this.source}" layer "${fr}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                                const le = et.encode(fr)
                                  , ee = [];
                                for (let Ze = 0; Ze < ke.length; Ze++) {
                                    const Ge = ke.feature(Ze)
                                      , vt = at.getId(Ge, fr);
                                    ee.push({
                                        feature: Ge,
                                        id: vt,
                                        index: Ze,
                                        sourceLayerIndex: le
                                    })
                                }
                                for (const Ze of dt[fr]) {
                                    const Ge = Ze[0];
                                    Ge.source !== this.source && f.w(`layer.source = ${Ge.source} does not equal this.source = ${this.source}`),
                                    Ge.minzoom && this.zoom < Math.floor(Ge.minzoom) || Ge.maxzoom && this.zoom >= Ge.maxzoom || Ge.visibility !== "none" && (k(Ze, this.zoom, ge),
                                    (Qe[Ge.id] = Ge.createBucket({
                                        index: at.bucketLayerIDs.length,
                                        layers: Ze,
                                        zoom: this.zoom,
                                        pixelRatio: this.pixelRatio,
                                        overscaling: this.overscaling,
                                        collisionBoxArray: this.collisionBoxArray,
                                        sourceLayerIndex: le,
                                        sourceID: this.source,
                                        globalState: this.globalState
                                    })).populate(ee, _t, this.tileID.canonical),
                                    at.bucketLayerIDs.push(Ze.map(vt => vt.id)))
                                }
                            }
                            const tt = f.bM(_t.glyphDependencies, fr => Object.keys(fr).map(Number));
                            this.inFlightDependencies.forEach(fr => fr?.abort()),
                            this.inFlightDependencies = [];
                            let St = Promise.resolve({});
                            if (Object.keys(tt).length) {
                                const fr = new AbortController;
                                this.inFlightDependencies.push(fr),
                                St = Me.sendAsync({
                                    type: "GG",
                                    data: {
                                        stacks: tt,
                                        source: this.source,
                                        tileID: this.tileID,
                                        type: "glyphs"
                                    }
                                }, fr)
                            }
                            const Ve = Object.keys(_t.iconDependencies);
                            let Ut = Promise.resolve({});
                            if (Ve.length) {
                                const fr = new AbortController;
                                this.inFlightDependencies.push(fr),
                                Ut = Me.sendAsync({
                                    type: "GI",
                                    data: {
                                        icons: Ve,
                                        source: this.source,
                                        tileID: this.tileID,
                                        type: "icons"
                                    }
                                }, fr)
                            }
                            const yr = Object.keys(_t.patternDependencies);
                            let Ht = Promise.resolve({});
                            if (yr.length) {
                                const fr = new AbortController;
                                this.inFlightDependencies.push(fr),
                                Ht = Me.sendAsync({
                                    type: "GI",
                                    data: {
                                        icons: yr,
                                        source: this.source,
                                        tileID: this.tileID,
                                        type: "patterns"
                                    }
                                }, fr)
                            }
                            const [sr,br,en] = yield Promise.all([St, Ut, Ht])
                              , qr = new w(sr)
                              , Dr = new f.cF(br,en);
                            for (const fr in Qe) {
                                const ke = Qe[fr];
                                ke instanceof f.a8 ? (k(ke.layers, this.zoom, ge),
                                f.cG({
                                    bucket: ke,
                                    glyphMap: sr,
                                    glyphPositions: qr.positions,
                                    imageMap: br,
                                    imagePositions: Dr.iconPositions,
                                    showCollisionBoxes: this.showCollisionBoxes,
                                    canonical: this.tileID.canonical,
                                    subdivisionGranularity: _t.subdivisionGranularity
                                })) : ke.hasPattern && (ke instanceof f.cH || ke instanceof f.cI || ke instanceof f.cJ) && (k(ke.layers, this.zoom, ge),
                                ke.addFeatures(_t, this.tileID.canonical, Dr.patternPositions))
                            }
                            return this.status = "done",
                            {
                                buckets: Object.values(Qe).filter(fr => !fr.isEmpty()),
                                featureIndex: at,
                                collisionBoxArray: this.collisionBoxArray,
                                glyphAtlasImage: qr.image,
                                imageAtlas: Dr,
                                glyphMap: this.returnDependencies ? sr : null,
                                iconMap: this.returnDependencies ? br : null,
                                glyphPositions: this.returnDependencies ? qr.positions : null
                            }
                        })
                    }
                }
                function k(Ue, se, fe) {
                    const ge = new f.F(se);
                    for (const Me of Ue)
                        Me.recalculate(ge, fe)
                }
                class L {
                    constructor(se, fe, ge) {
                        this.actor = se,
                        this.layerIndex = fe,
                        this.availableImages = ge,
                        this.fetching = {},
                        this.loading = {},
                        this.loaded = {}
                    }
                    loadVectorTile(se, fe) {
                        return f._(this, void 0, void 0, function*() {
                            const ge = yield f.n(se.request, fe);
                            try {
                                return {
                                    vectorTile: new f.cK.VectorTile(new f.cL(ge.data)),
                                    rawData: ge.data,
                                    cacheControl: ge.cacheControl,
                                    expires: ge.expires
                                }
                            } catch (Me) {
                                const $e = new Uint8Array(ge.data);
                                let et = `Unable to parse the tile at ${se.request.url}, `;
                                throw et += $e[0] === 31 && $e[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${Me.message}`,
                                new Error(et)
                            }
                        })
                    }
                    loadTile(se) {
                        return f._(this, void 0, void 0, function*() {
                            const fe = se.uid
                              , ge = !!(se && se.request && se.request.collectResourceTiming) && new f.cM(se.request)
                              , Me = new T(se);
                            this.loading[fe] = Me;
                            const $e = new AbortController;
                            Me.abort = $e;
                            try {
                                const et = yield this.loadVectorTile(se, $e);
                                if (delete this.loading[fe],
                                !et)
                                    return null;
                                const at = et.rawData
                                  , Qe = {};
                                et.expires && (Qe.expires = et.expires),
                                et.cacheControl && (Qe.cacheControl = et.cacheControl);
                                const _t = {};
                                if (ge) {
                                    const tt = ge.finish();
                                    tt && (_t.resourceTiming = JSON.parse(JSON.stringify(tt)))
                                }
                                Me.vectorTile = et.vectorTile;
                                const dt = Me.parse(et.vectorTile, this.layerIndex, this.availableImages, this.actor, se.subdivisionGranularity);
                                this.loaded[fe] = Me,
                                this.fetching[fe] = {
                                    rawTileData: at,
                                    cacheControl: Qe,
                                    resourceTiming: _t
                                };
                                try {
                                    const tt = yield dt;
                                    return f.e({
                                        rawTileData: at.slice(0)
                                    }, tt, Qe, _t)
                                } finally {
                                    delete this.fetching[fe]
                                }
                            } catch (et) {
                                throw delete this.loading[fe],
                                Me.status = "done",
                                this.loaded[fe] = Me,
                                et
                            }
                        })
                    }
                    reloadTile(se) {
                        return f._(this, void 0, void 0, function*() {
                            const fe = se.uid;
                            if (!this.loaded || !this.loaded[fe])
                                throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
                            const ge = this.loaded[fe];
                            if (ge.showCollisionBoxes = se.showCollisionBoxes,
                            ge.globalState = se.globalState,
                            ge.status === "parsing") {
                                const Me = yield ge.parse(ge.vectorTile, this.layerIndex, this.availableImages, this.actor, se.subdivisionGranularity);
                                let $e;
                                if (this.fetching[fe]) {
                                    const {rawTileData: et, cacheControl: at, resourceTiming: Qe} = this.fetching[fe];
                                    delete this.fetching[fe],
                                    $e = f.e({
                                        rawTileData: et.slice(0)
                                    }, Me, at, Qe)
                                } else
                                    $e = Me;
                                return $e
                            }
                            if (ge.status === "done" && ge.vectorTile)
                                return ge.parse(ge.vectorTile, this.layerIndex, this.availableImages, this.actor, se.subdivisionGranularity)
                        })
                    }
                    abortTile(se) {
                        return f._(this, void 0, void 0, function*() {
                            const fe = this.loading
                              , ge = se.uid;
                            fe && fe[ge] && fe[ge].abort && (fe[ge].abort.abort(),
                            delete fe[ge])
                        })
                    }
                    removeTile(se) {
                        return f._(this, void 0, void 0, function*() {
                            this.loaded && this.loaded[se.uid] && delete this.loaded[se.uid]
                        })
                    }
                }
                class z {
                    constructor() {
                        this.loaded = {}
                    }
                    loadTile(se) {
                        return f._(this, void 0, void 0, function*() {
                            const {uid: fe, encoding: ge, rawImageData: Me, redFactor: $e, greenFactor: et, blueFactor: at, baseShift: Qe} = se
                              , _t = Me.width + 2
                              , dt = Me.height + 2
                              , tt = f.b(Me) ? new f.R({
                                width: _t,
                                height: dt
                            },yield f.cN(Me, -1, -1, _t, dt)) : Me
                              , St = new f.cO(fe,tt,ge,$e,et,at,Qe);
                            return this.loaded = this.loaded || {},
                            this.loaded[fe] = St,
                            St
                        })
                    }
                    removeTile(se) {
                        const fe = this.loaded
                          , ge = se.uid;
                        fe && fe[ge] && delete fe[ge]
                    }
                }
                var D, N, U = function() {
                    if (N)
                        return D;
                    function Ue(fe, ge) {
                        if (fe.length !== 0) {
                            se(fe[0], ge);
                            for (var Me = 1; Me < fe.length; Me++)
                                se(fe[Me], !ge)
                        }
                    }
                    function se(fe, ge) {
                        for (var Me = 0, $e = 0, et = 0, at = fe.length, Qe = at - 1; et < at; Qe = et++) {
                            var _t = (fe[et][0] - fe[Qe][0]) * (fe[Qe][1] + fe[et][1])
                              , dt = Me + _t;
                            $e += Math.abs(Me) >= Math.abs(_t) ? Me - dt + _t : _t - dt + Me,
                            Me = dt
                        }
                        Me + $e >= 0 != !!ge && fe.reverse()
                    }
                    return N = 1,
                    D = function fe(ge, Me) {
                        var $e, et = ge && ge.type;
                        if (et === "FeatureCollection")
                            for ($e = 0; $e < ge.features.length; $e++)
                                fe(ge.features[$e], Me);
                        else if (et === "GeometryCollection")
                            for ($e = 0; $e < ge.geometries.length; $e++)
                                fe(ge.geometries[$e], Me);
                        else if (et === "Feature")
                            fe(ge.geometry, Me);
                        else if (et === "Polygon")
                            Ue(ge.coordinates, Me);
                        else if (et === "MultiPolygon")
                            for ($e = 0; $e < ge.coordinates.length; $e++)
                                Ue(ge.coordinates[$e], Me);
                        return ge
                    }
                }(), V = f.cP(U);
                const re = f.cK.VectorTileFeature.prototype.toGeoJSON;
                class ie {
                    constructor(se) {
                        this._feature = se,
                        this.extent = f.$,
                        this.type = se.type,
                        this.properties = se.tags,
                        "id"in se && !isNaN(se.id) && (this.id = parseInt(se.id, 10))
                    }
                    loadGeometry() {
                        if (this._feature.type === 1) {
                            const se = [];
                            for (const fe of this._feature.geometry)
                                se.push([new f.P(fe[0],fe[1])]);
                            return se
                        }
                        {
                            const se = [];
                            for (const fe of this._feature.geometry) {
                                const ge = [];
                                for (const Me of fe)
                                    ge.push(new f.P(Me[0],Me[1]));
                                se.push(ge)
                            }
                            return se
                        }
                    }
                    toGeoJSON(se, fe, ge) {
                        return re.call(this, se, fe, ge)
                    }
                }
                class ue {
                    constructor(se) {
                        this.layers = {
                            _geojsonTileLayer: this
                        },
                        this.name = "_geojsonTileLayer",
                        this.extent = f.$,
                        this.length = se.length,
                        this._features = se
                    }
                    feature(se) {
                        return new ie(this._features[se])
                    }
                }
                var ce, X, me, K = {
                    exports: {}
                }, be = function() {
                    if (me)
                        return K.exports;
                    me = 1;
                    var Ue = f.cS()
                      , se = function() {
                        if (X)
                            return ce;
                        X = 1;
                        var dt = f.cQ()
                          , tt = f.cR().VectorTileFeature;
                        function St(Ut, yr) {
                            this.options = yr || {},
                            this.features = Ut,
                            this.length = Ut.length
                        }
                        function Ve(Ut, yr) {
                            this.id = typeof Ut.id == "number" ? Ut.id : void 0,
                            this.type = Ut.type,
                            this.rawGeometry = Ut.type === 1 ? [Ut.geometry] : Ut.geometry,
                            this.properties = Ut.tags,
                            this.extent = yr || 4096
                        }
                        return ce = St,
                        St.prototype.feature = function(Ut) {
                            return new Ve(this.features[Ut],this.options.extent)
                        }
                        ,
                        Ve.prototype.loadGeometry = function() {
                            var Ut = this.rawGeometry;
                            this.geometry = [];
                            for (var yr = 0; yr < Ut.length; yr++) {
                                for (var Ht = Ut[yr], sr = [], br = 0; br < Ht.length; br++)
                                    sr.push(new dt(Ht[br][0],Ht[br][1]));
                                this.geometry.push(sr)
                            }
                            return this.geometry
                        }
                        ,
                        Ve.prototype.bbox = function() {
                            this.geometry || this.loadGeometry();
                            for (var Ut = this.geometry, yr = 1 / 0, Ht = -1 / 0, sr = 1 / 0, br = -1 / 0, en = 0; en < Ut.length; en++)
                                for (var qr = Ut[en], Dr = 0; Dr < qr.length; Dr++) {
                                    var fr = qr[Dr];
                                    yr = Math.min(yr, fr.x),
                                    Ht = Math.max(Ht, fr.x),
                                    sr = Math.min(sr, fr.y),
                                    br = Math.max(br, fr.y)
                                }
                            return [yr, sr, Ht, br]
                        }
                        ,
                        Ve.prototype.toGeoJSON = tt.prototype.toGeoJSON,
                        ce
                    }();
                    function fe(dt) {
                        var tt = new Ue;
                        return function(St, Ve) {
                            for (var Ut in St.layers)
                                Ve.writeMessage(3, ge, St.layers[Ut])
                        }(dt, tt),
                        tt.finish()
                    }
                    function ge(dt, tt) {
                        var St;
                        tt.writeVarintField(15, dt.version || 1),
                        tt.writeStringField(1, dt.name || ""),
                        tt.writeVarintField(5, dt.extent || 4096);
                        var Ve = {
                            keys: [],
                            values: [],
                            keycache: {},
                            valuecache: {}
                        };
                        for (St = 0; St < dt.length; St++)
                            Ve.feature = dt.feature(St),
                            tt.writeMessage(2, Me, Ve);
                        var Ut = Ve.keys;
                        for (St = 0; St < Ut.length; St++)
                            tt.writeStringField(3, Ut[St]);
                        var yr = Ve.values;
                        for (St = 0; St < yr.length; St++)
                            tt.writeMessage(4, _t, yr[St])
                    }
                    function Me(dt, tt) {
                        var St = dt.feature;
                        St.id !== void 0 && tt.writeVarintField(1, St.id),
                        tt.writeMessage(2, $e, dt),
                        tt.writeVarintField(3, St.type),
                        tt.writeMessage(4, Qe, St)
                    }
                    function $e(dt, tt) {
                        var St = dt.feature
                          , Ve = dt.keys
                          , Ut = dt.values
                          , yr = dt.keycache
                          , Ht = dt.valuecache;
                        for (var sr in St.properties) {
                            var br = St.properties[sr]
                              , en = yr[sr];
                            if (br !== null) {
                                en === void 0 && (Ve.push(sr),
                                yr[sr] = en = Ve.length - 1),
                                tt.writeVarint(en);
                                var qr = typeof br;
                                qr !== "string" && qr !== "boolean" && qr !== "number" && (br = JSON.stringify(br));
                                var Dr = qr + ":" + br
                                  , fr = Ht[Dr];
                                fr === void 0 && (Ut.push(br),
                                Ht[Dr] = fr = Ut.length - 1),
                                tt.writeVarint(fr)
                            }
                        }
                    }
                    function et(dt, tt) {
                        return (tt << 3) + (7 & dt)
                    }
                    function at(dt) {
                        return dt << 1 ^ dt >> 31
                    }
                    function Qe(dt, tt) {
                        for (var St = dt.loadGeometry(), Ve = dt.type, Ut = 0, yr = 0, Ht = St.length, sr = 0; sr < Ht; sr++) {
                            var br = St[sr]
                              , en = 1;
                            Ve === 1 && (en = br.length),
                            tt.writeVarint(et(1, en));
                            for (var qr = Ve === 3 ? br.length - 1 : br.length, Dr = 0; Dr < qr; Dr++) {
                                Dr === 1 && Ve !== 1 && tt.writeVarint(et(2, qr - 1));
                                var fr = br[Dr].x - Ut
                                  , ke = br[Dr].y - yr;
                                tt.writeVarint(at(fr)),
                                tt.writeVarint(at(ke)),
                                Ut += fr,
                                yr += ke
                            }
                            Ve === 3 && tt.writeVarint(et(7, 1))
                        }
                    }
                    function _t(dt, tt) {
                        var St = typeof dt;
                        St === "string" ? tt.writeStringField(1, dt) : St === "boolean" ? tt.writeBooleanField(7, dt) : St === "number" && (dt % 1 != 0 ? tt.writeDoubleField(3, dt) : dt < 0 ? tt.writeSVarintField(6, dt) : tt.writeVarintField(5, dt))
                    }
                    return K.exports = fe,
                    K.exports.fromVectorTileJs = fe,
                    K.exports.fromGeojsonVt = function(dt, tt) {
                        tt = tt || {};
                        var St = {};
                        for (var Ve in dt)
                            St[Ve] = new se(dt[Ve].features,tt),
                            St[Ve].name = Ve,
                            St[Ve].version = tt.version,
                            St[Ve].extent = tt.extent;
                        return fe({
                            layers: St
                        })
                    }
                    ,
                    K.exports.GeoJSONWrapper = se,
                    K.exports
                }(), Ee = f.cP(be);
                const Ce = {
                    minZoom: 0,
                    maxZoom: 16,
                    minPoints: 2,
                    radius: 40,
                    extent: 512,
                    nodeSize: 64,
                    log: !1,
                    generateId: !1,
                    reduce: null,
                    map: Ue => Ue
                }
                  , He = Math.fround || (ct = new Float32Array(1),
                Ue => (ct[0] = +Ue,
                ct[0]));
                var ct;
                class nt {
                    constructor(se) {
                        this.options = Object.assign(Object.create(Ce), se),
                        this.trees = new Array(this.options.maxZoom + 1),
                        this.stride = this.options.reduce ? 7 : 6,
                        this.clusterProps = []
                    }
                    load(se) {
                        const {log: fe, minZoom: ge, maxZoom: Me} = this.options;
                        fe && console.time("total time");
                        const $e = `prepare ${se.length} points`;
                        fe && console.time($e),
                        this.points = se;
                        const et = [];
                        for (let Qe = 0; Qe < se.length; Qe++) {
                            const _t = se[Qe];
                            if (!_t.geometry)
                                continue;
                            const [dt,tt] = _t.geometry.coordinates
                              , St = He(ve(dt))
                              , Ve = He(Ne(tt));
                            et.push(St, Ve, 1 / 0, Qe, -1, 1),
                            this.options.reduce && et.push(0)
                        }
                        let at = this.trees[Me + 1] = this._createTree(et);
                        fe && console.timeEnd($e);
                        for (let Qe = Me; Qe >= ge; Qe--) {
                            const _t = +Date.now();
                            at = this.trees[Qe] = this._createTree(this._cluster(at, Qe)),
                            fe && console.log("z%d: %d clusters in %dms", Qe, at.numItems, +Date.now() - _t)
                        }
                        return fe && console.timeEnd("total time"),
                        this
                    }
                    getClusters(se, fe) {
                        let ge = ((se[0] + 180) % 360 + 360) % 360 - 180;
                        const Me = Math.max(-90, Math.min(90, se[1]));
                        let $e = se[2] === 180 ? 180 : ((se[2] + 180) % 360 + 360) % 360 - 180;
                        const et = Math.max(-90, Math.min(90, se[3]));
                        if (se[2] - se[0] >= 360)
                            ge = -180,
                            $e = 180;
                        else if (ge > $e) {
                            const tt = this.getClusters([ge, Me, 180, et], fe)
                              , St = this.getClusters([-180, Me, $e, et], fe);
                            return tt.concat(St)
                        }
                        const at = this.trees[this._limitZoom(fe)]
                          , Qe = at.range(ve(ge), Ne(et), ve($e), Ne(Me))
                          , _t = at.data
                          , dt = [];
                        for (const tt of Qe) {
                            const St = this.stride * tt;
                            dt.push(_t[St + 5] > 1 ? J(_t, St, this.clusterProps) : this.points[_t[St + 3]])
                        }
                        return dt
                    }
                    getChildren(se) {
                        const fe = this._getOriginId(se)
                          , ge = this._getOriginZoom(se)
                          , Me = "No cluster with the specified id."
                          , $e = this.trees[ge];
                        if (!$e)
                            throw new Error(Me);
                        const et = $e.data;
                        if (fe * this.stride >= et.length)
                            throw new Error(Me);
                        const at = this.options.radius / (this.options.extent * Math.pow(2, ge - 1))
                          , Qe = $e.within(et[fe * this.stride], et[fe * this.stride + 1], at)
                          , _t = [];
                        for (const dt of Qe) {
                            const tt = dt * this.stride;
                            et[tt + 4] === se && _t.push(et[tt + 5] > 1 ? J(et, tt, this.clusterProps) : this.points[et[tt + 3]])
                        }
                        if (_t.length === 0)
                            throw new Error(Me);
                        return _t
                    }
                    getLeaves(se, fe, ge) {
                        const Me = [];
                        return this._appendLeaves(Me, se, fe = fe || 10, ge = ge || 0, 0),
                        Me
                    }
                    getTile(se, fe, ge) {
                        const Me = this.trees[this._limitZoom(se)]
                          , $e = Math.pow(2, se)
                          , {extent: et, radius: at} = this.options
                          , Qe = at / et
                          , _t = (ge - Qe) / $e
                          , dt = (ge + 1 + Qe) / $e
                          , tt = {
                            features: []
                        };
                        return this._addTileFeatures(Me.range((fe - Qe) / $e, _t, (fe + 1 + Qe) / $e, dt), Me.data, fe, ge, $e, tt),
                        fe === 0 && this._addTileFeatures(Me.range(1 - Qe / $e, _t, 1, dt), Me.data, $e, ge, $e, tt),
                        fe === $e - 1 && this._addTileFeatures(Me.range(0, _t, Qe / $e, dt), Me.data, -1, ge, $e, tt),
                        tt.features.length ? tt : null
                    }
                    getClusterExpansionZoom(se) {
                        let fe = this._getOriginZoom(se) - 1;
                        for (; fe <= this.options.maxZoom; ) {
                            const ge = this.getChildren(se);
                            if (fe++,
                            ge.length !== 1)
                                break;
                            se = ge[0].properties.cluster_id
                        }
                        return fe
                    }
                    _appendLeaves(se, fe, ge, Me, $e) {
                        const et = this.getChildren(fe);
                        for (const at of et) {
                            const Qe = at.properties;
                            if (Qe && Qe.cluster ? $e + Qe.point_count <= Me ? $e += Qe.point_count : $e = this._appendLeaves(se, Qe.cluster_id, ge, Me, $e) : $e < Me ? $e++ : se.push(at),
                            se.length === ge)
                                break
                        }
                        return $e
                    }
                    _createTree(se) {
                        const fe = new f.aH(se.length / this.stride | 0,this.options.nodeSize,Float32Array);
                        for (let ge = 0; ge < se.length; ge += this.stride)
                            fe.add(se[ge], se[ge + 1]);
                        return fe.finish(),
                        fe.data = se,
                        fe
                    }
                    _addTileFeatures(se, fe, ge, Me, $e, et) {
                        for (const at of se) {
                            const Qe = at * this.stride
                              , _t = fe[Qe + 5] > 1;
                            let dt, tt, St;
                            if (_t)
                                dt = he(fe, Qe, this.clusterProps),
                                tt = fe[Qe],
                                St = fe[Qe + 1];
                            else {
                                const yr = this.points[fe[Qe + 3]];
                                dt = yr.properties;
                                const [Ht,sr] = yr.geometry.coordinates;
                                tt = ve(Ht),
                                St = Ne(sr)
                            }
                            const Ve = {
                                type: 1,
                                geometry: [[Math.round(this.options.extent * (tt * $e - ge)), Math.round(this.options.extent * (St * $e - Me))]],
                                tags: dt
                            };
                            let Ut;
                            Ut = _t || this.options.generateId ? fe[Qe + 3] : this.points[fe[Qe + 3]].id,
                            Ut !== void 0 && (Ve.id = Ut),
                            et.features.push(Ve)
                        }
                    }
                    _limitZoom(se) {
                        return Math.max(this.options.minZoom, Math.min(Math.floor(+se), this.options.maxZoom + 1))
                    }
                    _cluster(se, fe) {
                        const {radius: ge, extent: Me, reduce: $e, minPoints: et} = this.options
                          , at = ge / (Me * Math.pow(2, fe))
                          , Qe = se.data
                          , _t = []
                          , dt = this.stride;
                        for (let tt = 0; tt < Qe.length; tt += dt) {
                            if (Qe[tt + 2] <= fe)
                                continue;
                            Qe[tt + 2] = fe;
                            const St = Qe[tt]
                              , Ve = Qe[tt + 1]
                              , Ut = se.within(Qe[tt], Qe[tt + 1], at)
                              , yr = Qe[tt + 5];
                            let Ht = yr;
                            for (const sr of Ut) {
                                const br = sr * dt;
                                Qe[br + 2] > fe && (Ht += Qe[br + 5])
                            }
                            if (Ht > yr && Ht >= et) {
                                let sr, br = St * yr, en = Ve * yr, qr = -1;
                                const Dr = (tt / dt << 5) + (fe + 1) + this.points.length;
                                for (const fr of Ut) {
                                    const ke = fr * dt;
                                    if (Qe[ke + 2] <= fe)
                                        continue;
                                    Qe[ke + 2] = fe;
                                    const le = Qe[ke + 5];
                                    br += Qe[ke] * le,
                                    en += Qe[ke + 1] * le,
                                    Qe[ke + 4] = Dr,
                                    $e && (sr || (sr = this._map(Qe, tt, !0),
                                    qr = this.clusterProps.length,
                                    this.clusterProps.push(sr)),
                                    $e(sr, this._map(Qe, ke)))
                                }
                                Qe[tt + 4] = Dr,
                                _t.push(br / Ht, en / Ht, 1 / 0, Dr, -1, Ht),
                                $e && _t.push(qr)
                            } else {
                                for (let sr = 0; sr < dt; sr++)
                                    _t.push(Qe[tt + sr]);
                                if (Ht > 1)
                                    for (const sr of Ut) {
                                        const br = sr * dt;
                                        if (!(Qe[br + 2] <= fe)) {
                                            Qe[br + 2] = fe;
                                            for (let en = 0; en < dt; en++)
                                                _t.push(Qe[br + en])
                                        }
                                    }
                            }
                        }
                        return _t
                    }
                    _getOriginId(se) {
                        return se - this.points.length >> 5
                    }
                    _getOriginZoom(se) {
                        return (se - this.points.length) % 32
                    }
                    _map(se, fe, ge) {
                        if (se[fe + 5] > 1) {
                            const et = this.clusterProps[se[fe + 6]];
                            return ge ? Object.assign({}, et) : et
                        }
                        const Me = this.points[se[fe + 3]].properties
                          , $e = this.options.map(Me);
                        return ge && $e === Me ? Object.assign({}, $e) : $e
                    }
                }
                function J(Ue, se, fe) {
                    return {
                        type: "Feature",
                        id: Ue[se + 3],
                        properties: he(Ue, se, fe),
                        geometry: {
                            type: "Point",
                            coordinates: [(ge = Ue[se],
                            360 * (ge - .5)), je(Ue[se + 1])]
                        }
                    };
                    var ge
                }
                function he(Ue, se, fe) {
                    const ge = Ue[se + 5]
                      , Me = ge >= 1e4 ? `${Math.round(ge / 1e3)}k` : ge >= 1e3 ? Math.round(ge / 100) / 10 + "k" : ge
                      , $e = Ue[se + 6]
                      , et = $e === -1 ? {} : Object.assign({}, fe[$e]);
                    return Object.assign(et, {
                        cluster: !0,
                        cluster_id: Ue[se + 3],
                        point_count: ge,
                        point_count_abbreviated: Me
                    })
                }
                function ve(Ue) {
                    return Ue / 360 + .5
                }
                function Ne(Ue) {
                    const se = Math.sin(Ue * Math.PI / 180)
                      , fe = .5 - .25 * Math.log((1 + se) / (1 - se)) / Math.PI;
                    return fe < 0 ? 0 : fe > 1 ? 1 : fe
                }
                function je(Ue) {
                    const se = (180 - 360 * Ue) * Math.PI / 180;
                    return 360 * Math.atan(Math.exp(se)) / Math.PI - 90
                }
                function lt(Ue, se, fe, ge) {
                    let Me = ge;
                    const $e = se + (fe - se >> 1);
                    let et, at = fe - se;
                    const Qe = Ue[se]
                      , _t = Ue[se + 1]
                      , dt = Ue[fe]
                      , tt = Ue[fe + 1];
                    for (let St = se + 3; St < fe; St += 3) {
                        const Ve = Pt(Ue[St], Ue[St + 1], Qe, _t, dt, tt);
                        if (Ve > Me)
                            et = St,
                            Me = Ve;
                        else if (Ve === Me) {
                            const Ut = Math.abs(St - $e);
                            Ut < at && (et = St,
                            at = Ut)
                        }
                    }
                    Me > ge && (et - se > 3 && lt(Ue, se, et, ge),
                    Ue[et + 2] = Me,
                    fe - et > 3 && lt(Ue, et, fe, ge))
                }
                function Pt(Ue, se, fe, ge, Me, $e) {
                    let et = Me - fe
                      , at = $e - ge;
                    if (et !== 0 || at !== 0) {
                        const Qe = ((Ue - fe) * et + (se - ge) * at) / (et * et + at * at);
                        Qe > 1 ? (fe = Me,
                        ge = $e) : Qe > 0 && (fe += et * Qe,
                        ge += at * Qe)
                    }
                    return et = Ue - fe,
                    at = se - ge,
                    et * et + at * at
                }
                function We(Ue, se, fe, ge) {
                    const Me = {
                        id: Ue ?? null,
                        type: se,
                        geometry: fe,
                        tags: ge,
                        minX: 1 / 0,
                        minY: 1 / 0,
                        maxX: -1 / 0,
                        maxY: -1 / 0
                    };
                    if (se === "Point" || se === "MultiPoint" || se === "LineString")
                        st(Me, fe);
                    else if (se === "Polygon")
                        st(Me, fe[0]);
                    else if (se === "MultiLineString")
                        for (const $e of fe)
                            st(Me, $e);
                    else if (se === "MultiPolygon")
                        for (const $e of fe)
                            st(Me, $e[0]);
                    return Me
                }
                function st(Ue, se) {
                    for (let fe = 0; fe < se.length; fe += 3)
                        Ue.minX = Math.min(Ue.minX, se[fe]),
                        Ue.minY = Math.min(Ue.minY, se[fe + 1]),
                        Ue.maxX = Math.max(Ue.maxX, se[fe]),
                        Ue.maxY = Math.max(Ue.maxY, se[fe + 1])
                }
                function Nt(Ue, se, fe, ge) {
                    if (!se.geometry)
                        return;
                    const Me = se.geometry.coordinates;
                    if (Me && Me.length === 0)
                        return;
                    const $e = se.geometry.type
                      , et = Math.pow(fe.tolerance / ((1 << fe.maxZoom) * fe.extent), 2);
                    let at = []
                      , Qe = se.id;
                    if (fe.promoteId ? Qe = se.properties[fe.promoteId] : fe.generateId && (Qe = ge || 0),
                    $e === "Point")
                        zt(Me, at);
                    else if ($e === "MultiPoint")
                        for (const _t of Me)
                            zt(_t, at);
                    else if ($e === "LineString")
                        Qt(Me, at, et, !1);
                    else if ($e === "MultiLineString") {
                        if (fe.lineMetrics) {
                            for (const _t of Me)
                                at = [],
                                Qt(_t, at, et, !1),
                                Ue.push(We(Qe, "LineString", at, se.properties));
                            return
                        }
                        Wt(Me, at, et, !1)
                    } else if ($e === "Polygon")
                        Wt(Me, at, et, !0);
                    else {
                        if ($e !== "MultiPolygon") {
                            if ($e === "GeometryCollection") {
                                for (const _t of se.geometry.geometries)
                                    Nt(Ue, {
                                        id: Qe,
                                        geometry: _t,
                                        properties: se.properties
                                    }, fe, ge);
                                return
                            }
                            throw new Error("Input data is not a valid GeoJSON object.")
                        }
                        for (const _t of Me) {
                            const dt = [];
                            Wt(_t, dt, et, !0),
                            at.push(dt)
                        }
                    }
                    Ue.push(We(Qe, $e, at, se.properties))
                }
                function zt(Ue, se) {
                    se.push(tr(Ue[0]), cr(Ue[1]), 0)
                }
                function Qt(Ue, se, fe, ge) {
                    let Me, $e, et = 0;
                    for (let Qe = 0; Qe < Ue.length; Qe++) {
                        const _t = tr(Ue[Qe][0])
                          , dt = cr(Ue[Qe][1]);
                        se.push(_t, dt, 0),
                        Qe > 0 && (et += ge ? (Me * dt - _t * $e) / 2 : Math.sqrt(Math.pow(_t - Me, 2) + Math.pow(dt - $e, 2))),
                        Me = _t,
                        $e = dt
                    }
                    const at = se.length - 3;
                    se[2] = 1,
                    lt(se, 0, at, fe),
                    se[at + 2] = 1,
                    se.size = Math.abs(et),
                    se.start = 0,
                    se.end = se.size
                }
                function Wt(Ue, se, fe, ge) {
                    for (let Me = 0; Me < Ue.length; Me++) {
                        const $e = [];
                        Qt(Ue[Me], $e, fe, ge),
                        se.push($e)
                    }
                }
                function tr(Ue) {
                    return Ue / 360 + .5
                }
                function cr(Ue) {
                    const se = Math.sin(Ue * Math.PI / 180)
                      , fe = .5 - .25 * Math.log((1 + se) / (1 - se)) / Math.PI;
                    return fe < 0 ? 0 : fe > 1 ? 1 : fe
                }
                function Yt(Ue, se, fe, ge, Me, $e, et, at) {
                    if (ge /= se,
                    $e >= (fe /= se) && et < ge)
                        return Ue;
                    if (et < fe || $e >= ge)
                        return null;
                    const Qe = [];
                    for (const _t of Ue) {
                        const dt = _t.geometry;
                        let tt = _t.type;
                        const St = Me === 0 ? _t.minX : _t.minY
                          , Ve = Me === 0 ? _t.maxX : _t.maxY;
                        if (St >= fe && Ve < ge) {
                            Qe.push(_t);
                            continue
                        }
                        if (Ve < fe || St >= ge)
                            continue;
                        let Ut = [];
                        if (tt === "Point" || tt === "MultiPoint")
                            Gr(dt, Ut, fe, ge, Me);
                        else if (tt === "LineString")
                            xr(dt, Ut, fe, ge, Me, !1, at.lineMetrics);
                        else if (tt === "MultiLineString")
                            ur(dt, Ut, fe, ge, Me, !1);
                        else if (tt === "Polygon")
                            ur(dt, Ut, fe, ge, Me, !0);
                        else if (tt === "MultiPolygon")
                            for (const yr of dt) {
                                const Ht = [];
                                ur(yr, Ht, fe, ge, Me, !0),
                                Ht.length && Ut.push(Ht)
                            }
                        if (Ut.length) {
                            if (at.lineMetrics && tt === "LineString") {
                                for (const yr of Ut)
                                    Qe.push(We(_t.id, tt, yr, _t.tags));
                                continue
                            }
                            tt !== "LineString" && tt !== "MultiLineString" || (Ut.length === 1 ? (tt = "LineString",
                            Ut = Ut[0]) : tt = "MultiLineString"),
                            tt !== "Point" && tt !== "MultiPoint" || (tt = Ut.length === 3 ? "Point" : "MultiPoint"),
                            Qe.push(We(_t.id, tt, Ut, _t.tags))
                        }
                    }
                    return Qe.length ? Qe : null
                }
                function Gr(Ue, se, fe, ge, Me) {
                    for (let $e = 0; $e < Ue.length; $e += 3) {
                        const et = Ue[$e + Me];
                        et >= fe && et <= ge && vr(se, Ue[$e], Ue[$e + 1], Ue[$e + 2])
                    }
                }
                function xr(Ue, se, fe, ge, Me, $e, et) {
                    let at = Nr(Ue);
                    const Qe = Me === 0 ? gr : hn;
                    let _t, dt, tt = Ue.start;
                    for (let Ht = 0; Ht < Ue.length - 3; Ht += 3) {
                        const sr = Ue[Ht]
                          , br = Ue[Ht + 1]
                          , en = Ue[Ht + 2]
                          , qr = Ue[Ht + 3]
                          , Dr = Ue[Ht + 4]
                          , fr = Me === 0 ? sr : br
                          , ke = Me === 0 ? qr : Dr;
                        let le = !1;
                        et && (_t = Math.sqrt(Math.pow(sr - qr, 2) + Math.pow(br - Dr, 2))),
                        fr < fe ? ke > fe && (dt = Qe(at, sr, br, qr, Dr, fe),
                        et && (at.start = tt + _t * dt)) : fr > ge ? ke < ge && (dt = Qe(at, sr, br, qr, Dr, ge),
                        et && (at.start = tt + _t * dt)) : vr(at, sr, br, en),
                        ke < fe && fr >= fe && (dt = Qe(at, sr, br, qr, Dr, fe),
                        le = !0),
                        ke > ge && fr <= ge && (dt = Qe(at, sr, br, qr, Dr, ge),
                        le = !0),
                        !$e && le && (et && (at.end = tt + _t * dt),
                        se.push(at),
                        at = Nr(Ue)),
                        et && (tt += _t)
                    }
                    let St = Ue.length - 3;
                    const Ve = Ue[St]
                      , Ut = Ue[St + 1]
                      , yr = Me === 0 ? Ve : Ut;
                    yr >= fe && yr <= ge && vr(at, Ve, Ut, Ue[St + 2]),
                    St = at.length - 3,
                    $e && St >= 3 && (at[St] !== at[0] || at[St + 1] !== at[1]) && vr(at, at[0], at[1], at[2]),
                    at.length && se.push(at)
                }
                function Nr(Ue) {
                    const se = [];
                    return se.size = Ue.size,
                    se.start = Ue.start,
                    se.end = Ue.end,
                    se
                }
                function ur(Ue, se, fe, ge, Me, $e) {
                    for (const et of Ue)
                        xr(et, se, fe, ge, Me, $e, !1)
                }
                function vr(Ue, se, fe, ge) {
                    Ue.push(se, fe, ge)
                }
                function gr(Ue, se, fe, ge, Me, $e) {
                    const et = ($e - se) / (ge - se);
                    return vr(Ue, $e, fe + (Me - fe) * et, 1),
                    et
                }
                function hn(Ue, se, fe, ge, Me, $e) {
                    const et = ($e - fe) / (Me - fe);
                    return vr(Ue, se + (ge - se) * et, $e, 1),
                    et
                }
                function Zr(Ue, se) {
                    const fe = [];
                    for (let ge = 0; ge < Ue.length; ge++) {
                        const Me = Ue[ge]
                          , $e = Me.type;
                        let et;
                        if ($e === "Point" || $e === "MultiPoint" || $e === "LineString")
                            et = $r(Me.geometry, se);
                        else if ($e === "MultiLineString" || $e === "Polygon") {
                            et = [];
                            for (const at of Me.geometry)
                                et.push($r(at, se))
                        } else if ($e === "MultiPolygon") {
                            et = [];
                            for (const at of Me.geometry) {
                                const Qe = [];
                                for (const _t of at)
                                    Qe.push($r(_t, se));
                                et.push(Qe)
                            }
                        }
                        fe.push(We(Me.id, $e, et, Me.tags))
                    }
                    return fe
                }
                function $r(Ue, se) {
                    const fe = [];
                    fe.size = Ue.size,
                    Ue.start !== void 0 && (fe.start = Ue.start,
                    fe.end = Ue.end);
                    for (let ge = 0; ge < Ue.length; ge += 3)
                        fe.push(Ue[ge] + se, Ue[ge + 1], Ue[ge + 2]);
                    return fe
                }
                function gn(Ue, se) {
                    if (Ue.transformed)
                        return Ue;
                    const fe = 1 << Ue.z
                      , ge = Ue.x
                      , Me = Ue.y;
                    for (const $e of Ue.features) {
                        const et = $e.geometry
                          , at = $e.type;
                        if ($e.geometry = [],
                        at === 1)
                            for (let Qe = 0; Qe < et.length; Qe += 2)
                                $e.geometry.push(zr(et[Qe], et[Qe + 1], se, fe, ge, Me));
                        else
                            for (let Qe = 0; Qe < et.length; Qe++) {
                                const _t = [];
                                for (let dt = 0; dt < et[Qe].length; dt += 2)
                                    _t.push(zr(et[Qe][dt], et[Qe][dt + 1], se, fe, ge, Me));
                                $e.geometry.push(_t)
                            }
                    }
                    return Ue.transformed = !0,
                    Ue
                }
                function zr(Ue, se, fe, ge, Me, $e) {
                    return [Math.round(fe * (Ue * ge - Me)), Math.round(fe * (se * ge - $e))]
                }
                function Wr(Ue, se, fe, ge, Me) {
                    const $e = se === Me.maxZoom ? 0 : Me.tolerance / ((1 << se) * Me.extent)
                      , et = {
                        features: [],
                        numPoints: 0,
                        numSimplified: 0,
                        numFeatures: Ue.length,
                        source: null,
                        x: fe,
                        y: ge,
                        z: se,
                        transformed: !1,
                        minX: 2,
                        minY: 1,
                        maxX: -1,
                        maxY: 0
                    };
                    for (const at of Ue)
                        $n(et, at, $e, Me);
                    return et
                }
                function $n(Ue, se, fe, ge) {
                    const Me = se.geometry
                      , $e = se.type
                      , et = [];
                    if (Ue.minX = Math.min(Ue.minX, se.minX),
                    Ue.minY = Math.min(Ue.minY, se.minY),
                    Ue.maxX = Math.max(Ue.maxX, se.maxX),
                    Ue.maxY = Math.max(Ue.maxY, se.maxY),
                    $e === "Point" || $e === "MultiPoint")
                        for (let at = 0; at < Me.length; at += 3)
                            et.push(Me[at], Me[at + 1]),
                            Ue.numPoints++,
                            Ue.numSimplified++;
                    else if ($e === "LineString")
                        Dn(et, Me, Ue, fe, !1, !1);
                    else if ($e === "MultiLineString" || $e === "Polygon")
                        for (let at = 0; at < Me.length; at++)
                            Dn(et, Me[at], Ue, fe, $e === "Polygon", at === 0);
                    else if ($e === "MultiPolygon")
                        for (let at = 0; at < Me.length; at++) {
                            const Qe = Me[at];
                            for (let _t = 0; _t < Qe.length; _t++)
                                Dn(et, Qe[_t], Ue, fe, !0, _t === 0)
                        }
                    if (et.length) {
                        let at = se.tags || null;
                        if ($e === "LineString" && ge.lineMetrics) {
                            at = {};
                            for (const _t in se.tags)
                                at[_t] = se.tags[_t];
                            at.mapbox_clip_start = Me.start / Me.size,
                            at.mapbox_clip_end = Me.end / Me.size
                        }
                        const Qe = {
                            geometry: et,
                            type: $e === "Polygon" || $e === "MultiPolygon" ? 3 : $e === "LineString" || $e === "MultiLineString" ? 2 : 1,
                            tags: at
                        };
                        se.id !== null && (Qe.id = se.id),
                        Ue.features.push(Qe)
                    }
                }
                function Dn(Ue, se, fe, ge, Me, $e) {
                    const et = ge * ge;
                    if (ge > 0 && se.size < (Me ? et : ge))
                        return void (fe.numPoints += se.length / 3);
                    const at = [];
                    for (let Qe = 0; Qe < se.length; Qe += 3)
                        (ge === 0 || se[Qe + 2] > et) && (fe.numSimplified++,
                        at.push(se[Qe], se[Qe + 1])),
                        fe.numPoints++;
                    Me && function(Qe, _t) {
                        let dt = 0;
                        for (let tt = 0, St = Qe.length, Ve = St - 2; tt < St; Ve = tt,
                        tt += 2)
                            dt += (Qe[tt] - Qe[Ve]) * (Qe[tt + 1] + Qe[Ve + 1]);
                        if (dt > 0 === _t)
                            for (let tt = 0, St = Qe.length; tt < St / 2; tt += 2) {
                                const Ve = Qe[tt]
                                  , Ut = Qe[tt + 1];
                                Qe[tt] = Qe[St - 2 - tt],
                                Qe[tt + 1] = Qe[St - 1 - tt],
                                Qe[St - 2 - tt] = Ve,
                                Qe[St - 1 - tt] = Ut
                            }
                    }(at, $e),
                    Ue.push(at)
                }
                const yn = {
                    maxZoom: 14,
                    indexMaxZoom: 5,
                    indexMaxPoints: 1e5,
                    tolerance: 3,
                    extent: 4096,
                    buffer: 64,
                    lineMetrics: !1,
                    promoteId: null,
                    generateId: !1,
                    debug: 0
                };
                class Tn {
                    constructor(se, fe) {
                        const ge = (fe = this.options = function($e, et) {
                            for (const at in et)
                                $e[at] = et[at];
                            return $e
                        }(Object.create(yn), fe)).debug;
                        if (ge && console.time("preprocess data"),
                        fe.maxZoom < 0 || fe.maxZoom > 24)
                            throw new Error("maxZoom should be in the 0-24 range");
                        if (fe.promoteId && fe.generateId)
                            throw new Error("promoteId and generateId cannot be used together.");
                        let Me = function($e, et) {
                            const at = [];
                            if ($e.type === "FeatureCollection")
                                for (let Qe = 0; Qe < $e.features.length; Qe++)
                                    Nt(at, $e.features[Qe], et, Qe);
                            else
                                Nt(at, $e.type === "Feature" ? $e : {
                                    geometry: $e
                                }, et);
                            return at
                        }(se, fe);
                        this.tiles = {},
                        this.tileCoords = [],
                        ge && (console.timeEnd("preprocess data"),
                        console.log("index: maxZoom: %d, maxPoints: %d", fe.indexMaxZoom, fe.indexMaxPoints),
                        console.time("generate tiles"),
                        this.stats = {},
                        this.total = 0),
                        Me = function($e, et) {
                            const at = et.buffer / et.extent;
                            let Qe = $e;
                            const _t = Yt($e, 1, -1 - at, at, 0, -1, 2, et)
                              , dt = Yt($e, 1, 1 - at, 2 + at, 0, -1, 2, et);
                            return (_t || dt) && (Qe = Yt($e, 1, -at, 1 + at, 0, -1, 2, et) || [],
                            _t && (Qe = Zr(_t, 1).concat(Qe)),
                            dt && (Qe = Qe.concat(Zr(dt, -1)))),
                            Qe
                        }(Me, fe),
                        Me.length && this.splitTile(Me, 0, 0, 0),
                        ge && (Me.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints),
                        console.timeEnd("generate tiles"),
                        console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
                    }
                    splitTile(se, fe, ge, Me, $e, et, at) {
                        const Qe = [se, fe, ge, Me]
                          , _t = this.options
                          , dt = _t.debug;
                        for (; Qe.length; ) {
                            Me = Qe.pop(),
                            ge = Qe.pop(),
                            fe = Qe.pop(),
                            se = Qe.pop();
                            const tt = 1 << fe
                              , St = bn(fe, ge, Me);
                            let Ve = this.tiles[St];
                            if (!Ve && (dt > 1 && console.time("creation"),
                            Ve = this.tiles[St] = Wr(se, fe, ge, Me, _t),
                            this.tileCoords.push({
                                z: fe,
                                x: ge,
                                y: Me
                            }),
                            dt)) {
                                dt > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", fe, ge, Me, Ve.numFeatures, Ve.numPoints, Ve.numSimplified),
                                console.timeEnd("creation"));
                                const le = `z${fe}`;
                                this.stats[le] = (this.stats[le] || 0) + 1,
                                this.total++
                            }
                            if (Ve.source = se,
                            $e == null) {
                                if (fe === _t.indexMaxZoom || Ve.numPoints <= _t.indexMaxPoints)
                                    continue
                            } else {
                                if (fe === _t.maxZoom || fe === $e)
                                    continue;
                                if ($e != null) {
                                    const le = $e - fe;
                                    if (ge !== et >> le || Me !== at >> le)
                                        continue
                                }
                            }
                            if (Ve.source = null,
                            se.length === 0)
                                continue;
                            dt > 1 && console.time("clipping");
                            const Ut = .5 * _t.buffer / _t.extent
                              , yr = .5 - Ut
                              , Ht = .5 + Ut
                              , sr = 1 + Ut;
                            let br = null
                              , en = null
                              , qr = null
                              , Dr = null
                              , fr = Yt(se, tt, ge - Ut, ge + Ht, 0, Ve.minX, Ve.maxX, _t)
                              , ke = Yt(se, tt, ge + yr, ge + sr, 0, Ve.minX, Ve.maxX, _t);
                            se = null,
                            fr && (br = Yt(fr, tt, Me - Ut, Me + Ht, 1, Ve.minY, Ve.maxY, _t),
                            en = Yt(fr, tt, Me + yr, Me + sr, 1, Ve.minY, Ve.maxY, _t),
                            fr = null),
                            ke && (qr = Yt(ke, tt, Me - Ut, Me + Ht, 1, Ve.minY, Ve.maxY, _t),
                            Dr = Yt(ke, tt, Me + yr, Me + sr, 1, Ve.minY, Ve.maxY, _t),
                            ke = null),
                            dt > 1 && console.timeEnd("clipping"),
                            Qe.push(br || [], fe + 1, 2 * ge, 2 * Me),
                            Qe.push(en || [], fe + 1, 2 * ge, 2 * Me + 1),
                            Qe.push(qr || [], fe + 1, 2 * ge + 1, 2 * Me),
                            Qe.push(Dr || [], fe + 1, 2 * ge + 1, 2 * Me + 1)
                        }
                    }
                    getTile(se, fe, ge) {
                        se = +se,
                        fe = +fe,
                        ge = +ge;
                        const Me = this.options
                          , {extent: $e, debug: et} = Me;
                        if (se < 0 || se > 24)
                            return null;
                        const at = 1 << se
                          , Qe = bn(se, fe = fe + at & at - 1, ge);
                        if (this.tiles[Qe])
                            return gn(this.tiles[Qe], $e);
                        et > 1 && console.log("drilling down to z%d-%d-%d", se, fe, ge);
                        let _t, dt = se, tt = fe, St = ge;
                        for (; !_t && dt > 0; )
                            dt--,
                            tt >>= 1,
                            St >>= 1,
                            _t = this.tiles[bn(dt, tt, St)];
                        return _t && _t.source ? (et > 1 && (console.log("found parent tile z%d-%d-%d", dt, tt, St),
                        console.time("drilling down")),
                        this.splitTile(_t.source, dt, tt, St, se, fe, ge),
                        et > 1 && console.timeEnd("drilling down"),
                        this.tiles[Qe] ? gn(this.tiles[Qe], $e) : null) : null
                    }
                }
                function bn(Ue, se, fe) {
                    return 32 * ((1 << Ue) * fe + se) + Ue
                }
                function sn(Ue, se) {
                    return se ? Ue.properties[se] : Ue.id
                }
                function Mt(Ue, se) {
                    if (Ue == null)
                        return !0;
                    if (Ue.type === "Feature")
                        return sn(Ue, se) != null;
                    if (Ue.type === "FeatureCollection") {
                        const fe = new Set;
                        for (const ge of Ue.features) {
                            const Me = sn(ge, se);
                            if (Me == null || fe.has(Me))
                                return !1;
                            fe.add(Me)
                        }
                        return !0
                    }
                    return !1
                }
                function kt(Ue, se) {
                    const fe = new Map;
                    if (Ue != null)
                        if (Ue.type === "Feature")
                            fe.set(sn(Ue, se), Ue);
                        else
                            for (const ge of Ue.features)
                                fe.set(sn(ge, se), ge);
                    return fe
                }
                class er extends L {
                    constructor() {
                        super(...arguments),
                        this._dataUpdateable = new Map
                    }
                    loadVectorTile(se, fe) {
                        return f._(this, void 0, void 0, function*() {
                            const ge = se.tileID.canonical;
                            if (!this._geoJSONIndex)
                                throw new Error("Unable to parse the data into a cluster or geojson");
                            const Me = this._geoJSONIndex.getTile(ge.z, ge.x, ge.y);
                            if (!Me)
                                return null;
                            const $e = new ue(Me.features);
                            let et = Ee($e);
                            return et.byteOffset === 0 && et.byteLength === et.buffer.byteLength || (et = new Uint8Array(et)),
                            {
                                vectorTile: $e,
                                rawData: et.buffer
                            }
                        })
                    }
                    loadData(se) {
                        return f._(this, void 0, void 0, function*() {
                            var fe;
                            (fe = this._pendingRequest) === null || fe === void 0 || fe.abort();
                            const ge = !!(se && se.request && se.request.collectResourceTiming) && new f.cM(se.request);
                            this._pendingRequest = new AbortController;
                            try {
                                this._pendingData = this.loadAndProcessGeoJSON(se, this._pendingRequest),
                                this._geoJSONIndex = se.cluster ? new nt(function({superclusterOptions: et, clusterProperties: at}) {
                                    if (!at || !et)
                                        return et;
                                    const Qe = {}
                                      , _t = {}
                                      , dt = {
                                        accumulated: null,
                                        zoom: 0
                                    }
                                      , tt = {
                                        properties: null
                                    }
                                      , St = Object.keys(at);
                                    for (const Ve of St) {
                                        const [Ut,yr] = at[Ve]
                                          , Ht = f.cT(yr)
                                          , sr = f.cT(typeof Ut == "string" ? [Ut, ["accumulated"], ["get", Ve]] : Ut);
                                        Qe[Ve] = Ht.value,
                                        _t[Ve] = sr.value
                                    }
                                    return et.map = Ve => {
                                        tt.properties = Ve;
                                        const Ut = {};
                                        for (const yr of St)
                                            Ut[yr] = Qe[yr].evaluate(dt, tt);
                                        return Ut
                                    }
                                    ,
                                    et.reduce = (Ve, Ut) => {
                                        tt.properties = Ut;
                                        for (const yr of St)
                                            dt.accumulated = Ve[yr],
                                            Ve[yr] = _t[yr].evaluate(dt, tt)
                                    }
                                    ,
                                    et
                                }(se)).load((yield this._pendingData).features) : (Me = yield this._pendingData,
                                new Tn(Me,se.geojsonVtOptions)),
                                this.loaded = {};
                                const $e = {};
                                if (ge) {
                                    const et = ge.finish();
                                    et && ($e.resourceTiming = {},
                                    $e.resourceTiming[se.source] = JSON.parse(JSON.stringify(et)))
                                }
                                return $e
                            } catch ($e) {
                                if (delete this._pendingRequest,
                                f.cx($e))
                                    return {
                                        abandoned: !0
                                    };
                                throw $e
                            }
                            var Me
                        })
                    }
                    getData() {
                        return f._(this, void 0, void 0, function*() {
                            return this._pendingData
                        })
                    }
                    reloadTile(se) {
                        const fe = this.loaded;
                        return fe && fe[se.uid] ? super.reloadTile(se) : this.loadTile(se)
                    }
                    loadAndProcessGeoJSON(se, fe) {
                        return f._(this, void 0, void 0, function*() {
                            let ge = yield this.loadGeoJSON(se, fe);
                            if (delete this._pendingRequest,
                            typeof ge != "object")
                                throw new Error(`Input data given to '${se.source}' is not a valid GeoJSON object.`);
                            if (V(ge, !0),
                            se.filter) {
                                const Me = f.cT(se.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if (Me.result === "error")
                                    throw new Error(Me.value.map(et => `${et.key}: ${et.message}`).join(", "));
                                ge = {
                                    type: "FeatureCollection",
                                    features: ge.features.filter(et => Me.value.evaluate({
                                        zoom: 0
                                    }, et))
                                }
                            }
                            return ge
                        })
                    }
                    loadGeoJSON(se, fe) {
                        return f._(this, void 0, void 0, function*() {
                            const {promoteId: ge} = se;
                            if (se.request) {
                                const Me = yield f.j(se.request, fe);
                                return this._dataUpdateable = Mt(Me.data, ge) ? kt(Me.data, ge) : void 0,
                                Me.data
                            }
                            if (typeof se.data == "string")
                                try {
                                    const Me = JSON.parse(se.data);
                                    return this._dataUpdateable = Mt(Me, ge) ? kt(Me, ge) : void 0,
                                    Me
                                } catch {
                                    throw new Error(`Input data given to '${se.source}' is not a valid GeoJSON object.`)
                                }
                            if (!se.dataDiff)
                                throw new Error(`Input data given to '${se.source}' is not a valid GeoJSON object.`);
                            if (!this._dataUpdateable)
                                throw new Error(`Cannot update existing geojson data in ${se.source}`);
                            return function(Me, $e, et) {
                                var at, Qe, _t, dt;
                                if ($e.removeAll && Me.clear(),
                                $e.remove)
                                    for (const tt of $e.remove)
                                        Me.delete(tt);
                                if ($e.add)
                                    for (const tt of $e.add) {
                                        const St = sn(tt, et);
                                        St != null && Me.set(St, tt)
                                    }
                                if ($e.update)
                                    for (const tt of $e.update) {
                                        let St = Me.get(tt.id);
                                        if (St == null)
                                            continue;
                                        const Ve = !tt.removeAllProperties && (((at = tt.removeProperties) === null || at === void 0 ? void 0 : at.length) > 0 || ((Qe = tt.addOrUpdateProperties) === null || Qe === void 0 ? void 0 : Qe.length) > 0);
                                        if ((tt.newGeometry || tt.removeAllProperties || Ve) && (St = Object.assign({}, St),
                                        Me.set(tt.id, St),
                                        Ve && (St.properties = Object.assign({}, St.properties))),
                                        tt.newGeometry && (St.geometry = tt.newGeometry),
                                        tt.removeAllProperties)
                                            St.properties = {};
                                        else if (((_t = tt.removeProperties) === null || _t === void 0 ? void 0 : _t.length) > 0)
                                            for (const Ut of tt.removeProperties)
                                                Object.prototype.hasOwnProperty.call(St.properties, Ut) && delete St.properties[Ut];
                                        if (((dt = tt.addOrUpdateProperties) === null || dt === void 0 ? void 0 : dt.length) > 0)
                                            for (const {key: Ut, value: yr} of tt.addOrUpdateProperties)
                                                St.properties[Ut] = yr
                                    }
                            }(this._dataUpdateable, se.dataDiff, ge),
                            {
                                type: "FeatureCollection",
                                features: Array.from(this._dataUpdateable.values())
                            }
                        })
                    }
                    removeSource(se) {
                        return f._(this, void 0, void 0, function*() {
                            this._pendingRequest && this._pendingRequest.abort()
                        })
                    }
                    getClusterExpansionZoom(se) {
                        return this._geoJSONIndex.getClusterExpansionZoom(se.clusterId)
                    }
                    getClusterChildren(se) {
                        return this._geoJSONIndex.getChildren(se.clusterId)
                    }
                    getClusterLeaves(se) {
                        return this._geoJSONIndex.getLeaves(se.clusterId, se.limit, se.offset)
                    }
                }
                class Er {
                    constructor(se) {
                        this.self = se,
                        this.actor = new f.J(se),
                        this.layerIndexes = {},
                        this.availableImages = {},
                        this.workerSources = {},
                        this.demWorkerSources = {},
                        this.externalWorkerSourceTypes = {},
                        this.self.registerWorkerSource = (fe, ge) => {
                            if (this.externalWorkerSourceTypes[fe])
                                throw new Error(`Worker source with name "${fe}" already registered.`);
                            this.externalWorkerSourceTypes[fe] = ge
                        }
                        ,
                        this.self.addProtocol = f.cz,
                        this.self.removeProtocol = f.cA,
                        this.self.registerRTLTextPlugin = fe => {
                            f.cU.setMethods(fe)
                        }
                        ,
                        this.actor.registerMessageHandler("LDT", (fe, ge) => this._getDEMWorkerSource(fe, ge.source).loadTile(ge)),
                        this.actor.registerMessageHandler("RDT", (fe, ge) => f._(this, void 0, void 0, function*() {
                            this._getDEMWorkerSource(fe, ge.source).removeTile(ge)
                        })),
                        this.actor.registerMessageHandler("GCEZ", (fe, ge) => f._(this, void 0, void 0, function*() {
                            return this._getWorkerSource(fe, ge.type, ge.source).getClusterExpansionZoom(ge)
                        })),
                        this.actor.registerMessageHandler("GCC", (fe, ge) => f._(this, void 0, void 0, function*() {
                            return this._getWorkerSource(fe, ge.type, ge.source).getClusterChildren(ge)
                        })),
                        this.actor.registerMessageHandler("GCL", (fe, ge) => f._(this, void 0, void 0, function*() {
                            return this._getWorkerSource(fe, ge.type, ge.source).getClusterLeaves(ge)
                        })),
                        this.actor.registerMessageHandler("LD", (fe, ge) => this._getWorkerSource(fe, ge.type, ge.source).loadData(ge)),
                        this.actor.registerMessageHandler("GD", (fe, ge) => this._getWorkerSource(fe, ge.type, ge.source).getData()),
                        this.actor.registerMessageHandler("LT", (fe, ge) => this._getWorkerSource(fe, ge.type, ge.source).loadTile(ge)),
                        this.actor.registerMessageHandler("RT", (fe, ge) => this._getWorkerSource(fe, ge.type, ge.source).reloadTile(ge)),
                        this.actor.registerMessageHandler("AT", (fe, ge) => this._getWorkerSource(fe, ge.type, ge.source).abortTile(ge)),
                        this.actor.registerMessageHandler("RMT", (fe, ge) => this._getWorkerSource(fe, ge.type, ge.source).removeTile(ge)),
                        this.actor.registerMessageHandler("RS", (fe, ge) => f._(this, void 0, void 0, function*() {
                            if (!this.workerSources[fe] || !this.workerSources[fe][ge.type] || !this.workerSources[fe][ge.type][ge.source])
                                return;
                            const Me = this.workerSources[fe][ge.type][ge.source];
                            delete this.workerSources[fe][ge.type][ge.source],
                            Me.removeSource !== void 0 && Me.removeSource(ge)
                        })),
                        this.actor.registerMessageHandler("RM", fe => f._(this, void 0, void 0, function*() {
                            delete this.layerIndexes[fe],
                            delete this.availableImages[fe],
                            delete this.workerSources[fe],
                            delete this.demWorkerSources[fe]
                        })),
                        this.actor.registerMessageHandler("SR", (fe, ge) => f._(this, void 0, void 0, function*() {
                            this.referrer = ge
                        })),
                        this.actor.registerMessageHandler("SRPS", (fe, ge) => this._syncRTLPluginState(fe, ge)),
                        this.actor.registerMessageHandler("IS", (fe, ge) => f._(this, void 0, void 0, function*() {
                            this.self.importScripts(ge)
                        })),
                        this.actor.registerMessageHandler("SI", (fe, ge) => this._setImages(fe, ge)),
                        this.actor.registerMessageHandler("UL", (fe, ge) => f._(this, void 0, void 0, function*() {
                            this._getLayerIndex(fe).update(ge.layers, ge.removedIds)
                        })),
                        this.actor.registerMessageHandler("SL", (fe, ge) => f._(this, void 0, void 0, function*() {
                            this._getLayerIndex(fe).replace(ge)
                        }))
                    }
                    _setImages(se, fe) {
                        return f._(this, void 0, void 0, function*() {
                            this.availableImages[se] = fe;
                            for (const ge in this.workerSources[se]) {
                                const Me = this.workerSources[se][ge];
                                for (const $e in Me)
                                    Me[$e].availableImages = fe
                            }
                        })
                    }
                    _syncRTLPluginState(se, fe) {
                        return f._(this, void 0, void 0, function*() {
                            return yield f.cU.syncState(fe, this.self.importScripts)
                        })
                    }
                    _getAvailableImages(se) {
                        let fe = this.availableImages[se];
                        return fe || (fe = []),
                        fe
                    }
                    _getLayerIndex(se) {
                        let fe = this.layerIndexes[se];
                        return fe || (fe = this.layerIndexes[se] = new o),
                        fe
                    }
                    _getWorkerSource(se, fe, ge) {
                        if (this.workerSources[se] || (this.workerSources[se] = {}),
                        this.workerSources[se][fe] || (this.workerSources[se][fe] = {}),
                        !this.workerSources[se][fe][ge]) {
                            const Me = {
                                sendAsync: ($e, et) => ($e.targetMapId = se,
                                this.actor.sendAsync($e, et))
                            };
                            switch (fe) {
                            case "vector":
                                this.workerSources[se][fe][ge] = new L(Me,this._getLayerIndex(se),this._getAvailableImages(se));
                                break;
                            case "geojson":
                                this.workerSources[se][fe][ge] = new er(Me,this._getLayerIndex(se),this._getAvailableImages(se));
                                break;
                            default:
                                this.workerSources[se][fe][ge] = new this.externalWorkerSourceTypes[fe](Me,this._getLayerIndex(se),this._getAvailableImages(se))
                            }
                        }
                        return this.workerSources[se][fe][ge]
                    }
                    _getDEMWorkerSource(se, fe) {
                        return this.demWorkerSources[se] || (this.demWorkerSources[se] = {}),
                        this.demWorkerSources[se][fe] || (this.demWorkerSources[se][fe] = new z),
                        this.demWorkerSources[se][fe]
                    }
                }
                return f.i(self) && (self.worker = new Er(self)),
                Er
            }),
            u("index", ["exports", "./shared"], function(f, o) {
                var w = "5.6.1";
                function T() {
                    var v = new o.A(4);
                    return o.A != Float32Array && (v[1] = 0,
                    v[2] = 0),
                    v[0] = 1,
                    v[3] = 1,
                    v
                }
                let k, L;
                const z = {
                    now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),
                    frame(v, r, a) {
                        const m = requestAnimationFrame(x => {
                            y(),
                            r(x)
                        }
                        )
                          , {unsubscribe: y} = o.s(v.signal, "abort", () => {
                            y(),
                            cancelAnimationFrame(m),
                            a(o.c())
                        }
                        , !1)
                    },
                    frameAsync(v) {
                        return new Promise( (r, a) => {
                            this.frame(v, r, a)
                        }
                        )
                    },
                    getImageData(v, r=0) {
                        return this.getImageCanvasContext(v).getImageData(-r, -r, v.width + 2 * r, v.height + 2 * r)
                    },
                    getImageCanvasContext(v) {
                        const r = window.document.createElement("canvas")
                          , a = r.getContext("2d", {
                            willReadFrequently: !0
                        });
                        if (!a)
                            throw new Error("failed to create canvas 2d context");
                        return r.width = v.width,
                        r.height = v.height,
                        a.drawImage(v, 0, 0, v.width, v.height),
                        a
                    },
                    resolveURL: v => (k || (k = document.createElement("a")),
                    k.href = v,
                    k.href),
                    hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
                    get prefersReducedMotion() {
                        return !!matchMedia && (L == null && (L = matchMedia("(prefers-reduced-motion: reduce)")),
                        L.matches)
                    }
                };
                class D {
                    static testProp(r) {
                        if (!D.docStyle)
                            return r[0];
                        for (let a = 0; a < r.length; a++)
                            if (r[a]in D.docStyle)
                                return r[a];
                        return r[0]
                    }
                    static create(r, a, m) {
                        const y = window.document.createElement(r);
                        return a !== void 0 && (y.className = a),
                        m && m.appendChild(y),
                        y
                    }
                    static createNS(r, a) {
                        return window.document.createElementNS(r, a)
                    }
                    static disableDrag() {
                        D.docStyle && D.selectProp && (D.userSelect = D.docStyle[D.selectProp],
                        D.docStyle[D.selectProp] = "none")
                    }
                    static enableDrag() {
                        D.docStyle && D.selectProp && (D.docStyle[D.selectProp] = D.userSelect)
                    }
                    static setTransform(r, a) {
                        r.style[D.transformProp] = a
                    }
                    static addEventListener(r, a, m, y={}) {
                        r.addEventListener(a, m, "passive"in y ? y : y.capture)
                    }
                    static removeEventListener(r, a, m, y={}) {
                        r.removeEventListener(a, m, "passive"in y ? y : y.capture)
                    }
                    static suppressClickInternal(r) {
                        r.preventDefault(),
                        r.stopPropagation(),
                        window.removeEventListener("click", D.suppressClickInternal, !0)
                    }
                    static suppressClick() {
                        window.addEventListener("click", D.suppressClickInternal, !0),
                        window.setTimeout( () => {
                            window.removeEventListener("click", D.suppressClickInternal, !0)
                        }
                        , 0)
                    }
                    static getScale(r) {
                        const a = r.getBoundingClientRect();
                        return {
                            x: a.width / r.offsetWidth || 1,
                            y: a.height / r.offsetHeight || 1,
                            boundingClientRect: a
                        }
                    }
                    static getPoint(r, a, m) {
                        const y = a.boundingClientRect;
                        return new o.P((m.clientX - y.left) / a.x - r.clientLeft,(m.clientY - y.top) / a.y - r.clientTop)
                    }
                    static mousePos(r, a) {
                        const m = D.getScale(r);
                        return D.getPoint(r, m, a)
                    }
                    static touchPos(r, a) {
                        const m = []
                          , y = D.getScale(r);
                        for (let x = 0; x < a.length; x++)
                            m.push(D.getPoint(r, y, a[x]));
                        return m
                    }
                    static mouseButton(r) {
                        return r.button
                    }
                    static remove(r) {
                        r.parentNode && r.parentNode.removeChild(r)
                    }
                    static sanitize(r) {
                        const a = new DOMParser().parseFromString(r, "text/html").body || document.createElement("body")
                          , m = a.querySelectorAll("script");
                        for (const y of m)
                            y.remove();
                        return D.clean(a),
                        a.innerHTML
                    }
                    static isPossiblyDangerous(r, a) {
                        const m = a.replace(/\s+/g, "").toLowerCase();
                        return !(!["src", "href", "xlink:href"].includes(r) || !m.includes("javascript:") && !m.includes("data:")) || !!r.startsWith("on") || void 0
                    }
                    static clean(r) {
                        const a = r.children;
                        for (const m of a)
                            D.removeAttributes(m),
                            D.clean(m)
                    }
                    static removeAttributes(r) {
                        for (const {name: a, value: m} of r.attributes)
                            D.isPossiblyDangerous(a, m) && r.removeAttribute(a)
                    }
                }
                D.docStyle = typeof window < "u" && window.document && window.document.documentElement.style,
                D.selectProp = D.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]),
                D.transformProp = D.testProp(["transform", "WebkitTransform"]);
                const N = {
                    supported: !1,
                    testSupport: function(v) {
                        !re && V && (ie ? ue(v) : U = v)
                    }
                };
                let U, V, re = !1, ie = !1;
                function ue(v) {
                    const r = v.createTexture();
                    v.bindTexture(v.TEXTURE_2D, r);
                    try {
                        if (v.texImage2D(v.TEXTURE_2D, 0, v.RGBA, v.RGBA, v.UNSIGNED_BYTE, V),
                        v.isContextLost())
                            return;
                        N.supported = !0
                    } catch {}
                    v.deleteTexture(r),
                    re = !0
                }
                var ce;
                typeof document < "u" && (V = document.createElement("img"),
                V.onload = () => {
                    U && ue(U),
                    U = null,
                    ie = !0
                }
                ,
                V.onerror = () => {
                    re = !0,
                    U = null
                }
                ,
                V.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="),
                function(v) {
                    let r, a, m, y;
                    v.resetRequestQueue = () => {
                        r = [],
                        a = 0,
                        m = 0,
                        y = {}
                    }
                    ,
                    v.addThrottleControl = A => {
                        const B = m++;
                        return y[B] = A,
                        B
                    }
                    ,
                    v.removeThrottleControl = A => {
                        delete y[A],
                        P()
                    }
                    ,
                    v.getImage = (A, B, $=!0) => new Promise( (Z, H) => {
                        N.supported && (A.headers || (A.headers = {}),
                        A.headers.accept = "image/webp,*/*"),
                        o.e(A, {
                            type: "image"
                        }),
                        r.push({
                            abortController: B,
                            requestParameters: A,
                            supportImageRefresh: $,
                            state: "queued",
                            onError: Y => {
                                H(Y)
                            }
                            ,
                            onSuccess: Y => {
                                Z(Y)
                            }
                        }),
                        P()
                    }
                    );
                    const x = A => o._(this, void 0, void 0, function*() {
                        A.state = "running";
                        const {requestParameters: B, supportImageRefresh: $, onError: Z, onSuccess: H, abortController: Y} = A
                          , ae = $ === !1 && !o.i(self) && !o.g(B.url) && (!B.headers || Object.keys(B.headers).reduce( (Te, Re) => Te && Re === "accept", !0));
                        a++;
                        const ye = ae ? I(B, Y) : o.m(B, Y);
                        try {
                            const Te = yield ye;
                            delete A.abortController,
                            A.state = "completed",
                            Te.data instanceof HTMLImageElement || o.b(Te.data) ? H(Te) : Te.data && H({
                                data: yield(Se = Te.data,
                                typeof createImageBitmap == "function" ? o.f(Se) : o.h(Se)),
                                cacheControl: Te.cacheControl,
                                expires: Te.expires
                            })
                        } catch (Te) {
                            delete A.abortController,
                            Z(Te)
                        } finally {
                            a--,
                            P()
                        }
                        var Se
                    })
                      , P = () => {
                        const A = ( () => {
                            for (const B of Object.keys(y))
                                if (y[B]())
                                    return !0;
                            return !1
                        }
                        )() ? o.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : o.a.MAX_PARALLEL_IMAGE_REQUESTS;
                        for (let B = a; B < A && r.length > 0; B++) {
                            const $ = r.shift();
                            $.abortController.signal.aborted ? B-- : x($)
                        }
                    }
                      , I = (A, B) => new Promise( ($, Z) => {
                        const H = new Image
                          , Y = A.url
                          , ae = A.credentials;
                        ae && ae === "include" ? H.crossOrigin = "use-credentials" : (ae && ae === "same-origin" || !o.d(Y)) && (H.crossOrigin = "anonymous"),
                        B.signal.addEventListener("abort", () => {
                            H.src = "",
                            Z(o.c())
                        }
                        ),
                        H.fetchPriority = "high",
                        H.onload = () => {
                            H.onerror = H.onload = null,
                            $({
                                data: H
                            })
                        }
                        ,
                        H.onerror = () => {
                            H.onerror = H.onload = null,
                            B.signal.aborted || Z(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
                        }
                        ,
                        H.src = Y
                    }
                    )
                }(ce || (ce = {})),
                ce.resetRequestQueue();
                class X {
                    constructor(r) {
                        this._transformRequestFn = r
                    }
                    transformRequest(r, a) {
                        return this._transformRequestFn && this._transformRequestFn(r, a) || {
                            url: r
                        }
                    }
                    setTransformRequest(r) {
                        this._transformRequestFn = r
                    }
                }
                function me(v) {
                    const r = [];
                    if (typeof v == "string")
                        r.push({
                            id: "default",
                            url: v
                        });
                    else if (v && v.length > 0) {
                        const a = [];
                        for (const {id: m, url: y} of v) {
                            const x = `${m}${y}`;
                            a.indexOf(x) === -1 && (a.push(x),
                            r.push({
                                id: m,
                                url: y
                            }))
                        }
                    }
                    return r
                }
                function K(v, r, a) {
                    try {
                        const m = new URL(v);
                        return m.pathname += `${r}${a}`,
                        m.toString()
                    } catch {
                        throw new Error(`Invalid sprite URL "${v}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
                    }
                }
                function be(v) {
                    const {userImage: r} = v;
                    return !!(r && r.render && r.render()) && (v.data.replace(new Uint8Array(r.data.buffer)),
                    !0)
                }
                class Ee extends o.E {
                    constructor() {
                        super(),
                        this.images = {},
                        this.updatedImages = {},
                        this.callbackDispatchedThisFrame = {},
                        this.loaded = !1,
                        this.requestors = [],
                        this.patterns = {},
                        this.atlasImage = new o.R({
                            width: 1,
                            height: 1
                        }),
                        this.dirty = !0
                    }
                    isLoaded() {
                        return this.loaded
                    }
                    setLoaded(r) {
                        if (this.loaded !== r && (this.loaded = r,
                        r)) {
                            for (const {ids: a, promiseResolve: m} of this.requestors)
                                m(this._getImagesForIds(a));
                            this.requestors = []
                        }
                    }
                    getImage(r) {
                        const a = this.images[r];
                        if (a && !a.data && a.spriteData) {
                            const m = a.spriteData;
                            a.data = new o.R({
                                width: m.width,
                                height: m.height
                            },m.context.getImageData(m.x, m.y, m.width, m.height).data),
                            a.spriteData = null
                        }
                        return a
                    }
                    addImage(r, a) {
                        if (this.images[r])
                            throw new Error(`Image id ${r} already exist, use updateImage instead`);
                        this._validate(r, a) && (this.images[r] = a)
                    }
                    _validate(r, a) {
                        let m = !0;
                        const y = a.data || a.spriteData;
                        return this._validateStretch(a.stretchX, y && y.width) || (this.fire(new o.k(new Error(`Image "${r}" has invalid "stretchX" value`))),
                        m = !1),
                        this._validateStretch(a.stretchY, y && y.height) || (this.fire(new o.k(new Error(`Image "${r}" has invalid "stretchY" value`))),
                        m = !1),
                        this._validateContent(a.content, a) || (this.fire(new o.k(new Error(`Image "${r}" has invalid "content" value`))),
                        m = !1),
                        m
                    }
                    _validateStretch(r, a) {
                        if (!r)
                            return !0;
                        let m = 0;
                        for (const y of r) {
                            if (y[0] < m || y[1] < y[0] || a < y[1])
                                return !1;
                            m = y[1]
                        }
                        return !0
                    }
                    _validateContent(r, a) {
                        if (!r)
                            return !0;
                        if (r.length !== 4)
                            return !1;
                        const m = a.spriteData
                          , y = m && m.width || a.data.width
                          , x = m && m.height || a.data.height;
                        return !(r[0] < 0 || y < r[0] || r[1] < 0 || x < r[1] || r[2] < 0 || y < r[2] || r[3] < 0 || x < r[3] || r[2] < r[0] || r[3] < r[1])
                    }
                    updateImage(r, a, m=!0) {
                        const y = this.getImage(r);
                        if (m && (y.data.width !== a.data.width || y.data.height !== a.data.height))
                            throw new Error(`size mismatch between old image (${y.data.width}x${y.data.height}) and new image (${a.data.width}x${a.data.height}).`);
                        a.version = y.version + 1,
                        this.images[r] = a,
                        this.updatedImages[r] = !0
                    }
                    removeImage(r) {
                        const a = this.images[r];
                        delete this.images[r],
                        delete this.patterns[r],
                        a.userImage && a.userImage.onRemove && a.userImage.onRemove()
                    }
                    listImages() {
                        return Object.keys(this.images)
                    }
                    getImages(r) {
                        return new Promise( (a, m) => {
                            let y = !0;
                            if (!this.isLoaded())
                                for (const x of r)
                                    this.images[x] || (y = !1);
                            this.isLoaded() || y ? a(this._getImagesForIds(r)) : this.requestors.push({
                                ids: r,
                                promiseResolve: a
                            })
                        }
                        )
                    }
                    _getImagesForIds(r) {
                        const a = {};
                        for (const m of r) {
                            let y = this.getImage(m);
                            y || (this.fire(new o.l("styleimagemissing",{
                                id: m
                            })),
                            y = this.getImage(m)),
                            y ? a[m] = {
                                data: y.data.clone(),
                                pixelRatio: y.pixelRatio,
                                sdf: y.sdf,
                                version: y.version,
                                stretchX: y.stretchX,
                                stretchY: y.stretchY,
                                content: y.content,
                                textFitWidth: y.textFitWidth,
                                textFitHeight: y.textFitHeight,
                                hasRenderCallback: !!(y.userImage && y.userImage.render)
                            } : o.w(`Image "${m}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
                        }
                        return a
                    }
                    getPixelSize() {
                        const {width: r, height: a} = this.atlasImage;
                        return {
                            width: r,
                            height: a
                        }
                    }
                    getPattern(r) {
                        const a = this.patterns[r]
                          , m = this.getImage(r);
                        if (!m)
                            return null;
                        if (a && a.position.version === m.version)
                            return a.position;
                        if (a)
                            a.position.version = m.version;
                        else {
                            const y = {
                                w: m.data.width + 2,
                                h: m.data.height + 2,
                                x: 0,
                                y: 0
                            }
                              , x = new o.I(y,m);
                            this.patterns[r] = {
                                bin: y,
                                position: x
                            }
                        }
                        return this._updatePatternAtlas(),
                        this.patterns[r].position
                    }
                    bind(r) {
                        const a = r.gl;
                        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage),
                        this.dirty = !1) : this.atlasTexture = new o.T(r,this.atlasImage,a.RGBA),
                        this.atlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE)
                    }
                    _updatePatternAtlas() {
                        const r = [];
                        for (const x in this.patterns)
                            r.push(this.patterns[x].bin);
                        const {w: a, h: m} = o.p(r)
                          , y = this.atlasImage;
                        y.resize({
                            width: a || 1,
                            height: m || 1
                        });
                        for (const x in this.patterns) {
                            const {bin: P} = this.patterns[x]
                              , I = P.x + 1
                              , A = P.y + 1
                              , B = this.getImage(x).data
                              , $ = B.width
                              , Z = B.height;
                            o.R.copy(B, y, {
                                x: 0,
                                y: 0
                            }, {
                                x: I,
                                y: A
                            }, {
                                width: $,
                                height: Z
                            }),
                            o.R.copy(B, y, {
                                x: 0,
                                y: Z - 1
                            }, {
                                x: I,
                                y: A - 1
                            }, {
                                width: $,
                                height: 1
                            }),
                            o.R.copy(B, y, {
                                x: 0,
                                y: 0
                            }, {
                                x: I,
                                y: A + Z
                            }, {
                                width: $,
                                height: 1
                            }),
                            o.R.copy(B, y, {
                                x: $ - 1,
                                y: 0
                            }, {
                                x: I - 1,
                                y: A
                            }, {
                                width: 1,
                                height: Z
                            }),
                            o.R.copy(B, y, {
                                x: 0,
                                y: 0
                            }, {
                                x: I + $,
                                y: A
                            }, {
                                width: 1,
                                height: Z
                            })
                        }
                        this.dirty = !0
                    }
                    beginFrame() {
                        this.callbackDispatchedThisFrame = {}
                    }
                    dispatchRenderCallbacks(r) {
                        for (const a of r) {
                            if (this.callbackDispatchedThisFrame[a])
                                continue;
                            this.callbackDispatchedThisFrame[a] = !0;
                            const m = this.getImage(a);
                            m || o.w(`Image with ID: "${a}" was not found`),
                            be(m) && this.updateImage(a, m)
                        }
                    }
                }
                const Ce = 1e20;
                function He(v, r, a, m, y, x, P, I, A) {
                    for (let B = r; B < r + m; B++)
                        ct(v, a * x + B, x, y, P, I, A);
                    for (let B = a; B < a + y; B++)
                        ct(v, B * x + r, 1, m, P, I, A)
                }
                function ct(v, r, a, m, y, x, P) {
                    x[0] = 0,
                    P[0] = -Ce,
                    P[1] = Ce,
                    y[0] = v[r];
                    for (let I = 1, A = 0, B = 0; I < m; I++) {
                        y[I] = v[r + I * a];
                        const $ = I * I;
                        do {
                            const Z = x[A];
                            B = (y[I] - y[Z] + $ - Z * Z) / (I - Z) / 2
                        } while (B <= P[A] && --A > -1);
                        A++,
                        x[A] = I,
                        P[A] = B,
                        P[A + 1] = Ce
                    }
                    for (let I = 0, A = 0; I < m; I++) {
                        for (; P[A + 1] < I; )
                            A++;
                        const B = x[A]
                          , $ = I - B;
                        v[r + I * a] = y[B] + $ * $
                    }
                }
                class nt {
                    constructor(r, a) {
                        this.requestManager = r,
                        this.localIdeographFontFamily = a,
                        this.entries = {}
                    }
                    setURL(r) {
                        this.url = r
                    }
                    getGlyphs(r) {
                        return o._(this, void 0, void 0, function*() {
                            const a = [];
                            for (const x in r)
                                for (const P of r[x])
                                    a.push(this._getAndCacheGlyphsPromise(x, P));
                            const m = yield Promise.all(a)
                              , y = {};
                            for (const {stack: x, id: P, glyph: I} of m)
                                y[x] || (y[x] = {}),
                                y[x][P] = I && {
                                    id: I.id,
                                    bitmap: I.bitmap.clone(),
                                    metrics: I.metrics
                                };
                            return y
                        })
                    }
                    _getAndCacheGlyphsPromise(r, a) {
                        return o._(this, void 0, void 0, function*() {
                            let m = this.entries[r];
                            m || (m = this.entries[r] = {
                                glyphs: {},
                                requests: {},
                                ranges: {}
                            });
                            let y = m.glyphs[a];
                            if (y !== void 0)
                                return {
                                    stack: r,
                                    id: a,
                                    glyph: y
                                };
                            if (y = this._tinySDF(m, r, a),
                            y)
                                return m.glyphs[a] = y,
                                {
                                    stack: r,
                                    id: a,
                                    glyph: y
                                };
                            const x = Math.floor(a / 256);
                            if (256 * x > 65535)
                                throw new Error("glyphs > 65535 not supported");
                            if (m.ranges[x])
                                return {
                                    stack: r,
                                    id: a,
                                    glyph: y
                                };
                            if (!this.url)
                                throw new Error("glyphsUrl is not set");
                            if (!m.requests[x]) {
                                const I = nt.loadGlyphRange(r, x, this.url, this.requestManager);
                                m.requests[x] = I
                            }
                            const P = yield m.requests[x];
                            for (const I in P)
                                this._doesCharSupportLocalGlyph(+I) || (m.glyphs[+I] = P[+I]);
                            return m.ranges[x] = !0,
                            {
                                stack: r,
                                id: a,
                                glyph: P[a] || null
                            }
                        })
                    }
                    _doesCharSupportLocalGlyph(r) {
                        return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}","u").test(String.fromCodePoint(r)) || o.u["CJK Unified Ideographs"](r) || o.u["Hangul Syllables"](r) || o.u.Hiragana(r) || o.u.Katakana(r) || o.u["CJK Symbols and Punctuation"](r) || o.u["Halfwidth and Fullwidth Forms"](r))
                    }
                    _tinySDF(r, a, m) {
                        const y = this.localIdeographFontFamily;
                        if (!y || !this._doesCharSupportLocalGlyph(m))
                            return;
                        let x = r.tinySDF;
                        if (!x) {
                            let I = "400";
                            /bold/i.test(a) ? I = "900" : /medium/i.test(a) ? I = "500" : /light/i.test(a) && (I = "200"),
                            x = r.tinySDF = new nt.TinySDF({
                                fontSize: 48,
                                buffer: 6,
                                radius: 16,
                                cutoff: .25,
                                fontFamily: y,
                                fontWeight: I
                            })
                        }
                        const P = x.draw(String.fromCharCode(m));
                        return {
                            id: m,
                            bitmap: new o.q({
                                width: P.width || 60,
                                height: P.height || 60
                            },P.data),
                            metrics: {
                                width: P.glyphWidth / 2 || 24,
                                height: P.glyphHeight / 2 || 24,
                                left: P.glyphLeft / 2 + .5 || 0,
                                top: P.glyphTop / 2 - 27.5 || -8,
                                advance: P.glyphAdvance / 2 || 24,
                                isDoubleResolution: !0
                            }
                        }
                    }
                }
                nt.loadGlyphRange = function(v, r, a, m) {
                    return o._(this, void 0, void 0, function*() {
                        const y = 256 * r
                          , x = y + 255
                          , P = m.transformRequest(a.replace("{fontstack}", v).replace("{range}", `${y}-${x}`), "Glyphs")
                          , I = yield o.n(P, new AbortController);
                        if (!I || !I.data)
                            throw new Error(`Could not load glyph range. range: ${r}, ${y}-${x}`);
                        const A = {};
                        for (const B of o.o(I.data))
                            A[B.id] = B;
                        return A
                    })
                }
                ,
                nt.TinySDF = class {
                    constructor({fontSize: v=24, buffer: r=3, radius: a=8, cutoff: m=.25, fontFamily: y="sans-serif", fontWeight: x="normal", fontStyle: P="normal"}={}) {
                        this.buffer = r,
                        this.cutoff = m,
                        this.radius = a;
                        const I = this.size = v + 4 * r
                          , A = this._createCanvas(I)
                          , B = this.ctx = A.getContext("2d", {
                            willReadFrequently: !0
                        });
                        B.font = `${P} ${x} ${v}px ${y}`,
                        B.textBaseline = "alphabetic",
                        B.textAlign = "left",
                        B.fillStyle = "black",
                        this.gridOuter = new Float64Array(I * I),
                        this.gridInner = new Float64Array(I * I),
                        this.f = new Float64Array(I),
                        this.z = new Float64Array(I + 1),
                        this.v = new Uint16Array(I)
                    }
                    _createCanvas(v) {
                        const r = document.createElement("canvas");
                        return r.width = r.height = v,
                        r
                    }
                    draw(v) {
                        const {width: r, actualBoundingBoxAscent: a, actualBoundingBoxDescent: m, actualBoundingBoxLeft: y, actualBoundingBoxRight: x} = this.ctx.measureText(v)
                          , P = Math.ceil(a)
                          , I = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(x - y)))
                          , A = Math.min(this.size - this.buffer, P + Math.ceil(m))
                          , B = I + 2 * this.buffer
                          , $ = A + 2 * this.buffer
                          , Z = Math.max(B * $, 0)
                          , H = new Uint8ClampedArray(Z)
                          , Y = {
                            data: H,
                            width: B,
                            height: $,
                            glyphWidth: I,
                            glyphHeight: A,
                            glyphTop: P,
                            glyphLeft: 0,
                            glyphAdvance: r
                        };
                        if (I === 0 || A === 0)
                            return Y;
                        const {ctx: ae, buffer: ye, gridInner: Se, gridOuter: Te} = this;
                        ae.clearRect(ye, ye, I, A),
                        ae.fillText(v, ye, ye + P);
                        const Re = ae.getImageData(ye, ye, I, A);
                        Te.fill(Ce, 0, Z),
                        Se.fill(0, 0, Z);
                        for (let De = 0; De < A; De++)
                            for (let Ae = 0; Ae < I; Ae++) {
                                const Be = Re.data[4 * (De * I + Ae) + 3] / 255;
                                if (Be === 0)
                                    continue;
                                const qe = (De + ye) * B + Ae + ye;
                                if (Be === 1)
                                    Te[qe] = 0,
                                    Se[qe] = Ce;
                                else {
                                    const ze = .5 - Be;
                                    Te[qe] = ze > 0 ? ze * ze : 0,
                                    Se[qe] = ze < 0 ? ze * ze : 0
                                }
                            }
                        He(Te, 0, 0, B, $, B, this.f, this.v, this.z),
                        He(Se, ye, ye, I, A, B, this.f, this.v, this.z);
                        for (let De = 0; De < Z; De++) {
                            const Ae = Math.sqrt(Te[De]) - Math.sqrt(Se[De]);
                            H[De] = Math.round(255 - 255 * (Ae / this.radius + this.cutoff))
                        }
                        return Y
                    }
                }
                ;
                class J {
                    constructor() {
                        this.specification = o.v.light.position
                    }
                    possiblyEvaluate(r, a) {
                        return o.B(r.expression.evaluate(a))
                    }
                    interpolate(r, a, m) {
                        return {
                            x: o.C.number(r.x, a.x, m),
                            y: o.C.number(r.y, a.y, m),
                            z: o.C.number(r.z, a.z, m)
                        }
                    }
                }
                let he;
                class ve extends o.E {
                    constructor(r) {
                        super(),
                        he = he || new o.r({
                            anchor: new o.D(o.v.light.anchor),
                            position: new J,
                            color: new o.D(o.v.light.color),
                            intensity: new o.D(o.v.light.intensity)
                        }),
                        this._transitionable = new o.t(he),
                        this.setLight(r),
                        this._transitioning = this._transitionable.untransitioned()
                    }
                    getLight() {
                        return this._transitionable.serialize()
                    }
                    setLight(r, a={}) {
                        if (!this._validate(o.x, r, a))
                            for (const m in r) {
                                const y = r[m];
                                m.endsWith("-transition") ? this._transitionable.setTransition(m.slice(0, -11), y) : this._transitionable.setValue(m, y)
                            }
                    }
                    updateTransitions(r) {
                        this._transitioning = this._transitionable.transitioned(r, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(r) {
                        this.properties = this._transitioning.possiblyEvaluate(r)
                    }
                    _validate(r, a, m) {
                        return (!m || m.validate !== !1) && o.y(this, r.call(o.z, {
                            value: a,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: o.v
                        }))
                    }
                }
                const Ne = new o.r({
                    "sky-color": new o.D(o.v.sky["sky-color"]),
                    "horizon-color": new o.D(o.v.sky["horizon-color"]),
                    "fog-color": new o.D(o.v.sky["fog-color"]),
                    "fog-ground-blend": new o.D(o.v.sky["fog-ground-blend"]),
                    "horizon-fog-blend": new o.D(o.v.sky["horizon-fog-blend"]),
                    "sky-horizon-blend": new o.D(o.v.sky["sky-horizon-blend"]),
                    "atmosphere-blend": new o.D(o.v.sky["atmosphere-blend"])
                });
                class je extends o.E {
                    constructor(r) {
                        super(),
                        this._transitionable = new o.t(Ne),
                        this.setSky(r),
                        this._transitioning = this._transitionable.untransitioned(),
                        this.recalculate(new o.F(0))
                    }
                    setSky(r, a={}) {
                        if (!this._validate(o.G, r, a)) {
                            r || (r = {
                                "sky-color": "transparent",
                                "horizon-color": "transparent",
                                "fog-color": "transparent",
                                "fog-ground-blend": 1,
                                "atmosphere-blend": 0
                            });
                            for (const m in r) {
                                const y = r[m];
                                m.endsWith("-transition") ? this._transitionable.setTransition(m.slice(0, -11), y) : this._transitionable.setValue(m, y)
                            }
                        }
                    }
                    getSky() {
                        return this._transitionable.serialize()
                    }
                    updateTransitions(r) {
                        this._transitioning = this._transitionable.transitioned(r, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(r) {
                        this.properties = this._transitioning.possiblyEvaluate(r)
                    }
                    _validate(r, a, m={}) {
                        return m?.validate !== !1 && o.y(this, r.call(o.z, o.e({
                            value: a,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: o.v
                        })))
                    }
                    calculateFogBlendOpacity(r) {
                        return r < 60 ? 0 : r < 70 ? (r - 60) / 10 : 1
                    }
                }
                class lt {
                    constructor(r, a) {
                        this.width = r,
                        this.height = a,
                        this.nextRow = 0,
                        this.data = new Uint8Array(this.width * this.height),
                        this.dashEntry = {}
                    }
                    getDash(r, a) {
                        const m = r.join(",") + String(a);
                        return this.dashEntry[m] || (this.dashEntry[m] = this.addDash(r, a)),
                        this.dashEntry[m]
                    }
                    getDashRanges(r, a, m) {
                        const y = [];
                        let x = r.length % 2 == 1 ? -r[r.length - 1] * m : 0
                          , P = r[0] * m
                          , I = !0;
                        y.push({
                            left: x,
                            right: P,
                            isDash: I,
                            zeroLength: r[0] === 0
                        });
                        let A = r[0];
                        for (let B = 1; B < r.length; B++) {
                            I = !I;
                            const $ = r[B];
                            x = A * m,
                            A += $,
                            P = A * m,
                            y.push({
                                left: x,
                                right: P,
                                isDash: I,
                                zeroLength: $ === 0
                            })
                        }
                        return y
                    }
                    addRoundDash(r, a, m) {
                        const y = a / 2;
                        for (let x = -m; x <= m; x++) {
                            const P = this.width * (this.nextRow + m + x);
                            let I = 0
                              , A = r[I];
                            for (let B = 0; B < this.width; B++) {
                                B / A.right > 1 && (A = r[++I]);
                                const $ = Math.abs(B - A.left)
                                  , Z = Math.abs(B - A.right)
                                  , H = Math.min($, Z);
                                let Y;
                                const ae = x / m * (y + 1);
                                if (A.isDash) {
                                    const ye = y - Math.abs(ae);
                                    Y = Math.sqrt(H * H + ye * ye)
                                } else
                                    Y = y - Math.sqrt(H * H + ae * ae);
                                this.data[P + B] = Math.max(0, Math.min(255, Y + 128))
                            }
                        }
                    }
                    addRegularDash(r) {
                        for (let I = r.length - 1; I >= 0; --I) {
                            const A = r[I]
                              , B = r[I + 1];
                            A.zeroLength ? r.splice(I, 1) : B && B.isDash === A.isDash && (B.left = A.left,
                            r.splice(I, 1))
                        }
                        const a = r[0]
                          , m = r[r.length - 1];
                        a.isDash === m.isDash && (a.left = m.left - this.width,
                        m.right = a.right + this.width);
                        const y = this.width * this.nextRow;
                        let x = 0
                          , P = r[x];
                        for (let I = 0; I < this.width; I++) {
                            I / P.right > 1 && (P = r[++x]);
                            const A = Math.abs(I - P.left)
                              , B = Math.abs(I - P.right)
                              , $ = Math.min(A, B);
                            this.data[y + I] = Math.max(0, Math.min(255, (P.isDash ? $ : -$) + 128))
                        }
                    }
                    addDash(r, a) {
                        const m = a ? 7 : 0
                          , y = 2 * m + 1;
                        if (this.nextRow + y > this.height)
                            return o.w("LineAtlas out of space"),
                            null;
                        let x = 0;
                        for (let I = 0; I < r.length; I++)
                            x += r[I];
                        if (x !== 0) {
                            const I = this.width / x
                              , A = this.getDashRanges(r, this.width, I);
                            a ? this.addRoundDash(A, I, m) : this.addRegularDash(A)
                        }
                        const P = {
                            y: (this.nextRow + m + .5) / this.height,
                            height: 2 * m / this.height,
                            width: x
                        };
                        return this.nextRow += y,
                        this.dirty = !0,
                        P
                    }
                    bind(r) {
                        const a = r.gl;
                        this.texture ? (a.bindTexture(a.TEXTURE_2D, this.texture),
                        this.dirty && (this.dirty = !1,
                        a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this.width, this.height, a.ALPHA, a.UNSIGNED_BYTE, this.data))) : (this.texture = a.createTexture(),
                        a.bindTexture(a.TEXTURE_2D, this.texture),
                        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.REPEAT),
                        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.REPEAT),
                        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR),
                        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR),
                        a.texImage2D(a.TEXTURE_2D, 0, a.ALPHA, this.width, this.height, 0, a.ALPHA, a.UNSIGNED_BYTE, this.data))
                    }
                }
                const Pt = "maplibre_preloaded_worker_pool";
                class We {
                    constructor() {
                        this.active = {}
                    }
                    acquire(r) {
                        if (!this.workers)
                            for (this.workers = []; this.workers.length < We.workerCount; )
                                this.workers.push(new Worker(o.a.WORKER_URL));
                        return this.active[r] = !0,
                        this.workers.slice()
                    }
                    release(r) {
                        delete this.active[r],
                        this.numActive() === 0 && (this.workers.forEach(a => {
                            a.terminate()
                        }
                        ),
                        this.workers = null)
                    }
                    isPreloaded() {
                        return !!this.active[Pt]
                    }
                    numActive() {
                        return Object.keys(this.active).length
                    }
                }
                const st = Math.floor(z.hardwareConcurrency / 2);
                let Nt, zt;
                function Qt() {
                    return Nt || (Nt = new We),
                    Nt
                }
                We.workerCount = o.H(globalThis) ? Math.max(Math.min(st, 3), 1) : 1;
                class Wt {
                    constructor(r, a) {
                        this.workerPool = r,
                        this.actors = [],
                        this.currentActor = 0,
                        this.id = a;
                        const m = this.workerPool.acquire(a);
                        for (let y = 0; y < m.length; y++) {
                            const x = new o.J(m[y],a);
                            x.name = `Worker ${y}`,
                            this.actors.push(x)
                        }
                        if (!this.actors.length)
                            throw new Error("No actors found")
                    }
                    broadcast(r, a) {
                        const m = [];
                        for (const y of this.actors)
                            m.push(y.sendAsync({
                                type: r,
                                data: a
                            }));
                        return Promise.all(m)
                    }
                    getActor() {
                        return this.currentActor = (this.currentActor + 1) % this.actors.length,
                        this.actors[this.currentActor]
                    }
                    remove(r=!0) {
                        this.actors.forEach(a => {
                            a.remove()
                        }
                        ),
                        this.actors = [],
                        r && this.workerPool.release(this.id)
                    }
                    registerMessageHandler(r, a) {
                        for (const m of this.actors)
                            m.registerMessageHandler(r, a)
                    }
                }
                function tr() {
                    return zt || (zt = new Wt(Qt(),o.K),
                    zt.registerMessageHandler("GR", (v, r, a) => o.m(r, a))),
                    zt
                }
                function cr(v, r) {
                    const a = o.L();
                    return o.M(a, a, [1, 1, 0]),
                    o.N(a, a, [.5 * v.width, .5 * v.height, 1]),
                    v.calculatePosMatrix ? o.O(a, a, v.calculatePosMatrix(r.toUnwrapped())) : a
                }
                function Yt(v, r, a, m, y, x, P) {
                    var I;
                    const A = function(H, Y, ae) {
                        if (H)
                            for (const ye of H) {
                                const Se = Y[ye];
                                if (Se && Se.source === ae && Se.type === "fill-extrusion")
                                    return !0
                            }
                        else
                            for (const ye in Y) {
                                const Se = Y[ye];
                                if (Se.source === ae && Se.type === "fill-extrusion")
                                    return !0
                            }
                        return !1
                    }((I = y?.layers) !== null && I !== void 0 ? I : null, r, v.id)
                      , B = x.maxPitchScaleFactor()
                      , $ = v.tilesIn(m, B, A);
                    $.sort(Gr);
                    const Z = [];
                    for (const H of $)
                        Z.push({
                            wrappedTileID: H.tileID.wrapped().key,
                            queryResults: H.tile.queryRenderedFeatures(r, a, v._state, H.queryGeometry, H.cameraQueryGeometry, H.scale, y, x, B, cr(v.transform, H.tileID), P ? (Y, ae) => P(H.tileID, Y, ae) : void 0)
                        });
                    return function(H, Y) {
                        for (const ae in H)
                            for (const ye of H[ae])
                                xr(ye, Y);
                        return H
                    }(function(H) {
                        const Y = {}
                          , ae = {};
                        for (const ye of H) {
                            const Se = ye.queryResults
                              , Te = ye.wrappedTileID
                              , Re = ae[Te] = ae[Te] || {};
                            for (const De in Se) {
                                const Ae = Se[De]
                                  , Be = Re[De] = Re[De] || {}
                                  , qe = Y[De] = Y[De] || [];
                                for (const ze of Ae)
                                    Be[ze.featureIndex] || (Be[ze.featureIndex] = !0,
                                    qe.push(ze))
                            }
                        }
                        return Y
                    }(Z), v)
                }
                function Gr(v, r) {
                    const a = v.tileID
                      , m = r.tileID;
                    return a.overscaledZ - m.overscaledZ || a.canonical.y - m.canonical.y || a.wrap - m.wrap || a.canonical.x - m.canonical.x
                }
                function xr(v, r) {
                    const a = v.feature
                      , m = r.getFeatureState(a.layer["source-layer"], a.id);
                    a.source = a.layer.source,
                    a.layer["source-layer"] && (a.sourceLayer = a.layer["source-layer"]),
                    a.state = m
                }
                function Nr(v, r, a) {
                    return o._(this, void 0, void 0, function*() {
                        let m = v;
                        if (v.url ? m = (yield o.j(r.transformRequest(v.url, "Source"), a)).data : yield z.frameAsync(a),
                        !m)
                            return null;
                        const y = o.Q(o.e(m, v), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
                        return "vector_layers"in m && m.vector_layers && (y.vectorLayerIds = m.vector_layers.map(x => x.id)),
                        y
                    })
                }
                class ur {
                    constructor(r, a) {
                        r && (a ? this.setSouthWest(r).setNorthEast(a) : Array.isArray(r) && (r.length === 4 ? this.setSouthWest([r[0], r[1]]).setNorthEast([r[2], r[3]]) : this.setSouthWest(r[0]).setNorthEast(r[1])))
                    }
                    setNorthEast(r) {
                        return this._ne = r instanceof o.S ? new o.S(r.lng,r.lat) : o.S.convert(r),
                        this
                    }
                    setSouthWest(r) {
                        return this._sw = r instanceof o.S ? new o.S(r.lng,r.lat) : o.S.convert(r),
                        this
                    }
                    extend(r) {
                        const a = this._sw
                          , m = this._ne;
                        let y, x;
                        if (r instanceof o.S)
                            y = r,
                            x = r;
                        else {
                            if (!(r instanceof ur))
                                return Array.isArray(r) ? r.length === 4 || r.every(Array.isArray) ? this.extend(ur.convert(r)) : this.extend(o.S.convert(r)) : r && ("lng"in r || "lon"in r) && "lat"in r ? this.extend(o.S.convert(r)) : this;
                            if (y = r._sw,
                            x = r._ne,
                            !y || !x)
                                return this
                        }
                        return a || m ? (a.lng = Math.min(y.lng, a.lng),
                        a.lat = Math.min(y.lat, a.lat),
                        m.lng = Math.max(x.lng, m.lng),
                        m.lat = Math.max(x.lat, m.lat)) : (this._sw = new o.S(y.lng,y.lat),
                        this._ne = new o.S(x.lng,x.lat)),
                        this
                    }
                    getCenter() {
                        return new o.S((this._sw.lng + this._ne.lng) / 2,(this._sw.lat + this._ne.lat) / 2)
                    }
                    getSouthWest() {
                        return this._sw
                    }
                    getNorthEast() {
                        return this._ne
                    }
                    getNorthWest() {
                        return new o.S(this.getWest(),this.getNorth())
                    }
                    getSouthEast() {
                        return new o.S(this.getEast(),this.getSouth())
                    }
                    getWest() {
                        return this._sw.lng
                    }
                    getSouth() {
                        return this._sw.lat
                    }
                    getEast() {
                        return this._ne.lng
                    }
                    getNorth() {
                        return this._ne.lat
                    }
                    toArray() {
                        return [this._sw.toArray(), this._ne.toArray()]
                    }
                    toString() {
                        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
                    }
                    isEmpty() {
                        return !(this._sw && this._ne)
                    }
                    contains(r) {
                        const {lng: a, lat: m} = o.S.convert(r);
                        let y = this._sw.lng <= a && a <= this._ne.lng;
                        return this._sw.lng > this._ne.lng && (y = this._sw.lng >= a && a >= this._ne.lng),
                        this._sw.lat <= m && m <= this._ne.lat && y
                    }
                    static convert(r) {
                        return r instanceof ur ? r : r && new ur(r)
                    }
                    static fromLngLat(r, a=0) {
                        const m = 360 * a / 40075017
                          , y = m / Math.cos(Math.PI / 180 * r.lat);
                        return new ur(new o.S(r.lng - y,r.lat - m),new o.S(r.lng + y,r.lat + m))
                    }
                    adjustAntiMeridian() {
                        const r = new o.S(this._sw.lng,this._sw.lat)
                          , a = new o.S(this._ne.lng,this._ne.lat);
                        return new ur(r,r.lng > a.lng ? new o.S(a.lng + 360,a.lat) : a)
                    }
                }
                class vr {
                    constructor(r, a, m) {
                        this.bounds = ur.convert(this.validateBounds(r)),
                        this.minzoom = a || 0,
                        this.maxzoom = m || 24
                    }
                    validateBounds(r) {
                        return Array.isArray(r) && r.length === 4 ? [Math.max(-180, r[0]), Math.max(-90, r[1]), Math.min(180, r[2]), Math.min(90, r[3])] : [-180, -90, 180, 90]
                    }
                    contains(r) {
                        const a = Math.pow(2, r.z)
                          , m = Math.floor(o.V(this.bounds.getWest()) * a)
                          , y = Math.floor(o.U(this.bounds.getNorth()) * a)
                          , x = Math.ceil(o.V(this.bounds.getEast()) * a)
                          , P = Math.ceil(o.U(this.bounds.getSouth()) * a);
                        return r.x >= m && r.x < x && r.y >= y && r.y < P
                    }
                }
                class gr extends o.E {
                    constructor(r, a, m, y) {
                        if (super(),
                        this.id = r,
                        this.dispatcher = m,
                        this.type = "vector",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.scheme = "xyz",
                        this.tileSize = 512,
                        this.reparseOverscaled = !0,
                        this.isTileClipped = !0,
                        this._loaded = !1,
                        o.e(this, o.Q(a, ["url", "scheme", "tileSize", "promoteId"])),
                        this._options = o.e({
                            type: "vector"
                        }, a),
                        this._collectResourceTiming = a.collectResourceTiming,
                        this.tileSize !== 512)
                            throw new Error("vector tile sources must have a tileSize of 512");
                        this.setEventedParent(y)
                    }
                    load() {
                        return o._(this, void 0, void 0, function*() {
                            this._loaded = !1,
                            this.fire(new o.l("dataloading",{
                                dataType: "source"
                            })),
                            this._tileJSONRequest = new AbortController;
                            try {
                                const r = yield Nr(this._options, this.map._requestManager, this._tileJSONRequest);
                                this._tileJSONRequest = null,
                                this._loaded = !0,
                                this.map.style.sourceCaches[this.id].clearTiles(),
                                r && (o.e(this, r),
                                r.bounds && (this.tileBounds = new vr(r.bounds,this.minzoom,this.maxzoom)),
                                this.fire(new o.l("data",{
                                    dataType: "source",
                                    sourceDataType: "metadata"
                                })),
                                this.fire(new o.l("data",{
                                    dataType: "source",
                                    sourceDataType: "content"
                                })))
                            } catch (r) {
                                this._tileJSONRequest = null,
                                this.fire(new o.k(r))
                            }
                        })
                    }
                    loaded() {
                        return this._loaded
                    }
                    hasTile(r) {
                        return !this.tileBounds || this.tileBounds.contains(r.canonical)
                    }
                    onAdd(r) {
                        this.map = r,
                        this.load()
                    }
                    setSourceProperty(r) {
                        this._tileJSONRequest && this._tileJSONRequest.abort(),
                        r(),
                        this.load()
                    }
                    setTiles(r) {
                        return this.setSourceProperty( () => {
                            this._options.tiles = r
                        }
                        ),
                        this
                    }
                    setUrl(r) {
                        return this.setSourceProperty( () => {
                            this.url = r,
                            this._options.url = r
                        }
                        ),
                        this
                    }
                    onRemove() {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(),
                        this._tileJSONRequest = null)
                    }
                    serialize() {
                        return o.e({}, this._options)
                    }
                    loadTile(r) {
                        return o._(this, void 0, void 0, function*() {
                            const a = r.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme)
                              , m = {
                                request: this.map._requestManager.transformRequest(a, "Tile"),
                                uid: r.uid,
                                tileID: r.tileID,
                                zoom: r.tileID.overscaledZ,
                                tileSize: this.tileSize * r.tileID.overscaleFactor(),
                                type: this.type,
                                source: this.id,
                                pixelRatio: this.map.getPixelRatio(),
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                promoteId: this.promoteId,
                                subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                                globalState: this.map.getGlobalState()
                            };
                            m.request.collectResourceTiming = this._collectResourceTiming;
                            let y = "RT";
                            if (r.actor && r.state !== "expired") {
                                if (r.state === "loading")
                                    return new Promise( (x, P) => {
                                        r.reloadPromise = {
                                            resolve: x,
                                            reject: P
                                        }
                                    }
                                    )
                            } else
                                r.actor = this.dispatcher.getActor(),
                                y = "LT";
                            r.abortController = new AbortController;
                            try {
                                const x = yield r.actor.sendAsync({
                                    type: y,
                                    data: m
                                }, r.abortController);
                                if (delete r.abortController,
                                r.aborted)
                                    return;
                                this._afterTileLoadWorkerResponse(r, x)
                            } catch (x) {
                                if (delete r.abortController,
                                r.aborted)
                                    return;
                                if (x && x.status !== 404)
                                    throw x;
                                this._afterTileLoadWorkerResponse(r, null)
                            }
                        })
                    }
                    _afterTileLoadWorkerResponse(r, a) {
                        if (a && a.resourceTiming && (r.resourceTiming = a.resourceTiming),
                        a && this.map._refreshExpiredTiles && r.setExpiryData(a),
                        r.loadVectorData(a, this.map.painter),
                        r.reloadPromise) {
                            const m = r.reloadPromise;
                            r.reloadPromise = null,
                            this.loadTile(r).then(m.resolve).catch(m.reject)
                        }
                    }
                    abortTile(r) {
                        return o._(this, void 0, void 0, function*() {
                            r.abortController && (r.abortController.abort(),
                            delete r.abortController),
                            r.actor && (yield r.actor.sendAsync({
                                type: "AT",
                                data: {
                                    uid: r.uid,
                                    type: this.type,
                                    source: this.id
                                }
                            }))
                        })
                    }
                    unloadTile(r) {
                        return o._(this, void 0, void 0, function*() {
                            r.unloadVectorData(),
                            r.actor && (yield r.actor.sendAsync({
                                type: "RMT",
                                data: {
                                    uid: r.uid,
                                    type: this.type,
                                    source: this.id
                                }
                            }))
                        })
                    }
                    hasTransition() {
                        return !1
                    }
                }
                class hn extends o.E {
                    constructor(r, a, m, y) {
                        super(),
                        this.id = r,
                        this.dispatcher = m,
                        this.setEventedParent(y),
                        this.type = "raster",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.roundZoom = !0,
                        this.scheme = "xyz",
                        this.tileSize = 512,
                        this._loaded = !1,
                        this._options = o.e({
                            type: "raster"
                        }, a),
                        o.e(this, o.Q(a, ["url", "scheme", "tileSize"]))
                    }
                    load() {
                        return o._(this, arguments, void 0, function*(r=!1) {
                            this._loaded = !1,
                            this.fire(new o.l("dataloading",{
                                dataType: "source"
                            })),
                            this._tileJSONRequest = new AbortController;
                            try {
                                const a = yield Nr(this._options, this.map._requestManager, this._tileJSONRequest);
                                this._tileJSONRequest = null,
                                this._loaded = !0,
                                a && (o.e(this, a),
                                a.bounds && (this.tileBounds = new vr(a.bounds,this.minzoom,this.maxzoom)),
                                this.fire(new o.l("data",{
                                    dataType: "source",
                                    sourceDataType: "metadata"
                                })),
                                this.fire(new o.l("data",{
                                    dataType: "source",
                                    sourceDataType: "content",
                                    sourceDataChanged: r
                                })))
                            } catch (a) {
                                this._tileJSONRequest = null,
                                this.fire(new o.k(a))
                            }
                        })
                    }
                    loaded() {
                        return this._loaded
                    }
                    onAdd(r) {
                        this.map = r,
                        this.load()
                    }
                    onRemove() {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(),
                        this._tileJSONRequest = null)
                    }
                    setSourceProperty(r) {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(),
                        this._tileJSONRequest = null),
                        r(),
                        this.load(!0)
                    }
                    setTiles(r) {
                        return this.setSourceProperty( () => {
                            this._options.tiles = r
                        }
                        ),
                        this
                    }
                    setUrl(r) {
                        return this.setSourceProperty( () => {
                            this.url = r,
                            this._options.url = r
                        }
                        ),
                        this
                    }
                    serialize() {
                        return o.e({}, this._options)
                    }
                    hasTile(r) {
                        return !this.tileBounds || this.tileBounds.contains(r.canonical)
                    }
                    loadTile(r) {
                        return o._(this, void 0, void 0, function*() {
                            const a = r.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
                            r.abortController = new AbortController;
                            try {
                                const m = yield ce.getImage(this.map._requestManager.transformRequest(a, "Tile"), r.abortController, this.map._refreshExpiredTiles);
                                if (delete r.abortController,
                                r.aborted)
                                    return void (r.state = "unloaded");
                                if (m && m.data) {
                                    this.map._refreshExpiredTiles && (m.cacheControl || m.expires) && r.setExpiryData({
                                        cacheControl: m.cacheControl,
                                        expires: m.expires
                                    });
                                    const y = this.map.painter.context
                                      , x = y.gl
                                      , P = m.data;
                                    r.texture = this.map.painter.getTileTexture(P.width),
                                    r.texture ? r.texture.update(P, {
                                        useMipmap: !0
                                    }) : (r.texture = new o.T(y,P,x.RGBA,{
                                        useMipmap: !0
                                    }),
                                    r.texture.bind(x.LINEAR, x.CLAMP_TO_EDGE, x.LINEAR_MIPMAP_NEAREST)),
                                    r.state = "loaded"
                                }
                            } catch (m) {
                                if (delete r.abortController,
                                r.aborted)
                                    r.state = "unloaded";
                                else if (m)
                                    throw r.state = "errored",
                                    m
                            }
                        })
                    }
                    abortTile(r) {
                        return o._(this, void 0, void 0, function*() {
                            r.abortController && (r.abortController.abort(),
                            delete r.abortController)
                        })
                    }
                    unloadTile(r) {
                        return o._(this, void 0, void 0, function*() {
                            r.texture && this.map.painter.saveTileTexture(r.texture)
                        })
                    }
                    hasTransition() {
                        return !1
                    }
                }
                class Zr extends hn {
                    constructor(r, a, m, y) {
                        super(r, a, m, y),
                        this.type = "raster-dem",
                        this.maxzoom = 22,
                        this._options = o.e({
                            type: "raster-dem"
                        }, a),
                        this.encoding = a.encoding || "mapbox",
                        this.redFactor = a.redFactor,
                        this.greenFactor = a.greenFactor,
                        this.blueFactor = a.blueFactor,
                        this.baseShift = a.baseShift
                    }
                    loadTile(r) {
                        return o._(this, void 0, void 0, function*() {
                            const a = r.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme)
                              , m = this.map._requestManager.transformRequest(a, "Tile");
                            r.neighboringTiles = this._getNeighboringTiles(r.tileID),
                            r.abortController = new AbortController;
                            try {
                                const y = yield ce.getImage(m, r.abortController, this.map._refreshExpiredTiles);
                                if (delete r.abortController,
                                r.aborted)
                                    return void (r.state = "unloaded");
                                if (y && y.data) {
                                    const x = y.data;
                                    this.map._refreshExpiredTiles && (y.cacheControl || y.expires) && r.setExpiryData({
                                        cacheControl: y.cacheControl,
                                        expires: y.expires
                                    });
                                    const P = o.b(x) && o.W() ? x : yield this.readImageNow(x)
                                      , I = {
                                        type: this.type,
                                        uid: r.uid,
                                        source: this.id,
                                        rawImageData: P,
                                        encoding: this.encoding,
                                        redFactor: this.redFactor,
                                        greenFactor: this.greenFactor,
                                        blueFactor: this.blueFactor,
                                        baseShift: this.baseShift
                                    };
                                    if (!r.actor || r.state === "expired") {
                                        r.actor = this.dispatcher.getActor();
                                        const A = yield r.actor.sendAsync({
                                            type: "LDT",
                                            data: I
                                        });
                                        r.dem = A,
                                        r.needsHillshadePrepare = !0,
                                        r.needsTerrainPrepare = !0,
                                        r.state = "loaded"
                                    }
                                }
                            } catch (y) {
                                if (delete r.abortController,
                                r.aborted)
                                    r.state = "unloaded";
                                else if (y)
                                    throw r.state = "errored",
                                    y
                            }
                        })
                    }
                    readImageNow(r) {
                        return o._(this, void 0, void 0, function*() {
                            if (typeof VideoFrame < "u" && o.X()) {
                                const a = r.width + 2
                                  , m = r.height + 2;
                                try {
                                    return new o.R({
                                        width: a,
                                        height: m
                                    },yield o.Y(r, -1, -1, a, m))
                                } catch {}
                            }
                            return z.getImageData(r, 1)
                        })
                    }
                    _getNeighboringTiles(r) {
                        const a = r.canonical
                          , m = Math.pow(2, a.z)
                          , y = (a.x - 1 + m) % m
                          , x = a.x === 0 ? r.wrap - 1 : r.wrap
                          , P = (a.x + 1 + m) % m
                          , I = a.x + 1 === m ? r.wrap + 1 : r.wrap
                          , A = {};
                        return A[new o.Z(r.overscaledZ,x,a.z,y,a.y).key] = {
                            backfilled: !1
                        },
                        A[new o.Z(r.overscaledZ,I,a.z,P,a.y).key] = {
                            backfilled: !1
                        },
                        a.y > 0 && (A[new o.Z(r.overscaledZ,x,a.z,y,a.y - 1).key] = {
                            backfilled: !1
                        },
                        A[new o.Z(r.overscaledZ,r.wrap,a.z,a.x,a.y - 1).key] = {
                            backfilled: !1
                        },
                        A[new o.Z(r.overscaledZ,I,a.z,P,a.y - 1).key] = {
                            backfilled: !1
                        }),
                        a.y + 1 < m && (A[new o.Z(r.overscaledZ,x,a.z,y,a.y + 1).key] = {
                            backfilled: !1
                        },
                        A[new o.Z(r.overscaledZ,r.wrap,a.z,a.x,a.y + 1).key] = {
                            backfilled: !1
                        },
                        A[new o.Z(r.overscaledZ,I,a.z,P,a.y + 1).key] = {
                            backfilled: !1
                        }),
                        A
                    }
                    unloadTile(r) {
                        return o._(this, void 0, void 0, function*() {
                            r.demTexture && this.map.painter.saveTileTexture(r.demTexture),
                            r.fbo && (r.fbo.destroy(),
                            delete r.fbo),
                            r.dem && delete r.dem,
                            delete r.neighboringTiles,
                            r.state = "unloaded",
                            r.actor && (yield r.actor.sendAsync({
                                type: "RDT",
                                data: {
                                    type: this.type,
                                    uid: r.uid,
                                    source: this.id
                                }
                            }))
                        })
                    }
                }
                class $r extends o.E {
                    constructor(r, a, m, y) {
                        super(),
                        this.id = r,
                        this.type = "geojson",
                        this.minzoom = 0,
                        this.maxzoom = 18,
                        this.tileSize = 512,
                        this.isTileClipped = !0,
                        this.reparseOverscaled = !0,
                        this._removed = !1,
                        this._pendingLoads = 0,
                        this.actor = m.getActor(),
                        this.setEventedParent(y),
                        this._data = a.data,
                        this._options = o.e({}, a),
                        this._collectResourceTiming = a.collectResourceTiming,
                        a.maxzoom !== void 0 && (this.maxzoom = a.maxzoom),
                        a.type && (this.type = a.type),
                        a.attribution && (this.attribution = a.attribution),
                        this.promoteId = a.promoteId,
                        a.clusterMaxZoom !== void 0 && this.maxzoom <= a.clusterMaxZoom && o.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${a.clusterMaxZoom}".`),
                        this.workerOptions = o.e({
                            source: this.id,
                            cluster: a.cluster || !1,
                            geojsonVtOptions: {
                                buffer: this._pixelsToTileUnits(a.buffer !== void 0 ? a.buffer : 128),
                                tolerance: this._pixelsToTileUnits(a.tolerance !== void 0 ? a.tolerance : .375),
                                extent: o.$,
                                maxZoom: this.maxzoom,
                                lineMetrics: a.lineMetrics || !1,
                                generateId: a.generateId || !1
                            },
                            superclusterOptions: {
                                maxZoom: this._getClusterMaxZoom(a.clusterMaxZoom),
                                minPoints: Math.max(2, a.clusterMinPoints || 2),
                                extent: o.$,
                                radius: this._pixelsToTileUnits(a.clusterRadius || 50),
                                log: !1,
                                generateId: a.generateId || !1
                            },
                            clusterProperties: a.clusterProperties,
                            filter: a.filter
                        }, a.workerOptions),
                        typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
                    }
                    _pixelsToTileUnits(r) {
                        return r * (o.$ / this.tileSize)
                    }
                    _getClusterMaxZoom(r) {
                        const a = r ? Math.round(r) : this.maxzoom - 1;
                        return Number.isInteger(r) || r === void 0 || o.w(`Integer expected for option 'clusterMaxZoom': provided value "${r}" rounded to "${a}"`),
                        a
                    }
                    load() {
                        return o._(this, void 0, void 0, function*() {
                            yield this._updateWorkerData()
                        })
                    }
                    onAdd(r) {
                        this.map = r,
                        this.load()
                    }
                    setData(r) {
                        return this._data = r,
                        this._updateWorkerData(),
                        this
                    }
                    updateData(r) {
                        return this._updateWorkerData(r),
                        this
                    }
                    getData() {
                        return o._(this, void 0, void 0, function*() {
                            const r = o.e({
                                type: this.type
                            }, this.workerOptions);
                            return this.actor.sendAsync({
                                type: "GD",
                                data: r
                            })
                        })
                    }
                    getCoordinatesFromGeometry(r) {
                        return r.type === "GeometryCollection" ? r.geometries.map(a => a.coordinates).flat(1 / 0) : r.coordinates.flat(1 / 0)
                    }
                    getBounds() {
                        return o._(this, void 0, void 0, function*() {
                            const r = new ur
                              , a = yield this.getData();
                            let m;
                            switch (a.type) {
                            case "FeatureCollection":
                                m = a.features.map(y => this.getCoordinatesFromGeometry(y.geometry)).flat(1 / 0);
                                break;
                            case "Feature":
                                m = this.getCoordinatesFromGeometry(a.geometry);
                                break;
                            default:
                                m = this.getCoordinatesFromGeometry(a)
                            }
                            if (m.length == 0)
                                return r;
                            for (let y = 0; y < m.length - 1; y += 2)
                                r.extend([m[y], m[y + 1]]);
                            return r
                        })
                    }
                    setClusterOptions(r) {
                        return this.workerOptions.cluster = r.cluster,
                        r && (r.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(r.clusterRadius)),
                        r.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(r.clusterMaxZoom))),
                        this._updateWorkerData(),
                        this
                    }
                    getClusterExpansionZoom(r) {
                        return this.actor.sendAsync({
                            type: "GCEZ",
                            data: {
                                type: this.type,
                                clusterId: r,
                                source: this.id
                            }
                        })
                    }
                    getClusterChildren(r) {
                        return this.actor.sendAsync({
                            type: "GCC",
                            data: {
                                type: this.type,
                                clusterId: r,
                                source: this.id
                            }
                        })
                    }
                    getClusterLeaves(r, a, m) {
                        return this.actor.sendAsync({
                            type: "GCL",
                            data: {
                                type: this.type,
                                source: this.id,
                                clusterId: r,
                                limit: a,
                                offset: m
                            }
                        })
                    }
                    _updateWorkerData(r) {
                        return o._(this, void 0, void 0, function*() {
                            const a = o.e({
                                type: this.type
                            }, this.workerOptions);
                            r ? a.dataDiff = r : typeof this._data == "string" ? (a.request = this.map._requestManager.transformRequest(z.resolveURL(this._data), "Source"),
                            a.request.collectResourceTiming = this._collectResourceTiming) : a.data = JSON.stringify(this._data),
                            this._pendingLoads++,
                            this.fire(new o.l("dataloading",{
                                dataType: "source"
                            }));
                            try {
                                const m = yield this.actor.sendAsync({
                                    type: "LD",
                                    data: a
                                });
                                if (this._pendingLoads--,
                                this._removed || m.abandoned)
                                    return void this.fire(new o.l("dataabort",{
                                        dataType: "source"
                                    }));
                                let y = null;
                                m.resourceTiming && m.resourceTiming[this.id] && (y = m.resourceTiming[this.id].slice(0));
                                const x = {
                                    dataType: "source"
                                };
                                this._collectResourceTiming && y && y.length > 0 && o.e(x, {
                                    resourceTiming: y
                                }),
                                this.fire(new o.l("data",Object.assign(Object.assign({}, x), {
                                    sourceDataType: "metadata"
                                }))),
                                this.fire(new o.l("data",Object.assign(Object.assign({}, x), {
                                    sourceDataType: "content"
                                })))
                            } catch (m) {
                                if (this._pendingLoads--,
                                this._removed)
                                    return void this.fire(new o.l("dataabort",{
                                        dataType: "source"
                                    }));
                                this.fire(new o.k(m))
                            }
                        })
                    }
                    loaded() {
                        return this._pendingLoads === 0
                    }
                    loadTile(r) {
                        return o._(this, void 0, void 0, function*() {
                            const a = r.actor ? "RT" : "LT";
                            r.actor = this.actor;
                            const m = {
                                type: this.type,
                                uid: r.uid,
                                tileID: r.tileID,
                                zoom: r.tileID.overscaledZ,
                                maxZoom: this.maxzoom,
                                tileSize: this.tileSize,
                                source: this.id,
                                pixelRatio: this.map.getPixelRatio(),
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                promoteId: this.promoteId,
                                subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                                globalState: this.map.getGlobalState()
                            };
                            r.abortController = new AbortController;
                            const y = yield this.actor.sendAsync({
                                type: a,
                                data: m
                            }, r.abortController);
                            delete r.abortController,
                            r.unloadVectorData(),
                            r.aborted || r.loadVectorData(y, this.map.painter, a === "RT")
                        })
                    }
                    abortTile(r) {
                        return o._(this, void 0, void 0, function*() {
                            r.abortController && (r.abortController.abort(),
                            delete r.abortController),
                            r.aborted = !0
                        })
                    }
                    unloadTile(r) {
                        return o._(this, void 0, void 0, function*() {
                            r.unloadVectorData(),
                            yield this.actor.sendAsync({
                                type: "RMT",
                                data: {
                                    uid: r.uid,
                                    type: this.type,
                                    source: this.id
                                }
                            })
                        })
                    }
                    onRemove() {
                        this._removed = !0,
                        this.actor.sendAsync({
                            type: "RS",
                            data: {
                                type: this.type,
                                source: this.id
                            }
                        })
                    }
                    serialize() {
                        return o.e({}, this._options, {
                            type: this.type,
                            data: this._data
                        })
                    }
                    hasTransition() {
                        return !1
                    }
                }
                class gn extends o.E {
                    constructor(r, a, m, y) {
                        super(),
                        this.flippedWindingOrder = !1,
                        this.id = r,
                        this.dispatcher = m,
                        this.coordinates = a.coordinates,
                        this.type = "image",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.tileSize = 512,
                        this.tiles = {},
                        this._loaded = !1,
                        this.setEventedParent(y),
                        this.options = a
                    }
                    load(r) {
                        return o._(this, void 0, void 0, function*() {
                            this._loaded = !1,
                            this.fire(new o.l("dataloading",{
                                dataType: "source"
                            })),
                            this.url = this.options.url,
                            this._request = new AbortController;
                            try {
                                const a = yield ce.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                                this._request = null,
                                this._loaded = !0,
                                a && a.data && (this.image = a.data,
                                r && (this.coordinates = r),
                                this._finishLoading())
                            } catch (a) {
                                this._request = null,
                                this._loaded = !0,
                                this.fire(new o.k(a))
                            }
                        })
                    }
                    loaded() {
                        return this._loaded
                    }
                    updateImage(r) {
                        return r.url ? (this._request && (this._request.abort(),
                        this._request = null),
                        this.options.url = r.url,
                        this.load(r.coordinates).finally( () => {
                            this.texture = null
                        }
                        ),
                        this) : this
                    }
                    _finishLoading() {
                        this.map && (this.setCoordinates(this.coordinates),
                        this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "metadata"
                        })))
                    }
                    onAdd(r) {
                        this.map = r,
                        this.load()
                    }
                    onRemove() {
                        this._request && (this._request.abort(),
                        this._request = null)
                    }
                    setCoordinates(r) {
                        this.coordinates = r;
                        const a = r.map(o.a0.fromLngLat);
                        var m;
                        return this.tileID = function(y) {
                            const x = o.a1.fromPoints(y)
                              , P = x.width()
                              , I = x.height()
                              , A = Math.max(P, I)
                              , B = Math.max(0, Math.floor(-Math.log(A) / Math.LN2))
                              , $ = Math.pow(2, B);
                            return new o.a3(B,Math.floor((x.minX + x.maxX) / 2 * $),Math.floor((x.minY + x.maxY) / 2 * $))
                        }(a),
                        this.terrainTileRanges = this._getOverlappingTileRanges(a),
                        this.minzoom = this.maxzoom = this.tileID.z,
                        this.tileCoords = a.map(y => this.tileID.getTilePoint(y)._round()),
                        this.flippedWindingOrder = ((m = this.tileCoords)[1].x - m[0].x) * (m[2].y - m[0].y) - (m[1].y - m[0].y) * (m[2].x - m[0].x) < 0,
                        this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "content"
                        })),
                        this
                    }
                    prepare() {
                        if (Object.keys(this.tiles).length === 0 || !this.image)
                            return;
                        const r = this.map.painter.context
                          , a = r.gl;
                        this.texture || (this.texture = new o.T(r,this.image,a.RGBA),
                        this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
                        let m = !1;
                        for (const y in this.tiles) {
                            const x = this.tiles[y];
                            x.state !== "loaded" && (x.state = "loaded",
                            x.texture = this.texture,
                            m = !0)
                        }
                        m && this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "idle",
                            sourceId: this.id
                        }))
                    }
                    loadTile(r) {
                        return o._(this, void 0, void 0, function*() {
                            this.tileID && this.tileID.equals(r.tileID.canonical) ? (this.tiles[String(r.tileID.wrap)] = r,
                            r.buckets = {}) : r.state = "errored"
                        })
                    }
                    serialize() {
                        return {
                            type: "image",
                            url: this.options.url,
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return !1
                    }
                    _getOverlappingTileRanges(r) {
                        const {minX: a, minY: m, maxX: y, maxY: x} = o.a1.fromPoints(r)
                          , P = {};
                        for (let I = 0; I <= o.a2; I++) {
                            const A = Math.pow(2, I)
                              , B = Math.floor(a * A)
                              , $ = Math.floor(m * A)
                              , Z = Math.floor(y * A)
                              , H = Math.floor(x * A);
                            P[I] = {
                                minTileX: B,
                                minTileY: $,
                                maxTileX: Z,
                                maxTileY: H
                            }
                        }
                        return P
                    }
                }
                class zr extends gn {
                    constructor(r, a, m, y) {
                        super(r, a, m, y),
                        this.roundZoom = !0,
                        this.type = "video",
                        this.options = a
                    }
                    load() {
                        return o._(this, void 0, void 0, function*() {
                            this._loaded = !1;
                            const r = this.options;
                            this.urls = [];
                            for (const a of r.urls)
                                this.urls.push(this.map._requestManager.transformRequest(a, "Source").url);
                            try {
                                const a = yield o.a4(this.urls);
                                if (this._loaded = !0,
                                !a)
                                    return;
                                this.video = a,
                                this.video.loop = !0,
                                this.video.addEventListener("playing", () => {
                                    this.map.triggerRepaint()
                                }
                                ),
                                this.map && this.video.play(),
                                this._finishLoading()
                            } catch (a) {
                                this.fire(new o.k(a))
                            }
                        })
                    }
                    pause() {
                        this.video && this.video.pause()
                    }
                    play() {
                        this.video && this.video.play()
                    }
                    seek(r) {
                        if (this.video) {
                            const a = this.video.seekable;
                            r < a.start(0) || r > a.end(0) ? this.fire(new o.k(new o.a5(`sources.${this.id}`,null,`Playback for this video can be set only between the ${a.start(0)} and ${a.end(0)}-second mark.`))) : this.video.currentTime = r
                        }
                    }
                    getVideo() {
                        return this.video
                    }
                    onAdd(r) {
                        this.map || (this.map = r,
                        this.load(),
                        this.video && (this.video.play(),
                        this.setCoordinates(this.coordinates)))
                    }
                    prepare() {
                        if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
                            return;
                        const r = this.map.painter.context
                          , a = r.gl;
                        this.texture ? this.video.paused || (this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE),
                        a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, a.RGBA, a.UNSIGNED_BYTE, this.video)) : (this.texture = new o.T(r,this.video,a.RGBA),
                        this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
                        let m = !1;
                        for (const y in this.tiles) {
                            const x = this.tiles[y];
                            x.state !== "loaded" && (x.state = "loaded",
                            x.texture = this.texture,
                            m = !0)
                        }
                        m && this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "idle",
                            sourceId: this.id
                        }))
                    }
                    serialize() {
                        return {
                            type: "video",
                            urls: this.urls,
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return this.video && !this.video.paused
                    }
                }
                class Wr extends gn {
                    constructor(r, a, m, y) {
                        super(r, a, m, y),
                        a.coordinates ? Array.isArray(a.coordinates) && a.coordinates.length === 4 && !a.coordinates.some(x => !Array.isArray(x) || x.length !== 2 || x.some(P => typeof P != "number")) || this.fire(new o.k(new o.a5(`sources.${r}`,null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.k(new o.a5(`sources.${r}`,null,'missing required property "coordinates"'))),
                        a.animate && typeof a.animate != "boolean" && this.fire(new o.k(new o.a5(`sources.${r}`,null,'optional "animate" property must be a boolean value'))),
                        a.canvas ? typeof a.canvas == "string" || a.canvas instanceof HTMLCanvasElement || this.fire(new o.k(new o.a5(`sources.${r}`,null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.k(new o.a5(`sources.${r}`,null,'missing required property "canvas"'))),
                        this.options = a,
                        this.animate = a.animate === void 0 || a.animate
                    }
                    load() {
                        return o._(this, void 0, void 0, function*() {
                            this._loaded = !0,
                            this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)),
                            this.width = this.canvas.width,
                            this.height = this.canvas.height,
                            this._hasInvalidDimensions() ? this.fire(new o.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                                this._playing = !0,
                                this.map.triggerRepaint()
                            }
                            ,
                            this.pause = function() {
                                this._playing && (this.prepare(),
                                this._playing = !1)
                            }
                            ,
                            this._finishLoading())
                        })
                    }
                    getCanvas() {
                        return this.canvas
                    }
                    onAdd(r) {
                        this.map = r,
                        this.load(),
                        this.canvas && this.animate && this.play()
                    }
                    onRemove() {
                        this.pause()
                    }
                    prepare() {
                        let r = !1;
                        if (this.canvas.width !== this.width && (this.width = this.canvas.width,
                        r = !0),
                        this.canvas.height !== this.height && (this.height = this.canvas.height,
                        r = !0),
                        this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0)
                            return;
                        const a = this.map.painter.context
                          , m = a.gl;
                        this.texture ? (r || this._playing) && this.texture.update(this.canvas, {
                            premultiply: !0
                        }) : this.texture = new o.T(a,this.canvas,m.RGBA,{
                            premultiply: !0
                        });
                        let y = !1;
                        for (const x in this.tiles) {
                            const P = this.tiles[x];
                            P.state !== "loaded" && (P.state = "loaded",
                            P.texture = this.texture,
                            y = !0)
                        }
                        y && this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "idle",
                            sourceId: this.id
                        }))
                    }
                    serialize() {
                        return {
                            type: "canvas",
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return this._playing
                    }
                    _hasInvalidDimensions() {
                        for (const r of [this.canvas.width, this.canvas.height])
                            if (isNaN(r) || r <= 0)
                                return !0;
                        return !1
                    }
                }
                const $n = {}
                  , Dn = v => {
                    switch (v) {
                    case "geojson":
                        return $r;
                    case "image":
                        return gn;
                    case "raster":
                        return hn;
                    case "raster-dem":
                        return Zr;
                    case "vector":
                        return gr;
                    case "video":
                        return zr;
                    case "canvas":
                        return Wr
                    }
                    return $n[v]
                }
                  , yn = "RTLPluginLoaded";
                class Tn extends o.E {
                    constructor() {
                        super(...arguments),
                        this.status = "unavailable",
                        this.url = null,
                        this.dispatcher = tr()
                    }
                    _syncState(r) {
                        return this.status = r,
                        this.dispatcher.broadcast("SRPS", {
                            pluginStatus: r,
                            pluginURL: this.url
                        }).catch(a => {
                            throw this.status = "error",
                            a
                        }
                        )
                    }
                    getRTLTextPluginStatus() {
                        return this.status
                    }
                    clearRTLTextPlugin() {
                        this.status = "unavailable",
                        this.url = null
                    }
                    setRTLTextPlugin(r) {
                        return o._(this, arguments, void 0, function*(a, m=!1) {
                            if (this.url)
                                throw new Error("setRTLTextPlugin cannot be called multiple times.");
                            if (this.url = z.resolveURL(a),
                            !this.url)
                                throw new Error(`requested url ${a} is invalid`);
                            if (this.status === "unavailable") {
                                if (!m)
                                    return this._requestImport();
                                this.status = "deferred",
                                this._syncState(this.status)
                            } else if (this.status === "requested")
                                return this._requestImport()
                        })
                    }
                    _requestImport() {
                        return o._(this, void 0, void 0, function*() {
                            yield this._syncState("loading"),
                            this.status = "loaded",
                            this.fire(new o.l(yn))
                        })
                    }
                    lazyLoad() {
                        this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
                    }
                }
                let bn = null;
                function sn() {
                    return bn || (bn = new Tn),
                    bn
                }
                class Mt {
                    constructor(r, a) {
                        this.timeAdded = 0,
                        this.fadeEndTime = 0,
                        this.tileID = r,
                        this.uid = o.a6(),
                        this.uses = 0,
                        this.tileSize = a,
                        this.buckets = {},
                        this.expirationTime = null,
                        this.queryPadding = 0,
                        this.hasSymbolBuckets = !1,
                        this.hasRTLText = !1,
                        this.dependencies = {},
                        this.rtt = [],
                        this.rttCoords = {},
                        this.expiredRequestCount = 0,
                        this.state = "loading"
                    }
                    registerFadeDuration(r) {
                        const a = r + this.timeAdded;
                        a < this.fadeEndTime || (this.fadeEndTime = a)
                    }
                    wasRequested() {
                        return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
                    }
                    clearTextures(r) {
                        this.demTexture && r.saveTileTexture(this.demTexture),
                        this.demTexture = null
                    }
                    loadVectorData(r, a, m) {
                        if (this.hasData() && this.unloadVectorData(),
                        this.state = "loaded",
                        r) {
                            r.featureIndex && (this.latestFeatureIndex = r.featureIndex,
                            r.rawTileData ? (this.latestRawTileData = r.rawTileData,
                            this.latestFeatureIndex.rawTileData = r.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)),
                            this.collisionBoxArray = r.collisionBoxArray,
                            this.buckets = function(y, x) {
                                const P = {};
                                if (!x)
                                    return P;
                                for (const I of y) {
                                    const A = I.layerIds.map(B => x.getLayer(B)).filter(Boolean);
                                    if (A.length !== 0) {
                                        I.layers = A,
                                        I.stateDependentLayerIds && (I.stateDependentLayers = I.stateDependentLayerIds.map(B => A.filter($ => $.id === B)[0]));
                                        for (const B of A)
                                            P[B.id] = I
                                    }
                                }
                                return P
                            }(r.buckets, a?.style),
                            this.hasSymbolBuckets = !1;
                            for (const y in this.buckets) {
                                const x = this.buckets[y];
                                if (x instanceof o.a8) {
                                    if (this.hasSymbolBuckets = !0,
                                    !m)
                                        break;
                                    x.justReloaded = !0
                                }
                            }
                            if (this.hasRTLText = !1,
                            this.hasSymbolBuckets)
                                for (const y in this.buckets) {
                                    const x = this.buckets[y];
                                    if (x instanceof o.a8 && x.hasRTLText) {
                                        this.hasRTLText = !0,
                                        sn().lazyLoad();
                                        break
                                    }
                                }
                            this.queryPadding = 0;
                            for (const y in this.buckets) {
                                const x = this.buckets[y];
                                this.queryPadding = Math.max(this.queryPadding, a.style.getLayer(y).queryRadius(x))
                            }
                            r.imageAtlas && (this.imageAtlas = r.imageAtlas),
                            r.glyphAtlasImage && (this.glyphAtlasImage = r.glyphAtlasImage)
                        } else
                            this.collisionBoxArray = new o.a7
                    }
                    unloadVectorData() {
                        for (const r in this.buckets)
                            this.buckets[r].destroy();
                        this.buckets = {},
                        this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                        this.imageAtlas && (this.imageAtlas = null),
                        this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                        this.latestFeatureIndex = null,
                        this.state = "unloaded"
                    }
                    getBucket(r) {
                        return this.buckets[r.id]
                    }
                    upload(r) {
                        for (const m in this.buckets) {
                            const y = this.buckets[m];
                            y.uploadPending() && y.upload(r)
                        }
                        const a = r.gl;
                        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new o.T(r,this.imageAtlas.image,a.RGBA),
                        this.imageAtlas.uploaded = !0),
                        this.glyphAtlasImage && (this.glyphAtlasTexture = new o.T(r,this.glyphAtlasImage,a.ALPHA),
                        this.glyphAtlasImage = null)
                    }
                    prepare(r) {
                        this.imageAtlas && this.imageAtlas.patchUpdatedImages(r, this.imageAtlasTexture)
                    }
                    queryRenderedFeatures(r, a, m, y, x, P, I, A, B, $, Z) {
                        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                            queryGeometry: y,
                            cameraQueryGeometry: x,
                            scale: P,
                            tileSize: this.tileSize,
                            pixelPosMatrix: $,
                            transform: A,
                            params: I,
                            queryPadding: this.queryPadding * B,
                            getElevation: Z
                        }, r, a, m) : {}
                    }
                    querySourceFeatures(r, a) {
                        const m = this.latestFeatureIndex;
                        if (!m || !m.rawTileData)
                            return;
                        const y = m.loadVTLayers()
                          , x = a && a.sourceLayer ? a.sourceLayer : ""
                          , P = y._geojsonTileLayer || y[x];
                        if (!P)
                            return;
                        const I = o.a9(a && a.filter)
                          , {z: A, x: B, y: $} = this.tileID.canonical
                          , Z = {
                            z: A,
                            x: B,
                            y: $
                        };
                        for (let H = 0; H < P.length; H++) {
                            const Y = P.feature(H);
                            if (I.needGeometry) {
                                const Se = o.aa(Y, !0);
                                if (!I.filter(new o.F(this.tileID.overscaledZ), Se, this.tileID.canonical))
                                    continue
                            } else if (!I.filter(new o.F(this.tileID.overscaledZ), Y))
                                continue;
                            const ae = m.getId(Y, x)
                              , ye = new o.ab(Y,A,B,$,ae);
                            ye.tile = Z,
                            r.push(ye)
                        }
                    }
                    hasData() {
                        return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
                    }
                    patternsLoaded() {
                        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
                    }
                    setExpiryData(r) {
                        const a = this.expirationTime;
                        if (r.cacheControl) {
                            const m = o.ac(r.cacheControl);
                            m["max-age"] && (this.expirationTime = Date.now() + 1e3 * m["max-age"])
                        } else
                            r.expires && (this.expirationTime = new Date(r.expires).getTime());
                        if (this.expirationTime) {
                            const m = Date.now();
                            let y = !1;
                            if (this.expirationTime > m)
                                y = !1;
                            else if (a)
                                if (this.expirationTime < a)
                                    y = !0;
                                else {
                                    const x = this.expirationTime - a;
                                    x ? this.expirationTime = m + Math.max(x, 3e4) : y = !0
                                }
                            else
                                y = !0;
                            y ? (this.expiredRequestCount++,
                            this.state = "expired") : this.expiredRequestCount = 0
                        }
                    }
                    getExpiryTimeout() {
                        if (this.expirationTime)
                            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
                    }
                    setFeatureState(r, a) {
                        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(r).length === 0)
                            return;
                        const m = this.latestFeatureIndex.loadVTLayers();
                        for (const y in this.buckets) {
                            if (!a.style.hasLayer(y))
                                continue;
                            const x = this.buckets[y]
                              , P = x.layers[0].sourceLayer || "_geojsonTileLayer"
                              , I = m[P]
                              , A = r[P];
                            if (!I || !A || Object.keys(A).length === 0)
                                continue;
                            x.update(A, I, this.imageAtlas && this.imageAtlas.patternPositions || {});
                            const B = a && a.style && a.style.getLayer(y);
                            B && (this.queryPadding = Math.max(this.queryPadding, B.queryRadius(x)))
                        }
                    }
                    holdingForFade() {
                        return this.symbolFadeHoldUntil !== void 0
                    }
                    symbolFadeFinished() {
                        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < z.now()
                    }
                    clearFadeHold() {
                        this.symbolFadeHoldUntil = void 0
                    }
                    setHoldDuration(r) {
                        this.symbolFadeHoldUntil = z.now() + r
                    }
                    setDependencies(r, a) {
                        const m = {};
                        for (const y of a)
                            m[y] = !0;
                        this.dependencies[r] = m
                    }
                    hasDependency(r, a) {
                        for (const m of r) {
                            const y = this.dependencies[m];
                            if (y) {
                                for (const x of a)
                                    if (y[x])
                                        return !0
                            }
                        }
                        return !1
                    }
                }
                class kt {
                    constructor(r, a) {
                        this.max = r,
                        this.onRemove = a,
                        this.reset()
                    }
                    reset() {
                        for (const r in this.data)
                            for (const a of this.data[r])
                                a.timeout && clearTimeout(a.timeout),
                                this.onRemove(a.value);
                        return this.data = {},
                        this.order = [],
                        this
                    }
                    add(r, a, m) {
                        const y = r.wrapped().key;
                        this.data[y] === void 0 && (this.data[y] = []);
                        const x = {
                            value: a,
                            timeout: void 0
                        };
                        if (m !== void 0 && (x.timeout = setTimeout( () => {
                            this.remove(r, x)
                        }
                        , m)),
                        this.data[y].push(x),
                        this.order.push(y),
                        this.order.length > this.max) {
                            const P = this._getAndRemoveByKey(this.order[0]);
                            P && this.onRemove(P)
                        }
                        return this
                    }
                    has(r) {
                        return r.wrapped().key in this.data
                    }
                    getAndRemove(r) {
                        return this.has(r) ? this._getAndRemoveByKey(r.wrapped().key) : null
                    }
                    _getAndRemoveByKey(r) {
                        const a = this.data[r].shift();
                        return a.timeout && clearTimeout(a.timeout),
                        this.data[r].length === 0 && delete this.data[r],
                        this.order.splice(this.order.indexOf(r), 1),
                        a.value
                    }
                    getByKey(r) {
                        const a = this.data[r];
                        return a ? a[0].value : null
                    }
                    get(r) {
                        return this.has(r) ? this.data[r.wrapped().key][0].value : null
                    }
                    remove(r, a) {
                        if (!this.has(r))
                            return this;
                        const m = r.wrapped().key
                          , y = a === void 0 ? 0 : this.data[m].indexOf(a)
                          , x = this.data[m][y];
                        return this.data[m].splice(y, 1),
                        x.timeout && clearTimeout(x.timeout),
                        this.data[m].length === 0 && delete this.data[m],
                        this.onRemove(x.value),
                        this.order.splice(this.order.indexOf(m), 1),
                        this
                    }
                    setMaxSize(r) {
                        for (this.max = r; this.order.length > this.max; ) {
                            const a = this._getAndRemoveByKey(this.order[0]);
                            a && this.onRemove(a)
                        }
                        return this
                    }
                    filter(r) {
                        const a = [];
                        for (const m in this.data)
                            for (const y of this.data[m])
                                r(y.value) || a.push(y);
                        for (const m of a)
                            this.remove(m.value.tileID, m)
                    }
                }
                class er {
                    constructor() {
                        this.state = {},
                        this.stateChanges = {},
                        this.deletedStates = {}
                    }
                    updateState(r, a, m) {
                        const y = String(a);
                        if (this.stateChanges[r] = this.stateChanges[r] || {},
                        this.stateChanges[r][y] = this.stateChanges[r][y] || {},
                        o.e(this.stateChanges[r][y], m),
                        this.deletedStates[r] === null) {
                            this.deletedStates[r] = {};
                            for (const x in this.state[r])
                                x !== y && (this.deletedStates[r][x] = null)
                        } else if (this.deletedStates[r] && this.deletedStates[r][y] === null) {
                            this.deletedStates[r][y] = {};
                            for (const x in this.state[r][y])
                                m[x] || (this.deletedStates[r][y][x] = null)
                        } else
                            for (const x in m)
                                this.deletedStates[r] && this.deletedStates[r][y] && this.deletedStates[r][y][x] === null && delete this.deletedStates[r][y][x]
                    }
                    removeFeatureState(r, a, m) {
                        if (this.deletedStates[r] === null)
                            return;
                        const y = String(a);
                        if (this.deletedStates[r] = this.deletedStates[r] || {},
                        m && a !== void 0)
                            this.deletedStates[r][y] !== null && (this.deletedStates[r][y] = this.deletedStates[r][y] || {},
                            this.deletedStates[r][y][m] = null);
                        else if (a !== void 0)
                            if (this.stateChanges[r] && this.stateChanges[r][y])
                                for (m in this.deletedStates[r][y] = {},
                                this.stateChanges[r][y])
                                    this.deletedStates[r][y][m] = null;
                            else
                                this.deletedStates[r][y] = null;
                        else
                            this.deletedStates[r] = null
                    }
                    getState(r, a) {
                        const m = String(a)
                          , y = o.e({}, (this.state[r] || {})[m], (this.stateChanges[r] || {})[m]);
                        if (this.deletedStates[r] === null)
                            return {};
                        if (this.deletedStates[r]) {
                            const x = this.deletedStates[r][a];
                            if (x === null)
                                return {};
                            for (const P in x)
                                delete y[P]
                        }
                        return y
                    }
                    initializeTileState(r, a) {
                        r.setFeatureState(this.state, a)
                    }
                    coalesceChanges(r, a) {
                        const m = {};
                        for (const y in this.stateChanges) {
                            this.state[y] = this.state[y] || {};
                            const x = {};
                            for (const P in this.stateChanges[y])
                                this.state[y][P] || (this.state[y][P] = {}),
                                o.e(this.state[y][P], this.stateChanges[y][P]),
                                x[P] = this.state[y][P];
                            m[y] = x
                        }
                        for (const y in this.deletedStates) {
                            this.state[y] = this.state[y] || {};
                            const x = {};
                            if (this.deletedStates[y] === null)
                                for (const P in this.state[y])
                                    x[P] = {},
                                    this.state[y][P] = {};
                            else
                                for (const P in this.deletedStates[y]) {
                                    if (this.deletedStates[y][P] === null)
                                        this.state[y][P] = {};
                                    else
                                        for (const I of Object.keys(this.deletedStates[y][P]))
                                            delete this.state[y][P][I];
                                    x[P] = this.state[y][P]
                                }
                            m[y] = m[y] || {},
                            o.e(m[y], x)
                        }
                        if (this.stateChanges = {},
                        this.deletedStates = {},
                        Object.keys(m).length !== 0)
                            for (const y in r)
                                r[y].setFeatureState(m, a)
                    }
                }
                const Er = 89.25;
                function Ue(v, r) {
                    const a = o.ag(r.lat, -o.ah, o.ah);
                    return new o.P(o.V(r.lng) * v,o.U(a) * v)
                }
                function se(v, r) {
                    return new o.a0(r.x / v,r.y / v).toLngLat()
                }
                function fe(v) {
                    return v.cameraToCenterDistance * Math.min(.85 * Math.tan(o.ad(90 - v.pitch)), Math.tan(o.ad(Er - v.pitch)))
                }
                function ge(v, r) {
                    const a = v.canonical
                      , m = r / o.ae(a.z)
                      , y = a.x + Math.pow(2, a.z) * v.wrap
                      , x = o.af(new Float64Array(16));
                    return o.M(x, x, [y * m, a.y * m, 0]),
                    o.N(x, x, [m / o.$, m / o.$, 1]),
                    x
                }
                function Me(v, r, a, m, y) {
                    const x = o.a0.fromLngLat(v, r)
                      , P = y * o.ai(1, v.lat)
                      , I = P * Math.cos(o.ad(a))
                      , A = Math.sqrt(P * P - I * I)
                      , B = A * Math.sin(o.ad(-m))
                      , $ = A * Math.cos(o.ad(-m));
                    return new o.a0(x.x + B,x.y + $,x.z + I)
                }
                function $e(v, r, a) {
                    const m = r.intersectsFrustum(v);
                    if (!a || m === 0)
                        return m;
                    const y = r.intersectsPlane(a);
                    return y === 0 ? 0 : m === 2 && y === 2 ? 2 : 1
                }
                function et(v, r, a) {
                    let m = 0;
                    const y = (a - r) / 10;
                    for (let x = 0; x < 10; x++)
                        m += y * Math.pow(Math.cos(r + (x + .5) / 10 * (a - r)), v);
                    return m
                }
                function at(v, r) {
                    return function(a, m, y, x, P) {
                        const I = 2 * ((v - 1) / o.aj(Math.cos(o.ad(Er - P)) / Math.cos(o.ad(Er))) - 1)
                          , A = Math.acos(y / x)
                          , B = 2 * et(I - 1, 0, o.ad(P / 2))
                          , $ = Math.min(o.ad(Er), A + o.ad(P / 2))
                          , Z = et(I - 1, Math.min($, A - o.ad(P / 2)), $)
                          , H = Math.atan(m / y)
                          , Y = Math.hypot(m, y);
                        let ae = a;
                        return ae += o.aj(x / Y / Math.max(.5, Math.cos(o.ad(P / 2)))),
                        ae += I * o.aj(Math.cos(H)) / 2,
                        ae -= o.aj(Math.max(1, Z / B / r)) / 2,
                        ae
                    }
                }
                const Qe = at(9.314, 3);
                function _t(v, r) {
                    const a = (r.roundZoom ? Math.round : Math.floor)(v.zoom + o.aj(v.tileSize / r.tileSize));
                    return Math.max(0, a)
                }
                function dt(v, r) {
                    const a = v.getCameraFrustum()
                      , m = v.getClippingPlane()
                      , y = v.screenPointToMercatorCoordinate(v.getCameraPoint())
                      , x = o.a0.fromLngLat(v.center, v.elevation);
                    y.z = x.z + Math.cos(v.pitchInRadians) * v.cameraToCenterDistance / v.worldSize;
                    const P = v.getCoveringTilesDetailsProvider()
                      , I = P.allowVariableZoom(v, r)
                      , A = _t(v, r)
                      , B = r.minzoom || 0
                      , $ = r.maxzoom !== void 0 ? r.maxzoom : v.maxZoom
                      , Z = Math.min(Math.max(0, A), $)
                      , H = Math.pow(2, Z)
                      , Y = [H * y.x, H * y.y, 0]
                      , ae = [H * x.x, H * x.y, 0]
                      , ye = Math.hypot(x.x - y.x, x.y - y.y)
                      , Se = Math.abs(x.z - y.z)
                      , Te = Math.hypot(ye, Se)
                      , Re = Be => ({
                        zoom: 0,
                        x: 0,
                        y: 0,
                        wrap: Be,
                        fullyVisible: !1
                    })
                      , De = []
                      , Ae = [];
                    if (v.renderWorldCopies && P.allowWorldCopies())
                        for (let Be = 1; Be <= 3; Be++)
                            De.push(Re(-Be)),
                            De.push(Re(Be));
                    for (De.push(Re(0)); De.length > 0; ) {
                        const Be = De.pop()
                          , qe = Be.x
                          , ze = Be.y;
                        let Ke = Be.fullyVisible;
                        const ht = {
                            x: qe,
                            y: ze,
                            z: Be.zoom
                        }
                          , ot = P.getTileBoundingVolume(ht, Be.wrap, v.elevation, r);
                        if (!Ke) {
                            const jt = $e(a, ot, m);
                            if (jt === 0)
                                continue;
                            Ke = jt === 2
                        }
                        const ut = P.distanceToTile2d(y.x, y.y, ht, ot);
                        let mt = A;
                        I && (mt = (r.calculateTileZoom || Qe)(v.zoom + o.aj(v.tileSize / r.tileSize), ut, Se, Te, v.fov)),
                        mt = (r.roundZoom ? Math.round : Math.floor)(mt),
                        mt = Math.max(0, mt);
                        const $t = Math.min(mt, $);
                        if (Be.wrap = P.getWrap(x, ht, Be.wrap),
                        Be.zoom >= $t) {
                            if (Be.zoom < B)
                                continue;
                            const jt = Z - Be.zoom
                              , It = Y[0] - .5 - (qe << jt)
                              , or = Y[1] - .5 - (ze << jt)
                              , Vr = r.reparseOverscaled ? Math.max(Be.zoom, mt) : Be.zoom;
                            Ae.push({
                                tileID: new o.Z(Be.zoom === $ ? Vr : Be.zoom,Be.wrap,Be.zoom,qe,ze),
                                distanceSq: o.ak([ae[0] - .5 - qe, ae[1] - .5 - ze]),
                                tileDistanceToCamera: Math.sqrt(It * It + or * or)
                            })
                        } else
                            for (let jt = 0; jt < 4; jt++)
                                De.push({
                                    zoom: Be.zoom + 1,
                                    x: (qe << 1) + jt % 2,
                                    y: (ze << 1) + (jt >> 1),
                                    wrap: Be.wrap,
                                    fullyVisible: Ke
                                })
                    }
                    return Ae.sort( (Be, qe) => Be.distanceSq - qe.distanceSq).map(Be => Be.tileID)
                }
                const tt = o.a1.fromPoints([new o.P(0,0), new o.P(o.$,o.$)]);
                class St extends o.E {
                    constructor(r, a, m) {
                        super(),
                        this.id = r,
                        this.dispatcher = m,
                        this.on("data", y => this._dataHandler(y)),
                        this.on("dataloading", () => {
                            this._sourceErrored = !1
                        }
                        ),
                        this.on("error", () => {
                            this._sourceErrored = this._source.loaded()
                        }
                        ),
                        this._source = ( (y, x, P, I) => {
                            const A = new (Dn(x.type))(y,x,P,I);
                            if (A.id !== y)
                                throw new Error(`Expected Source id to be ${y} instead of ${A.id}`);
                            return A
                        }
                        )(r, a, m, this),
                        this._tiles = {},
                        this._cache = new kt(0,y => this._unloadTile(y)),
                        this._timers = {},
                        this._cacheTimers = {},
                        this._maxTileCacheSize = null,
                        this._maxTileCacheZoomLevels = null,
                        this._loadedParentTiles = {},
                        this._coveredTiles = {},
                        this._state = new er,
                        this._didEmitContent = !1,
                        this._updated = !1
                    }
                    onAdd(r) {
                        this.map = r,
                        this._maxTileCacheSize = r ? r._maxTileCacheSize : null,
                        this._maxTileCacheZoomLevels = r ? r._maxTileCacheZoomLevels : null,
                        this._source && this._source.onAdd && this._source.onAdd(r)
                    }
                    onRemove(r) {
                        this.clearTiles(),
                        this._source && this._source.onRemove && this._source.onRemove(r)
                    }
                    loaded() {
                        if (this._sourceErrored)
                            return !0;
                        if (!this._sourceLoaded || !this._source.loaded())
                            return !1;
                        if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain))
                            return !0;
                        if (!this._updated)
                            return !1;
                        for (const r in this._tiles) {
                            const a = this._tiles[r];
                            if (a.state !== "loaded" && a.state !== "errored")
                                return !1
                        }
                        return !0
                    }
                    getSource() {
                        return this._source
                    }
                    pause() {
                        this._paused = !0
                    }
                    resume() {
                        if (!this._paused)
                            return;
                        const r = this._shouldReloadOnResume;
                        this._paused = !1,
                        this._shouldReloadOnResume = !1,
                        r && this.reload(),
                        this.transform && this.update(this.transform, this.terrain)
                    }
                    _loadTile(r, a, m) {
                        return o._(this, void 0, void 0, function*() {
                            try {
                                yield this._source.loadTile(r),
                                this._tileLoaded(r, a, m)
                            } catch (y) {
                                r.state = "errored",
                                y.status !== 404 ? this._source.fire(new o.k(y,{
                                    tile: r
                                })) : this.update(this.transform, this.terrain)
                            }
                        })
                    }
                    _unloadTile(r) {
                        this._source.unloadTile && this._source.unloadTile(r)
                    }
                    _abortTile(r) {
                        this._source.abortTile && this._source.abortTile(r),
                        this._source.fire(new o.l("dataabort",{
                            tile: r,
                            coord: r.tileID,
                            dataType: "source"
                        }))
                    }
                    serialize() {
                        return this._source.serialize()
                    }
                    prepare(r) {
                        this._source.prepare && this._source.prepare(),
                        this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                        for (const a in this._tiles) {
                            const m = this._tiles[a];
                            m.upload(r),
                            m.prepare(this.map.style.imageManager)
                        }
                    }
                    getIds() {
                        return Object.values(this._tiles).map(r => r.tileID).sort(Ve).map(r => r.key)
                    }
                    getRenderableIds(r) {
                        const a = [];
                        for (const m in this._tiles)
                            this._isIdRenderable(m, r) && a.push(this._tiles[m]);
                        return r ? a.sort( (m, y) => {
                            const x = m.tileID
                              , P = y.tileID
                              , I = new o.P(x.canonical.x,x.canonical.y)._rotate(-this.transform.bearingInRadians)
                              , A = new o.P(P.canonical.x,P.canonical.y)._rotate(-this.transform.bearingInRadians);
                            return x.overscaledZ - P.overscaledZ || A.y - I.y || A.x - I.x
                        }
                        ).map(m => m.tileID.key) : a.map(m => m.tileID).sort(Ve).map(m => m.key)
                    }
                    hasRenderableParent(r) {
                        const a = this.findLoadedParent(r, 0);
                        return !!a && this._isIdRenderable(a.tileID.key)
                    }
                    _isIdRenderable(r, a) {
                        return this._tiles[r] && this._tiles[r].hasData() && !this._coveredTiles[r] && (a || !this._tiles[r].holdingForFade())
                    }
                    reload(r) {
                        if (this._paused)
                            this._shouldReloadOnResume = !0;
                        else {
                            this._cache.reset();
                            for (const a in this._tiles)
                                r ? this._reloadTile(a, "expired") : this._tiles[a].state !== "errored" && this._reloadTile(a, "reloading")
                        }
                    }
                    _reloadTile(r, a) {
                        return o._(this, void 0, void 0, function*() {
                            const m = this._tiles[r];
                            m && (m.state !== "loading" && (m.state = a),
                            yield this._loadTile(m, r, a))
                        })
                    }
                    _tileLoaded(r, a, m) {
                        r.timeAdded = z.now(),
                        m === "expired" && (r.refreshedUponExpiration = !0),
                        this._setTileReloadTimer(a, r),
                        this.getSource().type === "raster-dem" && r.dem && this._backfillDEM(r),
                        this._state.initializeTileState(r, this.map ? this.map.painter : null),
                        r.aborted || this._source.fire(new o.l("data",{
                            dataType: "source",
                            tile: r,
                            coord: r.tileID
                        }))
                    }
                    _backfillDEM(r) {
                        const a = this.getRenderableIds();
                        for (let y = 0; y < a.length; y++) {
                            const x = a[y];
                            if (r.neighboringTiles && r.neighboringTiles[x]) {
                                const P = this.getTileByID(x);
                                m(r, P),
                                m(P, r)
                            }
                        }
                        function m(y, x) {
                            y.needsHillshadePrepare = !0,
                            y.needsTerrainPrepare = !0;
                            let P = x.tileID.canonical.x - y.tileID.canonical.x;
                            const I = x.tileID.canonical.y - y.tileID.canonical.y
                              , A = Math.pow(2, y.tileID.canonical.z)
                              , B = x.tileID.key;
                            P === 0 && I === 0 || Math.abs(I) > 1 || (Math.abs(P) > 1 && (Math.abs(P + A) === 1 ? P += A : Math.abs(P - A) === 1 && (P -= A)),
                            x.dem && y.dem && (y.dem.backfillBorder(x.dem, P, I),
                            y.neighboringTiles && y.neighboringTiles[B] && (y.neighboringTiles[B].backfilled = !0)))
                        }
                    }
                    getTile(r) {
                        return this.getTileByID(r.key)
                    }
                    getTileByID(r) {
                        return this._tiles[r]
                    }
                    _retainLoadedChildren(r, a, m, y) {
                        for (const x in this._tiles) {
                            let P = this._tiles[x];
                            if (y[x] || !P.hasData() || P.tileID.overscaledZ <= a || P.tileID.overscaledZ > m)
                                continue;
                            let I = P.tileID;
                            for (; P && P.tileID.overscaledZ > a + 1; ) {
                                const B = P.tileID.scaledTo(P.tileID.overscaledZ - 1);
                                P = this._tiles[B.key],
                                P && P.hasData() && (I = B)
                            }
                            let A = I;
                            for (; A.overscaledZ > a; )
                                if (A = A.scaledTo(A.overscaledZ - 1),
                                r[A.key] || r[A.canonical.key]) {
                                    y[I.key] = I;
                                    break
                                }
                        }
                    }
                    findLoadedParent(r, a) {
                        if (r.key in this._loadedParentTiles) {
                            const m = this._loadedParentTiles[r.key];
                            return m && m.tileID.overscaledZ >= a ? m : null
                        }
                        for (let m = r.overscaledZ - 1; m >= a; m--) {
                            const y = r.scaledTo(m)
                              , x = this._getLoadedTile(y);
                            if (x)
                                return x
                        }
                    }
                    findLoadedSibling(r) {
                        return this._getLoadedTile(r)
                    }
                    _getLoadedTile(r) {
                        const a = this._tiles[r.key];
                        return a && a.hasData() ? a : this._cache.getByKey(r.wrapped().key)
                    }
                    updateCacheSize(r) {
                        const a = Math.ceil(r.width / this._source.tileSize) + 1
                          , m = Math.ceil(r.height / this._source.tileSize) + 1
                          , y = Math.floor(a * m * (this._maxTileCacheZoomLevels === null ? o.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels))
                          , x = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, y) : y;
                        this._cache.setMaxSize(x)
                    }
                    handleWrapJump(r) {
                        const a = Math.round((r - (this._prevLng === void 0 ? r : this._prevLng)) / 360);
                        if (this._prevLng = r,
                        a) {
                            const m = {};
                            for (const y in this._tiles) {
                                const x = this._tiles[y];
                                x.tileID = x.tileID.unwrapTo(x.tileID.wrap + a),
                                m[x.tileID.key] = x
                            }
                            this._tiles = m;
                            for (const y in this._timers)
                                clearTimeout(this._timers[y]),
                                delete this._timers[y];
                            for (const y in this._tiles)
                                this._setTileReloadTimer(y, this._tiles[y])
                        }
                    }
                    _updateCoveredAndRetainedTiles(r, a, m, y, x, P) {
                        const I = {}
                          , A = {}
                          , B = Object.keys(r)
                          , $ = z.now();
                        for (const Z of B) {
                            const H = r[Z]
                              , Y = this._tiles[Z];
                            if (!Y || Y.fadeEndTime !== 0 && Y.fadeEndTime <= $)
                                continue;
                            const ae = this.findLoadedParent(H, a)
                              , ye = this.findLoadedSibling(H)
                              , Se = ae || ye || null;
                            Se && (this._addTile(Se.tileID),
                            I[Se.tileID.key] = Se.tileID),
                            A[Z] = H
                        }
                        this._retainLoadedChildren(A, y, m, r);
                        for (const Z in I)
                            r[Z] || (this._coveredTiles[Z] = !0,
                            r[Z] = I[Z]);
                        if (P) {
                            const Z = {}
                              , H = {};
                            for (const Y of x)
                                this._tiles[Y.key].hasData() ? Z[Y.key] = Y : H[Y.key] = Y;
                            for (const Y in H) {
                                const ae = H[Y].children(this._source.maxzoom);
                                this._tiles[ae[0].key] && this._tiles[ae[1].key] && this._tiles[ae[2].key] && this._tiles[ae[3].key] && (Z[ae[0].key] = r[ae[0].key] = ae[0],
                                Z[ae[1].key] = r[ae[1].key] = ae[1],
                                Z[ae[2].key] = r[ae[2].key] = ae[2],
                                Z[ae[3].key] = r[ae[3].key] = ae[3],
                                delete H[Y])
                            }
                            for (const Y in H) {
                                const ae = H[Y]
                                  , ye = this.findLoadedParent(ae, this._source.minzoom)
                                  , Se = this.findLoadedSibling(ae)
                                  , Te = ye || Se || null;
                                if (Te) {
                                    Z[Te.tileID.key] = r[Te.tileID.key] = Te.tileID;
                                    for (const Re in Z)
                                        Z[Re].isChildOf(Te.tileID) && delete Z[Re]
                                }
                            }
                            for (const Y in this._tiles)
                                Z[Y] || (this._coveredTiles[Y] = !0)
                        }
                    }
                    update(r, a) {
                        if (!this._sourceLoaded || this._paused)
                            return;
                        let m;
                        this.transform = r,
                        this.terrain = a,
                        this.updateCacheSize(r),
                        this.handleWrapJump(this.transform.center.lng),
                        this._coveredTiles = {},
                        this.used || this.usedForTerrain ? this._source.tileID ? m = r.getVisibleUnwrappedCoordinates(this._source.tileID).map($ => new o.Z($.canonical.z,$.wrap,$.canonical.z,$.canonical.x,$.canonical.y)) : (m = dt(r, {
                            tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
                            minzoom: this._source.minzoom,
                            maxzoom: this._source.maxzoom,
                            roundZoom: !this.usedForTerrain && this._source.roundZoom,
                            reparseOverscaled: this._source.reparseOverscaled,
                            terrain: a,
                            calculateTileZoom: this._source.calculateTileZoom
                        }),
                        this._source.hasTile && (m = m.filter($ => this._source.hasTile($)))) : m = [];
                        const y = _t(r, this._source)
                          , x = Math.max(y - St.maxOverzooming, this._source.minzoom)
                          , P = Math.max(y + St.maxUnderzooming, this._source.minzoom);
                        if (this.usedForTerrain) {
                            const $ = {};
                            for (const Z of m)
                                if (Z.canonical.z > this._source.minzoom) {
                                    const H = Z.scaledTo(Z.canonical.z - 1);
                                    $[H.key] = H;
                                    const Y = Z.scaledTo(Math.max(this._source.minzoom, Math.min(Z.canonical.z, 5)));
                                    $[Y.key] = Y
                                }
                            m = m.concat(Object.values($))
                        }
                        const I = m.length === 0 && !this._updated && this._didEmitContent;
                        this._updated = !0,
                        I && this.fire(new o.l("data",{
                            sourceDataType: "idle",
                            dataType: "source",
                            sourceId: this.id
                        }));
                        const A = this._updateRetainedTiles(m, y);
                        Ut(this._source.type) && this._updateCoveredAndRetainedTiles(A, x, P, y, m, a);
                        for (const $ in A)
                            this._tiles[$].clearFadeHold();
                        const B = o.al(this._tiles, A);
                        for (const $ of B) {
                            const Z = this._tiles[$];
                            Z.hasSymbolBuckets && !Z.holdingForFade() ? Z.setHoldDuration(this.map._fadeDuration) : Z.hasSymbolBuckets && !Z.symbolFadeFinished() || this._removeTile($)
                        }
                        this._updateLoadedParentTileCache(),
                        this._updateLoadedSiblingTileCache()
                    }
                    releaseSymbolFadeTiles() {
                        for (const r in this._tiles)
                            this._tiles[r].holdingForFade() && this._removeTile(r)
                    }
                    _updateRetainedTiles(r, a) {
                        var m;
                        const y = {}
                          , x = {}
                          , P = Math.max(a - St.maxOverzooming, this._source.minzoom)
                          , I = Math.max(a + St.maxUnderzooming, this._source.minzoom)
                          , A = {};
                        for (const B of r) {
                            const $ = this._addTile(B);
                            y[B.key] = B,
                            $.hasData() || a < this._source.maxzoom && (A[B.key] = B)
                        }
                        this._retainLoadedChildren(A, a, I, y);
                        for (const B of r) {
                            let $ = this._tiles[B.key];
                            if ($.hasData())
                                continue;
                            if (a + 1 > this._source.maxzoom) {
                                const H = B.children(this._source.maxzoom)[0]
                                  , Y = this.getTile(H);
                                if (Y && Y.hasData()) {
                                    y[H.key] = H;
                                    continue
                                }
                            } else {
                                const H = B.children(this._source.maxzoom);
                                if (y[H[0].key] && y[H[1].key] && y[H[2].key] && y[H[3].key])
                                    continue
                            }
                            let Z = $.wasRequested();
                            for (let H = B.overscaledZ - 1; H >= P; --H) {
                                const Y = B.scaledTo(H);
                                if (x[Y.key])
                                    break;
                                if (x[Y.key] = !0,
                                $ = this.getTile(Y),
                                !$ && Z && ($ = this._addTile(Y)),
                                $) {
                                    const ae = $.hasData();
                                    if ((ae || !(!((m = this.map) === null || m === void 0) && m.cancelPendingTileRequestsWhileZooming) || Z) && (y[Y.key] = Y),
                                    Z = $.wasRequested(),
                                    ae)
                                        break
                                }
                            }
                        }
                        return y
                    }
                    _updateLoadedParentTileCache() {
                        this._loadedParentTiles = {};
                        for (const r in this._tiles) {
                            const a = [];
                            let m, y = this._tiles[r].tileID;
                            for (; y.overscaledZ > 0; ) {
                                if (y.key in this._loadedParentTiles) {
                                    m = this._loadedParentTiles[y.key];
                                    break
                                }
                                a.push(y.key);
                                const x = y.scaledTo(y.overscaledZ - 1);
                                if (m = this._getLoadedTile(x),
                                m)
                                    break;
                                y = x
                            }
                            for (const x of a)
                                this._loadedParentTiles[x] = m
                        }
                    }
                    _updateLoadedSiblingTileCache() {
                        this._loadedSiblingTiles = {};
                        for (const r in this._tiles) {
                            const a = this._tiles[r].tileID
                              , m = this._getLoadedTile(a);
                            this._loadedSiblingTiles[a.key] = m
                        }
                    }
                    _addTile(r) {
                        let a = this._tiles[r.key];
                        if (a)
                            return a;
                        a = this._cache.getAndRemove(r),
                        a && (this._setTileReloadTimer(r.key, a),
                        a.tileID = r,
                        this._state.initializeTileState(a, this.map ? this.map.painter : null),
                        this._cacheTimers[r.key] && (clearTimeout(this._cacheTimers[r.key]),
                        delete this._cacheTimers[r.key],
                        this._setTileReloadTimer(r.key, a)));
                        const m = a;
                        return a || (a = new Mt(r,this._source.tileSize * r.overscaleFactor()),
                        this._loadTile(a, r.key, a.state)),
                        a.uses++,
                        this._tiles[r.key] = a,
                        m || this._source.fire(new o.l("dataloading",{
                            tile: a,
                            coord: a.tileID,
                            dataType: "source"
                        })),
                        a
                    }
                    _setTileReloadTimer(r, a) {
                        r in this._timers && (clearTimeout(this._timers[r]),
                        delete this._timers[r]);
                        const m = a.getExpiryTimeout();
                        m && (this._timers[r] = setTimeout( () => {
                            this._reloadTile(r, "expired"),
                            delete this._timers[r]
                        }
                        , m))
                    }
                    refreshTiles(r) {
                        for (const a in this._tiles)
                            (this._isIdRenderable(a) || this._tiles[a].state == "errored") && r.some(m => m.equals(this._tiles[a].tileID.canonical)) && this._reloadTile(a, "expired")
                    }
                    _removeTile(r) {
                        const a = this._tiles[r];
                        a && (a.uses--,
                        delete this._tiles[r],
                        this._timers[r] && (clearTimeout(this._timers[r]),
                        delete this._timers[r]),
                        a.uses > 0 || (a.hasData() && a.state !== "reloading" ? this._cache.add(a.tileID, a, a.getExpiryTimeout()) : (a.aborted = !0,
                        this._abortTile(a),
                        this._unloadTile(a))))
                    }
                    _dataHandler(r) {
                        const a = r.sourceDataType;
                        r.dataType === "source" && a === "metadata" && (this._sourceLoaded = !0),
                        this._sourceLoaded && !this._paused && r.dataType === "source" && a === "content" && (this.reload(r.sourceDataChanged),
                        this.transform && this.update(this.transform, this.terrain),
                        this._didEmitContent = !0)
                    }
                    clearTiles() {
                        this._shouldReloadOnResume = !1,
                        this._paused = !1;
                        for (const r in this._tiles)
                            this._removeTile(r);
                        this._cache.reset()
                    }
                    tilesIn(r, a, m) {
                        const y = []
                          , x = this.transform;
                        if (!x)
                            return y;
                        const P = x.getCoveringTilesDetailsProvider().allowWorldCopies()
                          , I = m ? x.getCameraQueryGeometry(r) : r
                          , A = Y => x.screenPointToMercatorCoordinate(Y, this.terrain)
                          , B = this.transformBbox(r, A, !P)
                          , $ = this.transformBbox(I, A, !P)
                          , Z = this.getIds()
                          , H = o.a1.fromPoints($);
                        for (let Y = 0; Y < Z.length; Y++) {
                            const ae = this._tiles[Z[Y]];
                            if (ae.holdingForFade())
                                continue;
                            const ye = P ? [ae.tileID] : [ae.tileID.unwrapTo(-1), ae.tileID.unwrapTo(0)]
                              , Se = Math.pow(2, x.zoom - ae.tileID.overscaledZ)
                              , Te = a * ae.queryPadding * o.$ / ae.tileSize / Se;
                            for (const Re of ye) {
                                const De = H.map(Ae => Re.getTilePoint(new o.a0(Ae.x,Ae.y)));
                                if (De.expandBy(Te),
                                De.intersects(tt)) {
                                    const Ae = B.map(qe => Re.getTilePoint(qe))
                                      , Be = $.map(qe => Re.getTilePoint(qe));
                                    y.push({
                                        tile: ae,
                                        tileID: P ? Re : Re.unwrapTo(0),
                                        queryGeometry: Ae,
                                        cameraQueryGeometry: Be,
                                        scale: Se
                                    })
                                }
                            }
                        }
                        return y
                    }
                    transformBbox(r, a, m) {
                        let y = r.map(a);
                        if (m) {
                            const x = o.a1.fromPoints(r);
                            x.shrinkBy(.001 * Math.min(x.width(), x.height()));
                            const P = x.map(a);
                            o.a1.fromPoints(y).covers(P) || (y = y.map(I => I.x > .5 ? new o.a0(I.x - 1,I.y,I.z) : I))
                        }
                        return y
                    }
                    getVisibleCoordinates(r) {
                        const a = this.getRenderableIds(r).map(m => this._tiles[m].tileID);
                        return this.transform && this.transform.populateCache(a),
                        a
                    }
                    hasTransition() {
                        if (this._source.hasTransition())
                            return !0;
                        if (Ut(this._source.type)) {
                            const r = z.now();
                            for (const a in this._tiles)
                                if (this._tiles[a].fadeEndTime >= r)
                                    return !0
                        }
                        return !1
                    }
                    setFeatureState(r, a, m) {
                        this._state.updateState(r = r || "_geojsonTileLayer", a, m)
                    }
                    removeFeatureState(r, a, m) {
                        this._state.removeFeatureState(r = r || "_geojsonTileLayer", a, m)
                    }
                    getFeatureState(r, a) {
                        return this._state.getState(r = r || "_geojsonTileLayer", a)
                    }
                    setDependencies(r, a, m) {
                        const y = this._tiles[r];
                        y && y.setDependencies(a, m)
                    }
                    reloadTilesForDependencies(r, a) {
                        for (const m in this._tiles)
                            this._tiles[m].hasDependency(r, a) && this._reloadTile(m, "reloading");
                        this._cache.filter(m => !m.hasDependency(r, a))
                    }
                }
                function Ve(v, r) {
                    const a = Math.abs(2 * v.wrap) - +(v.wrap < 0)
                      , m = Math.abs(2 * r.wrap) - +(r.wrap < 0);
                    return v.overscaledZ - r.overscaledZ || m - a || r.canonical.y - v.canonical.y || r.canonical.x - v.canonical.x
                }
                function Ut(v) {
                    return v === "raster" || v === "image" || v === "video"
                }
                St.maxOverzooming = 10,
                St.maxUnderzooming = 3;
                class yr {
                    constructor(r, a) {
                        this.reset(r, a)
                    }
                    reset(r, a) {
                        this.points = r || [],
                        this._distances = [0];
                        for (let m = 1; m < this.points.length; m++)
                            this._distances[m] = this._distances[m - 1] + this.points[m].dist(this.points[m - 1]);
                        this.length = this._distances[this._distances.length - 1],
                        this.padding = Math.min(a || 0, .5 * this.length),
                        this.paddedLength = this.length - 2 * this.padding
                    }
                    lerp(r) {
                        if (this.points.length === 1)
                            return this.points[0];
                        r = o.ag(r, 0, 1);
                        let a = 1
                          , m = this._distances[a];
                        const y = r * this.paddedLength + this.padding;
                        for (; m < y && a < this._distances.length; )
                            m = this._distances[++a];
                        const x = a - 1
                          , P = this._distances[x]
                          , I = m - P
                          , A = I > 0 ? (y - P) / I : 0;
                        return this.points[x].mult(1 - A).add(this.points[a].mult(A))
                    }
                }
                function Ht(v, r) {
                    let a = !0;
                    return v === "always" || v !== "never" && r !== "never" || (a = !1),
                    a
                }
                class sr {
                    constructor(r, a, m) {
                        const y = this.boxCells = []
                          , x = this.circleCells = [];
                        this.xCellCount = Math.ceil(r / m),
                        this.yCellCount = Math.ceil(a / m);
                        for (let P = 0; P < this.xCellCount * this.yCellCount; P++)
                            y.push([]),
                            x.push([]);
                        this.circleKeys = [],
                        this.boxKeys = [],
                        this.bboxes = [],
                        this.circles = [],
                        this.width = r,
                        this.height = a,
                        this.xScale = this.xCellCount / r,
                        this.yScale = this.yCellCount / a,
                        this.boxUid = 0,
                        this.circleUid = 0
                    }
                    keysLength() {
                        return this.boxKeys.length + this.circleKeys.length
                    }
                    insert(r, a, m, y, x) {
                        this._forEachCell(a, m, y, x, this._insertBoxCell, this.boxUid++),
                        this.boxKeys.push(r),
                        this.bboxes.push(a),
                        this.bboxes.push(m),
                        this.bboxes.push(y),
                        this.bboxes.push(x)
                    }
                    insertCircle(r, a, m, y) {
                        this._forEachCell(a - y, m - y, a + y, m + y, this._insertCircleCell, this.circleUid++),
                        this.circleKeys.push(r),
                        this.circles.push(a),
                        this.circles.push(m),
                        this.circles.push(y)
                    }
                    _insertBoxCell(r, a, m, y, x, P) {
                        this.boxCells[x].push(P)
                    }
                    _insertCircleCell(r, a, m, y, x, P) {
                        this.circleCells[x].push(P)
                    }
                    _query(r, a, m, y, x, P, I) {
                        if (m < 0 || r > this.width || y < 0 || a > this.height)
                            return [];
                        const A = [];
                        if (r <= 0 && a <= 0 && this.width <= m && this.height <= y) {
                            if (x)
                                return [{
                                    key: null,
                                    x1: r,
                                    y1: a,
                                    x2: m,
                                    y2: y
                                }];
                            for (let B = 0; B < this.boxKeys.length; B++)
                                A.push({
                                    key: this.boxKeys[B],
                                    x1: this.bboxes[4 * B],
                                    y1: this.bboxes[4 * B + 1],
                                    x2: this.bboxes[4 * B + 2],
                                    y2: this.bboxes[4 * B + 3]
                                });
                            for (let B = 0; B < this.circleKeys.length; B++) {
                                const $ = this.circles[3 * B]
                                  , Z = this.circles[3 * B + 1]
                                  , H = this.circles[3 * B + 2];
                                A.push({
                                    key: this.circleKeys[B],
                                    x1: $ - H,
                                    y1: Z - H,
                                    x2: $ + H,
                                    y2: Z + H
                                })
                            }
                        } else
                            this._forEachCell(r, a, m, y, this._queryCell, A, {
                                hitTest: x,
                                overlapMode: P,
                                seenUids: {
                                    box: {},
                                    circle: {}
                                }
                            }, I);
                        return A
                    }
                    query(r, a, m, y) {
                        return this._query(r, a, m, y, !1, null)
                    }
                    hitTest(r, a, m, y, x, P) {
                        return this._query(r, a, m, y, !0, x, P).length > 0
                    }
                    hitTestCircle(r, a, m, y, x) {
                        const P = r - m
                          , I = r + m
                          , A = a - m
                          , B = a + m;
                        if (I < 0 || P > this.width || B < 0 || A > this.height)
                            return !1;
                        const $ = [];
                        return this._forEachCell(P, A, I, B, this._queryCellCircle, $, {
                            hitTest: !0,
                            overlapMode: y,
                            circle: {
                                x: r,
                                y: a,
                                radius: m
                            },
                            seenUids: {
                                box: {},
                                circle: {}
                            }
                        }, x),
                        $.length > 0
                    }
                    _queryCell(r, a, m, y, x, P, I, A) {
                        const {seenUids: B, hitTest: $, overlapMode: Z} = I
                          , H = this.boxCells[x];
                        if (H !== null) {
                            const ae = this.bboxes;
                            for (const ye of H)
                                if (!B.box[ye]) {
                                    B.box[ye] = !0;
                                    const Se = 4 * ye
                                      , Te = this.boxKeys[ye];
                                    if (r <= ae[Se + 2] && a <= ae[Se + 3] && m >= ae[Se + 0] && y >= ae[Se + 1] && (!A || A(Te)) && (!$ || !Ht(Z, Te.overlapMode)) && (P.push({
                                        key: Te,
                                        x1: ae[Se],
                                        y1: ae[Se + 1],
                                        x2: ae[Se + 2],
                                        y2: ae[Se + 3]
                                    }),
                                    $))
                                        return !0
                                }
                        }
                        const Y = this.circleCells[x];
                        if (Y !== null) {
                            const ae = this.circles;
                            for (const ye of Y)
                                if (!B.circle[ye]) {
                                    B.circle[ye] = !0;
                                    const Se = 3 * ye
                                      , Te = this.circleKeys[ye];
                                    if (this._circleAndRectCollide(ae[Se], ae[Se + 1], ae[Se + 2], r, a, m, y) && (!A || A(Te)) && (!$ || !Ht(Z, Te.overlapMode))) {
                                        const Re = ae[Se]
                                          , De = ae[Se + 1]
                                          , Ae = ae[Se + 2];
                                        if (P.push({
                                            key: Te,
                                            x1: Re - Ae,
                                            y1: De - Ae,
                                            x2: Re + Ae,
                                            y2: De + Ae
                                        }),
                                        $)
                                            return !0
                                    }
                                }
                        }
                        return !1
                    }
                    _queryCellCircle(r, a, m, y, x, P, I, A) {
                        const {circle: B, seenUids: $, overlapMode: Z} = I
                          , H = this.boxCells[x];
                        if (H !== null) {
                            const ae = this.bboxes;
                            for (const ye of H)
                                if (!$.box[ye]) {
                                    $.box[ye] = !0;
                                    const Se = 4 * ye
                                      , Te = this.boxKeys[ye];
                                    if (this._circleAndRectCollide(B.x, B.y, B.radius, ae[Se + 0], ae[Se + 1], ae[Se + 2], ae[Se + 3]) && (!A || A(Te)) && !Ht(Z, Te.overlapMode))
                                        return P.push(!0),
                                        !0
                                }
                        }
                        const Y = this.circleCells[x];
                        if (Y !== null) {
                            const ae = this.circles;
                            for (const ye of Y)
                                if (!$.circle[ye]) {
                                    $.circle[ye] = !0;
                                    const Se = 3 * ye
                                      , Te = this.circleKeys[ye];
                                    if (this._circlesCollide(ae[Se], ae[Se + 1], ae[Se + 2], B.x, B.y, B.radius) && (!A || A(Te)) && !Ht(Z, Te.overlapMode))
                                        return P.push(!0),
                                        !0
                                }
                        }
                    }
                    _forEachCell(r, a, m, y, x, P, I, A) {
                        const B = this._convertToXCellCoord(r)
                          , $ = this._convertToYCellCoord(a)
                          , Z = this._convertToXCellCoord(m)
                          , H = this._convertToYCellCoord(y);
                        for (let Y = B; Y <= Z; Y++)
                            for (let ae = $; ae <= H; ae++)
                                if (x.call(this, r, a, m, y, this.xCellCount * ae + Y, P, I, A))
                                    return
                    }
                    _convertToXCellCoord(r) {
                        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(r * this.xScale)))
                    }
                    _convertToYCellCoord(r) {
                        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(r * this.yScale)))
                    }
                    _circlesCollide(r, a, m, y, x, P) {
                        const I = y - r
                          , A = x - a
                          , B = m + P;
                        return B * B > I * I + A * A
                    }
                    _circleAndRectCollide(r, a, m, y, x, P, I) {
                        const A = (P - y) / 2
                          , B = Math.abs(r - (y + A));
                        if (B > A + m)
                            return !1;
                        const $ = (I - x) / 2
                          , Z = Math.abs(a - (x + $));
                        if (Z > $ + m)
                            return !1;
                        if (B <= A || Z <= $)
                            return !0;
                        const H = B - A
                          , Y = Z - $;
                        return H * H + Y * Y <= m * m
                    }
                }
                function br(v, r, a) {
                    const m = o.L();
                    if (!v) {
                        const {vecSouth: Z, vecEast: H} = qr(r)
                          , Y = T();
                        Y[0] = H[0],
                        Y[1] = H[1],
                        Y[2] = Z[0],
                        Y[3] = Z[1],
                        y = Y,
                        ($ = (P = (x = Y)[0]) * (B = x[3]) - (A = x[2]) * (I = x[1])) && (y[0] = B * ($ = 1 / $),
                        y[1] = -I * $,
                        y[2] = -A * $,
                        y[3] = P * $),
                        m[0] = Y[0],
                        m[1] = Y[1],
                        m[4] = Y[2],
                        m[5] = Y[3]
                    }
                    var y, x, P, I, A, B, $;
                    return o.N(m, m, [1 / a, 1 / a, 1]),
                    m
                }
                function en(v, r, a, m) {
                    if (v) {
                        const y = o.L();
                        if (!r) {
                            const {vecSouth: x, vecEast: P} = qr(a);
                            y[0] = P[0],
                            y[1] = P[1],
                            y[4] = x[0],
                            y[5] = x[1]
                        }
                        return o.N(y, y, [m, m, 1]),
                        y
                    }
                    return a.pixelsToClipSpaceMatrix
                }
                function qr(v) {
                    const r = Math.cos(v.rollInRadians)
                      , a = Math.sin(v.rollInRadians)
                      , m = Math.cos(v.pitchInRadians)
                      , y = Math.cos(v.bearingInRadians)
                      , x = Math.sin(v.bearingInRadians)
                      , P = o.aq();
                    P[0] = -y * m * a - x * r,
                    P[1] = -x * m * a + y * r;
                    const I = o.ar(P);
                    I < 1e-9 ? o.as(P) : o.at(P, P, 1 / I);
                    const A = o.aq();
                    A[0] = y * m * r - x * a,
                    A[1] = x * m * r + y * a;
                    const B = o.ar(A);
                    return B < 1e-9 ? o.as(A) : o.at(A, A, 1 / B),
                    {
                        vecEast: A,
                        vecSouth: P
                    }
                }
                function Dr(v, r, a, m) {
                    let y;
                    m ? (y = [v, r, m(v, r), 1],
                    o.av(y, y, a)) : (y = [v, r, 0, 1],
                    ni(y, y, a));
                    const x = y[3];
                    return {
                        point: new o.P(y[0] / x,y[1] / x),
                        signedDistanceFromCamera: x,
                        isOccluded: !1
                    }
                }
                function fr(v, r) {
                    return .5 + v / r * .5
                }
                function ke(v, r) {
                    return v.x >= -r[0] && v.x <= r[0] && v.y >= -r[1] && v.y <= r[1]
                }
                function le(v, r, a, m, y, x, P, I, A, B, $, Z, H) {
                    const Y = a ? v.textSizeData : v.iconSizeData
                      , ae = o.am(Y, r.transform.zoom)
                      , ye = [256 / r.width * 2 + 1, 256 / r.height * 2 + 1]
                      , Se = a ? v.text.dynamicLayoutVertexArray : v.icon.dynamicLayoutVertexArray;
                    Se.clear();
                    const Te = v.lineVertexArray
                      , Re = a ? v.text.placedSymbolArray : v.icon.placedSymbolArray
                      , De = r.transform.width / r.transform.height;
                    let Ae = !1;
                    for (let Be = 0; Be < Re.length; Be++) {
                        const qe = Re.get(Be);
                        if (qe.hidden || qe.writingMode === o.an.vertical && !Ae) {
                            ri(qe.numGlyphs, Se);
                            continue
                        }
                        Ae = !1;
                        const ze = new o.P(qe.anchorX,qe.anchorY)
                          , Ke = {
                            getElevation: H,
                            pitchedLabelPlaneMatrix: m,
                            lineVertexArray: Te,
                            pitchWithMap: x,
                            projectionCache: {
                                projections: {},
                                offsets: {},
                                cachedAnchorPoint: void 0,
                                anyProjectionOccluded: !1
                            },
                            transform: r.transform,
                            tileAnchorPoint: ze,
                            unwrappedTileID: A,
                            width: B,
                            height: $,
                            translation: Z
                        }
                          , ht = Ct(qe.anchorX, qe.anchorY, Ke);
                        if (!ke(ht.point, ye)) {
                            ri(qe.numGlyphs, Se);
                            continue
                        }
                        const ot = fr(r.transform.cameraToCenterDistance, ht.signedDistanceFromCamera)
                          , ut = o.ao(Y, ae, qe)
                          , mt = x ? ut * r.transform.getPitchedTextCorrection(qe.anchorX, qe.anchorY, A) / ot : ut * ot
                          , $t = Ge({
                            projectionContext: Ke,
                            pitchedLabelPlaneMatrixInverse: y,
                            symbol: qe,
                            fontSize: mt,
                            flip: !1,
                            keepUpright: P,
                            glyphOffsetArray: v.glyphOffsetArray,
                            dynamicLayoutVertexArray: Se,
                            aspectRatio: De,
                            rotateToLine: I
                        });
                        Ae = $t.useVertical,
                        ($t.notEnoughRoom || Ae || $t.needsFlipping && Ge({
                            projectionContext: Ke,
                            pitchedLabelPlaneMatrixInverse: y,
                            symbol: qe,
                            fontSize: mt,
                            flip: !0,
                            keepUpright: P,
                            glyphOffsetArray: v.glyphOffsetArray,
                            dynamicLayoutVertexArray: Se,
                            aspectRatio: De,
                            rotateToLine: I
                        }).notEnoughRoom) && ri(qe.numGlyphs, Se)
                    }
                    a ? v.text.dynamicLayoutVertexBuffer.updateData(Se) : v.icon.dynamicLayoutVertexBuffer.updateData(Se)
                }
                function ee(v, r, a, m, y, x, P, I) {
                    const A = x.glyphStartIndex + x.numGlyphs
                      , B = x.lineStartIndex
                      , $ = x.lineStartIndex + x.lineLength
                      , Z = r.getoffsetX(x.glyphStartIndex)
                      , H = r.getoffsetX(A - 1)
                      , Y = lr(v * Z, a, m, y, x.segment, B, $, I, P);
                    if (!Y)
                        return null;
                    const ae = lr(v * H, a, m, y, x.segment, B, $, I, P);
                    return ae ? I.projectionCache.anyProjectionOccluded ? null : {
                        first: Y,
                        last: ae
                    } : null
                }
                function Ze(v, r, a, m) {
                    return v === o.an.horizontal && Math.abs(a.y - r.y) > Math.abs(a.x - r.x) * m ? {
                        useVertical: !0
                    } : (v === o.an.vertical ? r.y < a.y : r.x > a.x) ? {
                        needsFlipping: !0
                    } : null
                }
                function Ge(v) {
                    const {projectionContext: r, pitchedLabelPlaneMatrixInverse: a, symbol: m, fontSize: y, flip: x, keepUpright: P, glyphOffsetArray: I, dynamicLayoutVertexArray: A, aspectRatio: B, rotateToLine: $} = v
                      , Z = y / 24
                      , H = m.lineOffsetX * Z
                      , Y = m.lineOffsetY * Z;
                    let ae;
                    if (m.numGlyphs > 1) {
                        const ye = m.glyphStartIndex + m.numGlyphs
                          , Se = m.lineStartIndex
                          , Te = m.lineStartIndex + m.lineLength
                          , Re = ee(Z, I, H, Y, x, m, $, r);
                        if (!Re)
                            return {
                                notEnoughRoom: !0
                            };
                        const De = wt(Re.first.point.x, Re.first.point.y, r, a)
                          , Ae = wt(Re.last.point.x, Re.last.point.y, r, a);
                        if (P && !x) {
                            const Be = Ze(m.writingMode, De, Ae, B);
                            if (Be)
                                return Be
                        }
                        ae = [Re.first];
                        for (let Be = m.glyphStartIndex + 1; Be < ye - 1; Be++) {
                            const qe = lr(Z * I.getoffsetX(Be), H, Y, x, m.segment, Se, Te, r, $);
                            if (!qe)
                                return {
                                    notEnoughRoom: !0
                                };
                            ae.push(qe)
                        }
                        ae.push(Re.last)
                    } else {
                        if (P && !x) {
                            const Se = Xe(r.tileAnchorPoint.x, r.tileAnchorPoint.y, r).point
                              , Te = m.lineStartIndex + m.segment + 1
                              , Re = new o.P(r.lineVertexArray.getx(Te),r.lineVertexArray.gety(Te))
                              , De = Xe(Re.x, Re.y, r)
                              , Ae = De.signedDistanceFromCamera > 0 ? De.point : vt(r.tileAnchorPoint, Re, Se, 1, r)
                              , Be = wt(Se.x, Se.y, r, a)
                              , qe = wt(Ae.x, Ae.y, r, a)
                              , ze = Ze(m.writingMode, Be, qe, B);
                            if (ze)
                                return ze
                        }
                        const ye = lr(Z * I.getoffsetX(m.glyphStartIndex), H, Y, x, m.segment, m.lineStartIndex, m.lineStartIndex + m.lineLength, r, $);
                        if (!ye || r.projectionCache.anyProjectionOccluded)
                            return {
                                notEnoughRoom: !0
                            };
                        ae = [ye]
                    }
                    for (const ye of ae)
                        o.au(A, ye.point, ye.angle);
                    return {}
                }
                function vt(v, r, a, m, y) {
                    const x = v.add(v.sub(r)._unit())
                      , P = Xe(x.x, x.y, y).point
                      , I = a.sub(P);
                    return a.add(I._mult(m / I.mag()))
                }
                function it(v, r, a) {
                    const m = r.projectionCache;
                    if (m.projections[v])
                        return m.projections[v];
                    const y = new o.P(r.lineVertexArray.getx(v),r.lineVertexArray.gety(v))
                      , x = Xe(y.x, y.y, r);
                    if (x.signedDistanceFromCamera > 0)
                        return m.projections[v] = x.point,
                        m.anyProjectionOccluded = m.anyProjectionOccluded || x.isOccluded,
                        x.point;
                    const P = v - a.direction;
                    return vt(a.distanceFromAnchor === 0 ? r.tileAnchorPoint : new o.P(r.lineVertexArray.getx(P),r.lineVertexArray.gety(P)), y, a.previousVertex, a.absOffsetX - a.distanceFromAnchor + 1, r)
                }
                function Xe(v, r, a) {
                    const m = v + a.translation[0]
                      , y = r + a.translation[1];
                    let x;
                    return a.pitchWithMap ? (x = Dr(m, y, a.pitchedLabelPlaneMatrix, a.getElevation),
                    x.isOccluded = !1) : (x = a.transform.projectTileCoordinates(m, y, a.unwrappedTileID, a.getElevation),
                    x.point.x = (.5 * x.point.x + .5) * a.width,
                    x.point.y = (.5 * -x.point.y + .5) * a.height),
                    x
                }
                function wt(v, r, a, m) {
                    if (a.pitchWithMap) {
                        const y = [v, r, 0, 1];
                        return o.av(y, y, m),
                        a.transform.projectTileCoordinates(y[0] / y[3], y[1] / y[3], a.unwrappedTileID, a.getElevation).point
                    }
                    return {
                        x: v / a.width * 2 - 1,
                        y: 1 - r / a.height * 2
                    }
                }
                function Ct(v, r, a) {
                    return a.transform.projectTileCoordinates(v, r, a.unwrappedTileID, a.getElevation)
                }
                function Gt(v, r, a) {
                    return v._unit()._perp()._mult(r * a)
                }
                function Xt(v, r, a, m, y, x, P, I, A) {
                    if (I.projectionCache.offsets[v])
                        return I.projectionCache.offsets[v];
                    const B = a.add(r);
                    if (v + A.direction < m || v + A.direction >= y)
                        return I.projectionCache.offsets[v] = B,
                        B;
                    const $ = it(v + A.direction, I, A)
                      , Z = Gt($.sub(a), P, A.direction)
                      , H = a.add(Z)
                      , Y = $.add(Z);
                    return I.projectionCache.offsets[v] = o.aw(x, B, H, Y) || B,
                    I.projectionCache.offsets[v]
                }
                function lr(v, r, a, m, y, x, P, I, A) {
                    const B = m ? v - r : v + r;
                    let $ = B > 0 ? 1 : -1
                      , Z = 0;
                    m && ($ *= -1,
                    Z = Math.PI),
                    $ < 0 && (Z += Math.PI);
                    let H, Y = $ > 0 ? x + y : x + y + 1;
                    I.projectionCache.cachedAnchorPoint ? H = I.projectionCache.cachedAnchorPoint : (H = Xe(I.tileAnchorPoint.x, I.tileAnchorPoint.y, I).point,
                    I.projectionCache.cachedAnchorPoint = H);
                    let ae, ye, Se = H, Te = H, Re = 0, De = 0;
                    const Ae = Math.abs(B)
                      , Be = [];
                    let qe;
                    for (; Re + De <= Ae; ) {
                        if (Y += $,
                        Y < x || Y >= P)
                            return null;
                        Re += De,
                        Te = Se,
                        ye = ae;
                        const ht = {
                            absOffsetX: Ae,
                            direction: $,
                            distanceFromAnchor: Re,
                            previousVertex: Te
                        };
                        if (Se = it(Y, I, ht),
                        a === 0)
                            Be.push(Te),
                            qe = Se.sub(Te);
                        else {
                            let ot;
                            const ut = Se.sub(Te);
                            ot = ut.mag() === 0 ? Gt(it(Y + $, I, ht).sub(Se), a, $) : Gt(ut, a, $),
                            ye || (ye = Te.add(ot)),
                            ae = Xt(Y, ot, Se, x, P, ye, a, I, ht),
                            Be.push(ye),
                            qe = ae.sub(ye)
                        }
                        De = qe.mag()
                    }
                    const ze = qe._mult((Ae - Re) / De)._add(ye || Te)
                      , Ke = Z + Math.atan2(Se.y - Te.y, Se.x - Te.x);
                    return Be.push(ze),
                    {
                        point: ze,
                        angle: A ? Ke : 0,
                        path: Be
                    }
                }
                const _r = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
                function ri(v, r) {
                    for (let a = 0; a < v; a++) {
                        const m = r.length;
                        r.resize(m + 4),
                        r.float32.set(_r, 3 * m)
                    }
                }
                function ni(v, r, a) {
                    const m = r[0]
                      , y = r[1];
                    return v[0] = a[0] * m + a[4] * y + a[12],
                    v[1] = a[1] * m + a[5] * y + a[13],
                    v[3] = a[3] * m + a[7] * y + a[15],
                    v
                }
                const kr = 100;
                class ci {
                    constructor(r, a=new sr(r.width + 200,r.height + 200,25), m=new sr(r.width + 200,r.height + 200,25)) {
                        this.transform = r,
                        this.grid = a,
                        this.ignoredGrid = m,
                        this.pitchFactor = Math.cos(r.pitch * Math.PI / 180) * r.cameraToCenterDistance,
                        this.screenRightBoundary = r.width + kr,
                        this.screenBottomBoundary = r.height + kr,
                        this.gridRightBoundary = r.width + 200,
                        this.gridBottomBoundary = r.height + 200,
                        this.perspectiveRatioCutoff = .6
                    }
                    placeCollisionBox(r, a, m, y, x, P, I, A, B, $, Z, H) {
                        const Y = this.projectAndGetPerspectiveRatio(r.anchorPointX + A[0], r.anchorPointY + A[1], x, $, H)
                          , ae = m * Y.perspectiveRatio;
                        let ye;
                        if (P || I)
                            ye = this._projectCollisionBox(r, ae, y, x, P, I, A, Y, $, Z, H);
                        else {
                            const qe = Y.x + (Z ? Z.x * ae : 0)
                              , ze = Y.y + (Z ? Z.y * ae : 0);
                            ye = {
                                allPointsOccluded: !1,
                                box: [qe + r.x1 * ae, ze + r.y1 * ae, qe + r.x2 * ae, ze + r.y2 * ae]
                            }
                        }
                        const [Se,Te,Re,De] = ye.box
                          , Ae = P ? ye.allPointsOccluded : Y.isOccluded;
                        let Be = Ae;
                        return Be || (Be = Y.perspectiveRatio < this.perspectiveRatioCutoff),
                        Be || (Be = !this.isInsideGrid(Se, Te, Re, De)),
                        Be || a !== "always" && this.grid.hitTest(Se, Te, Re, De, a, B) ? {
                            box: [Se, Te, Re, De],
                            placeable: !1,
                            offscreen: !1,
                            occluded: Ae
                        } : {
                            box: [Se, Te, Re, De],
                            placeable: !0,
                            offscreen: this.isOffscreen(Se, Te, Re, De),
                            occluded: Ae
                        }
                    }
                    placeCollisionCircles(r, a, m, y, x, P, I, A, B, $, Z, H, Y, ae) {
                        const ye = []
                          , Se = new o.P(a.anchorX,a.anchorY)
                          , Te = this.getPerspectiveRatio(Se.x, Se.y, P, ae)
                          , Re = (B ? x * this.transform.getPitchedTextCorrection(a.anchorX, a.anchorY, P) / Te : x * Te) / o.aA
                          , De = {
                            getElevation: ae,
                            pitchedLabelPlaneMatrix: I,
                            lineVertexArray: m,
                            pitchWithMap: B,
                            projectionCache: {
                                projections: {},
                                offsets: {},
                                cachedAnchorPoint: void 0,
                                anyProjectionOccluded: !1
                            },
                            transform: this.transform,
                            tileAnchorPoint: Se,
                            unwrappedTileID: P,
                            width: this.transform.width,
                            height: this.transform.height,
                            translation: Y
                        }
                          , Ae = ee(Re, y, a.lineOffsetX * Re, a.lineOffsetY * Re, !1, a, !1, De);
                        let Be = !1
                          , qe = !1
                          , ze = !0;
                        if (Ae) {
                            const Ke = .5 * Z * Te + H
                              , ht = new o.P(-100,-100)
                              , ot = new o.P(this.screenRightBoundary,this.screenBottomBoundary)
                              , ut = new yr
                              , mt = Ae.first
                              , $t = Ae.last;
                            let jt = [];
                            for (let Vr = mt.path.length - 1; Vr >= 1; Vr--)
                                jt.push(mt.path[Vr]);
                            for (let Vr = 1; Vr < $t.path.length; Vr++)
                                jt.push($t.path[Vr]);
                            const It = 2.5 * Ke;
                            if (B) {
                                const Vr = this.projectPathToScreenSpace(jt, De);
                                jt = Vr.some(cn => cn.signedDistanceFromCamera <= 0) ? [] : Vr.map(cn => cn.point)
                            }
                            let or = [];
                            if (jt.length > 0) {
                                const Vr = jt[0].clone()
                                  , cn = jt[0].clone();
                                for (let Kn = 1; Kn < jt.length; Kn++)
                                    Vr.x = Math.min(Vr.x, jt[Kn].x),
                                    Vr.y = Math.min(Vr.y, jt[Kn].y),
                                    cn.x = Math.max(cn.x, jt[Kn].x),
                                    cn.y = Math.max(cn.y, jt[Kn].y);
                                or = Vr.x >= ht.x && cn.x <= ot.x && Vr.y >= ht.y && cn.y <= ot.y ? [jt] : cn.x < ht.x || Vr.x > ot.x || cn.y < ht.y || Vr.y > ot.y ? [] : o.ax([jt], ht.x, ht.y, ot.x, ot.y)
                            }
                            for (const Vr of or) {
                                ut.reset(Vr, .25 * Ke);
                                let cn = 0;
                                cn = ut.length <= .5 * Ke ? 1 : Math.ceil(ut.paddedLength / It) + 1;
                                for (let Kn = 0; Kn < cn; Kn++) {
                                    const Sn = Kn / Math.max(cn - 1, 1)
                                      , On = ut.lerp(Sn)
                                      , kn = On.x + kr
                                      , pn = On.y + kr;
                                    ye.push(kn, pn, Ke, 0);
                                    const vn = kn - Ke
                                      , zi = pn - Ke
                                      , rn = kn + Ke
                                      , Ti = pn + Ke;
                                    if (ze = ze && this.isOffscreen(vn, zi, rn, Ti),
                                    qe = qe || this.isInsideGrid(vn, zi, rn, Ti),
                                    r !== "always" && this.grid.hitTestCircle(kn, pn, Ke, r, $) && (Be = !0,
                                    !A))
                                        return {
                                            circles: [],
                                            offscreen: !1,
                                            collisionDetected: Be
                                        }
                                }
                            }
                        }
                        return {
                            circles: !A && Be || !qe || Te < this.perspectiveRatioCutoff ? [] : ye,
                            offscreen: ze,
                            collisionDetected: Be
                        }
                    }
                    projectPathToScreenSpace(r, a) {
                        const m = function(y, x) {
                            const P = o.L();
                            return o.ap(P, x.pitchedLabelPlaneMatrix),
                            y.map(I => {
                                const A = Dr(I.x, I.y, P, x.getElevation)
                                  , B = x.transform.projectTileCoordinates(A.point.x, A.point.y, x.unwrappedTileID, x.getElevation);
                                return B.point.x = (.5 * B.point.x + .5) * x.width,
                                B.point.y = (.5 * -B.point.y + .5) * x.height,
                                B
                            }
                            )
                        }(r, a);
                        return function(y) {
                            let x = 0
                              , P = 0
                              , I = 0
                              , A = 0;
                            for (let B = 0; B < y.length; B++)
                                y[B].isOccluded ? (I = B + 1,
                                A = 0) : (A++,
                                A > P && (P = A,
                                x = I));
                            return y.slice(x, x + P)
                        }(m)
                    }
                    queryRenderedSymbols(r) {
                        if (r.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
                            return {};
                        const a = []
                          , m = new o.a1;
                        for (const Z of r) {
                            const H = new o.P(Z.x + kr,Z.y + kr);
                            m.extend(H),
                            a.push(H)
                        }
                        const {minX: y, minY: x, maxX: P, maxY: I} = m
                          , A = this.grid.query(y, x, P, I).concat(this.ignoredGrid.query(y, x, P, I))
                          , B = {}
                          , $ = {};
                        for (const Z of A) {
                            const H = Z.key;
                            if (B[H.bucketInstanceId] === void 0 && (B[H.bucketInstanceId] = {}),
                            B[H.bucketInstanceId][H.featureIndex])
                                continue;
                            const Y = [new o.P(Z.x1,Z.y1), new o.P(Z.x2,Z.y1), new o.P(Z.x2,Z.y2), new o.P(Z.x1,Z.y2)];
                            o.ay(a, Y) && (B[H.bucketInstanceId][H.featureIndex] = !0,
                            $[H.bucketInstanceId] === void 0 && ($[H.bucketInstanceId] = []),
                            $[H.bucketInstanceId].push(H.featureIndex))
                        }
                        return $
                    }
                    insertCollisionBox(r, a, m, y, x, P) {
                        (m ? this.ignoredGrid : this.grid).insert({
                            bucketInstanceId: y,
                            featureIndex: x,
                            collisionGroupID: P,
                            overlapMode: a
                        }, r[0], r[1], r[2], r[3])
                    }
                    insertCollisionCircles(r, a, m, y, x, P) {
                        const I = m ? this.ignoredGrid : this.grid
                          , A = {
                            bucketInstanceId: y,
                            featureIndex: x,
                            collisionGroupID: P,
                            overlapMode: a
                        };
                        for (let B = 0; B < r.length; B += 4)
                            I.insertCircle(A, r[B], r[B + 1], r[B + 2])
                    }
                    projectAndGetPerspectiveRatio(r, a, m, y, x) {
                        if (x) {
                            let P;
                            y ? (P = [r, a, y(r, a), 1],
                            o.av(P, P, x)) : (P = [r, a, 0, 1],
                            ni(P, P, x));
                            const I = P[3];
                            return {
                                x: (P[0] / I + 1) / 2 * this.transform.width + kr,
                                y: (-P[1] / I + 1) / 2 * this.transform.height + kr,
                                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / I * .5,
                                isOccluded: !1,
                                signedDistanceFromCamera: I
                            }
                        }
                        {
                            const P = this.transform.projectTileCoordinates(r, a, m, y);
                            return {
                                x: (P.point.x + 1) / 2 * this.transform.width + kr,
                                y: (1 - P.point.y) / 2 * this.transform.height + kr,
                                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / P.signedDistanceFromCamera * .5,
                                isOccluded: P.isOccluded,
                                signedDistanceFromCamera: P.signedDistanceFromCamera
                            }
                        }
                    }
                    getPerspectiveRatio(r, a, m, y) {
                        const x = this.transform.projectTileCoordinates(r, a, m, y);
                        return .5 + this.transform.cameraToCenterDistance / x.signedDistanceFromCamera * .5
                    }
                    isOffscreen(r, a, m, y) {
                        return m < kr || r >= this.screenRightBoundary || y < kr || a > this.screenBottomBoundary
                    }
                    isInsideGrid(r, a, m, y) {
                        return m >= 0 && r < this.gridRightBoundary && y >= 0 && a < this.gridBottomBoundary
                    }
                    getViewportMatrix() {
                        const r = o.af([]);
                        return o.M(r, r, [-100, -100, 0]),
                        r
                    }
                    _projectCollisionBox(r, a, m, y, x, P, I, A, B, $, Z) {
                        let H = 1
                          , Y = 0
                          , ae = 0
                          , ye = 1;
                        const Se = r.anchorPointX + I[0]
                          , Te = r.anchorPointY + I[1];
                        if (P && !x) {
                            const jt = this.projectAndGetPerspectiveRatio(Se + 1, Te, y, B, Z)
                              , It = jt.x - A.x
                              , or = Math.atan((jt.y - A.y) / It) + (It < 0 ? Math.PI : 0)
                              , Vr = Math.sin(or)
                              , cn = Math.cos(or);
                            H = cn,
                            Y = Vr,
                            ae = -Vr,
                            ye = cn
                        } else if (!P && x) {
                            const jt = qr(this.transform);
                            H = jt.vecEast[0],
                            Y = jt.vecEast[1],
                            ae = jt.vecSouth[0],
                            ye = jt.vecSouth[1]
                        }
                        let Re = A.x
                          , De = A.y
                          , Ae = a;
                        x && (Re = Se,
                        De = Te,
                        Ae = Math.pow(2, -(this.transform.zoom - m.overscaledZ)),
                        Ae *= this.transform.getPitchedTextCorrection(Se, Te, y),
                        $ || (Ae *= o.ag(.5 + A.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))),
                        $ && (Re += H * $.x * Ae + ae * $.y * Ae,
                        De += Y * $.x * Ae + ye * $.y * Ae);
                        const Be = r.x1 * Ae
                          , qe = r.x2 * Ae
                          , ze = (Be + qe) / 2
                          , Ke = r.y1 * Ae
                          , ht = r.y2 * Ae
                          , ot = (Ke + ht) / 2
                          , ut = [{
                            offsetX: Be,
                            offsetY: Ke
                        }, {
                            offsetX: ze,
                            offsetY: Ke
                        }, {
                            offsetX: qe,
                            offsetY: Ke
                        }, {
                            offsetX: qe,
                            offsetY: ot
                        }, {
                            offsetX: qe,
                            offsetY: ht
                        }, {
                            offsetX: ze,
                            offsetY: ht
                        }, {
                            offsetX: Be,
                            offsetY: ht
                        }, {
                            offsetX: Be,
                            offsetY: ot
                        }];
                        let mt = [];
                        for (const {offsetX: jt, offsetY: It} of ut)
                            mt.push(new o.P(Re + H * jt + ae * It,De + Y * jt + ye * It));
                        let $t = !1;
                        if (x) {
                            const jt = mt.map(It => this.projectAndGetPerspectiveRatio(It.x, It.y, y, B, Z));
                            $t = jt.some(It => !It.isOccluded),
                            mt = jt.map(It => new o.P(It.x,It.y))
                        } else
                            $t = !0;
                        return {
                            box: o.az(mt),
                            allPointsOccluded: !$t
                        }
                    }
                }
                class Si {
                    constructor(r, a, m, y) {
                        this.opacity = r ? Math.max(0, Math.min(1, r.opacity + (r.placed ? a : -a))) : y && m ? 1 : 0,
                        this.placed = m
                    }
                    isHidden() {
                        return this.opacity === 0 && !this.placed
                    }
                }
                class $i {
                    constructor(r, a, m, y, x) {
                        this.text = new Si(r ? r.text : null,a,m,x),
                        this.icon = new Si(r ? r.icon : null,a,y,x)
                    }
                    isHidden() {
                        return this.text.isHidden() && this.icon.isHidden()
                    }
                }
                class Ro {
                    constructor(r, a, m) {
                        this.text = r,
                        this.icon = a,
                        this.skipFade = m
                    }
                }
                class Ln {
                    constructor(r, a, m, y, x) {
                        this.bucketInstanceId = r,
                        this.featureIndex = a,
                        this.sourceLayerIndex = m,
                        this.bucketIndex = y,
                        this.tileID = x
                    }
                }
                class an {
                    constructor(r) {
                        this.crossSourceCollisions = r,
                        this.maxGroupID = 0,
                        this.collisionGroups = {}
                    }
                    get(r) {
                        if (this.crossSourceCollisions)
                            return {
                                ID: 0,
                                predicate: null
                            };
                        if (!this.collisionGroups[r]) {
                            const a = ++this.maxGroupID;
                            this.collisionGroups[r] = {
                                ID: a,
                                predicate: m => m.collisionGroupID === a
                            }
                        }
                        return this.collisionGroups[r]
                    }
                }
                function qn(v, r, a, m, y) {
                    const {horizontalAlign: x, verticalAlign: P} = o.aG(v);
                    return new o.P(-(x - .5) * r + m[0] * y,-(P - .5) * a + m[1] * y)
                }
                class Ei {
                    constructor(r, a, m, y, x) {
                        this.transform = r.clone(),
                        this.terrain = a,
                        this.collisionIndex = new ci(this.transform),
                        this.placements = {},
                        this.opacities = {},
                        this.variableOffsets = {},
                        this.stale = !1,
                        this.commitTime = 0,
                        this.fadeDuration = m,
                        this.retainedQueryData = {},
                        this.collisionGroups = new an(y),
                        this.collisionCircleArrays = {},
                        this.collisionBoxArrays = new Map,
                        this.prevPlacement = x,
                        x && (x.prevPlacement = void 0),
                        this.placedOrientations = {}
                    }
                    _getTerrainElevationFunc(r) {
                        const a = this.terrain;
                        return a ? (m, y) => a.getElevation(r, m, y) : null
                    }
                    getBucketParts(r, a, m, y) {
                        const x = m.getBucket(a)
                          , P = m.latestFeatureIndex;
                        if (!x || !P || a.id !== x.layerIds[0])
                            return;
                        const I = m.collisionBoxArray
                          , A = x.layers[0].layout
                          , B = x.layers[0].paint
                          , $ = Math.pow(2, this.transform.zoom - m.tileID.overscaledZ)
                          , Z = m.tileSize / o.$
                          , H = m.tileID.toUnwrapped()
                          , Y = A.get("text-rotation-alignment") === "map"
                          , ae = o.aB(m, 1, this.transform.zoom)
                          , ye = o.aC(this.collisionIndex.transform, m, B.get("text-translate"), B.get("text-translate-anchor"))
                          , Se = o.aC(this.collisionIndex.transform, m, B.get("icon-translate"), B.get("icon-translate-anchor"))
                          , Te = br(Y, this.transform, ae);
                        this.retainedQueryData[x.bucketInstanceId] = new Ln(x.bucketInstanceId,P,x.sourceLayerIndex,x.index,m.tileID);
                        const Re = {
                            bucket: x,
                            layout: A,
                            translationText: ye,
                            translationIcon: Se,
                            unwrappedTileID: H,
                            pitchedLabelPlaneMatrix: Te,
                            scale: $,
                            textPixelRatio: Z,
                            holdingForFade: m.holdingForFade(),
                            collisionBoxArray: I,
                            partiallyEvaluatedTextSize: o.am(x.textSizeData, this.transform.zoom),
                            collisionGroup: this.collisionGroups.get(x.sourceID)
                        };
                        if (y)
                            for (const De of x.sortKeyRanges) {
                                const {sortKey: Ae, symbolInstanceStart: Be, symbolInstanceEnd: qe} = De;
                                r.push({
                                    sortKey: Ae,
                                    symbolInstanceStart: Be,
                                    symbolInstanceEnd: qe,
                                    parameters: Re
                                })
                            }
                        else
                            r.push({
                                symbolInstanceStart: 0,
                                symbolInstanceEnd: x.symbolInstances.length,
                                parameters: Re
                            })
                    }
                    attemptAnchorPlacement(r, a, m, y, x, P, I, A, B, $, Z, H, Y, ae, ye, Se, Te, Re, De, Ae) {
                        const Be = o.aD[r.textAnchor]
                          , qe = [r.textOffset0, r.textOffset1]
                          , ze = qn(Be, m, y, qe, x)
                          , Ke = this.collisionIndex.placeCollisionBox(a, H, A, B, $, I, P, Se, Z.predicate, De, ze, Ae);
                        if ((!Re || this.collisionIndex.placeCollisionBox(Re, H, A, B, $, I, P, Te, Z.predicate, De, ze, Ae).placeable) && Ke.placeable) {
                            let ht;
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[Y.crossTileID] && this.prevPlacement.placements[Y.crossTileID] && this.prevPlacement.placements[Y.crossTileID].text && (ht = this.prevPlacement.variableOffsets[Y.crossTileID].anchor),
                            Y.crossTileID === 0)
                                throw new Error("symbolInstance.crossTileID can't be 0");
                            return this.variableOffsets[Y.crossTileID] = {
                                textOffset: qe,
                                width: m,
                                height: y,
                                anchor: Be,
                                textBoxScale: x,
                                prevAnchor: ht
                            },
                            this.markUsedJustification(ae, Be, Y, ye),
                            ae.allowVerticalPlacement && (this.markUsedOrientation(ae, ye, Y),
                            this.placedOrientations[Y.crossTileID] = ye),
                            {
                                shift: ze,
                                placedGlyphBoxes: Ke
                            }
                        }
                    }
                    placeLayerBucketPart(r, a, m) {
                        const {bucket: y, layout: x, translationText: P, translationIcon: I, unwrappedTileID: A, pitchedLabelPlaneMatrix: B, textPixelRatio: $, holdingForFade: Z, collisionBoxArray: H, partiallyEvaluatedTextSize: Y, collisionGroup: ae} = r.parameters
                          , ye = x.get("text-optional")
                          , Se = x.get("icon-optional")
                          , Te = o.aE(x, "text-overlap", "text-allow-overlap")
                          , Re = Te === "always"
                          , De = o.aE(x, "icon-overlap", "icon-allow-overlap")
                          , Ae = De === "always"
                          , Be = x.get("text-rotation-alignment") === "map"
                          , qe = x.get("text-pitch-alignment") === "map"
                          , ze = x.get("icon-text-fit") !== "none"
                          , Ke = x.get("symbol-z-order") === "viewport-y"
                          , ht = Re && (Ae || !y.hasIconData() || Se)
                          , ot = Ae && (Re || !y.hasTextData() || ye);
                        !y.collisionArrays && H && y.deserializeCollisionBoxes(H);
                        const ut = this.retainedQueryData[y.bucketInstanceId].tileID
                          , mt = this._getTerrainElevationFunc(ut)
                          , $t = this.transform.getFastPathSimpleProjectionMatrix(ut)
                          , jt = (It, or, Vr) => {
                            var cn, Kn;
                            if (a[It.crossTileID])
                                return;
                            if (Z)
                                return void (this.placements[It.crossTileID] = new Ro(!1,!1,!1));
                            let Sn = !1
                              , On = !1
                              , kn = !0
                              , pn = null
                              , vn = {
                                box: null,
                                placeable: !1,
                                offscreen: null,
                                occluded: !1
                            }
                              , zi = {
                                placeable: !1
                            }
                              , rn = null
                              , Ti = null
                              , Di = null
                              , ma = 0
                              , ga = 0
                              , Ys = 0;
                            or.textFeatureIndex ? ma = or.textFeatureIndex : It.useRuntimeCollisionCircles && (ma = It.featureIndex),
                            or.verticalTextFeatureIndex && (ga = or.verticalTextFeatureIndex);
                            const Is = or.textBox;
                            if (Is) {
                                const wo = ti => {
                                    let Bn = o.an.horizontal;
                                    if (y.allowVerticalPlacement && !ti && this.prevPlacement) {
                                        const Li = this.prevPlacement.placedOrientations[It.crossTileID];
                                        Li && (this.placedOrientations[It.crossTileID] = Li,
                                        Bn = Li,
                                        this.markUsedOrientation(y, Bn, It))
                                    }
                                    return Bn
                                }
                                  , Rs = (ti, Bn) => {
                                    if (y.allowVerticalPlacement && It.numVerticalGlyphVertices > 0 && or.verticalTextBox) {
                                        for (const Li of y.writingModes)
                                            if (Li === o.an.vertical ? (vn = Bn(),
                                            zi = vn) : vn = ti(),
                                            vn && vn.placeable)
                                                break
                                    } else
                                        vn = ti()
                                }
                                  , tl = It.textAnchorOffsetStartIndex
                                  , rl = It.textAnchorOffsetEndIndex;
                                if (rl === tl) {
                                    const ti = (Bn, Li) => {
                                        const Pi = this.collisionIndex.placeCollisionBox(Bn, Te, $, ut, A, qe, Be, P, ae.predicate, mt, void 0, $t);
                                        return Pi && Pi.placeable && (this.markUsedOrientation(y, Li, It),
                                        this.placedOrientations[It.crossTileID] = Li),
                                        Pi
                                    }
                                    ;
                                    Rs( () => ti(Is, o.an.horizontal), () => {
                                        const Bn = or.verticalTextBox;
                                        return y.allowVerticalPlacement && It.numVerticalGlyphVertices > 0 && Bn ? ti(Bn, o.an.vertical) : {
                                            box: null,
                                            offscreen: null
                                        }
                                    }
                                    ),
                                    wo(vn && vn.placeable)
                                } else {
                                    let ti = o.aD[(Kn = (cn = this.prevPlacement) === null || cn === void 0 ? void 0 : cn.variableOffsets[It.crossTileID]) === null || Kn === void 0 ? void 0 : Kn.anchor];
                                    const Bn = (Pi, $f, cm) => {
                                        const es = Pi.x2 - Pi.x1
                                          , Vl = Pi.y2 - Pi.y1
                                          , ya = It.textBoxScale
                                          , Ks = ze && De === "never" ? $f : null;
                                        let Oi = null
                                          , Qs = Te === "never" ? 1 : 2
                                          , Fu = "never";
                                        ti && Qs++;
                                        for (let ts = 0; ts < Qs; ts++) {
                                            for (let Bu = tl; Bu < rl; Bu++) {
                                                const ju = y.textAnchorOffsets.get(Bu);
                                                if (ti && ju.textAnchor !== ti)
                                                    continue;
                                                const Nu = this.attemptAnchorPlacement(ju, Pi, es, Vl, ya, Be, qe, $, ut, A, ae, Fu, It, y, cm, P, I, Ks, mt);
                                                if (Nu && (Oi = Nu.placedGlyphBoxes,
                                                Oi && Oi.placeable))
                                                    return Sn = !0,
                                                    pn = Nu.shift,
                                                    Oi
                                            }
                                            ti ? ti = null : Fu = Te
                                        }
                                        return m && !Oi && (Oi = {
                                            box: this.collisionIndex.placeCollisionBox(Is, "always", $, ut, A, qe, Be, P, ae.predicate, mt, void 0, $t).box,
                                            offscreen: !1,
                                            placeable: !1,
                                            occluded: !1
                                        }),
                                        Oi
                                    }
                                    ;
                                    Rs( () => Bn(Is, or.iconBox, o.an.horizontal), () => {
                                        const Pi = or.verticalTextBox;
                                        return y.allowVerticalPlacement && (!vn || !vn.placeable) && It.numVerticalGlyphVertices > 0 && Pi ? Bn(Pi, or.verticalIconBox, o.an.vertical) : {
                                            box: null,
                                            occluded: !0,
                                            offscreen: null
                                        }
                                    }
                                    ),
                                    vn && (Sn = vn.placeable,
                                    kn = vn.offscreen);
                                    const Li = wo(vn && vn.placeable);
                                    if (!Sn && this.prevPlacement) {
                                        const Pi = this.prevPlacement.variableOffsets[It.crossTileID];
                                        Pi && (this.variableOffsets[It.crossTileID] = Pi,
                                        this.markUsedJustification(y, Pi.anchor, It, Li))
                                    }
                                }
                            }
                            if (rn = vn,
                            Sn = rn && rn.placeable,
                            kn = rn && rn.offscreen,
                            It.useRuntimeCollisionCircles) {
                                const wo = y.text.placedSymbolArray.get(It.centerJustifiedTextSymbolIndex)
                                  , Rs = o.ao(y.textSizeData, Y, wo)
                                  , tl = x.get("text-padding");
                                Ti = this.collisionIndex.placeCollisionCircles(Te, wo, y.lineVertexArray, y.glyphOffsetArray, Rs, A, B, m, qe, ae.predicate, It.collisionCircleDiameter, tl, P, mt),
                                Ti.circles.length && Ti.collisionDetected && !m && o.w("Collisions detected, but collision boxes are not shown"),
                                Sn = Re || Ti.circles.length > 0 && !Ti.collisionDetected,
                                kn = kn && Ti.offscreen
                            }
                            if (or.iconFeatureIndex && (Ys = or.iconFeatureIndex),
                            or.iconBox) {
                                const wo = Rs => this.collisionIndex.placeCollisionBox(Rs, De, $, ut, A, qe, Be, I, ae.predicate, mt, ze && pn ? pn : void 0, $t);
                                zi && zi.placeable && or.verticalIconBox ? (Di = wo(or.verticalIconBox),
                                On = Di.placeable) : (Di = wo(or.iconBox),
                                On = Di.placeable),
                                kn = kn && Di.offscreen
                            }
                            const Ic = ye || It.numHorizontalGlyphVertices === 0 && It.numVerticalGlyphVertices === 0
                              , Rc = Se || It.numIconVertices === 0;
                            Ic || Rc ? Rc ? Ic || (On = On && Sn) : Sn = On && Sn : On = Sn = On && Sn;
                            const Ac = On && Di.placeable;
                            if (Sn && rn.placeable && this.collisionIndex.insertCollisionBox(rn.box, Te, x.get("text-ignore-placement"), y.bucketInstanceId, zi && zi.placeable && ga ? ga : ma, ae.ID),
                            Ac && this.collisionIndex.insertCollisionBox(Di.box, De, x.get("icon-ignore-placement"), y.bucketInstanceId, Ys, ae.ID),
                            Ti && Sn && this.collisionIndex.insertCollisionCircles(Ti.circles, Te, x.get("text-ignore-placement"), y.bucketInstanceId, ma, ae.ID),
                            m && this.storeCollisionData(y.bucketInstanceId, Vr, or, rn, Di, Ti),
                            It.crossTileID === 0)
                                throw new Error("symbolInstance.crossTileID can't be 0");
                            if (y.bucketInstanceId === 0)
                                throw new Error("bucket.bucketInstanceId can't be 0");
                            this.placements[It.crossTileID] = new Ro((Sn || ht) && !rn?.occluded,(On || ot) && !Di?.occluded,kn || y.justReloaded),
                            a[It.crossTileID] = !0
                        }
                        ;
                        if (Ke) {
                            if (r.symbolInstanceStart !== 0)
                                throw new Error("bucket.bucketInstanceId should be 0");
                            const It = y.getSortedSymbolIndexes(-this.transform.bearingInRadians);
                            for (let or = It.length - 1; or >= 0; --or) {
                                const Vr = It[or];
                                jt(y.symbolInstances.get(Vr), y.collisionArrays[Vr], Vr)
                            }
                        } else
                            for (let It = r.symbolInstanceStart; It < r.symbolInstanceEnd; It++)
                                jt(y.symbolInstances.get(It), y.collisionArrays[It], It);
                        y.justReloaded = !1
                    }
                    storeCollisionData(r, a, m, y, x, P) {
                        if (m.textBox || m.iconBox) {
                            let I, A;
                            this.collisionBoxArrays.has(r) ? I = this.collisionBoxArrays.get(r) : (I = new Map,
                            this.collisionBoxArrays.set(r, I)),
                            I.has(a) ? A = I.get(a) : (A = {
                                text: null,
                                icon: null
                            },
                            I.set(a, A)),
                            m.textBox && (A.text = y.box),
                            m.iconBox && (A.icon = x.box)
                        }
                        if (P) {
                            let I = this.collisionCircleArrays[r];
                            I === void 0 && (I = this.collisionCircleArrays[r] = []);
                            for (let A = 0; A < P.circles.length; A += 4)
                                I.push(P.circles[A + 0] - kr),
                                I.push(P.circles[A + 1] - kr),
                                I.push(P.circles[A + 2]),
                                I.push(P.collisionDetected ? 1 : 0)
                        }
                    }
                    markUsedJustification(r, a, m, y) {
                        let x;
                        x = y === o.an.vertical ? m.verticalPlacedTextSymbolIndex : {
                            left: m.leftJustifiedTextSymbolIndex,
                            center: m.centerJustifiedTextSymbolIndex,
                            right: m.rightJustifiedTextSymbolIndex
                        }[o.aF(a)];
                        const P = [m.leftJustifiedTextSymbolIndex, m.centerJustifiedTextSymbolIndex, m.rightJustifiedTextSymbolIndex, m.verticalPlacedTextSymbolIndex];
                        for (const I of P)
                            I >= 0 && (r.text.placedSymbolArray.get(I).crossTileID = x >= 0 && I !== x ? 0 : m.crossTileID)
                    }
                    markUsedOrientation(r, a, m) {
                        const y = a === o.an.horizontal || a === o.an.horizontalOnly ? a : 0
                          , x = a === o.an.vertical ? a : 0
                          , P = [m.leftJustifiedTextSymbolIndex, m.centerJustifiedTextSymbolIndex, m.rightJustifiedTextSymbolIndex];
                        for (const I of P)
                            r.text.placedSymbolArray.get(I).placedOrientation = y;
                        m.verticalPlacedTextSymbolIndex && (r.text.placedSymbolArray.get(m.verticalPlacedTextSymbolIndex).placedOrientation = x)
                    }
                    commit(r) {
                        this.commitTime = r,
                        this.zoomAtLastRecencyCheck = this.transform.zoom;
                        const a = this.prevPlacement;
                        let m = !1;
                        this.prevZoomAdjustment = a ? a.zoomAdjustment(this.transform.zoom) : 0;
                        const y = a ? a.symbolFadeChange(r) : 1
                          , x = a ? a.opacities : {}
                          , P = a ? a.variableOffsets : {}
                          , I = a ? a.placedOrientations : {};
                        for (const A in this.placements) {
                            const B = this.placements[A]
                              , $ = x[A];
                            $ ? (this.opacities[A] = new $i($,y,B.text,B.icon),
                            m = m || B.text !== $.text.placed || B.icon !== $.icon.placed) : (this.opacities[A] = new $i(null,y,B.text,B.icon,B.skipFade),
                            m = m || B.text || B.icon)
                        }
                        for (const A in x) {
                            const B = x[A];
                            if (!this.opacities[A]) {
                                const $ = new $i(B,y,!1,!1);
                                $.isHidden() || (this.opacities[A] = $,
                                m = m || B.text.placed || B.icon.placed)
                            }
                        }
                        for (const A in P)
                            this.variableOffsets[A] || !this.opacities[A] || this.opacities[A].isHidden() || (this.variableOffsets[A] = P[A]);
                        for (const A in I)
                            this.placedOrientations[A] || !this.opacities[A] || this.opacities[A].isHidden() || (this.placedOrientations[A] = I[A]);
                        if (a && a.lastPlacementChangeTime === void 0)
                            throw new Error("Last placement time for previous placement is not defined");
                        m ? this.lastPlacementChangeTime = r : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = a ? a.lastPlacementChangeTime : r)
                    }
                    updateLayerOpacities(r, a) {
                        const m = {};
                        for (const y of a) {
                            const x = y.getBucket(r);
                            x && y.latestFeatureIndex && r.id === x.layerIds[0] && this.updateBucketOpacities(x, y.tileID, m, y.collisionBoxArray)
                        }
                    }
                    updateBucketOpacities(r, a, m, y) {
                        r.hasTextData() && (r.text.opacityVertexArray.clear(),
                        r.text.hasVisibleVertices = !1),
                        r.hasIconData() && (r.icon.opacityVertexArray.clear(),
                        r.icon.hasVisibleVertices = !1),
                        r.hasIconCollisionBoxData() && r.iconCollisionBox.collisionVertexArray.clear(),
                        r.hasTextCollisionBoxData() && r.textCollisionBox.collisionVertexArray.clear();
                        const x = r.layers[0]
                          , P = x.layout
                          , I = new $i(null,0,!1,!1,!0)
                          , A = P.get("text-allow-overlap")
                          , B = P.get("icon-allow-overlap")
                          , $ = x._unevaluatedLayout.hasValue("text-variable-anchor") || x._unevaluatedLayout.hasValue("text-variable-anchor-offset")
                          , Z = P.get("text-rotation-alignment") === "map"
                          , H = P.get("text-pitch-alignment") === "map"
                          , Y = P.get("icon-text-fit") !== "none"
                          , ae = new $i(null,0,A && (B || !r.hasIconData() || P.get("icon-optional")),B && (A || !r.hasTextData() || P.get("text-optional")),!0);
                        !r.collisionArrays && y && (r.hasIconCollisionBoxData() || r.hasTextCollisionBoxData()) && r.deserializeCollisionBoxes(y);
                        const ye = (Te, Re, De) => {
                            for (let Ae = 0; Ae < Re / 4; Ae++)
                                Te.opacityVertexArray.emplaceBack(De);
                            Te.hasVisibleVertices = Te.hasVisibleVertices || De !== Zo
                        }
                          , Se = this.collisionBoxArrays.get(r.bucketInstanceId);
                        for (let Te = 0; Te < r.symbolInstances.length; Te++) {
                            const Re = r.symbolInstances.get(Te)
                              , {numHorizontalGlyphVertices: De, numVerticalGlyphVertices: Ae, crossTileID: Be} = Re;
                            let qe = this.opacities[Be];
                            m[Be] ? qe = I : qe || (qe = ae,
                            this.opacities[Be] = qe),
                            m[Be] = !0;
                            const ze = Re.numIconVertices > 0
                              , Ke = this.placedOrientations[Re.crossTileID]
                              , ht = Ke === o.an.vertical
                              , ot = Ke === o.an.horizontal || Ke === o.an.horizontalOnly;
                            if (De > 0 || Ae > 0) {
                                const mt = bs(qe.text);
                                ye(r.text, De, ht ? Zo : mt),
                                ye(r.text, Ae, ot ? Zo : mt);
                                const $t = qe.text.isHidden();
                                [Re.rightJustifiedTextSymbolIndex, Re.centerJustifiedTextSymbolIndex, Re.leftJustifiedTextSymbolIndex].forEach(or => {
                                    or >= 0 && (r.text.placedSymbolArray.get(or).hidden = $t || ht ? 1 : 0)
                                }
                                ),
                                Re.verticalPlacedTextSymbolIndex >= 0 && (r.text.placedSymbolArray.get(Re.verticalPlacedTextSymbolIndex).hidden = $t || ot ? 1 : 0);
                                const jt = this.variableOffsets[Re.crossTileID];
                                jt && this.markUsedJustification(r, jt.anchor, Re, Ke);
                                const It = this.placedOrientations[Re.crossTileID];
                                It && (this.markUsedJustification(r, "left", Re, It),
                                this.markUsedOrientation(r, It, Re))
                            }
                            if (ze) {
                                const mt = bs(qe.icon)
                                  , $t = !(Y && Re.verticalPlacedIconSymbolIndex && ht);
                                Re.placedIconSymbolIndex >= 0 && (ye(r.icon, Re.numIconVertices, $t ? mt : Zo),
                                r.icon.placedSymbolArray.get(Re.placedIconSymbolIndex).hidden = qe.icon.isHidden()),
                                Re.verticalPlacedIconSymbolIndex >= 0 && (ye(r.icon, Re.numVerticalIconVertices, $t ? Zo : mt),
                                r.icon.placedSymbolArray.get(Re.verticalPlacedIconSymbolIndex).hidden = qe.icon.isHidden())
                            }
                            const ut = Se && Se.has(Te) ? Se.get(Te) : {
                                text: null,
                                icon: null
                            };
                            if (r.hasIconCollisionBoxData() || r.hasTextCollisionBoxData()) {
                                const mt = r.collisionArrays[Te];
                                if (mt) {
                                    let $t = new o.P(0,0);
                                    if (mt.textBox || mt.verticalTextBox) {
                                        let jt = !0;
                                        if ($) {
                                            const It = this.variableOffsets[Be];
                                            It ? ($t = qn(It.anchor, It.width, It.height, It.textOffset, It.textBoxScale),
                                            Z && $t._rotate(H ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : jt = !1
                                        }
                                        if (mt.textBox || mt.verticalTextBox) {
                                            let It;
                                            mt.textBox && (It = ht),
                                            mt.verticalTextBox && (It = ot),
                                            Ao(r.textCollisionBox.collisionVertexArray, qe.text.placed, !jt || It, ut.text, $t.x, $t.y)
                                        }
                                    }
                                    if (mt.iconBox || mt.verticalIconBox) {
                                        const jt = !!(!ot && mt.verticalIconBox);
                                        let It;
                                        mt.iconBox && (It = jt),
                                        mt.verticalIconBox && (It = !jt),
                                        Ao(r.iconCollisionBox.collisionVertexArray, qe.icon.placed, It, ut.icon, Y ? $t.x : 0, Y ? $t.y : 0)
                                    }
                                }
                            }
                        }
                        if (r.sortFeatures(-this.transform.bearingInRadians),
                        this.retainedQueryData[r.bucketInstanceId] && (this.retainedQueryData[r.bucketInstanceId].featureSortOrder = r.featureSortOrder),
                        r.hasTextData() && r.text.opacityVertexBuffer && r.text.opacityVertexBuffer.updateData(r.text.opacityVertexArray),
                        r.hasIconData() && r.icon.opacityVertexBuffer && r.icon.opacityVertexBuffer.updateData(r.icon.opacityVertexArray),
                        r.hasIconCollisionBoxData() && r.iconCollisionBox.collisionVertexBuffer && r.iconCollisionBox.collisionVertexBuffer.updateData(r.iconCollisionBox.collisionVertexArray),
                        r.hasTextCollisionBoxData() && r.textCollisionBox.collisionVertexBuffer && r.textCollisionBox.collisionVertexBuffer.updateData(r.textCollisionBox.collisionVertexArray),
                        r.text.opacityVertexArray.length !== r.text.layoutVertexArray.length / 4)
                            throw new Error(`bucket.text.opacityVertexArray.length (= ${r.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${r.text.layoutVertexArray.length}) / 4`);
                        if (r.icon.opacityVertexArray.length !== r.icon.layoutVertexArray.length / 4)
                            throw new Error(`bucket.icon.opacityVertexArray.length (= ${r.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${r.icon.layoutVertexArray.length}) / 4`);
                        r.bucketInstanceId in this.collisionCircleArrays && (r.collisionCircleArray = this.collisionCircleArrays[r.bucketInstanceId],
                        delete this.collisionCircleArrays[r.bucketInstanceId])
                    }
                    symbolFadeChange(r) {
                        return this.fadeDuration === 0 ? 1 : (r - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
                    }
                    zoomAdjustment(r) {
                        return Math.max(0, (this.transform.zoom - r) / 1.5)
                    }
                    hasTransitions(r) {
                        return this.stale || r - this.lastPlacementChangeTime < this.fadeDuration
                    }
                    stillRecent(r, a) {
                        const m = this.zoomAtLastRecencyCheck === a ? 1 - this.zoomAdjustment(a) : 1;
                        return this.zoomAtLastRecencyCheck = a,
                        this.commitTime + this.fadeDuration * m > r
                    }
                    setStale() {
                        this.stale = !0
                    }
                }
                function Ao(v, r, a, m, y, x) {
                    m && m.length !== 0 || (m = [0, 0, 0, 0]);
                    const P = m[0] - kr
                      , I = m[1] - kr
                      , A = m[2] - kr
                      , B = m[3] - kr;
                    v.emplaceBack(r ? 1 : 0, a ? 1 : 0, y || 0, x || 0, P, I),
                    v.emplaceBack(r ? 1 : 0, a ? 1 : 0, y || 0, x || 0, A, I),
                    v.emplaceBack(r ? 1 : 0, a ? 1 : 0, y || 0, x || 0, A, B),
                    v.emplaceBack(r ? 1 : 0, a ? 1 : 0, y || 0, x || 0, P, B)
                }
                const Hn = Math.pow(2, 25)
                  , Go = Math.pow(2, 24)
                  , xl = Math.pow(2, 17)
                  , Wo = Math.pow(2, 16)
                  , qo = Math.pow(2, 9)
                  , Ho = Math.pow(2, 8)
                  , xs = Math.pow(2, 1);
                function bs(v) {
                    if (v.opacity === 0 && !v.placed)
                        return 0;
                    if (v.opacity === 1 && v.placed)
                        return 4294967295;
                    const r = v.placed ? 1 : 0
                      , a = Math.floor(127 * v.opacity);
                    return a * Hn + r * Go + a * xl + r * Wo + a * qo + r * Ho + a * xs + r
                }
                const Zo = 0;
                class Vi {
                    constructor(r) {
                        this._sortAcrossTiles = r.layout.get("symbol-z-order") !== "viewport-y" && !r.layout.get("symbol-sort-key").isConstant(),
                        this._currentTileIndex = 0,
                        this._currentPartIndex = 0,
                        this._seenCrossTileIDs = {},
                        this._bucketParts = []
                    }
                    continuePlacement(r, a, m, y, x) {
                        const P = this._bucketParts;
                        for (; this._currentTileIndex < r.length; )
                            if (a.getBucketParts(P, y, r[this._currentTileIndex], this._sortAcrossTiles),
                            this._currentTileIndex++,
                            x())
                                return !0;
                        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1,
                        P.sort( (I, A) => I.sortKey - A.sortKey)); this._currentPartIndex < P.length; )
                            if (a.placeLayerBucketPart(P[this._currentPartIndex], this._seenCrossTileIDs, m),
                            this._currentPartIndex++,
                            x())
                                return !0;
                        return !1
                    }
                }
                class oa {
                    constructor(r, a, m, y, x, P, I, A) {
                        this.placement = new Ei(r,a,P,I,A),
                        this._currentPlacementIndex = m.length - 1,
                        this._forceFullPlacement = y,
                        this._showCollisionBoxes = x,
                        this._done = !1
                    }
                    isDone() {
                        return this._done
                    }
                    continuePlacement(r, a, m) {
                        const y = z.now()
                          , x = () => !this._forceFullPlacement && z.now() - y > 2;
                        for (; this._currentPlacementIndex >= 0; ) {
                            const P = a[r[this._currentPlacementIndex]]
                              , I = this.placement.collisionIndex.transform.zoom;
                            if (P.type === "symbol" && (!P.minzoom || P.minzoom <= I) && (!P.maxzoom || P.maxzoom > I)) {
                                if (this._inProgressLayer || (this._inProgressLayer = new Vi(P)),
                                this._inProgressLayer.continuePlacement(m[P.source], this.placement, this._showCollisionBoxes, P, x))
                                    return;
                                delete this._inProgressLayer
                            }
                            this._currentPlacementIndex--
                        }
                        this._done = !0
                    }
                    commit(r) {
                        return this.placement.commit(r),
                        this.placement
                    }
                }
                const Ki = 512 / o.$ / 2;
                class su {
                    constructor(r, a, m) {
                        this.tileID = r,
                        this.bucketInstanceId = m,
                        this._symbolsByKey = {};
                        const y = new Map;
                        for (let x = 0; x < a.length; x++) {
                            const P = a.get(x)
                              , I = P.key
                              , A = y.get(I);
                            A ? A.push(P) : y.set(I, [P])
                        }
                        for (const [x,P] of y) {
                            const I = {
                                positions: P.map(A => ({
                                    x: Math.floor(A.anchorX * Ki),
                                    y: Math.floor(A.anchorY * Ki)
                                })),
                                crossTileIDs: P.map(A => A.crossTileID)
                            };
                            if (I.positions.length > 128) {
                                const A = new o.aH(I.positions.length,16,Uint16Array);
                                for (const {x: B, y: $} of I.positions)
                                    A.add(B, $);
                                A.finish(),
                                delete I.positions,
                                I.index = A
                            }
                            this._symbolsByKey[x] = I
                        }
                    }
                    getScaledCoordinates(r, a) {
                        const {x: m, y, z: x} = this.tileID.canonical
                          , {x: P, y: I, z: A} = a.canonical
                          , B = Ki / Math.pow(2, A - x)
                          , $ = (I * o.$ + r.anchorY) * B
                          , Z = y * o.$ * Ki;
                        return {
                            x: Math.floor((P * o.$ + r.anchorX) * B - m * o.$ * Ki),
                            y: Math.floor($ - Z)
                        }
                    }
                    findMatches(r, a, m) {
                        const y = this.tileID.canonical.z < a.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - a.canonical.z);
                        for (let x = 0; x < r.length; x++) {
                            const P = r.get(x);
                            if (P.crossTileID)
                                continue;
                            const I = this._symbolsByKey[P.key];
                            if (!I)
                                continue;
                            const A = this.getScaledCoordinates(P, a);
                            if (I.index) {
                                const B = I.index.range(A.x - y, A.y - y, A.x + y, A.y + y).sort();
                                for (const $ of B) {
                                    const Z = I.crossTileIDs[$];
                                    if (!m[Z]) {
                                        m[Z] = !0,
                                        P.crossTileID = Z;
                                        break
                                    }
                                }
                            } else if (I.positions)
                                for (let B = 0; B < I.positions.length; B++) {
                                    const $ = I.positions[B]
                                      , Z = I.crossTileIDs[B];
                                    if (Math.abs($.x - A.x) <= y && Math.abs($.y - A.y) <= y && !m[Z]) {
                                        m[Z] = !0,
                                        P.crossTileID = Z;
                                        break
                                    }
                                }
                        }
                    }
                    getCrossTileIDsLists() {
                        return Object.values(this._symbolsByKey).map( ({crossTileIDs: r}) => r)
                    }
                }
                class bl {
                    constructor() {
                        this.maxCrossTileID = 0
                    }
                    generate() {
                        return ++this.maxCrossTileID
                    }
                }
                class wf {
                    constructor() {
                        this.indexes = {},
                        this.usedCrossTileIDs = {},
                        this.lng = 0
                    }
                    handleWrapJump(r) {
                        const a = Math.round((r - this.lng) / 360);
                        if (a !== 0)
                            for (const m in this.indexes) {
                                const y = this.indexes[m]
                                  , x = {};
                                for (const P in y) {
                                    const I = y[P];
                                    I.tileID = I.tileID.unwrapTo(I.tileID.wrap + a),
                                    x[I.tileID.key] = I
                                }
                                this.indexes[m] = x
                            }
                        this.lng = r
                    }
                    addBucket(r, a, m) {
                        if (this.indexes[r.overscaledZ] && this.indexes[r.overscaledZ][r.key]) {
                            if (this.indexes[r.overscaledZ][r.key].bucketInstanceId === a.bucketInstanceId)
                                return !1;
                            this.removeBucketCrossTileIDs(r.overscaledZ, this.indexes[r.overscaledZ][r.key])
                        }
                        for (let x = 0; x < a.symbolInstances.length; x++)
                            a.symbolInstances.get(x).crossTileID = 0;
                        this.usedCrossTileIDs[r.overscaledZ] || (this.usedCrossTileIDs[r.overscaledZ] = {});
                        const y = this.usedCrossTileIDs[r.overscaledZ];
                        for (const x in this.indexes) {
                            const P = this.indexes[x];
                            if (Number(x) > r.overscaledZ)
                                for (const I in P) {
                                    const A = P[I];
                                    A.tileID.isChildOf(r) && A.findMatches(a.symbolInstances, r, y)
                                }
                            else {
                                const I = P[r.scaledTo(Number(x)).key];
                                I && I.findMatches(a.symbolInstances, r, y)
                            }
                        }
                        for (let x = 0; x < a.symbolInstances.length; x++) {
                            const P = a.symbolInstances.get(x);
                            P.crossTileID || (P.crossTileID = m.generate(),
                            y[P.crossTileID] = !0)
                        }
                        return this.indexes[r.overscaledZ] === void 0 && (this.indexes[r.overscaledZ] = {}),
                        this.indexes[r.overscaledZ][r.key] = new su(r,a.symbolInstances,a.bucketInstanceId),
                        !0
                    }
                    removeBucketCrossTileIDs(r, a) {
                        for (const m of a.getCrossTileIDsLists())
                            for (const y of m)
                                delete this.usedCrossTileIDs[r][y]
                    }
                    removeStaleBuckets(r) {
                        let a = !1;
                        for (const m in this.indexes) {
                            const y = this.indexes[m];
                            for (const x in y)
                                r[y[x].bucketInstanceId] || (this.removeBucketCrossTileIDs(m, y[x]),
                                delete y[x],
                                a = !0)
                        }
                        return a
                    }
                }
                class ic {
                    constructor() {
                        this.layerIndexes = {},
                        this.crossTileIDs = new bl,
                        this.maxBucketInstanceId = 0,
                        this.bucketsInCurrentPlacement = {}
                    }
                    addLayer(r, a, m) {
                        let y = this.layerIndexes[r.id];
                        y === void 0 && (y = this.layerIndexes[r.id] = new wf);
                        let x = !1;
                        const P = {};
                        y.handleWrapJump(m);
                        for (const I of a) {
                            const A = I.getBucket(r);
                            A && r.id === A.layerIds[0] && (A.bucketInstanceId || (A.bucketInstanceId = ++this.maxBucketInstanceId),
                            y.addBucket(I.tileID, A, this.crossTileIDs) && (x = !0),
                            P[A.bucketInstanceId] = !0)
                        }
                        return y.removeStaleBuckets(P) && (x = !0),
                        x
                    }
                    pruneUnusedLayers(r) {
                        const a = {};
                        r.forEach(m => {
                            a[m] = !0
                        }
                        );
                        for (const m in this.layerIndexes)
                            a[m] || delete this.layerIndexes[m]
                    }
                }
                var dn = "void main() {fragColor=vec4(1.0);}";
                const ws = {
                    prelude: Xr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
                    projectionMercator: Xr("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
                    projectionGlobe: Xr("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
                    background: Xr(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
                    backgroundPattern: Xr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
                    circle: Xr(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
                    clippingMask: Xr(dn, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
                    heatmap: Xr(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
                    heatmapTexture: Xr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
                    collisionBox: Xr("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
                    collisionCircle: Xr("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
                    colorRelief: Xr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
                    debug: Xr("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
                    depth: Xr(dn, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
                    fill: Xr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
                    fillOutline: Xr(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
                    fillOutlinePattern: Xr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
                    fillPattern: Xr(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
                    fillExtrusion: Xr(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
                    fillExtrusionPattern: Xr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
                    hillshadePrepare: Xr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
                    hillshade: Xr(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
                    line: Xr(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
                    lineGradient: Xr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
                    linePattern: Xr(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
                    lineSDF: Xr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`),
                    raster: Xr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
                    symbolIcon: Xr(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
                    symbolSDF: Xr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
                    symbolTextAndIcon: Xr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
                    terrain: Xr("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
                    terrainDepth: Xr("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
                    terrainCoords: Xr("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
                    projectionErrorMeasurement: Xr("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
                    atmosphere: Xr(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
                    sky: Xr("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
                };
                function Xr(v, r) {
                    const a = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g
                      , m = r.match(/in ([\w]+) ([\w]+)/g)
                      , y = v.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g)
                      , x = r.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g)
                      , P = x ? x.concat(y) : y
                      , I = {};
                    return {
                        fragmentSource: v = v.replace(a, (A, B, $, Z, H) => (I[H] = !0,
                        B === "define" ? `
#ifndef HAS_UNIFORM_u_${H}
in ${$} ${Z} ${H};
#else
uniform ${$} ${Z} u_${H};
#endif
` : `
#ifdef HAS_UNIFORM_u_${H}
    ${$} ${Z} ${H} = u_${H};
#endif
`)),
                        vertexSource: r = r.replace(a, (A, B, $, Z, H) => {
                            const Y = Z === "float" ? "vec2" : "vec4"
                              , ae = H.match(/color/) ? "color" : Y;
                            return I[H] ? B === "define" ? `
#ifndef HAS_UNIFORM_u_${H}
uniform lowp float u_${H}_t;
in ${$} ${Y} a_${H};
out ${$} ${Z} ${H};
#else
uniform ${$} ${Z} u_${H};
#endif
` : ae === "vec4" ? `
#ifndef HAS_UNIFORM_u_${H}
    ${H} = a_${H};
#else
    ${$} ${Z} ${H} = u_${H};
#endif
` : `
#ifndef HAS_UNIFORM_u_${H}
    ${H} = unpack_mix_${ae}(a_${H}, u_${H}_t);
#else
    ${$} ${Z} ${H} = u_${H};
#endif
` : B === "define" ? `
#ifndef HAS_UNIFORM_u_${H}
uniform lowp float u_${H}_t;
in ${$} ${Y} a_${H};
#else
uniform ${$} ${Z} u_${H};
#endif
` : ae === "vec4" ? `
#ifndef HAS_UNIFORM_u_${H}
    ${$} ${Z} ${H} = a_${H};
#else
    ${$} ${Z} ${H} = u_${H};
#endif
` : `
#ifndef HAS_UNIFORM_u_${H}
    ${$} ${Z} ${H} = unpack_mix_${ae}(a_${H}, u_${H}_t);
#else
    ${$} ${Z} ${H} = u_${H};
#endif
`
                        }
                        ),
                        staticAttributes: m,
                        staticUniforms: P
                    }
                }
                class Ss {
                    constructor(r, a, m) {
                        this.vertexBuffer = r,
                        this.indexBuffer = a,
                        this.segments = m
                    }
                    destroy() {
                        this.vertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.segments.destroy(),
                        this.vertexBuffer = null,
                        this.indexBuffer = null,
                        this.segments = null
                    }
                }
                var Ns = o.aI([{
                    name: "a_pos",
                    type: "Int16",
                    components: 2
                }]);
                const Da = "#define PROJECTION_MERCATOR"
                  , ch = "mercator";
                class au {
                    constructor() {
                        this._cachedMesh = null
                    }
                    get name() {
                        return "mercator"
                    }
                    get useSubdivision() {
                        return !1
                    }
                    get shaderVariantName() {
                        return ch
                    }
                    get shaderDefine() {
                        return Da
                    }
                    get shaderPreludeCode() {
                        return ws.projectionMercator
                    }
                    get vertexShaderPreludeCode() {
                        return ws.projectionMercator.vertexSource
                    }
                    get subdivisionGranularity() {
                        return o.aJ.noSubdivision
                    }
                    get useGlobeControls() {
                        return !1
                    }
                    get transitionState() {
                        return 0
                    }
                    get latitudeErrorCorrectionRadians() {
                        return 0
                    }
                    destroy() {}
                    updateGPUdependent(r) {}
                    getMeshFromTileID(r, a, m, y, x) {
                        if (this._cachedMesh)
                            return this._cachedMesh;
                        const P = new o.aK;
                        P.emplaceBack(0, 0),
                        P.emplaceBack(o.$, 0),
                        P.emplaceBack(0, o.$),
                        P.emplaceBack(o.$, o.$);
                        const I = r.createVertexBuffer(P, Ns.members)
                          , A = o.aL.simpleSegment(0, 0, 4, 2)
                          , B = new o.aM;
                        B.emplaceBack(1, 0, 2),
                        B.emplaceBack(1, 2, 3);
                        const $ = r.createIndexBuffer(B);
                        return this._cachedMesh = new Ss(I,$,A),
                        this._cachedMesh
                    }
                    recalculate() {}
                    hasTransition() {
                        return !1
                    }
                    setErrorQueryLatitudeDegrees(r) {}
                }
                class po {
                    constructor(r=0, a=0, m=0, y=0) {
                        if (isNaN(r) || r < 0 || isNaN(a) || a < 0 || isNaN(m) || m < 0 || isNaN(y) || y < 0)
                            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                        this.top = r,
                        this.bottom = a,
                        this.left = m,
                        this.right = y
                    }
                    interpolate(r, a, m) {
                        return a.top != null && r.top != null && (this.top = o.C.number(r.top, a.top, m)),
                        a.bottom != null && r.bottom != null && (this.bottom = o.C.number(r.bottom, a.bottom, m)),
                        a.left != null && r.left != null && (this.left = o.C.number(r.left, a.left, m)),
                        a.right != null && r.right != null && (this.right = o.C.number(r.right, a.right, m)),
                        this
                    }
                    getCenter(r, a) {
                        const m = o.ag((this.left + r - this.right) / 2, 0, r)
                          , y = o.ag((this.top + a - this.bottom) / 2, 0, a);
                        return new o.P(m,y)
                    }
                    equals(r) {
                        return this.top === r.top && this.bottom === r.bottom && this.left === r.left && this.right === r.right
                    }
                    clone() {
                        return new po(this.top,this.bottom,this.left,this.right)
                    }
                    toJSON() {
                        return {
                            top: this.top,
                            bottom: this.bottom,
                            left: this.left,
                            right: this.right
                        }
                    }
                }
                function Qi(v, r) {
                    if (!v.renderWorldCopies || v.lngRange)
                        return;
                    const a = r.lng - v.center.lng;
                    r.lng += a > 180 ? -360 : a < -180 ? 360 : 0
                }
                function Br(v) {
                    return Math.max(0, Math.floor(v))
                }
                class cs {
                    constructor(r, a, m, y, x, P) {
                        this._callbacks = r,
                        this._tileSize = 512,
                        this._renderWorldCopies = P === void 0 || !!P,
                        this._minZoom = a || 0,
                        this._maxZoom = m || 22,
                        this._minPitch = y ?? 0,
                        this._maxPitch = x ?? 60,
                        this.setMaxBounds(),
                        this._width = 0,
                        this._height = 0,
                        this._center = new o.S(0,0),
                        this._elevation = 0,
                        this._zoom = 0,
                        this._tileZoom = Br(this._zoom),
                        this._scale = o.ae(this._zoom),
                        this._bearingInRadians = 0,
                        this._fovInRadians = .6435011087932844,
                        this._pitchInRadians = 0,
                        this._rollInRadians = 0,
                        this._unmodified = !0,
                        this._edgeInsets = new po,
                        this._minElevationForCurrentTile = 0,
                        this._autoCalculateNearFarZ = !0
                    }
                    apply(r, a, m) {
                        this._latRange = r.latRange,
                        this._lngRange = r.lngRange,
                        this._width = r.width,
                        this._height = r.height,
                        this._center = r.center,
                        this._elevation = r.elevation,
                        this._minElevationForCurrentTile = r.minElevationForCurrentTile,
                        this._zoom = r.zoom,
                        this._tileZoom = Br(this._zoom),
                        this._scale = o.ae(this._zoom),
                        this._bearingInRadians = r.bearingInRadians,
                        this._fovInRadians = r.fovInRadians,
                        this._pitchInRadians = r.pitchInRadians,
                        this._rollInRadians = r.rollInRadians,
                        this._unmodified = r.unmodified,
                        this._edgeInsets = new po(r.padding.top,r.padding.bottom,r.padding.left,r.padding.right),
                        this._minZoom = r.minZoom,
                        this._maxZoom = r.maxZoom,
                        this._minPitch = r.minPitch,
                        this._maxPitch = r.maxPitch,
                        this._renderWorldCopies = r.renderWorldCopies,
                        this._cameraToCenterDistance = r.cameraToCenterDistance,
                        this._nearZ = r.nearZ,
                        this._farZ = r.farZ,
                        this._autoCalculateNearFarZ = !m && r.autoCalculateNearFarZ,
                        a && this._constrain(),
                        this._calcMatrices()
                    }
                    get pixelsToClipSpaceMatrix() {
                        return this._pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._clipSpaceToPixelsMatrix
                    }
                    get minElevationForCurrentTile() {
                        return this._minElevationForCurrentTile
                    }
                    setMinElevationForCurrentTile(r) {
                        this._minElevationForCurrentTile = r
                    }
                    get tileSize() {
                        return this._tileSize
                    }
                    get tileZoom() {
                        return this._tileZoom
                    }
                    get scale() {
                        return this._scale
                    }
                    get width() {
                        return this._width
                    }
                    get height() {
                        return this._height
                    }
                    get bearingInRadians() {
                        return this._bearingInRadians
                    }
                    get lngRange() {
                        return this._lngRange
                    }
                    get latRange() {
                        return this._latRange
                    }
                    get pixelsToGLUnits() {
                        return this._pixelsToGLUnits
                    }
                    get minZoom() {
                        return this._minZoom
                    }
                    setMinZoom(r) {
                        this._minZoom !== r && (this._minZoom = r,
                        this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
                    }
                    get maxZoom() {
                        return this._maxZoom
                    }
                    setMaxZoom(r) {
                        this._maxZoom !== r && (this._maxZoom = r,
                        this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
                    }
                    get minPitch() {
                        return this._minPitch
                    }
                    setMinPitch(r) {
                        this._minPitch !== r && (this._minPitch = r,
                        this.setPitch(Math.max(this.pitch, r)))
                    }
                    get maxPitch() {
                        return this._maxPitch
                    }
                    setMaxPitch(r) {
                        this._maxPitch !== r && (this._maxPitch = r,
                        this.setPitch(Math.min(this.pitch, r)))
                    }
                    get renderWorldCopies() {
                        return this._renderWorldCopies
                    }
                    setRenderWorldCopies(r) {
                        r === void 0 ? r = !0 : r === null && (r = !1),
                        this._renderWorldCopies = r
                    }
                    get worldSize() {
                        return this._tileSize * this._scale
                    }
                    get centerOffset() {
                        return this.centerPoint._sub(this.size._div(2))
                    }
                    get size() {
                        return new o.P(this._width,this._height)
                    }
                    get bearing() {
                        return this._bearingInRadians / Math.PI * 180
                    }
                    setBearing(r) {
                        const a = o.aN(r, -180, 180) * Math.PI / 180;
                        var m, y, x, P, I, A, B, $, Z;
                        this._bearingInRadians !== a && (this._unmodified = !1,
                        this._bearingInRadians = a,
                        this._calcMatrices(),
                        this._rotationMatrix = T(),
                        m = this._rotationMatrix,
                        x = -this._bearingInRadians,
                        P = (y = this._rotationMatrix)[0],
                        I = y[1],
                        A = y[2],
                        B = y[3],
                        $ = Math.sin(x),
                        Z = Math.cos(x),
                        m[0] = P * Z + A * $,
                        m[1] = I * Z + B * $,
                        m[2] = P * -$ + A * Z,
                        m[3] = I * -$ + B * Z)
                    }
                    get rotationMatrix() {
                        return this._rotationMatrix
                    }
                    get pitchInRadians() {
                        return this._pitchInRadians
                    }
                    get pitch() {
                        return this._pitchInRadians / Math.PI * 180
                    }
                    setPitch(r) {
                        const a = o.ag(r, this.minPitch, this.maxPitch) / 180 * Math.PI;
                        this._pitchInRadians !== a && (this._unmodified = !1,
                        this._pitchInRadians = a,
                        this._calcMatrices())
                    }
                    get rollInRadians() {
                        return this._rollInRadians
                    }
                    get roll() {
                        return this._rollInRadians / Math.PI * 180
                    }
                    setRoll(r) {
                        const a = r / 180 * Math.PI;
                        this._rollInRadians !== a && (this._unmodified = !1,
                        this._rollInRadians = a,
                        this._calcMatrices())
                    }
                    get fovInRadians() {
                        return this._fovInRadians
                    }
                    get fov() {
                        return o.aO(this._fovInRadians)
                    }
                    setFov(r) {
                        r = o.ag(r, .1, 150),
                        this.fov !== r && (this._unmodified = !1,
                        this._fovInRadians = o.ad(r),
                        this._calcMatrices())
                    }
                    get zoom() {
                        return this._zoom
                    }
                    setZoom(r) {
                        const a = this.getConstrained(this._center, r).zoom;
                        this._zoom !== a && (this._unmodified = !1,
                        this._zoom = a,
                        this._tileZoom = Math.max(0, Math.floor(a)),
                        this._scale = o.ae(a),
                        this._constrain(),
                        this._calcMatrices())
                    }
                    get center() {
                        return this._center
                    }
                    setCenter(r) {
                        r.lat === this._center.lat && r.lng === this._center.lng || (this._unmodified = !1,
                        this._center = r,
                        this._constrain(),
                        this._calcMatrices())
                    }
                    get elevation() {
                        return this._elevation
                    }
                    setElevation(r) {
                        r !== this._elevation && (this._elevation = r,
                        this._constrain(),
                        this._calcMatrices())
                    }
                    get padding() {
                        return this._edgeInsets.toJSON()
                    }
                    setPadding(r) {
                        this._edgeInsets.equals(r) || (this._unmodified = !1,
                        this._edgeInsets.interpolate(this._edgeInsets, r, 1),
                        this._calcMatrices())
                    }
                    get centerPoint() {
                        return this._edgeInsets.getCenter(this._width, this._height)
                    }
                    get pixelsPerMeter() {
                        return this._pixelPerMeter
                    }
                    get unmodified() {
                        return this._unmodified
                    }
                    get cameraToCenterDistance() {
                        return this._cameraToCenterDistance
                    }
                    get nearZ() {
                        return this._nearZ
                    }
                    get farZ() {
                        return this._farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._autoCalculateNearFarZ
                    }
                    overrideNearFarZ(r, a) {
                        this._autoCalculateNearFarZ = !1,
                        this._nearZ = r,
                        this._farZ = a,
                        this._calcMatrices()
                    }
                    clearNearFarZOverride() {
                        this._autoCalculateNearFarZ = !0,
                        this._calcMatrices()
                    }
                    isPaddingEqual(r) {
                        return this._edgeInsets.equals(r)
                    }
                    interpolatePadding(r, a, m) {
                        this._unmodified = !1,
                        this._edgeInsets.interpolate(r, a, m),
                        this._constrain(),
                        this._calcMatrices()
                    }
                    resize(r, a, m=!0) {
                        this._width = r,
                        this._height = a,
                        m && this._constrain(),
                        this._calcMatrices()
                    }
                    getMaxBounds() {
                        return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new ur([this._lngRange[0], this._latRange[0]],[this._lngRange[1], this._latRange[1]]) : null
                    }
                    setMaxBounds(r) {
                        r ? (this._lngRange = [r.getWest(), r.getEast()],
                        this._latRange = [r.getSouth(), r.getNorth()],
                        this._constrain()) : (this._lngRange = null,
                        this._latRange = [-o.ah, o.ah])
                    }
                    getConstrained(r, a) {
                        return this._callbacks.getConstrained(r, a)
                    }
                    getCameraQueryGeometry(r, a) {
                        if (a.length === 1)
                            return [a[0], r];
                        {
                            const {minX: m, minY: y, maxX: x, maxY: P} = o.a1.fromPoints(a).extend(r);
                            return [new o.P(m,y), new o.P(x,y), new o.P(x,P), new o.P(m,P), new o.P(m,y)]
                        }
                    }
                    _constrain() {
                        if (!this.center || !this._width || !this._height || this._constraining)
                            return;
                        this._constraining = !0;
                        const r = this._unmodified
                          , {center: a, zoom: m} = this.getConstrained(this.center, this.zoom);
                        this.setCenter(a),
                        this.setZoom(m),
                        this._unmodified = r,
                        this._constraining = !1
                    }
                    _calcMatrices() {
                        if (this._width && this._height) {
                            this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
                            let r = o.af(new Float64Array(16));
                            o.N(r, r, [this._width / 2, -this._height / 2, 1]),
                            o.M(r, r, [1, -1, 0]),
                            this._clipSpaceToPixelsMatrix = r,
                            r = o.af(new Float64Array(16)),
                            o.N(r, r, [1, -1, 1]),
                            o.M(r, r, [-1, -1, 0]),
                            o.N(r, r, [2 / this._width, 2 / this._height, 1]),
                            this._pixelsToClipSpaceMatrix = r,
                            this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
                        }
                        this._callbacks.calcMatrices()
                    }
                    calculateCenterFromCameraLngLatAlt(r, a, m, y) {
                        const x = m !== void 0 ? m : this.bearing
                          , P = y = y !== void 0 ? y : this.pitch
                          , I = o.a0.fromLngLat(r, a)
                          , A = -Math.cos(o.ad(P))
                          , B = Math.sin(o.ad(P))
                          , $ = B * Math.sin(o.ad(x))
                          , Z = -B * Math.cos(o.ad(x));
                        let H = this.elevation;
                        const Y = a - H;
                        let ae;
                        A * Y >= 0 || Math.abs(A) < .1 ? (ae = 1e4,
                        H = a + ae * A) : ae = -Y / A;
                        let ye, Se, Te = o.aP(1, I.y), Re = 0;
                        do {
                            if (Re += 1,
                            Re > 10)
                                break;
                            Se = ae / Te,
                            ye = new o.a0(I.x + $ * Se,I.y + Z * Se),
                            Te = 1 / ye.meterInMercatorCoordinateUnits()
                        } while (Math.abs(ae - Se * Te) > 1e-12);
                        return {
                            center: ye.toLngLat(),
                            elevation: H,
                            zoom: o.aj(this.height / 2 / Math.tan(this.fovInRadians / 2) / Se / this.tileSize)
                        }
                    }
                    recalculateZoomAndCenter(r) {
                        if (this.elevation - r == 0)
                            return;
                        const a = o.ai(1, this.center.lat) * this.worldSize
                          , m = this.cameraToCenterDistance / a
                          , y = o.a0.fromLngLat(this.center, this.elevation)
                          , x = Me(this.center, this.elevation, this.pitch, this.bearing, m);
                        this._elevation = r;
                        const P = this.calculateCenterFromCameraLngLatAlt(x.toLngLat(), o.aP(x.z, y.y), this.bearing, this.pitch);
                        this._elevation = P.elevation,
                        this._center = P.center,
                        this.setZoom(P.zoom)
                    }
                    getCameraPoint() {
                        const r = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
                        return this.centerPoint.add(new o.P(r * Math.sin(this.rollInRadians),r * Math.cos(this.rollInRadians)))
                    }
                    getCameraAltitude() {
                        return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
                    }
                    getCameraLngLat() {
                        const r = o.ai(1, this.center.lat) * this.worldSize;
                        return Me(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / r).toLngLat()
                    }
                    getMercatorTileCoordinates(r) {
                        if (!r)
                            return [0, 0, 1, 1];
                        const a = r.canonical.z >= 0 ? 1 << r.canonical.z : Math.pow(2, r.canonical.z);
                        return [r.canonical.x / a, r.canonical.y / a, 1 / a / o.$, 1 / a / o.$]
                    }
                }
                class La {
                    constructor(r, a) {
                        this.min = r,
                        this.max = a,
                        this.center = o.aQ([], o.aR([], this.min, this.max), .5)
                    }
                    quadrant(r) {
                        const a = [r % 2 == 0, r < 2]
                          , m = o.aS(this.min)
                          , y = o.aS(this.max);
                        for (let x = 0; x < a.length; x++)
                            m[x] = a[x] ? this.min[x] : this.center[x],
                            y[x] = a[x] ? this.center[x] : this.max[x];
                        return y[2] = this.max[2],
                        new La(m,y)
                    }
                    distanceX(r) {
                        return Math.max(Math.min(this.max[0], r[0]), this.min[0]) - r[0]
                    }
                    distanceY(r) {
                        return Math.max(Math.min(this.max[1], r[1]), this.min[1]) - r[1]
                    }
                    intersectsFrustum(r) {
                        let a = !0;
                        for (let m = 0; m < r.planes.length; m++) {
                            const y = this.intersectsPlane(r.planes[m]);
                            if (y === 0)
                                return 0;
                            y === 1 && (a = !1)
                        }
                        return a ? 2 : r.aabb.min[0] > this.max[0] || r.aabb.min[1] > this.max[1] || r.aabb.min[2] > this.max[2] || r.aabb.max[0] < this.min[0] || r.aabb.max[1] < this.min[1] || r.aabb.max[2] < this.min[2] ? 0 : 1
                    }
                    intersectsPlane(r) {
                        let a = r[3]
                          , m = r[3];
                        for (let y = 0; y < 3; y++)
                            r[y] > 0 ? (a += r[y] * this.min[y],
                            m += r[y] * this.max[y]) : (m += r[y] * this.min[y],
                            a += r[y] * this.max[y]);
                        return a >= 0 ? 2 : m < 0 ? 0 : 1
                    }
                }
                class wl {
                    distanceToTile2d(r, a, m, y) {
                        const x = y.distanceX([r, a])
                          , P = y.distanceY([r, a]);
                        return Math.hypot(x, P)
                    }
                    getWrap(r, a, m) {
                        return m
                    }
                    getTileBoundingVolume(r, a, m, y) {
                        var x, P;
                        let I = m
                          , A = m;
                        if (y?.terrain) {
                            const $ = new o.Z(r.z,a,r.z,r.x,r.y)
                              , Z = y.terrain.getMinMaxElevation($);
                            I = (x = Z.minElevation) !== null && x !== void 0 ? x : m,
                            A = (P = Z.maxElevation) !== null && P !== void 0 ? P : m
                        }
                        const B = 1 << r.z;
                        return new La([a + r.x / B, r.y / B, I],[a + (r.x + 1) / B, (r.y + 1) / B, A])
                    }
                    allowVariableZoom(r, a) {
                        const m = r.fov * (Math.abs(Math.cos(r.rollInRadians)) * r.height + Math.abs(Math.sin(r.rollInRadians)) * r.width) / r.height
                          , y = o.ag(78.5 - m / 2, 0, 60);
                        return !!a.terrain || r.pitch > y
                    }
                    allowWorldCopies() {
                        return !0
                    }
                    prepareNextFrame() {}
                }
                class ei {
                    constructor(r, a, m) {
                        this.points = r,
                        this.planes = a,
                        this.aabb = m
                    }
                    static fromInvProjectionMatrix(r, a=1, m=0, y, x) {
                        const P = x ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]]
                          , I = Math.pow(2, m)
                          , A = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(H => function(Y, ae, ye, Se) {
                            const Te = o.av([], Y, ae)
                              , Re = 1 / Te[3] / ye * Se;
                            return o.aX(Te, Te, [Re, Re, 1 / Te[3], Re])
                        }(H, r, a, I));
                        y && function(H, Y, ae, ye) {
                            const Se = ye ? 4 : 0
                              , Te = ye ? 0 : 4;
                            let Re = 0;
                            const De = []
                              , Ae = [];
                            for (let ze = 0; ze < 4; ze++) {
                                const Ke = o.aT([], H[ze + Te], H[ze + Se])
                                  , ht = o.aY(Ke);
                                o.aQ(Ke, Ke, 1 / ht),
                                De.push(ht),
                                Ae.push(Ke)
                            }
                            for (let ze = 0; ze < 4; ze++) {
                                const Ke = o.aZ(H[ze + Se], Ae[ze], ae);
                                Re = Ke !== null && Ke >= 0 ? Math.max(Re, Ke) : Math.max(Re, De[ze])
                            }
                            const Be = function(ze, Ke) {
                                const ht = o.aT([], ze[Ke[0]], ze[Ke[1]])
                                  , ot = o.aT([], ze[Ke[2]], ze[Ke[1]])
                                  , ut = [0, 0, 0, 0];
                                return o.aU(ut, o.aV([], ht, ot)),
                                ut[3] = -o.aW(ut, ze[Ke[0]]),
                                ut
                            }(H, Y)
                              , qe = function(ze, Ke) {
                                const ht = o.a_(ze)
                                  , ot = o.a$([], ze, 1 / ht)
                                  , ut = o.aT([], Ke, o.aQ([], ot, o.aW(Ke, ot)))
                                  , mt = o.a_(ut);
                                if (mt > 0) {
                                    const $t = Math.sqrt(1 - ot[3] * ot[3])
                                      , jt = o.aQ([], ot, -ot[3])
                                      , It = o.aR([], jt, o.aQ([], ut, $t / mt));
                                    return o.b0(Ke, It)
                                }
                                return null
                            }(ae, Be);
                            if (qe !== null) {
                                const ze = qe / o.aW(Ae[0], Be);
                                Re = Math.min(Re, ze)
                            }
                            for (let ze = 0; ze < 4; ze++) {
                                const Ke = Math.min(Re, De[ze]);
                                H[ze + Te] = [H[ze + Se][0] + Ae[ze][0] * Ke, H[ze + Se][1] + Ae[ze][1] * Ke, H[ze + Se][2] + Ae[ze][2] * Ke, 1]
                            }
                        }(A, P[0], y, x);
                        const B = P.map(H => {
                            const Y = o.aT([], A[H[0]], A[H[1]])
                              , ae = o.aT([], A[H[2]], A[H[1]])
                              , ye = o.aU([], o.aV([], Y, ae))
                              , Se = -o.aW(ye, A[H[1]]);
                            return ye.concat(Se)
                        }
                        )
                          , $ = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
                          , Z = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
                        for (const H of A)
                            for (let Y = 0; Y < 3; Y++)
                                $[Y] = Math.min($[Y], H[Y]),
                                Z[Y] = Math.max(Z[Y], H[Y]);
                        return new ei(A,B,new La($,Z))
                    }
                }
                class mi {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits
                    }
                    get centerOffset() {
                        return this._helper.centerOffset
                    }
                    get size() {
                        return this._helper.size
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix
                    }
                    get centerPoint() {
                        return this._helper.centerPoint
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter
                    }
                    setMinZoom(r) {
                        this._helper.setMinZoom(r)
                    }
                    setMaxZoom(r) {
                        this._helper.setMaxZoom(r)
                    }
                    setMinPitch(r) {
                        this._helper.setMinPitch(r)
                    }
                    setMaxPitch(r) {
                        this._helper.setMaxPitch(r)
                    }
                    setRenderWorldCopies(r) {
                        this._helper.setRenderWorldCopies(r)
                    }
                    setBearing(r) {
                        this._helper.setBearing(r)
                    }
                    setPitch(r) {
                        this._helper.setPitch(r)
                    }
                    setRoll(r) {
                        this._helper.setRoll(r)
                    }
                    setFov(r) {
                        this._helper.setFov(r)
                    }
                    setZoom(r) {
                        this._helper.setZoom(r)
                    }
                    setCenter(r) {
                        this._helper.setCenter(r)
                    }
                    setElevation(r) {
                        this._helper.setElevation(r)
                    }
                    setMinElevationForCurrentTile(r) {
                        this._helper.setMinElevationForCurrentTile(r)
                    }
                    setPadding(r) {
                        this._helper.setPadding(r)
                    }
                    interpolatePadding(r, a, m) {
                        return this._helper.interpolatePadding(r, a, m)
                    }
                    isPaddingEqual(r) {
                        return this._helper.isPaddingEqual(r)
                    }
                    resize(r, a, m=!0) {
                        this._helper.resize(r, a, m)
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds()
                    }
                    setMaxBounds(r) {
                        this._helper.setMaxBounds(r)
                    }
                    overrideNearFarZ(r, a) {
                        this._helper.overrideNearFarZ(r, a)
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride()
                    }
                    getCameraQueryGeometry(r) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), r)
                    }
                    get tileSize() {
                        return this._helper.tileSize
                    }
                    get tileZoom() {
                        return this._helper.tileZoom
                    }
                    get scale() {
                        return this._helper.scale
                    }
                    get worldSize() {
                        return this._helper.worldSize
                    }
                    get width() {
                        return this._helper.width
                    }
                    get height() {
                        return this._helper.height
                    }
                    get lngRange() {
                        return this._helper.lngRange
                    }
                    get latRange() {
                        return this._helper.latRange
                    }
                    get minZoom() {
                        return this._helper.minZoom
                    }
                    get maxZoom() {
                        return this._helper.maxZoom
                    }
                    get zoom() {
                        return this._helper.zoom
                    }
                    get center() {
                        return this._helper.center
                    }
                    get minPitch() {
                        return this._helper.minPitch
                    }
                    get maxPitch() {
                        return this._helper.maxPitch
                    }
                    get pitch() {
                        return this._helper.pitch
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians
                    }
                    get roll() {
                        return this._helper.roll
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians
                    }
                    get bearing() {
                        return this._helper.bearing
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians
                    }
                    get fov() {
                        return this._helper.fov
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians
                    }
                    get elevation() {
                        return this._helper.elevation
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile
                    }
                    get padding() {
                        return this._helper.padding
                    }
                    get unmodified() {
                        return this._helper.unmodified
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance
                    }
                    get nearZ() {
                        return this._helper.nearZ
                    }
                    get farZ() {
                        return this._helper.farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ
                    }
                    setTransitionState(r, a) {}
                    constructor(r, a, m, y, x) {
                        this._posMatrixCache = new Map,
                        this._alignedPosMatrixCache = new Map,
                        this._fogMatrixCacheF32 = new Map,
                        this._helper = new cs({
                            calcMatrices: () => {
                                this._calcMatrices()
                            }
                            ,
                            getConstrained: (P, I) => this.getConstrained(P, I)
                        },r,a,m,y,x),
                        this._coveringTilesDetailsProvider = new wl
                    }
                    clone() {
                        const r = new mi;
                        return r.apply(this),
                        r
                    }
                    apply(r, a, m) {
                        this._helper.apply(r, a, m)
                    }
                    get cameraPosition() {
                        return this._cameraPosition
                    }
                    get projectionMatrix() {
                        return this._projectionMatrix
                    }
                    get modelViewProjectionMatrix() {
                        return this._viewProjMatrix
                    }
                    get inverseProjectionMatrix() {
                        return this._invProjMatrix
                    }
                    get mercatorMatrix() {
                        return this._mercatorMatrix
                    }
                    getVisibleUnwrappedCoordinates(r) {
                        const a = [new o.b1(0,r)];
                        if (this._helper._renderWorldCopies) {
                            const m = this.screenPointToMercatorCoordinate(new o.P(0,0))
                              , y = this.screenPointToMercatorCoordinate(new o.P(this._helper._width,0))
                              , x = this.screenPointToMercatorCoordinate(new o.P(this._helper._width,this._helper._height))
                              , P = this.screenPointToMercatorCoordinate(new o.P(0,this._helper._height))
                              , I = Math.floor(Math.min(m.x, y.x, x.x, P.x))
                              , A = Math.floor(Math.max(m.x, y.x, x.x, P.x))
                              , B = 1;
                            for (let $ = I - B; $ <= A + B; $++)
                                $ !== 0 && a.push(new o.b1($,r))
                        }
                        return a
                    }
                    getCameraFrustum() {
                        return ei.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
                    }
                    getClippingPlane() {
                        return null
                    }
                    getCoveringTilesDetailsProvider() {
                        return this._coveringTilesDetailsProvider
                    }
                    recalculateZoomAndCenter(r) {
                        const a = this.screenPointToLocation(this.centerPoint, r)
                          , m = r ? r.getElevationForLngLatZoom(a, this._helper._tileZoom) : 0;
                        this._helper.recalculateZoomAndCenter(m)
                    }
                    setLocationAtPoint(r, a) {
                        const m = o.ai(this.elevation, this.center.lat)
                          , y = this.screenPointToMercatorCoordinateAtZ(a, m)
                          , x = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, m)
                          , P = o.a0.fromLngLat(r)
                          , I = new o.a0(P.x - (y.x - x.x),P.y - (y.y - x.y));
                        this.setCenter(I?.toLngLat()),
                        this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
                    }
                    locationToScreenPoint(r, a) {
                        return a ? this.coordinatePoint(o.a0.fromLngLat(r), a.getElevationForLngLatZoom(r, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(o.a0.fromLngLat(r))
                    }
                    screenPointToLocation(r, a) {
                        var m;
                        return (m = this.screenPointToMercatorCoordinate(r, a)) === null || m === void 0 ? void 0 : m.toLngLat()
                    }
                    screenPointToMercatorCoordinate(r, a) {
                        if (a) {
                            const m = a.pointCoordinate(r);
                            if (m != null)
                                return m
                        }
                        return this.screenPointToMercatorCoordinateAtZ(r)
                    }
                    screenPointToMercatorCoordinateAtZ(r, a) {
                        const m = a || 0
                          , y = [r.x, r.y, 0, 1]
                          , x = [r.x, r.y, 1, 1];
                        o.av(y, y, this._pixelMatrixInverse),
                        o.av(x, x, this._pixelMatrixInverse);
                        const P = y[3]
                          , I = x[3]
                          , A = y[1] / P
                          , B = x[1] / I
                          , $ = y[2] / P
                          , Z = x[2] / I
                          , H = $ === Z ? 0 : (m - $) / (Z - $);
                        return new o.a0(o.C.number(y[0] / P, x[0] / I, H) / this.worldSize,o.C.number(A, B, H) / this.worldSize,m)
                    }
                    coordinatePoint(r, a=0, m=this._pixelMatrix) {
                        const y = [r.x * this.worldSize, r.y * this.worldSize, a, 1];
                        return o.av(y, y, m),
                        new o.P(y[0] / y[3],y[1] / y[3])
                    }
                    getBounds() {
                        const r = Math.max(0, this._helper._height / 2 - fe(this));
                        return new ur().extend(this.screenPointToLocation(new o.P(0,r))).extend(this.screenPointToLocation(new o.P(this._helper._width,r))).extend(this.screenPointToLocation(new o.P(this._helper._width,this._helper._height))).extend(this.screenPointToLocation(new o.P(0,this._helper._height)))
                    }
                    isPointOnMapSurface(r, a) {
                        return a ? a.pointCoordinate(r) != null : r.y > this.height / 2 - fe(this)
                    }
                    calculatePosMatrix(r, a=!1, m) {
                        var y;
                        const x = (y = r.key) !== null && y !== void 0 ? y : o.b2(r.wrap, r.canonical.z, r.canonical.z, r.canonical.x, r.canonical.y)
                          , P = a ? this._alignedPosMatrixCache : this._posMatrixCache;
                        if (P.has(x)) {
                            const B = P.get(x);
                            return m ? B.f32 : B.f64
                        }
                        const I = ge(r, this.worldSize);
                        o.O(I, a ? this._alignedProjMatrix : this._viewProjMatrix, I);
                        const A = {
                            f64: I,
                            f32: new Float32Array(I)
                        };
                        return P.set(x, A),
                        m ? A.f32 : A.f64
                    }
                    calculateFogMatrix(r) {
                        const a = r.key
                          , m = this._fogMatrixCacheF32;
                        if (m.has(a))
                            return m.get(a);
                        const y = ge(r, this.worldSize);
                        return o.O(y, this._fogMatrix, y),
                        m.set(a, new Float32Array(y)),
                        m.get(a)
                    }
                    getConstrained(r, a) {
                        a = o.ag(+a, this.minZoom, this.maxZoom);
                        const m = {
                            center: new o.S(r.lng,r.lat),
                            zoom: a
                        };
                        let y = this._helper._lngRange;
                        if (!this._helper._renderWorldCopies && y === null) {
                            const De = 179.9999999999;
                            y = [-De, De]
                        }
                        const x = this.tileSize * o.ae(m.zoom);
                        let P = 0
                          , I = x
                          , A = 0
                          , B = x
                          , $ = 0
                          , Z = 0;
                        const {x: H, y: Y} = this.size;
                        if (this._helper._latRange) {
                            const De = this._helper._latRange;
                            P = o.U(De[1]) * x,
                            I = o.U(De[0]) * x,
                            I - P < Y && ($ = Y / (I - P))
                        }
                        y && (A = o.aN(o.V(y[0]) * x, 0, x),
                        B = o.aN(o.V(y[1]) * x, 0, x),
                        B < A && (B += x),
                        B - A < H && (Z = H / (B - A)));
                        const {x: ae, y: ye} = Ue(x, r);
                        let Se, Te;
                        const Re = Math.max(Z || 0, $ || 0);
                        if (Re) {
                            const De = new o.P(Z ? (B + A) / 2 : ae,$ ? (I + P) / 2 : ye);
                            return m.center = se(x, De).wrap(),
                            m.zoom += o.aj(Re),
                            m
                        }
                        if (this._helper._latRange) {
                            const De = Y / 2;
                            ye - De < P && (Te = P + De),
                            ye + De > I && (Te = I - De)
                        }
                        if (y) {
                            const De = (A + B) / 2;
                            let Ae = ae;
                            this._helper._renderWorldCopies && (Ae = o.aN(ae, De - x / 2, De + x / 2));
                            const Be = H / 2;
                            Ae - Be < A && (Se = A + Be),
                            Ae + Be > B && (Se = B - Be)
                        }
                        if (Se !== void 0 || Te !== void 0) {
                            const De = new o.P(Se ?? ae,Te ?? ye);
                            m.center = se(x, De).wrap()
                        }
                        return m
                    }
                    calculateCenterFromCameraLngLatAlt(r, a, m, y) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(r, a, m, y)
                    }
                    _calculateNearFarZIfNeeded(r, a, m) {
                        if (!this._helper.autoCalculateNearFarZ)
                            return;
                        const y = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100)
                          , x = r - y * this._helper._pixelPerMeter / Math.cos(a)
                          , P = y < 0 ? x : r
                          , I = Math.PI / 2 + this.pitchInRadians
                          , A = o.ad(this.fov) * (Math.abs(Math.cos(o.ad(this.roll))) * this.height + Math.abs(Math.sin(o.ad(this.roll))) * this.width) / this.height * (.5 + m.y / this.height)
                          , B = Math.sin(A) * P / Math.sin(o.ag(Math.PI - I - A, .01, Math.PI - .01))
                          , $ = fe(this)
                          , Z = Math.atan($ / this._helper.cameraToCenterDistance)
                          , H = o.ad(.75)
                          , Y = Z > H ? 2 * Z * (.5 + m.y / (2 * $)) : H
                          , ae = Math.sin(Y) * P / Math.sin(o.ag(Math.PI - I - Y, .01, Math.PI - .01))
                          , ye = Math.min(B, ae);
                        this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - a) * ye + P),
                        this._helper._nearZ = this._helper._height / 50
                    }
                    _calcMatrices() {
                        if (!this._helper._height)
                            return;
                        const r = this.centerOffset
                          , a = Ue(this.worldSize, this.center)
                          , m = a.x
                          , y = a.y;
                        this._helper._pixelPerMeter = o.ai(1, this.center.lat) * this.worldSize;
                        const x = o.ad(Math.min(this.pitch, Er))
                          , P = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(x));
                        let I;
                        this._calculateNearFarZIfNeeded(P, x, r),
                        I = new Float64Array(16),
                        o.b3(I, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ),
                        this._invProjMatrix = new Float64Array(16),
                        o.ap(this._invProjMatrix, I),
                        I[8] = 2 * -r.x / this._helper._width,
                        I[9] = 2 * r.y / this._helper._height,
                        this._projectionMatrix = o.b4(I),
                        o.N(I, I, [1, -1, 1]),
                        o.M(I, I, [0, 0, -this._helper.cameraToCenterDistance]),
                        o.b5(I, I, -this.rollInRadians),
                        o.b6(I, I, this.pitchInRadians),
                        o.b5(I, I, -this.bearingInRadians),
                        o.M(I, I, [-m, -y, 0]),
                        this._mercatorMatrix = o.N([], I, [this.worldSize, this.worldSize, this.worldSize]),
                        o.N(I, I, [1, 1, this._helper._pixelPerMeter]),
                        this._pixelMatrix = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, I),
                        o.M(I, I, [0, 0, -this.elevation]),
                        this._viewProjMatrix = I,
                        this._invViewProjMatrix = o.ap([], I);
                        const A = [0, 0, -1, 1];
                        o.av(A, A, this._invViewProjMatrix),
                        this._cameraPosition = [A[0] / A[3], A[1] / A[3], A[2] / A[3]],
                        this._fogMatrix = new Float64Array(16),
                        o.b3(this._fogMatrix, this.fovInRadians, this.width / this.height, P, this._helper._farZ),
                        this._fogMatrix[8] = 2 * -r.x / this.width,
                        this._fogMatrix[9] = 2 * r.y / this.height,
                        o.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]),
                        o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]),
                        o.b5(this._fogMatrix, this._fogMatrix, -this.rollInRadians),
                        o.b6(this._fogMatrix, this._fogMatrix, this.pitchInRadians),
                        o.b5(this._fogMatrix, this._fogMatrix, -this.bearingInRadians),
                        o.M(this._fogMatrix, this._fogMatrix, [-m, -y, 0]),
                        o.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]),
                        o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]),
                        this._pixelMatrix3D = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, I);
                        const B = this._helper._width % 2 / 2
                          , $ = this._helper._height % 2 / 2
                          , Z = Math.cos(this.bearingInRadians)
                          , H = Math.sin(-this.bearingInRadians)
                          , Y = m - Math.round(m) + Z * B + H * $
                          , ae = y - Math.round(y) + Z * $ + H * B
                          , ye = new Float64Array(I);
                        if (o.M(ye, ye, [Y > .5 ? Y - 1 : Y, ae > .5 ? ae - 1 : ae, 0]),
                        this._alignedProjMatrix = ye,
                        I = o.ap(new Float64Array(16), this._pixelMatrix),
                        !I)
                            throw new Error("failed to invert matrix");
                        this._pixelMatrixInverse = I,
                        this._clearMatrixCaches()
                    }
                    _clearMatrixCaches() {
                        this._posMatrixCache.clear(),
                        this._alignedPosMatrixCache.clear(),
                        this._fogMatrixCacheF32.clear()
                    }
                    maxPitchScaleFactor() {
                        if (!this._pixelMatrixInverse)
                            return 1;
                        const r = this.screenPointToMercatorCoordinate(new o.P(0,0))
                          , a = [r.x * this.worldSize, r.y * this.worldSize, 0, 1];
                        return o.av(a, a, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint()
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude()
                    }
                    getCameraLngLat() {
                        const r = o.ai(1, this.center.lat) * this.worldSize;
                        return Me(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / r).toLngLat()
                    }
                    lngLatToCameraDepth(r, a) {
                        const m = o.a0.fromLngLat(r)
                          , y = [m.x * this.worldSize, m.y * this.worldSize, a, 1];
                        return o.av(y, y, this._viewProjMatrix),
                        y[2] / y[3]
                    }
                    getProjectionData(r) {
                        const {overscaledTileID: a, aligned: m, applyTerrainMatrix: y} = r
                          , x = this._helper.getMercatorTileCoordinates(a)
                          , P = a ? this.calculatePosMatrix(a, m, !0) : null;
                        let I;
                        return I = a && a.terrainRttPosMatrix32f && y ? a.terrainRttPosMatrix32f : P || o.b7(),
                        {
                            mainMatrix: I,
                            tileMercatorCoords: x,
                            clippingPlane: [0, 0, 0, 0],
                            projectionTransition: 0,
                            fallbackMatrix: I
                        }
                    }
                    isLocationOccluded(r) {
                        return !1
                    }
                    getPixelScale() {
                        return 1
                    }
                    getCircleRadiusCorrection() {
                        return 1
                    }
                    getPitchedTextCorrection(r, a, m) {
                        return 1
                    }
                    transformLightDirection(r) {
                        return o.aS(r)
                    }
                    getRayDirectionFromPixel(r) {
                        throw new Error("Not implemented.")
                    }
                    projectTileCoordinates(r, a, m, y) {
                        const x = this.calculatePosMatrix(m);
                        let P;
                        y ? (P = [r, a, y(r, a), 1],
                        o.av(P, P, x)) : (P = [r, a, 0, 1],
                        ni(P, P, x));
                        const I = P[3];
                        return {
                            point: new o.P(P[0] / I,P[1] / I),
                            signedDistanceFromCamera: I,
                            isOccluded: !1
                        }
                    }
                    populateCache(r) {
                        for (const a of r)
                            this.calculatePosMatrix(a)
                    }
                    getMatrixForModel(r, a) {
                        const m = o.a0.fromLngLat(r, a)
                          , y = m.meterInMercatorCoordinateUnits()
                          , x = o.b8();
                        return o.M(x, x, [m.x, m.y, m.z]),
                        o.b5(x, x, Math.PI),
                        o.b6(x, x, Math.PI / 2),
                        o.N(x, x, [-y, y, y]),
                        x
                    }
                    getProjectionDataForCustomLayer(r=!0) {
                        const a = new o.Z(0,0,0,0,0)
                          , m = this.getProjectionData({
                            overscaledTileID: a,
                            applyGlobeMatrix: r
                        })
                          , y = ge(a, this.worldSize);
                        o.O(y, this._viewProjMatrix, y),
                        m.tileMercatorCoords = [0, 0, 1, 1];
                        const x = [o.$, o.$, this.worldSize / this._helper.pixelsPerMeter]
                          , P = o.b9();
                        return o.N(P, y, x),
                        m.fallbackMatrix = P,
                        m.mainMatrix = P,
                        m
                    }
                    getFastPathSimpleProjectionMatrix(r) {
                        return this.calculatePosMatrix(r)
                    }
                }
                function Ui() {
                    o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
                }
                function ii(v) {
                    if (v.useSlerp)
                        if (v.k < 1) {
                            const r = o.ba(v.startEulerAngles.roll, v.startEulerAngles.pitch, v.startEulerAngles.bearing)
                              , a = o.ba(v.endEulerAngles.roll, v.endEulerAngles.pitch, v.endEulerAngles.bearing)
                              , m = new Float64Array(4);
                            o.bb(m, r, a, v.k);
                            const y = o.bc(m);
                            v.tr.setRoll(y.roll),
                            v.tr.setPitch(y.pitch),
                            v.tr.setBearing(y.bearing)
                        } else
                            v.tr.setRoll(v.endEulerAngles.roll),
                            v.tr.setPitch(v.endEulerAngles.pitch),
                            v.tr.setBearing(v.endEulerAngles.bearing);
                    else
                        v.tr.setRoll(o.C.number(v.startEulerAngles.roll, v.endEulerAngles.roll, v.k)),
                        v.tr.setPitch(o.C.number(v.startEulerAngles.pitch, v.endEulerAngles.pitch, v.k)),
                        v.tr.setBearing(o.C.number(v.startEulerAngles.bearing, v.endEulerAngles.bearing, v.k))
                }
                function Qn(v, r, a, m, y) {
                    const x = y.padding
                      , P = Ue(y.worldSize, a.getNorthWest())
                      , I = Ue(y.worldSize, a.getNorthEast())
                      , A = Ue(y.worldSize, a.getSouthEast())
                      , B = Ue(y.worldSize, a.getSouthWest())
                      , $ = o.ad(-m)
                      , Z = P.rotate($)
                      , H = I.rotate($)
                      , Y = A.rotate($)
                      , ae = B.rotate($)
                      , ye = new o.P(Math.max(Z.x, H.x, ae.x, Y.x),Math.max(Z.y, H.y, ae.y, Y.y))
                      , Se = new o.P(Math.min(Z.x, H.x, ae.x, Y.x),Math.min(Z.y, H.y, ae.y, Y.y))
                      , Te = ye.sub(Se)
                      , Re = (y.width - (x.left + x.right + r.left + r.right)) / Te.x
                      , De = (y.height - (x.top + x.bottom + r.top + r.bottom)) / Te.y;
                    if (De < 0 || Re < 0)
                        return void Ui();
                    const Ae = Math.min(o.aj(y.scale * Math.min(Re, De)), v.maxZoom)
                      , Be = o.P.convert(v.offset)
                      , qe = new o.P((r.left - r.right) / 2,(r.top - r.bottom) / 2).rotate(o.ad(m))
                      , ze = Be.add(qe).mult(y.scale / o.ae(Ae));
                    return {
                        center: se(y.worldSize, P.add(A).div(2).sub(ze)),
                        zoom: Ae,
                        bearing: m
                    }
                }
                class lu {
                    get useGlobeControls() {
                        return !1
                    }
                    handlePanInertia(r, a) {
                        return {
                            easingOffset: r,
                            easingCenter: a.center
                        }
                    }
                    handleMapControlsRollPitchBearingZoom(r, a) {
                        r.bearingDelta && a.setBearing(a.bearing + r.bearingDelta),
                        r.pitchDelta && a.setPitch(a.pitch + r.pitchDelta),
                        r.rollDelta && a.setRoll(a.roll + r.rollDelta),
                        r.zoomDelta && a.setZoom(a.zoom + r.zoomDelta)
                    }
                    handleMapControlsPan(r, a, m) {
                        r.around.distSqr(a.centerPoint) < .01 || a.setLocationAtPoint(m, r.around)
                    }
                    cameraForBoxAndBearing(r, a, m, y, x) {
                        return Qn(r, a, m, y, x)
                    }
                    handleJumpToCenterZoom(r, a) {
                        r.zoom !== (a.zoom !== void 0 ? +a.zoom : r.zoom) && r.setZoom(+a.zoom),
                        a.center !== void 0 && r.setCenter(o.S.convert(a.center))
                    }
                    handleEaseTo(r, a) {
                        const m = r.zoom
                          , y = r.padding
                          , x = {
                            roll: r.roll,
                            pitch: r.pitch,
                            bearing: r.bearing
                        }
                          , P = {
                            roll: a.roll === void 0 ? r.roll : a.roll,
                            pitch: a.pitch === void 0 ? r.pitch : a.pitch,
                            bearing: a.bearing === void 0 ? r.bearing : a.bearing
                        }
                          , I = a.zoom !== void 0
                          , A = !r.isPaddingEqual(a.padding);
                        let B = !1;
                        const $ = I ? +a.zoom : r.zoom;
                        let Z = r.centerPoint.add(a.offsetAsPoint);
                        const H = r.screenPointToLocation(Z)
                          , {center: Y, zoom: ae} = r.getConstrained(o.S.convert(a.center || H), $ ?? m);
                        Qi(r, Y);
                        const ye = Ue(r.worldSize, H)
                          , Se = Ue(r.worldSize, Y).sub(ye)
                          , Te = o.ae(ae - m);
                        return B = ae !== m,
                        {
                            easeFunc: Re => {
                                if (B && r.setZoom(o.C.number(m, ae, Re)),
                                o.bd(x, P) || ii({
                                    startEulerAngles: x,
                                    endEulerAngles: P,
                                    tr: r,
                                    k: Re,
                                    useSlerp: x.roll != P.roll
                                }),
                                A && (r.interpolatePadding(y, a.padding, Re),
                                Z = r.centerPoint.add(a.offsetAsPoint)),
                                a.around)
                                    r.setLocationAtPoint(a.around, a.aroundPoint);
                                else {
                                    const De = o.ae(r.zoom - m)
                                      , Ae = ae > m ? Math.min(2, Te) : Math.max(.5, Te)
                                      , Be = Math.pow(Ae, 1 - Re)
                                      , qe = se(r.worldSize, ye.add(Se.mult(Re * Be)).mult(De));
                                    r.setLocationAtPoint(r.renderWorldCopies ? qe.wrap() : qe, Z)
                                }
                            }
                            ,
                            isZooming: B,
                            elevationCenter: Y
                        }
                    }
                    handleFlyTo(r, a) {
                        const m = a.zoom !== void 0
                          , y = r.zoom
                          , x = r.getConstrained(o.S.convert(a.center || a.locationAtOffset), m ? +a.zoom : y)
                          , P = x.center
                          , I = x.zoom;
                        Qi(r, P);
                        const A = Ue(r.worldSize, a.locationAtOffset)
                          , B = Ue(r.worldSize, P).sub(A)
                          , $ = B.mag()
                          , Z = o.ae(I - y);
                        let H;
                        if (a.minZoom !== void 0) {
                            const Y = Math.min(+a.minZoom, y, I)
                              , ae = r.getConstrained(P, Y).zoom;
                            H = o.ae(ae - y)
                        }
                        return {
                            easeFunc: (Y, ae, ye, Se) => {
                                r.setZoom(Y === 1 ? I : y + o.aj(ae));
                                const Te = Y === 1 ? P : se(r.worldSize, A.add(B.mult(ye)).mult(ae));
                                r.setLocationAtPoint(r.renderWorldCopies ? Te.wrap() : Te, Se)
                            }
                            ,
                            scaleOfZoom: Z,
                            targetCenter: P,
                            scaleOfMinZoom: H,
                            pixelPathLength: $
                        }
                    }
                }
                class Yr {
                    constructor(r, a, m) {
                        this.blendFunction = r,
                        this.blendColor = a,
                        this.mask = m
                    }
                }
                Yr.Replace = [1, 0],
                Yr.disabled = new Yr(Yr.Replace,o.be.transparent,[!1, !1, !1, !1]),
                Yr.unblended = new Yr(Yr.Replace,o.be.transparent,[!0, !0, !0, !0]),
                Yr.alphaBlended = new Yr([1, 771],o.be.transparent,[!0, !0, !0, !0]);
                const mo = 2305;
                class jr {
                    constructor(r, a, m) {
                        this.enable = r,
                        this.mode = a,
                        this.frontFace = m
                    }
                }
                jr.disabled = new jr(!1,1029,mo),
                jr.backCCW = new jr(!0,1029,mo),
                jr.frontCCW = new jr(!0,1028,mo);
                class Fr {
                    constructor(r, a, m) {
                        this.func = r,
                        this.mask = a,
                        this.range = m
                    }
                }
                Fr.ReadOnly = !1,
                Fr.ReadWrite = !0,
                Fr.disabled = new Fr(519,Fr.ReadOnly,[0, 1]);
                const Cs = 7680;
                class Sr {
                    constructor(r, a, m, y, x, P) {
                        this.test = r,
                        this.ref = a,
                        this.mask = m,
                        this.fail = y,
                        this.depthFail = x,
                        this.pass = P
                    }
                }
                Sr.disabled = new Sr({
                    func: 519,
                    mask: 0
                },0,0,Cs,Cs,Cs);
                const $s = new WeakMap;
                function go(v) {
                    var r;
                    if ($s.has(v))
                        return $s.get(v);
                    {
                        const a = (r = v.getParameter(v.VERSION)) === null || r === void 0 ? void 0 : r.startsWith("WebGL 2.0");
                        return $s.set(v, a),
                        a
                    }
                }
                class oc {
                    get awaitingQuery() {
                        return !!this._readbackQueue
                    }
                    constructor(r) {
                        this._readbackWaitFrames = 4,
                        this._measureWaitFrames = 6,
                        this._texWidth = 1,
                        this._texHeight = 1,
                        this._measuredError = 0,
                        this._updateCount = 0,
                        this._lastReadbackFrame = -1e3,
                        this._readbackQueue = null,
                        this._cachedRenderContext = r;
                        const a = r.context
                          , m = a.gl;
                        this._texFormat = m.RGBA,
                        this._texType = m.UNSIGNED_BYTE;
                        const y = new o.aK;
                        y.emplaceBack(-1, -1),
                        y.emplaceBack(2, -1),
                        y.emplaceBack(-1, 2);
                        const x = new o.aM;
                        x.emplaceBack(0, 1, 2),
                        this._fullscreenTriangle = new Ss(a.createVertexBuffer(y, Ns.members),a.createIndexBuffer(x),o.aL.simpleSegment(0, 0, y.length, x.length)),
                        this._resultBuffer = new Uint8Array(4),
                        a.activeTexture.set(m.TEXTURE1);
                        const P = m.createTexture();
                        m.bindTexture(m.TEXTURE_2D, P),
                        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE),
                        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE),
                        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST),
                        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST),
                        m.texImage2D(m.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null),
                        this._fbo = a.createFramebuffer(this._texWidth, this._texHeight, !1, !1),
                        this._fbo.colorAttachment.set(P),
                        go(m) && (this._pbo = m.createBuffer(),
                        m.bindBuffer(m.PIXEL_PACK_BUFFER, this._pbo),
                        m.bufferData(m.PIXEL_PACK_BUFFER, 4, m.STREAM_READ),
                        m.bindBuffer(m.PIXEL_PACK_BUFFER, null))
                    }
                    destroy() {
                        const r = this._cachedRenderContext.context.gl;
                        this._fullscreenTriangle.destroy(),
                        this._fbo.destroy(),
                        r.deleteBuffer(this._pbo),
                        this._fullscreenTriangle = null,
                        this._fbo = null,
                        this._pbo = null,
                        this._resultBuffer = null
                    }
                    updateErrorLoop(r, a) {
                        const m = this._updateCount;
                        return this._readbackQueue ? m >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : m >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(r, a),
                        this._updateCount++,
                        this._measuredError
                    }
                    _bindFramebuffer() {
                        const r = this._cachedRenderContext.context
                          , a = r.gl;
                        r.activeTexture.set(a.TEXTURE1),
                        a.bindTexture(a.TEXTURE_2D, this._fbo.colorAttachment.get()),
                        r.bindFramebuffer.set(this._fbo.framebuffer)
                    }
                    _renderErrorTexture(r, a) {
                        const m = this._cachedRenderContext.context
                          , y = m.gl;
                        if (this._bindFramebuffer(),
                        m.viewport.set([0, 0, this._texWidth, this._texHeight]),
                        m.clear({
                            color: o.be.transparent
                        }),
                        this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(m, y.TRIANGLES, Fr.disabled, Sr.disabled, Yr.unblended, jr.disabled, ( (x, P) => ({
                            u_input: x,
                            u_output_expected: P
                        }))(r, a), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments),
                        this._pbo && go(y)) {
                            y.bindBuffer(y.PIXEL_PACK_BUFFER, this._pbo),
                            y.readBuffer(y.COLOR_ATTACHMENT0),
                            y.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0),
                            y.bindBuffer(y.PIXEL_PACK_BUFFER, null);
                            const x = y.fenceSync(y.SYNC_GPU_COMMANDS_COMPLETE, 0);
                            y.flush(),
                            this._readbackQueue = {
                                frameNumberIssued: this._updateCount,
                                sync: x
                            }
                        } else
                            this._readbackQueue = {
                                frameNumberIssued: this._updateCount,
                                sync: null
                            }
                    }
                    _tryReadback() {
                        const r = this._cachedRenderContext.context.gl;
                        if (this._pbo && this._readbackQueue && go(r)) {
                            const a = r.clientWaitSync(this._readbackQueue.sync, 0, 0);
                            if (a === r.WAIT_FAILED)
                                return o.w("WebGL2 clientWaitSync failed."),
                                this._readbackQueue = null,
                                void (this._lastReadbackFrame = this._updateCount);
                            if (a === r.TIMEOUT_EXPIRED)
                                return;
                            r.bindBuffer(r.PIXEL_PACK_BUFFER, this._pbo),
                            r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4),
                            r.bindBuffer(r.PIXEL_PACK_BUFFER, null)
                        } else
                            this._bindFramebuffer(),
                            r.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
                        this._readbackQueue = null,
                        this._measuredError = oc._parseRGBA8float(this._resultBuffer),
                        this._lastReadbackFrame = this._updateCount
                    }
                    static _parseRGBA8float(r) {
                        let a = 0;
                        return a += r[0] / 256,
                        a += r[1] / 65536,
                        a += r[2] / 16777216,
                        r[3] < 127 && (a = -a),
                        a / 128
                    }
                }
                const Ji = o.$ / 128;
                function sc(v, r) {
                    const a = v.granularity !== void 0 ? Math.max(v.granularity, 1) : 1
                      , m = a + (v.generateBorders ? 2 : 0)
                      , y = a + (v.extendToNorthPole || v.generateBorders ? 1 : 0) + (v.extendToSouthPole || v.generateBorders ? 1 : 0)
                      , x = m + 1
                      , P = y + 1
                      , I = v.generateBorders ? -1 : 0
                      , A = v.generateBorders || v.extendToNorthPole ? -1 : 0
                      , B = a + (v.generateBorders ? 1 : 0)
                      , $ = a + (v.generateBorders || v.extendToSouthPole ? 1 : 0)
                      , Z = x * P
                      , H = m * y * 6
                      , Y = x * P > 65536;
                    if (Y && r === "16bit")
                        throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
                    const ae = Y || r === "32bit"
                      , ye = new Int16Array(2 * Z);
                    let Se = 0;
                    for (let De = A; De <= $; De++)
                        for (let Ae = I; Ae <= B; Ae++) {
                            let Be = Ae / a * o.$;
                            Ae === -1 && (Be = -Ji),
                            Ae === a + 1 && (Be = o.$ + Ji);
                            let qe = De / a * o.$;
                            De === -1 && (qe = v.extendToNorthPole ? o.bg : -Ji),
                            De === a + 1 && (qe = v.extendToSouthPole ? o.bh : o.$ + Ji),
                            ye[Se++] = Be,
                            ye[Se++] = qe
                        }
                    const Te = ae ? new Uint32Array(H) : new Uint16Array(H);
                    let Re = 0;
                    for (let De = 0; De < y; De++)
                        for (let Ae = 0; Ae < m; Ae++) {
                            const Be = Ae + 1 + De * x
                              , qe = Ae + (De + 1) * x
                              , ze = Ae + 1 + (De + 1) * x;
                            Te[Re++] = Ae + De * x,
                            Te[Re++] = qe,
                            Te[Re++] = Be,
                            Te[Re++] = Be,
                            Te[Re++] = qe,
                            Te[Re++] = ze
                        }
                    return {
                        vertices: ye.buffer.slice(0),
                        indices: Te.buffer.slice(0),
                        uses32bitIndices: ae
                    }
                }
                const us = new o.aJ({
                    fill: new o.bi(128,2),
                    line: new o.bi(512,0),
                    tile: new o.bi(128,32),
                    stencil: new o.bi(128,1),
                    circle: 3
                });
                class od {
                    constructor() {
                        this._tileMeshCache = {},
                        this._errorCorrectionUsable = 0,
                        this._errorMeasurementLastValue = 0,
                        this._errorCorrectionPreviousValue = 0,
                        this._errorMeasurementLastChangeTime = -1e3
                    }
                    get name() {
                        return "vertical-perspective"
                    }
                    get transitionState() {
                        return 1
                    }
                    get useSubdivision() {
                        return !0
                    }
                    get shaderVariantName() {
                        return "globe"
                    }
                    get shaderDefine() {
                        return "#define GLOBE"
                    }
                    get shaderPreludeCode() {
                        return ws.projectionGlobe
                    }
                    get vertexShaderPreludeCode() {
                        return ws.projectionMercator.vertexSource
                    }
                    get subdivisionGranularity() {
                        return us
                    }
                    get useGlobeControls() {
                        return !0
                    }
                    get latitudeErrorCorrectionRadians() {
                        return this._errorCorrectionUsable
                    }
                    destroy() {
                        this._errorMeasurement && this._errorMeasurement.destroy()
                    }
                    updateGPUdependent(r) {
                        this._errorMeasurement || (this._errorMeasurement = new oc(r));
                        const a = o.U(this._errorQueryLatitudeDegrees)
                          , m = 2 * Math.atan(Math.exp(Math.PI - a * Math.PI * 2)) - .5 * Math.PI
                          , y = this._errorMeasurement.updateErrorLoop(a, m)
                          , x = z.now();
                        y !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable,
                        this._errorMeasurementLastValue = y,
                        this._errorMeasurementLastChangeTime = x);
                        const P = Math.min(Math.max((x - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
                        this._errorCorrectionUsable = o.bj(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, o.bk(P))
                    }
                    _getMeshKey(r) {
                        return `${r.granularity.toString(36)}_${r.generateBorders ? "b" : ""}${r.extendToNorthPole ? "n" : ""}${r.extendToSouthPole ? "s" : ""}`
                    }
                    getMeshFromTileID(r, a, m, y, x) {
                        const P = (x === "stencil" ? us.stencil : us.tile).getGranularityForZoomLevel(a.z);
                        return this._getMesh(r, {
                            granularity: P,
                            generateBorders: m,
                            extendToNorthPole: a.y === 0 && y,
                            extendToSouthPole: a.y === (1 << a.z) - 1 && y
                        })
                    }
                    _getMesh(r, a) {
                        const m = this._getMeshKey(a);
                        if (m in this._tileMeshCache)
                            return this._tileMeshCache[m];
                        const y = function(x, P) {
                            const I = sc(P, "16bit")
                              , A = o.aK.deserialize({
                                arrayBuffer: I.vertices,
                                length: I.vertices.byteLength / 2 / 2
                            })
                              , B = o.aM.deserialize({
                                arrayBuffer: I.indices,
                                length: I.indices.byteLength / 2 / 3
                            });
                            return new Ss(x.createVertexBuffer(A, Ns.members),x.createIndexBuffer(B),o.aL.simpleSegment(0, 0, A.length, B.length))
                        }(r, a);
                        return this._tileMeshCache[m] = y,
                        y
                    }
                    recalculate(r) {}
                    hasTransition() {
                        const r = z.now();
                        let a = !1;
                        return a = a || (r - this._errorMeasurementLastChangeTime) / 1e3 < .7,
                        a = a || this._errorMeasurement && this._errorMeasurement.awaitingQuery,
                        a
                    }
                    setErrorQueryLatitudeDegrees(r) {
                        this._errorQueryLatitudeDegrees = r
                    }
                }
                const sa = new o.r({
                    type: new o.D(o.v.projection.type)
                });
                class Sl extends o.E {
                    constructor(r) {
                        super(),
                        this._transitionable = new o.t(sa),
                        this.setProjection(r),
                        this._transitioning = this._transitionable.untransitioned(),
                        this.recalculate(new o.F(0)),
                        this._mercatorProjection = new au,
                        this._verticalPerspectiveProjection = new od
                    }
                    get transitionState() {
                        const r = this.properties.get("type");
                        if (typeof r == "string" && r === "mercator")
                            return 0;
                        if (typeof r == "string" && r === "vertical-perspective")
                            return 1;
                        if (r instanceof o.bl) {
                            if (r.from === "vertical-perspective" && r.to === "mercator")
                                return 1 - r.transition;
                            if (r.from === "mercator" && r.to === "vertical-perspective")
                                return r.transition
                        }
                        return 1
                    }
                    get useGlobeRendering() {
                        return this.transitionState > 0
                    }
                    get latitudeErrorCorrectionRadians() {
                        return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
                    }
                    get currentProjection() {
                        return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
                    }
                    get name() {
                        return "globe"
                    }
                    get useSubdivision() {
                        return this.currentProjection.useSubdivision
                    }
                    get shaderVariantName() {
                        return this.currentProjection.shaderVariantName
                    }
                    get shaderDefine() {
                        return this.currentProjection.shaderDefine
                    }
                    get shaderPreludeCode() {
                        return this.currentProjection.shaderPreludeCode
                    }
                    get vertexShaderPreludeCode() {
                        return this.currentProjection.vertexShaderPreludeCode
                    }
                    get subdivisionGranularity() {
                        return this.currentProjection.subdivisionGranularity
                    }
                    get useGlobeControls() {
                        return this.transitionState > 0
                    }
                    destroy() {
                        this._mercatorProjection.destroy(),
                        this._verticalPerspectiveProjection.destroy()
                    }
                    updateGPUdependent(r) {
                        this._mercatorProjection.updateGPUdependent(r),
                        this._verticalPerspectiveProjection.updateGPUdependent(r)
                    }
                    getMeshFromTileID(r, a, m, y, x) {
                        return this.currentProjection.getMeshFromTileID(r, a, m, y, x)
                    }
                    setProjection(r) {
                        this._transitionable.setValue("type", r?.type || "mercator")
                    }
                    updateTransitions(r) {
                        this._transitioning = this._transitionable.transitioned(r, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
                    }
                    recalculate(r) {
                        this.properties = this._transitioning.possiblyEvaluate(r)
                    }
                    setErrorQueryLatitudeDegrees(r) {
                        this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(r),
                        this._mercatorProjection.setErrorQueryLatitudeDegrees(r)
                    }
                }
                function Oa(v) {
                    const r = aa(v.worldSize, v.center.lat);
                    return 2 * Math.PI * r
                }
                function hs(v, r, a, m, y) {
                    const x = 1 / (1 << y)
                      , P = r / o.$ * x + m * x
                      , I = o.bn((v / o.$ * x + a * x) * Math.PI * 2 + Math.PI, 2 * Math.PI)
                      , A = 2 * Math.atan(Math.exp(Math.PI - P * Math.PI * 2)) - .5 * Math.PI
                      , B = Math.cos(A)
                      , $ = new Float64Array(3);
                    return $[0] = Math.sin(I) * B,
                    $[1] = Math.sin(A),
                    $[2] = Math.cos(I) * B,
                    $
                }
                function ui(v) {
                    return function(r, a) {
                        const m = Math.cos(a)
                          , y = new Float64Array(3);
                        return y[0] = Math.sin(r) * m,
                        y[1] = Math.sin(a),
                        y[2] = Math.cos(r) * m,
                        y
                    }(v.lng * Math.PI / 180, v.lat * Math.PI / 180)
                }
                function aa(v, r) {
                    return v / (2 * Math.PI) / Math.cos(r * Math.PI / 180)
                }
                function ac(v) {
                    const r = Math.asin(v[1]) / Math.PI * 180
                      , a = Math.sqrt(v[0] * v[0] + v[2] * v[2]);
                    if (a > 1e-6) {
                        const m = v[0] / a
                          , y = Math.acos(v[2] / a)
                          , x = (m > 0 ? y : -y) / Math.PI * 180;
                        return new o.S(o.aN(x, -180, 180),r)
                    }
                    return new o.S(0,r)
                }
                function Ii(v) {
                    return Math.cos(v * Math.PI / 180)
                }
                function Zn(v, r) {
                    const a = Ii(v)
                      , m = Ii(r);
                    return o.aj(m / a)
                }
                function Cl(v, r) {
                    const a = v.rotate(r.bearingInRadians)
                      , m = r.zoom + Zn(r.center.lat, 0)
                      , y = o.bj(1 / Ii(r.center.lat), 1 / Ii(Math.min(Math.abs(r.center.lat), 60)), o.bm(m, 7, 3, 0, 1))
                      , x = 360 / Oa({
                        worldSize: r.worldSize,
                        center: {
                            lat: r.center.lat
                        }
                    });
                    return new o.S(r.center.lng - a.x * x * y,o.ag(r.center.lat + a.y * x, -o.ah, o.ah))
                }
                function Vs(v) {
                    const r = .5 * v
                      , a = Math.sin(r)
                      , m = Math.cos(r);
                    return Math.log(a + m) - Math.log(m - a)
                }
                function lc(v, r, a, m) {
                    const y = v.lat + a * m;
                    if (Math.abs(a) > 1) {
                        const x = (Math.sign(v.lat + a) !== Math.sign(v.lat) ? -Math.abs(v.lat) : Math.abs(v.lat)) * Math.PI / 180
                          , P = Math.abs(v.lat + a) * Math.PI / 180
                          , I = Vs(x + m * (P - x))
                          , A = Vs(x)
                          , B = Vs(P);
                        return new o.S(v.lng + r * ((I - A) / (B - A)),y)
                    }
                    return new o.S(v.lng + r * m,y)
                }
                class sd {
                    constructor(r) {
                        this._cachePrevious = new Map,
                        this._cache = new Map,
                        this._hadAnyChanges = !1,
                        this._boundingVolumeFactory = r
                    }
                    swapBuffers() {
                        if (!this._hadAnyChanges)
                            return;
                        const r = this._cachePrevious;
                        this._cachePrevious = this._cache,
                        this._cache = r,
                        this._cache.clear(),
                        this._hadAnyChanges = !1
                    }
                    getTileBoundingVolume(r, a, m, y) {
                        const x = `${r.z}_${r.x}_${r.y}_${y?.terrain ? "t" : ""}`
                          , P = this._cache.get(x);
                        if (P)
                            return P;
                        const I = this._cachePrevious.get(x);
                        if (I)
                            return this._cache.set(x, I),
                            I;
                        const A = this._boundingVolumeFactory(r, a, m, y);
                        return this._cache.set(x, A),
                        this._hadAnyChanges = !0,
                        A
                    }
                }
                class Us {
                    constructor(r, a, m, y) {
                        this.min = m,
                        this.max = y,
                        this.points = r,
                        this.planes = a
                    }
                    static fromAabb(r, a) {
                        const m = [];
                        for (let y = 0; y < 8; y++)
                            m.push([1 & ~y ? r[0] : a[0], (y >> 1 & 1) == 1 ? a[1] : r[1], (y >> 2 & 1) == 1 ? a[2] : r[2]]);
                        return new Us(m,[[-1, 0, 0, a[0]], [1, 0, 0, -r[0]], [0, -1, 0, a[1]], [0, 1, 0, -r[1]], [0, 0, -1, a[2]], [0, 0, 1, -r[2]]],r,a)
                    }
                    static fromCenterSizeAngles(r, a, m) {
                        const y = o.bq([], m[0], m[1], m[2])
                          , x = o.br([], [a[0], 0, 0], y)
                          , P = o.br([], [0, a[1], 0], y)
                          , I = o.br([], [0, 0, a[2]], y)
                          , A = [...r]
                          , B = [...r];
                        for (let Z = 0; Z < 8; Z++)
                            for (let H = 0; H < 3; H++) {
                                const Y = r[H] + x[H] * (1 & ~Z ? -1 : 1) + P[H] * ((Z >> 1 & 1) == 1 ? 1 : -1) + I[H] * ((Z >> 2 & 1) == 1 ? 1 : -1);
                                A[H] = Math.min(A[H], Y),
                                B[H] = Math.max(B[H], Y)
                            }
                        const $ = [];
                        for (let Z = 0; Z < 8; Z++) {
                            const H = [...r];
                            o.aR(H, H, o.aQ([], x, 1 & ~Z ? -1 : 1)),
                            o.aR(H, H, o.aQ([], P, (Z >> 1 & 1) == 1 ? 1 : -1)),
                            o.aR(H, H, o.aQ([], I, (Z >> 2 & 1) == 1 ? 1 : -1)),
                            $.push(H)
                        }
                        return new Us($,[[...x, -o.aW(x, $[0])], [...P, -o.aW(P, $[0])], [...I, -o.aW(I, $[0])], [-x[0], -x[1], -x[2], -o.aW(x, $[7])], [-P[0], -P[1], -P[2], -o.aW(P, $[7])], [-I[0], -I[1], -I[2], -o.aW(I, $[7])]],A,B)
                    }
                    intersectsFrustum(r) {
                        let a = !0;
                        const m = this.points.length
                          , y = this.planes.length
                          , x = r.planes.length
                          , P = r.points.length;
                        for (let I = 0; I < x; I++) {
                            const A = r.planes[I];
                            let B = 0;
                            for (let $ = 0; $ < m; $++) {
                                const Z = this.points[$];
                                A[0] * Z[0] + A[1] * Z[1] + A[2] * Z[2] + A[3] >= 0 && B++
                            }
                            if (B === 0)
                                return 0;
                            B < m && (a = !1)
                        }
                        if (a)
                            return 2;
                        for (let I = 0; I < y; I++) {
                            const A = this.planes[I];
                            let B = 0;
                            for (let $ = 0; $ < P; $++) {
                                const Z = r.points[$];
                                A[0] * Z[0] + A[1] * Z[1] + A[2] * Z[2] + A[3] >= 0 && B++
                            }
                            if (B === 0)
                                return 0
                        }
                        return 1
                    }
                    intersectsPlane(r) {
                        const a = this.points.length;
                        let m = 0;
                        for (let y = 0; y < a; y++) {
                            const x = this.points[y];
                            r[0] * x[0] + r[1] * x[1] + r[2] * x[2] + r[3] >= 0 && m++
                        }
                        return m === a ? 2 : m === 0 ? 0 : 1
                    }
                }
                function la(v, r, a) {
                    const m = v - r;
                    return m < 0 ? -m : Math.max(0, m - a)
                }
                function cc(v, r, a, m, y) {
                    const x = v - a;
                    let P;
                    return P = x < 0 ? Math.min(-x, 1 + x - y) : x > 1 ? Math.min(Math.max(x - y, 0), 1 - x) : 0,
                    Math.max(P, la(r, m, y))
                }
                class Sf {
                    constructor() {
                        this._boundingVolumeCache = new sd(this._computeTileBoundingVolume)
                    }
                    prepareNextFrame() {
                        this._boundingVolumeCache.swapBuffers()
                    }
                    distanceToTile2d(r, a, m, y) {
                        const x = 1 << m.z
                          , P = 1 / x
                          , I = m.x / x
                          , A = m.y / x;
                        let B = 2;
                        return B = Math.min(B, cc(r, a, I, A, P)),
                        B = Math.min(B, cc(r, a, I + .5, -A - P, P)),
                        B = Math.min(B, cc(r, a, I + .5, 2 - A - P, P)),
                        B
                    }
                    getWrap(r, a, m) {
                        const y = 1 << a.z
                          , x = 1 / y
                          , P = a.x / y
                          , I = la(r.x, P, x)
                          , A = la(r.x, P - 1, x)
                          , B = la(r.x, P + 1, x)
                          , $ = Math.min(I, A, B);
                        return $ === B ? 1 : $ === A ? -1 : 0
                    }
                    allowVariableZoom(r, a) {
                        return _t(r, a) > 4
                    }
                    allowWorldCopies() {
                        return !1
                    }
                    getTileBoundingVolume(r, a, m, y) {
                        return this._boundingVolumeCache.getTileBoundingVolume(r, a, m, y)
                    }
                    _computeTileBoundingVolume(r, a, m, y) {
                        var x, P;
                        let I = m
                          , A = m;
                        if (y?.terrain) {
                            const B = new o.Z(r.z,a,r.z,r.x,r.y)
                              , $ = y.terrain.getMinMaxElevation(B);
                            I = (x = $.minElevation) !== null && x !== void 0 ? x : m,
                            A = (P = $.maxElevation) !== null && P !== void 0 ? P : m
                        }
                        if (I /= o.bt,
                        A /= o.bt,
                        I += 1,
                        A += 1,
                        r.z <= 0)
                            return Us.fromAabb([-A, -A, -A], [A, A, A]);
                        if (r.z === 1)
                            return Us.fromAabb([r.x === 0 ? -A : 0, r.y === 0 ? 0 : -A, -A], [r.x === 0 ? 0 : A, r.y === 0 ? A : 0, A]);
                        {
                            const B = [hs(0, 0, r.x, r.y, r.z), hs(o.$, 0, r.x, r.y, r.z), hs(o.$, o.$, r.x, r.y, r.z), hs(0, o.$, r.x, r.y, r.z)]
                              , $ = [];
                            for (const ut of B)
                                $.push(o.aQ([], ut, A));
                            if (A !== I)
                                for (const ut of B)
                                    $.push(o.aQ([], ut, I));
                            r.y === 0 && $.push([0, 1, 0]),
                            r.y === (1 << r.z) - 1 && $.push([0, -1, 0]);
                            const Z = [1, 1, 1]
                              , H = [-1, -1, -1];
                            for (const ut of $)
                                for (let mt = 0; mt < 3; mt++)
                                    Z[mt] = Math.min(Z[mt], ut[mt]),
                                    H[mt] = Math.max(H[mt], ut[mt]);
                            const Y = hs(o.$ / 2, o.$ / 2, r.x, r.y, r.z)
                              , ae = o.aV([], [0, 1, 0], Y);
                            o.aU(ae, ae);
                            const ye = o.aV([], Y, ae);
                            o.aU(ye, ye);
                            const Se = o.aV([], B[2], B[1]);
                            o.aU(Se, Se);
                            const Te = o.aV([], B[0], B[3]);
                            o.aU(Te, Te),
                            $.push(o.aQ([], Y, A)),
                            r.y >= (1 << r.z) / 2 && $.push(o.aQ([], hs(o.$ / 2, 0, r.x, r.y, r.z), A)),
                            r.y < (1 << r.z) / 2 && $.push(o.aQ([], hs(o.$ / 2, o.$, r.x, r.y, r.z), A));
                            const Re = yo(Y, $)
                              , De = yo(ye, $)
                              , Ae = [-Y[0], -Y[1], -Y[2], Re.max]
                              , Be = [Y[0], Y[1], Y[2], -Re.min]
                              , qe = [-ye[0], -ye[1], -ye[2], De.max]
                              , ze = [ye[0], ye[1], ye[2], -De.min]
                              , Ke = [...Se, 0]
                              , ht = [...Te, 0]
                              , ot = [];
                            return r.y === 0 ? ot.push(o.bs(ht, Ke, Ae), o.bs(ht, Ke, Be)) : ot.push(o.bs(qe, Ke, Ae), o.bs(qe, Ke, Be), o.bs(qe, ht, Ae), o.bs(qe, ht, Be)),
                            r.y === (1 << r.z) - 1 ? ot.push(o.bs(ht, Ke, Ae), o.bs(ht, Ke, Be)) : ot.push(o.bs(ze, Ke, Ae), o.bs(ze, Ke, Be), o.bs(ze, ht, Ae), o.bs(ze, ht, Be)),
                            new Us(ot,[Ae, Be, qe, ze, Ke, ht],Z,H)
                        }
                    }
                }
                function yo(v, r) {
                    let a = 1 / 0
                      , m = -1 / 0;
                    for (const y of r) {
                        const x = o.aW(v, y);
                        a = Math.min(a, x),
                        m = Math.max(m, x)
                    }
                    return {
                        min: a,
                        max: m
                    }
                }
                class uc {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits
                    }
                    get centerOffset() {
                        return this._helper.centerOffset
                    }
                    get size() {
                        return this._helper.size
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix
                    }
                    get centerPoint() {
                        return this._helper.centerPoint
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter
                    }
                    setMinZoom(r) {
                        this._helper.setMinZoom(r)
                    }
                    setMaxZoom(r) {
                        this._helper.setMaxZoom(r)
                    }
                    setMinPitch(r) {
                        this._helper.setMinPitch(r)
                    }
                    setMaxPitch(r) {
                        this._helper.setMaxPitch(r)
                    }
                    setRenderWorldCopies(r) {
                        this._helper.setRenderWorldCopies(r)
                    }
                    setBearing(r) {
                        this._helper.setBearing(r)
                    }
                    setPitch(r) {
                        this._helper.setPitch(r)
                    }
                    setRoll(r) {
                        this._helper.setRoll(r)
                    }
                    setFov(r) {
                        this._helper.setFov(r)
                    }
                    setZoom(r) {
                        this._helper.setZoom(r)
                    }
                    setCenter(r) {
                        this._helper.setCenter(r)
                    }
                    setElevation(r) {
                        this._helper.setElevation(r)
                    }
                    setMinElevationForCurrentTile(r) {
                        this._helper.setMinElevationForCurrentTile(r)
                    }
                    setPadding(r) {
                        this._helper.setPadding(r)
                    }
                    interpolatePadding(r, a, m) {
                        return this._helper.interpolatePadding(r, a, m)
                    }
                    isPaddingEqual(r) {
                        return this._helper.isPaddingEqual(r)
                    }
                    resize(r, a) {
                        this._helper.resize(r, a)
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds()
                    }
                    setMaxBounds(r) {
                        this._helper.setMaxBounds(r)
                    }
                    overrideNearFarZ(r, a) {
                        this._helper.overrideNearFarZ(r, a)
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride()
                    }
                    getCameraQueryGeometry(r) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), r)
                    }
                    get tileSize() {
                        return this._helper.tileSize
                    }
                    get tileZoom() {
                        return this._helper.tileZoom
                    }
                    get scale() {
                        return this._helper.scale
                    }
                    get worldSize() {
                        return this._helper.worldSize
                    }
                    get width() {
                        return this._helper.width
                    }
                    get height() {
                        return this._helper.height
                    }
                    get lngRange() {
                        return this._helper.lngRange
                    }
                    get latRange() {
                        return this._helper.latRange
                    }
                    get minZoom() {
                        return this._helper.minZoom
                    }
                    get maxZoom() {
                        return this._helper.maxZoom
                    }
                    get zoom() {
                        return this._helper.zoom
                    }
                    get center() {
                        return this._helper.center
                    }
                    get minPitch() {
                        return this._helper.minPitch
                    }
                    get maxPitch() {
                        return this._helper.maxPitch
                    }
                    get pitch() {
                        return this._helper.pitch
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians
                    }
                    get roll() {
                        return this._helper.roll
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians
                    }
                    get bearing() {
                        return this._helper.bearing
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians
                    }
                    get fov() {
                        return this._helper.fov
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians
                    }
                    get elevation() {
                        return this._helper.elevation
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile
                    }
                    get padding() {
                        return this._helper.padding
                    }
                    get unmodified() {
                        return this._helper.unmodified
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies
                    }
                    get nearZ() {
                        return this._helper.nearZ
                    }
                    get farZ() {
                        return this._helper.farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ
                    }
                    setTransitionState(r) {}
                    constructor() {
                        this._cachedClippingPlane = o.bu(),
                        this._projectionMatrix = o.b8(),
                        this._globeViewProjMatrix32f = o.b7(),
                        this._globeViewProjMatrixNoCorrection = o.b8(),
                        this._globeViewProjMatrixNoCorrectionInverted = o.b8(),
                        this._globeProjMatrixInverted = o.b8(),
                        this._cameraPosition = o.bo(),
                        this._globeLatitudeErrorCorrectionRadians = 0,
                        this._helper = new cs({
                            calcMatrices: () => {
                                this._calcMatrices()
                            }
                            ,
                            getConstrained: (r, a) => this.getConstrained(r, a)
                        }),
                        this._coveringTilesDetailsProvider = new Sf
                    }
                    clone() {
                        const r = new uc;
                        return r.apply(this),
                        r
                    }
                    apply(r, a) {
                        this._globeLatitudeErrorCorrectionRadians = a || 0,
                        this._helper.apply(r)
                    }
                    get projectionMatrix() {
                        return this._projectionMatrix
                    }
                    get modelViewProjectionMatrix() {
                        return this._globeViewProjMatrixNoCorrection
                    }
                    get inverseProjectionMatrix() {
                        return this._globeProjMatrixInverted
                    }
                    get cameraPosition() {
                        const r = o.bo();
                        return r[0] = this._cameraPosition[0],
                        r[1] = this._cameraPosition[1],
                        r[2] = this._cameraPosition[2],
                        r
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance
                    }
                    getProjectionData(r) {
                        const {overscaledTileID: a, applyGlobeMatrix: m} = r
                          , y = this._helper.getMercatorTileCoordinates(a);
                        return {
                            mainMatrix: this._globeViewProjMatrix32f,
                            tileMercatorCoords: y,
                            clippingPlane: this._cachedClippingPlane,
                            projectionTransition: m ? 1 : 0,
                            fallbackMatrix: this._globeViewProjMatrix32f
                        }
                    }
                    _computeClippingPlane(r) {
                        const a = this.pitchInRadians
                          , m = this.cameraToCenterDistance / r
                          , y = Math.sin(a) * m
                          , x = Math.cos(a) * m + 1
                          , P = 1 / Math.sqrt(y * y + x * x) * 1;
                        let I = -y
                          , A = x;
                        const B = Math.sqrt(I * I + A * A);
                        I /= B,
                        A /= B;
                        const $ = [0, I, A];
                        o.bv($, $, [0, 0, 0], -this.bearingInRadians),
                        o.bw($, $, [0, 0, 0], -1 * this.center.lat * Math.PI / 180),
                        o.bx($, $, [0, 0, 0], this.center.lng * Math.PI / 180);
                        const Z = 1 / o.aY($);
                        return o.aQ($, $, Z),
                        [...$, -P * Z]
                    }
                    isLocationOccluded(r) {
                        return !this.isSurfacePointVisible(ui(r))
                    }
                    transformLightDirection(r) {
                        const a = this._helper._center.lng * Math.PI / 180
                          , m = this._helper._center.lat * Math.PI / 180
                          , y = Math.cos(m)
                          , x = [Math.sin(a) * y, Math.sin(m), Math.cos(a) * y]
                          , P = [x[2], 0, -x[0]]
                          , I = [0, 0, 0];
                        o.aV(I, P, x),
                        o.aU(P, P),
                        o.aU(I, I);
                        const A = [0, 0, 0];
                        return o.aU(A, [P[0] * r[0] + I[0] * r[1] + x[0] * r[2], P[1] * r[0] + I[1] * r[1] + x[1] * r[2], P[2] * r[0] + I[2] * r[1] + x[2] * r[2]]),
                        A
                    }
                    getPixelScale() {
                        return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
                    }
                    getCircleRadiusCorrection() {
                        return Math.cos(this._helper._center.lat * Math.PI / 180)
                    }
                    getPitchedTextCorrection(r, a, m) {
                        const y = function(I, A, B) {
                            const $ = 1 / (1 << B.z);
                            return new o.a0(I / o.$ * $ + B.x * $,A / o.$ * $ + B.y * $)
                        }(r, a, m.canonical)
                          , x = (P = y.y,
                        [o.bn(y.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - P * Math.PI * 2)) - .5 * Math.PI]);
                        var P;
                        return this.getCircleRadiusCorrection() / Math.cos(x[1])
                    }
                    projectTileCoordinates(r, a, m, y) {
                        const x = m.canonical
                          , P = hs(r, a, x.x, x.y, x.z)
                          , I = 1 + (y ? y(r, a) : 0) / o.bt
                          , A = [P[0] * I, P[1] * I, P[2] * I, 1];
                        o.av(A, A, this._globeViewProjMatrixNoCorrection);
                        const B = this._cachedClippingPlane
                          , $ = B[0] * P[0] + B[1] * P[1] + B[2] * P[2] + B[3] < 0;
                        return {
                            point: new o.P(A[0] / A[3],A[1] / A[3]),
                            signedDistanceFromCamera: A[3],
                            isOccluded: $
                        }
                    }
                    _calcMatrices() {
                        if (!this._helper._width || !this._helper._height)
                            return;
                        const r = aa(this.worldSize, this.center.lat)
                          , a = o.b9()
                          , m = o.b9();
                        this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5,
                        this._helper._farZ = this.cameraToCenterDistance + 2 * r),
                        o.b3(a, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
                        const y = this.centerOffset;
                        a[8] = 2 * -y.x / this._helper._width,
                        a[9] = 2 * y.y / this._helper._height,
                        this._projectionMatrix = o.b4(a),
                        this._globeProjMatrixInverted = o.b9(),
                        o.ap(this._globeProjMatrixInverted, a),
                        o.M(a, a, [0, 0, -this.cameraToCenterDistance]),
                        o.b5(a, a, this.rollInRadians),
                        o.b6(a, a, -this.pitchInRadians),
                        o.b5(a, a, this.bearingInRadians),
                        o.M(a, a, [0, 0, -r]);
                        const x = o.bo();
                        x[0] = r,
                        x[1] = r,
                        x[2] = r,
                        o.b6(m, a, this.center.lat * Math.PI / 180),
                        o.by(m, m, -this.center.lng * Math.PI / 180),
                        o.N(m, m, x),
                        this._globeViewProjMatrixNoCorrection = m,
                        o.b6(a, a, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians),
                        o.by(a, a, -this.center.lng * Math.PI / 180),
                        o.N(a, a, x),
                        this._globeViewProjMatrix32f = new Float32Array(a),
                        this._globeViewProjMatrixNoCorrectionInverted = o.b9(),
                        o.ap(this._globeViewProjMatrixNoCorrectionInverted, m);
                        const P = o.bo();
                        this._cameraPosition = o.bo(),
                        this._cameraPosition[2] = this.cameraToCenterDistance / r,
                        o.bv(this._cameraPosition, this._cameraPosition, P, -this.rollInRadians),
                        o.bw(this._cameraPosition, this._cameraPosition, P, this.pitchInRadians),
                        o.bv(this._cameraPosition, this._cameraPosition, P, -this.bearingInRadians),
                        o.aR(this._cameraPosition, this._cameraPosition, [0, 0, 1]),
                        o.bw(this._cameraPosition, this._cameraPosition, P, -this.center.lat * Math.PI / 180),
                        o.bx(this._cameraPosition, this._cameraPosition, P, this.center.lng * Math.PI / 180),
                        this._cachedClippingPlane = this._computeClippingPlane(r);
                        const I = o.b4(this._globeViewProjMatrixNoCorrectionInverted);
                        o.N(I, I, [1, 1, -1]),
                        this._cachedFrustum = ei.fromInvProjectionMatrix(I, 1, 0, this._cachedClippingPlane, !0)
                    }
                    calculateFogMatrix(r) {
                        o.w("calculateFogMatrix is not supported on globe projection.");
                        const a = o.b9();
                        return o.af(a),
                        a
                    }
                    getVisibleUnwrappedCoordinates(r) {
                        return [new o.b1(0,r)]
                    }
                    getCameraFrustum() {
                        return this._cachedFrustum
                    }
                    getClippingPlane() {
                        return this._cachedClippingPlane
                    }
                    getCoveringTilesDetailsProvider() {
                        return this._coveringTilesDetailsProvider
                    }
                    recalculateZoomAndCenter(r) {
                        r && o.w("terrain is not fully supported on vertical perspective projection."),
                        this._helper.recalculateZoomAndCenter(0)
                    }
                    maxPitchScaleFactor() {
                        return 1
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint()
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude()
                    }
                    getCameraLngLat() {
                        return this._helper.getCameraLngLat()
                    }
                    lngLatToCameraDepth(r, a) {
                        if (!this._globeViewProjMatrixNoCorrection)
                            return 1;
                        const m = ui(r);
                        o.aQ(m, m, 1 + a / o.bt);
                        const y = o.bu();
                        return o.av(y, [m[0], m[1], m[2], 1], this._globeViewProjMatrixNoCorrection),
                        y[2] / y[3]
                    }
                    populateCache(r) {}
                    getBounds() {
                        const r = .5 * this.width
                          , a = .5 * this.height
                          , m = [new o.P(0,0), new o.P(r,0), new o.P(this.width,0), new o.P(this.width,a), new o.P(this.width,this.height), new o.P(r,this.height), new o.P(0,this.height), new o.P(0,a)]
                          , y = [];
                        for (const Z of m)
                            y.push(this.unprojectScreenPoint(Z));
                        let x = 0
                          , P = 0
                          , I = 0
                          , A = 0;
                        const B = this.center;
                        for (const Z of y) {
                            const H = o.bz(B.lng, Z.lng)
                              , Y = o.bz(B.lat, Z.lat);
                            H < P && (P = H),
                            H > x && (x = H),
                            Y < A && (A = Y),
                            Y > I && (I = Y)
                        }
                        const $ = [B.lng + P, B.lat + A, B.lng + x, B.lat + I];
                        return this.isSurfacePointOnScreen([0, 1, 0]) && ($[3] = 90,
                        $[0] = -180,
                        $[2] = 180),
                        this.isSurfacePointOnScreen([0, -1, 0]) && ($[1] = -90,
                        $[0] = -180,
                        $[2] = 180),
                        new ur($)
                    }
                    getConstrained(r, a) {
                        const m = o.ag(r.lat, -o.ah, o.ah)
                          , y = o.ag(+a, this.minZoom + Zn(0, m), this.maxZoom);
                        return {
                            center: new o.S(r.lng,m),
                            zoom: y
                        }
                    }
                    calculateCenterFromCameraLngLatAlt(r, a, m, y) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(r, a, m, y)
                    }
                    setLocationAtPoint(r, a) {
                        const m = ui(this.unprojectScreenPoint(a))
                          , y = ui(r)
                          , x = o.bo();
                        o.bA(x);
                        const P = o.bo();
                        o.bx(P, m, x, -this.center.lng * Math.PI / 180),
                        o.bw(P, P, x, this.center.lat * Math.PI / 180);
                        const I = y[0] * y[0] + y[2] * y[2]
                          , A = P[0] * P[0];
                        if (I < A)
                            return;
                        const B = Math.sqrt(I - A)
                          , $ = -B
                          , Z = o.bB(y[0], y[2], P[0], B)
                          , H = o.bB(y[0], y[2], P[0], $)
                          , Y = o.bo();
                        o.bx(Y, y, x, -Z);
                        const ae = o.bB(Y[1], Y[2], P[1], P[2])
                          , ye = o.bo();
                        o.bx(ye, y, x, -H);
                        const Se = o.bB(ye[1], ye[2], P[1], P[2])
                          , Te = .5 * Math.PI
                          , Re = ae >= -Te && ae <= Te
                          , De = Se >= -Te && Se <= Te;
                        let Ae, Be;
                        if (Re && De) {
                            const ht = this.center.lng * Math.PI / 180
                              , ot = this.center.lat * Math.PI / 180;
                            o.bC(Z, ht) + o.bC(ae, ot) < o.bC(H, ht) + o.bC(Se, ot) ? (Ae = Z,
                            Be = ae) : (Ae = H,
                            Be = Se)
                        } else if (Re)
                            Ae = Z,
                            Be = ae;
                        else {
                            if (!De)
                                return;
                            Ae = H,
                            Be = Se
                        }
                        const qe = Ae / Math.PI * 180
                          , ze = Be / Math.PI * 180
                          , Ke = this.center.lat;
                        this.setCenter(new o.S(qe,o.ag(ze, -90, 90))),
                        this.setZoom(this.zoom + Zn(Ke, this.center.lat))
                    }
                    locationToScreenPoint(r, a) {
                        const m = ui(r);
                        if (a) {
                            const y = a.getElevationForLngLatZoom(r, this._helper._tileZoom);
                            o.aQ(m, m, 1 + y / o.bt)
                        }
                        return this._projectSurfacePointToScreen(m)
                    }
                    _projectSurfacePointToScreen(r) {
                        const a = o.bu();
                        return o.av(a, [...r, 1], this._globeViewProjMatrixNoCorrection),
                        a[0] /= a[3],
                        a[1] /= a[3],
                        new o.P((.5 * a[0] + .5) * this.width,(.5 * -a[1] + .5) * this.height)
                    }
                    screenPointToMercatorCoordinate(r, a) {
                        if (a) {
                            const m = a.pointCoordinate(r);
                            if (m)
                                return m
                        }
                        return o.a0.fromLngLat(this.unprojectScreenPoint(r))
                    }
                    screenPointToLocation(r, a) {
                        var m;
                        return (m = this.screenPointToMercatorCoordinate(r, a)) === null || m === void 0 ? void 0 : m.toLngLat()
                    }
                    isPointOnMapSurface(r, a) {
                        const m = this._cameraPosition
                          , y = this.getRayDirectionFromPixel(r);
                        return !!this.rayPlanetIntersection(m, y)
                    }
                    getRayDirectionFromPixel(r) {
                        const a = o.bu();
                        a[0] = r.x / this.width * 2 - 1,
                        a[1] = -1 * (r.y / this.height * 2 - 1),
                        a[2] = 1,
                        a[3] = 1,
                        o.av(a, a, this._globeViewProjMatrixNoCorrectionInverted),
                        a[0] /= a[3],
                        a[1] /= a[3],
                        a[2] /= a[3];
                        const m = o.bo();
                        m[0] = a[0] - this._cameraPosition[0],
                        m[1] = a[1] - this._cameraPosition[1],
                        m[2] = a[2] - this._cameraPosition[2];
                        const y = o.bo();
                        return o.aU(y, m),
                        y
                    }
                    isSurfacePointVisible(r) {
                        const a = this._cachedClippingPlane;
                        return a[0] * r[0] + a[1] * r[1] + a[2] * r[2] + a[3] >= 0
                    }
                    isSurfacePointOnScreen(r) {
                        if (!this.isSurfacePointVisible(r))
                            return !1;
                        const a = o.bu();
                        return o.av(a, [...r, 1], this._globeViewProjMatrixNoCorrection),
                        a[0] /= a[3],
                        a[1] /= a[3],
                        a[2] /= a[3],
                        a[0] > -1 && a[0] < 1 && a[1] > -1 && a[1] < 1 && a[2] > -1 && a[2] < 1
                    }
                    rayPlanetIntersection(r, a) {
                        const m = o.aW(r, a)
                          , y = o.bo()
                          , x = o.bo();
                        o.aQ(x, a, m),
                        o.aT(y, r, x);
                        const P = 1 - o.aW(y, y);
                        if (P < 0)
                            return null;
                        const I = o.aW(r, r) - 1
                          , A = -m + (m < 0 ? 1 : -1) * Math.sqrt(P)
                          , B = I / A
                          , $ = A;
                        return {
                            tMin: Math.min(B, $),
                            tMax: Math.max(B, $)
                        }
                    }
                    unprojectScreenPoint(r) {
                        const a = this._cameraPosition
                          , m = this.getRayDirectionFromPixel(r)
                          , y = this.rayPlanetIntersection(a, m);
                        if (y) {
                            const $ = o.bo();
                            o.aR($, a, [m[0] * y.tMin, m[1] * y.tMin, m[2] * y.tMin]);
                            const Z = o.bo();
                            return o.aU(Z, $),
                            ac(Z)
                        }
                        const x = this._cachedClippingPlane
                          , P = x[0] * m[0] + x[1] * m[1] + x[2] * m[2]
                          , I = -o.b0(x, a) / P
                          , A = o.bo();
                        if (I > 0)
                            o.aR(A, a, [m[0] * I, m[1] * I, m[2] * I]);
                        else {
                            const $ = o.bo();
                            o.aR($, a, [2 * m[0], 2 * m[1], 2 * m[2]]);
                            const Z = o.b0(this._cachedClippingPlane, $);
                            o.aT(A, $, [this._cachedClippingPlane[0] * Z, this._cachedClippingPlane[1] * Z, this._cachedClippingPlane[2] * Z])
                        }
                        const B = function($) {
                            const Z = o.bo();
                            return Z[0] = $[0] * -$[3],
                            Z[1] = $[1] * -$[3],
                            Z[2] = $[2] * -$[3],
                            {
                                center: Z,
                                radius: Math.sqrt(1 - $[3] * $[3])
                            }
                        }(x);
                        return ac(function($, Z, H) {
                            const Y = o.bo();
                            o.aT(Y, H, $);
                            const ae = o.bo();
                            return o.bp(ae, $, Y, Z / o.a_(Y)),
                            ae
                        }(B.center, B.radius, A))
                    }
                    getMatrixForModel(r, a) {
                        const m = o.S.convert(r)
                          , y = 1 / o.bt
                          , x = o.b8();
                        return o.by(x, x, m.lng / 180 * Math.PI),
                        o.b6(x, x, -m.lat / 180 * Math.PI),
                        o.M(x, x, [0, 0, 1 + a / o.bt]),
                        o.b6(x, x, .5 * Math.PI),
                        o.N(x, x, [y, y, y]),
                        x
                    }
                    getProjectionDataForCustomLayer(r=!0) {
                        const a = this.getProjectionData({
                            overscaledTileID: new o.Z(0,0,0,0,0),
                            applyGlobeMatrix: r
                        });
                        return a.tileMercatorCoords = [0, 0, 1, 1],
                        a
                    }
                    getFastPathSimpleProjectionMatrix(r) {}
                }
                class Xo {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits
                    }
                    get centerOffset() {
                        return this._helper.centerOffset
                    }
                    get size() {
                        return this._helper.size
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix
                    }
                    get centerPoint() {
                        return this._helper.centerPoint
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter
                    }
                    setMinZoom(r) {
                        this._helper.setMinZoom(r)
                    }
                    setMaxZoom(r) {
                        this._helper.setMaxZoom(r)
                    }
                    setMinPitch(r) {
                        this._helper.setMinPitch(r)
                    }
                    setMaxPitch(r) {
                        this._helper.setMaxPitch(r)
                    }
                    setRenderWorldCopies(r) {
                        this._helper.setRenderWorldCopies(r)
                    }
                    setBearing(r) {
                        this._helper.setBearing(r)
                    }
                    setPitch(r) {
                        this._helper.setPitch(r)
                    }
                    setRoll(r) {
                        this._helper.setRoll(r)
                    }
                    setFov(r) {
                        this._helper.setFov(r)
                    }
                    setZoom(r) {
                        this._helper.setZoom(r)
                    }
                    setCenter(r) {
                        this._helper.setCenter(r)
                    }
                    setElevation(r) {
                        this._helper.setElevation(r)
                    }
                    setMinElevationForCurrentTile(r) {
                        this._helper.setMinElevationForCurrentTile(r)
                    }
                    setPadding(r) {
                        this._helper.setPadding(r)
                    }
                    interpolatePadding(r, a, m) {
                        return this._helper.interpolatePadding(r, a, m)
                    }
                    isPaddingEqual(r) {
                        return this._helper.isPaddingEqual(r)
                    }
                    resize(r, a, m=!0) {
                        this._helper.resize(r, a, m)
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds()
                    }
                    setMaxBounds(r) {
                        this._helper.setMaxBounds(r)
                    }
                    overrideNearFarZ(r, a) {
                        this._helper.overrideNearFarZ(r, a)
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride()
                    }
                    getCameraQueryGeometry(r) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), r)
                    }
                    get tileSize() {
                        return this._helper.tileSize
                    }
                    get tileZoom() {
                        return this._helper.tileZoom
                    }
                    get scale() {
                        return this._helper.scale
                    }
                    get worldSize() {
                        return this._helper.worldSize
                    }
                    get width() {
                        return this._helper.width
                    }
                    get height() {
                        return this._helper.height
                    }
                    get lngRange() {
                        return this._helper.lngRange
                    }
                    get latRange() {
                        return this._helper.latRange
                    }
                    get minZoom() {
                        return this._helper.minZoom
                    }
                    get maxZoom() {
                        return this._helper.maxZoom
                    }
                    get zoom() {
                        return this._helper.zoom
                    }
                    get center() {
                        return this._helper.center
                    }
                    get minPitch() {
                        return this._helper.minPitch
                    }
                    get maxPitch() {
                        return this._helper.maxPitch
                    }
                    get pitch() {
                        return this._helper.pitch
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians
                    }
                    get roll() {
                        return this._helper.roll
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians
                    }
                    get bearing() {
                        return this._helper.bearing
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians
                    }
                    get fov() {
                        return this._helper.fov
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians
                    }
                    get elevation() {
                        return this._helper.elevation
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile
                    }
                    get padding() {
                        return this._helper.padding
                    }
                    get unmodified() {
                        return this._helper.unmodified
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance
                    }
                    get nearZ() {
                        return this._helper.nearZ
                    }
                    get farZ() {
                        return this._helper.farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ
                    }
                    get isGlobeRendering() {
                        return this._globeness > 0
                    }
                    setTransitionState(r, a) {
                        this._globeness = r,
                        this._globeLatitudeErrorCorrectionRadians = a,
                        this._calcMatrices(),
                        this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(),
                        this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
                    }
                    get currentTransform() {
                        return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
                    }
                    constructor() {
                        this._globeLatitudeErrorCorrectionRadians = 0,
                        this._globeness = 1,
                        this._helper = new cs({
                            calcMatrices: () => {
                                this._calcMatrices()
                            }
                            ,
                            getConstrained: (r, a) => this.getConstrained(r, a)
                        }),
                        this._globeness = 1,
                        this._mercatorTransform = new mi,
                        this._verticalPerspectiveTransform = new uc
                    }
                    clone() {
                        const r = new Xo;
                        return r._globeness = this._globeness,
                        r._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians,
                        r.apply(this),
                        r
                    }
                    apply(r) {
                        this._helper.apply(r),
                        this._mercatorTransform.apply(this),
                        this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
                    }
                    get projectionMatrix() {
                        return this.currentTransform.projectionMatrix
                    }
                    get modelViewProjectionMatrix() {
                        return this.currentTransform.modelViewProjectionMatrix
                    }
                    get inverseProjectionMatrix() {
                        return this.currentTransform.inverseProjectionMatrix
                    }
                    get cameraPosition() {
                        return this.currentTransform.cameraPosition
                    }
                    getProjectionData(r) {
                        const a = this._mercatorTransform.getProjectionData(r)
                          , m = this._verticalPerspectiveTransform.getProjectionData(r);
                        return {
                            mainMatrix: this.isGlobeRendering ? m.mainMatrix : a.mainMatrix,
                            clippingPlane: m.clippingPlane,
                            tileMercatorCoords: m.tileMercatorCoords,
                            projectionTransition: r.applyGlobeMatrix ? this._globeness : 0,
                            fallbackMatrix: a.fallbackMatrix
                        }
                    }
                    isLocationOccluded(r) {
                        return this.currentTransform.isLocationOccluded(r)
                    }
                    transformLightDirection(r) {
                        return this.currentTransform.transformLightDirection(r)
                    }
                    getPixelScale() {
                        return o.bj(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
                    }
                    getCircleRadiusCorrection() {
                        return o.bj(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
                    }
                    getPitchedTextCorrection(r, a, m) {
                        const y = this._mercatorTransform.getPitchedTextCorrection(r, a, m)
                          , x = this._verticalPerspectiveTransform.getPitchedTextCorrection(r, a, m);
                        return o.bj(y, x, this._globeness)
                    }
                    projectTileCoordinates(r, a, m, y) {
                        return this.currentTransform.projectTileCoordinates(r, a, m, y)
                    }
                    _calcMatrices() {
                        this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians),
                        this._helper._nearZ = this._verticalPerspectiveTransform.nearZ,
                        this._helper._farZ = this._verticalPerspectiveTransform.farZ,
                        this._mercatorTransform.apply(this, !0, this.isGlobeRendering),
                        this._helper._nearZ = this._mercatorTransform.nearZ,
                        this._helper._farZ = this._mercatorTransform.farZ)
                    }
                    calculateFogMatrix(r) {
                        return this.currentTransform.calculateFogMatrix(r)
                    }
                    getVisibleUnwrappedCoordinates(r) {
                        return this.currentTransform.getVisibleUnwrappedCoordinates(r)
                    }
                    getCameraFrustum() {
                        return this.currentTransform.getCameraFrustum()
                    }
                    getClippingPlane() {
                        return this.currentTransform.getClippingPlane()
                    }
                    getCoveringTilesDetailsProvider() {
                        return this.currentTransform.getCoveringTilesDetailsProvider()
                    }
                    recalculateZoomAndCenter(r) {
                        this._mercatorTransform.recalculateZoomAndCenter(r),
                        this._verticalPerspectiveTransform.recalculateZoomAndCenter(r)
                    }
                    maxPitchScaleFactor() {
                        return this._mercatorTransform.maxPitchScaleFactor()
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint()
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude()
                    }
                    getCameraLngLat() {
                        return this._helper.getCameraLngLat()
                    }
                    lngLatToCameraDepth(r, a) {
                        return this.currentTransform.lngLatToCameraDepth(r, a)
                    }
                    populateCache(r) {
                        this._mercatorTransform.populateCache(r),
                        this._verticalPerspectiveTransform.populateCache(r)
                    }
                    getBounds() {
                        return this.currentTransform.getBounds()
                    }
                    getConstrained(r, a) {
                        return this.currentTransform.getConstrained(r, a)
                    }
                    calculateCenterFromCameraLngLatAlt(r, a, m, y) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(r, a, m, y)
                    }
                    setLocationAtPoint(r, a) {
                        if (!this.isGlobeRendering)
                            return this._mercatorTransform.setLocationAtPoint(r, a),
                            void this.apply(this._mercatorTransform);
                        this._verticalPerspectiveTransform.setLocationAtPoint(r, a),
                        this.apply(this._verticalPerspectiveTransform)
                    }
                    locationToScreenPoint(r, a) {
                        return this.currentTransform.locationToScreenPoint(r, a)
                    }
                    screenPointToMercatorCoordinate(r, a) {
                        return this.currentTransform.screenPointToMercatorCoordinate(r, a)
                    }
                    screenPointToLocation(r, a) {
                        return this.currentTransform.screenPointToLocation(r, a)
                    }
                    isPointOnMapSurface(r, a) {
                        return this.currentTransform.isPointOnMapSurface(r, a)
                    }
                    getRayDirectionFromPixel(r) {
                        return this._verticalPerspectiveTransform.getRayDirectionFromPixel(r)
                    }
                    getMatrixForModel(r, a) {
                        return this.currentTransform.getMatrixForModel(r, a)
                    }
                    getProjectionDataForCustomLayer(r=!0) {
                        const a = this._mercatorTransform.getProjectionDataForCustomLayer(r);
                        if (!this.isGlobeRendering)
                            return a;
                        const m = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(r);
                        return m.fallbackMatrix = a.mainMatrix,
                        m
                    }
                    getFastPathSimpleProjectionMatrix(r) {
                        return this.currentTransform.getFastPathSimpleProjectionMatrix(r)
                    }
                }
                class eo {
                    get useGlobeControls() {
                        return !0
                    }
                    handlePanInertia(r, a) {
                        const m = Cl(r, a);
                        return Math.abs(m.lng - a.center.lng) > 180 && (m.lng = a.center.lng + 179.5 * Math.sign(m.lng - a.center.lng)),
                        {
                            easingCenter: m,
                            easingOffset: new o.P(0,0)
                        }
                    }
                    handleMapControlsRollPitchBearingZoom(r, a) {
                        const m = r.around
                          , y = a.screenPointToLocation(m);
                        r.bearingDelta && a.setBearing(a.bearing + r.bearingDelta),
                        r.pitchDelta && a.setPitch(a.pitch + r.pitchDelta),
                        r.rollDelta && a.setRoll(a.roll + r.rollDelta);
                        const x = a.zoom;
                        r.zoomDelta && a.setZoom(a.zoom + r.zoomDelta);
                        const P = a.zoom - x;
                        if (P === 0)
                            return;
                        const I = o.bz(a.center.lng, y.lng)
                          , A = I / (Math.abs(I / 180) + 1)
                          , B = o.bz(a.center.lat, y.lat)
                          , $ = a.getRayDirectionFromPixel(m)
                          , Z = a.cameraPosition
                          , H = -1 * o.aW(Z, $)
                          , Y = o.bo();
                        o.aR(Y, Z, [$[0] * H, $[1] * H, $[2] * H]);
                        const ae = o.aY(Y) - 1
                          , ye = Math.exp(.5 * -Math.max(ae - .3, 0))
                          , Se = aa(a.worldSize, a.center.lat) / Math.min(a.width, a.height)
                          , Te = o.bm(Se, .9, .5, 1, .25)
                          , Re = (1 - o.ae(-P)) * Math.min(ye, Te)
                          , De = a.center.lat
                          , Ae = a.zoom
                          , Be = new o.S(a.center.lng + A * Re,o.ag(a.center.lat + B * Re, -o.ah, o.ah));
                        a.setLocationAtPoint(y, m);
                        const qe = a.center
                          , ze = o.bm(Math.abs(I), 45, 85, 0, 1)
                          , Ke = o.bm(Se, .75, .35, 0, 1)
                          , ht = Math.pow(Math.max(ze, Ke), .25)
                          , ot = o.bz(qe.lng, Be.lng)
                          , ut = o.bz(qe.lat, Be.lat);
                        a.setCenter(new o.S(qe.lng + ot * ht,qe.lat + ut * ht).wrap()),
                        a.setZoom(Ae + Zn(De, a.center.lat))
                    }
                    handleMapControlsPan(r, a, m) {
                        if (!r.panDelta)
                            return;
                        const y = a.center.lat
                          , x = a.zoom;
                        a.setCenter(Cl(r.panDelta, a).wrap()),
                        a.setZoom(x + Zn(y, a.center.lat))
                    }
                    cameraForBoxAndBearing(r, a, m, y, x) {
                        const P = Qn(r, a, m, y, x)
                          , I = a.left / x.width * 2 - 1
                          , A = (x.width - a.right) / x.width * 2 - 1
                          , B = a.top / x.height * -2 + 1
                          , $ = (x.height - a.bottom) / x.height * -2 + 1
                          , Z = o.bz(m.getWest(), m.getEast()) < 0
                          , H = Z ? m.getEast() : m.getWest()
                          , Y = Z ? m.getWest() : m.getEast()
                          , ae = Math.max(m.getNorth(), m.getSouth())
                          , ye = Math.min(m.getNorth(), m.getSouth())
                          , Se = H + .5 * o.bz(H, Y)
                          , Te = ae + .5 * o.bz(ae, ye)
                          , Re = x.clone();
                        Re.setCenter(P.center),
                        Re.setBearing(P.bearing),
                        Re.setPitch(0),
                        Re.setRoll(0),
                        Re.setZoom(P.zoom);
                        const De = Re.modelViewProjectionMatrix
                          , Ae = [ui(m.getNorthWest()), ui(m.getNorthEast()), ui(m.getSouthWest()), ui(m.getSouthEast()), ui(new o.S(Y,Te)), ui(new o.S(H,Te)), ui(new o.S(Se,ae)), ui(new o.S(Se,ye))]
                          , Be = ui(P.center);
                        let qe = Number.POSITIVE_INFINITY;
                        for (const ze of Ae)
                            I < 0 && (qe = eo.getLesserNonNegativeNonNull(qe, eo.solveVectorScale(ze, Be, De, "x", I))),
                            A > 0 && (qe = eo.getLesserNonNegativeNonNull(qe, eo.solveVectorScale(ze, Be, De, "x", A))),
                            B > 0 && (qe = eo.getLesserNonNegativeNonNull(qe, eo.solveVectorScale(ze, Be, De, "y", B))),
                            $ < 0 && (qe = eo.getLesserNonNegativeNonNull(qe, eo.solveVectorScale(ze, Be, De, "y", $)));
                        if (Number.isFinite(qe) && qe !== 0)
                            return P.zoom = Re.zoom + o.aj(qe),
                            P;
                        Ui()
                    }
                    handleJumpToCenterZoom(r, a) {
                        const m = r.center.lat
                          , y = r.getConstrained(a.center ? o.S.convert(a.center) : r.center, r.zoom).center;
                        r.setCenter(y.wrap());
                        const x = a.zoom !== void 0 ? +a.zoom : r.zoom + Zn(m, y.lat);
                        r.zoom !== x && r.setZoom(x)
                    }
                    handleEaseTo(r, a) {
                        const m = r.zoom
                          , y = r.center
                          , x = r.padding
                          , P = {
                            roll: r.roll,
                            pitch: r.pitch,
                            bearing: r.bearing
                        }
                          , I = {
                            roll: a.roll === void 0 ? r.roll : a.roll,
                            pitch: a.pitch === void 0 ? r.pitch : a.pitch,
                            bearing: a.bearing === void 0 ? r.bearing : a.bearing
                        }
                          , A = a.zoom !== void 0
                          , B = !r.isPaddingEqual(a.padding);
                        let $ = !1;
                        const Z = a.center ? o.S.convert(a.center) : y
                          , H = r.getConstrained(Z, m).center;
                        Qi(r, H);
                        const Y = r.clone();
                        Y.setCenter(H),
                        Y.setZoom(A ? +a.zoom : m + Zn(y.lat, Z.lat)),
                        Y.setBearing(a.bearing);
                        const ae = new o.P(o.ag(r.centerPoint.x + a.offsetAsPoint.x, 0, r.width),o.ag(r.centerPoint.y + a.offsetAsPoint.y, 0, r.height));
                        Y.setLocationAtPoint(H, ae);
                        const ye = (a.offset && a.offsetAsPoint.mag()) > 0 ? Y.center : H
                          , Se = A ? +a.zoom : m + Zn(y.lat, ye.lat)
                          , Te = m + Zn(y.lat, 0)
                          , Re = Se + Zn(ye.lat, 0)
                          , De = o.bz(y.lng, ye.lng)
                          , Ae = o.bz(y.lat, ye.lat)
                          , Be = o.ae(Re - Te);
                        return $ = Se !== m,
                        {
                            easeFunc: qe => {
                                if (o.bd(P, I) || ii({
                                    startEulerAngles: P,
                                    endEulerAngles: I,
                                    tr: r,
                                    k: qe,
                                    useSlerp: P.roll != I.roll
                                }),
                                B && r.interpolatePadding(x, a.padding, qe),
                                a.around)
                                    o.w("Easing around a point is not supported under globe projection."),
                                    r.setLocationAtPoint(a.around, a.aroundPoint);
                                else {
                                    const ze = Re > Te ? Math.min(2, Be) : Math.max(.5, Be)
                                      , Ke = Math.pow(ze, 1 - qe)
                                      , ht = lc(y, De, Ae, qe * Ke);
                                    r.setCenter(ht.wrap())
                                }
                                if ($) {
                                    const ze = o.C.number(Te, Re, qe) + Zn(0, r.center.lat);
                                    r.setZoom(ze)
                                }
                            }
                            ,
                            isZooming: $,
                            elevationCenter: ye
                        }
                    }
                    handleFlyTo(r, a) {
                        const m = a.zoom !== void 0
                          , y = r.center
                          , x = r.zoom
                          , P = r.padding
                          , I = !r.isPaddingEqual(a.padding)
                          , A = r.getConstrained(o.S.convert(a.center || a.locationAtOffset), x).center
                          , B = m ? +a.zoom : r.zoom + Zn(r.center.lat, A.lat)
                          , $ = r.clone();
                        $.setCenter(A),
                        $.setZoom(B),
                        $.setBearing(a.bearing);
                        const Z = new o.P(o.ag(r.centerPoint.x + a.offsetAsPoint.x, 0, r.width),o.ag(r.centerPoint.y + a.offsetAsPoint.y, 0, r.height));
                        $.setLocationAtPoint(A, Z);
                        const H = $.center;
                        Qi(r, H);
                        const Y = function(Ae, Be, qe) {
                            const ze = ui(Be)
                              , Ke = ui(qe)
                              , ht = o.aW(ze, Ke)
                              , ot = Math.acos(ht)
                              , ut = Oa(Ae);
                            return ot / (2 * Math.PI) * ut
                        }(r, y, H)
                          , ae = x + Zn(y.lat, 0)
                          , ye = B + Zn(H.lat, 0)
                          , Se = o.ae(ye - ae);
                        let Te;
                        if (typeof a.minZoom == "number") {
                            const Ae = +a.minZoom + Zn(H.lat, 0)
                              , Be = Math.min(Ae, ae, ye) + Zn(0, H.lat)
                              , qe = r.getConstrained(H, Be).zoom + Zn(H.lat, 0);
                            Te = o.ae(qe - ae)
                        }
                        const Re = o.bz(y.lng, H.lng)
                          , De = o.bz(y.lat, H.lat);
                        return {
                            easeFunc: (Ae, Be, qe, ze) => {
                                const Ke = lc(y, Re, De, qe);
                                I && r.interpolatePadding(P, a.padding, Ae);
                                const ht = Ae === 1 ? H : Ke;
                                r.setCenter(ht.wrap());
                                const ot = ae + o.aj(Be);
                                r.setZoom(Ae === 1 ? B : ot + Zn(0, ht.lat))
                            }
                            ,
                            scaleOfZoom: Se,
                            targetCenter: H,
                            scaleOfMinZoom: Te,
                            pixelPathLength: Y
                        }
                    }
                    static solveVectorScale(r, a, m, y, x) {
                        const P = y === "x" ? [m[0], m[4], m[8], m[12]] : [m[1], m[5], m[9], m[13]]
                          , I = [m[3], m[7], m[11], m[15]]
                          , A = r[0] * P[0] + r[1] * P[1] + r[2] * P[2]
                          , B = r[0] * I[0] + r[1] * I[1] + r[2] * I[2]
                          , $ = a[0] * P[0] + a[1] * P[1] + a[2] * P[2]
                          , Z = a[0] * I[0] + a[1] * I[1] + a[2] * I[2];
                        return $ + x * B === A + x * Z || I[3] * (A - $) + P[3] * (Z - B) + A * Z == $ * B ? null : ($ + P[3] - x * Z - x * I[3]) / ($ - A - x * Z + x * B)
                    }
                    static getLesserNonNegativeNonNull(r, a) {
                        return a !== null && a >= 0 && a < r ? a : r
                    }
                }
                class ad {
                    constructor(r) {
                        this._globe = r,
                        this._mercatorCameraHelper = new lu,
                        this._verticalPerspectiveCameraHelper = new eo
                    }
                    get useGlobeControls() {
                        return this._globe.useGlobeRendering
                    }
                    get currentHelper() {
                        return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
                    }
                    handlePanInertia(r, a) {
                        return this.currentHelper.handlePanInertia(r, a)
                    }
                    handleMapControlsRollPitchBearingZoom(r, a) {
                        return this.currentHelper.handleMapControlsRollPitchBearingZoom(r, a)
                    }
                    handleMapControlsPan(r, a, m) {
                        this.currentHelper.handleMapControlsPan(r, a, m)
                    }
                    cameraForBoxAndBearing(r, a, m, y, x) {
                        return this.currentHelper.cameraForBoxAndBearing(r, a, m, y, x)
                    }
                    handleJumpToCenterZoom(r, a) {
                        this.currentHelper.handleJumpToCenterZoom(r, a)
                    }
                    handleEaseTo(r, a) {
                        return this.currentHelper.handleEaseTo(r, a)
                    }
                    handleFlyTo(r, a) {
                        return this.currentHelper.handleFlyTo(r, a)
                    }
                }
                const cu = (v, r) => o.y(v, r && r.filter(a => a.identifier !== "source.canvas"))
                  , hc = o.bD();
                class ld extends o.E {
                    constructor(r, a={}) {
                        super(),
                        this._rtlPluginLoaded = () => {
                            for (const m in this.sourceCaches) {
                                const y = this.sourceCaches[m].getSource().type;
                                y !== "vector" && y !== "geojson" || this.sourceCaches[m].reload()
                            }
                        }
                        ,
                        this.map = r,
                        this.dispatcher = new Wt(Qt(),r._getMapId()),
                        this.dispatcher.registerMessageHandler("GG", (m, y) => this.getGlyphs(m, y)),
                        this.dispatcher.registerMessageHandler("GI", (m, y) => this.getImages(m, y)),
                        this.imageManager = new Ee,
                        this.imageManager.setEventedParent(this),
                        this.glyphManager = new nt(r._requestManager,a.localIdeographFontFamily),
                        this.lineAtlas = new lt(256,512),
                        this.crossTileSymbolIndex = new ic,
                        this._spritesImagesIds = {},
                        this._layers = {},
                        this._order = [],
                        this.sourceCaches = {},
                        this.zoomHistory = new o.bE,
                        this._loaded = !1,
                        this._availableImages = [],
                        this._globalState = {},
                        this._resetUpdates(),
                        this.dispatcher.broadcast("SR", o.bF()),
                        sn().on(yn, this._rtlPluginLoaded),
                        this.on("data", m => {
                            if (m.dataType !== "source" || m.sourceDataType !== "metadata")
                                return;
                            const y = this.sourceCaches[m.sourceId];
                            if (!y)
                                return;
                            const x = y.getSource();
                            if (x && x.vectorLayerIds)
                                for (const P in this._layers) {
                                    const I = this._layers[P];
                                    I.source === x.id && this._validateLayer(I)
                                }
                        }
                        )
                    }
                    setGlobalStateProperty(r, a) {
                        var m, y, x;
                        this._checkLoaded();
                        const P = a === null ? (x = (y = (m = this.stylesheet.state) === null || m === void 0 ? void 0 : m[r]) === null || y === void 0 ? void 0 : y.default) !== null && x !== void 0 ? x : null : a;
                        if (o.bG(P, this._globalState[r]))
                            return this;
                        this._globalState[r] = P;
                        const I = this._findGlobalStateAffectedSources([r]);
                        for (const A in this.sourceCaches)
                            I.has(A) && (this._reloadSource(A),
                            this._changed = !0)
                    }
                    getGlobalState() {
                        return this._globalState
                    }
                    setGlobalState(r) {
                        this._checkLoaded();
                        const a = [];
                        for (const y in r)
                            !o.bG(this._globalState[y], r[y].default) && (a.push(y),
                            this._globalState[y] = r[y].default);
                        const m = this._findGlobalStateAffectedSources(a);
                        for (const y in this.sourceCaches)
                            m.has(y) && (this._reloadSource(y),
                            this._changed = !0)
                    }
                    _findGlobalStateAffectedSources(r) {
                        if (r.length === 0)
                            return new Set;
                        const a = new Set;
                        for (const m in this._layers) {
                            const y = this._layers[m]
                              , x = y.getLayoutAffectingGlobalStateRefs();
                            for (const P of r)
                                x.has(P) && a.add(y.source)
                        }
                        return a
                    }
                    loadURL(r, a={}, m) {
                        this.fire(new o.l("dataloading",{
                            dataType: "style"
                        })),
                        a.validate = typeof a.validate != "boolean" || a.validate;
                        const y = this.map._requestManager.transformRequest(r, "Style");
                        this._loadStyleRequest = new AbortController;
                        const x = this._loadStyleRequest;
                        o.j(y, this._loadStyleRequest).then(P => {
                            this._loadStyleRequest = null,
                            this._load(P.data, a, m)
                        }
                        ).catch(P => {
                            this._loadStyleRequest = null,
                            P && !x.signal.aborted && this.fire(new o.k(P))
                        }
                        )
                    }
                    loadJSON(r, a={}, m) {
                        this.fire(new o.l("dataloading",{
                            dataType: "style"
                        })),
                        this._frameRequest = new AbortController,
                        z.frameAsync(this._frameRequest).then( () => {
                            this._frameRequest = null,
                            a.validate = a.validate !== !1,
                            this._load(r, a, m)
                        }
                        ).catch( () => {}
                        )
                    }
                    loadEmpty() {
                        this.fire(new o.l("dataloading",{
                            dataType: "style"
                        })),
                        this._load(hc, {
                            validate: !1
                        })
                    }
                    _load(r, a, m) {
                        var y, x, P;
                        const I = a.transformStyle ? a.transformStyle(m, r) : r;
                        if (!a.validate || !cu(this, o.z(I))) {
                            this._loaded = !0,
                            this.stylesheet = I;
                            for (const A in I.sources)
                                this.addSource(A, I.sources[A], {
                                    validate: !1
                                });
                            I.sprite ? this._loadSprite(I.sprite) : this.imageManager.setLoaded(!0),
                            this.glyphManager.setURL(I.glyphs),
                            this._createLayers(),
                            this.light = new ve(this.stylesheet.light),
                            this._setProjectionInternal(((y = this.stylesheet.projection) === null || y === void 0 ? void 0 : y.type) || "mercator"),
                            this.sky = new je(this.stylesheet.sky),
                            this.map.setTerrain((x = this.stylesheet.terrain) !== null && x !== void 0 ? x : null),
                            this.setGlobalState((P = this.stylesheet.state) !== null && P !== void 0 ? P : null),
                            this.fire(new o.l("data",{
                                dataType: "style"
                            })),
                            this.fire(new o.l("style.load"))
                        }
                    }
                    _createLayers() {
                        const r = o.bH(this.stylesheet.layers);
                        this.dispatcher.broadcast("SL", r),
                        this._order = r.map(a => a.id),
                        this._layers = {},
                        this._serializedLayers = null;
                        for (const a of r) {
                            const m = o.bI(a);
                            m.setEventedParent(this, {
                                layer: {
                                    id: a.id
                                }
                            }),
                            this._layers[a.id] = m
                        }
                    }
                    _loadSprite(r, a=!1, m=void 0) {
                        let y;
                        this.imageManager.setLoaded(!1),
                        this._spriteRequest = new AbortController,
                        function(x, P, I, A) {
                            return o._(this, void 0, void 0, function*() {
                                const B = me(x)
                                  , $ = I > 1 ? "@2x" : ""
                                  , Z = {}
                                  , H = {};
                                for (const {id: Y, url: ae} of B) {
                                    const ye = P.transformRequest(K(ae, $, ".json"), "SpriteJSON");
                                    Z[Y] = o.j(ye, A);
                                    const Se = P.transformRequest(K(ae, $, ".png"), "SpriteImage");
                                    H[Y] = ce.getImage(Se, A)
                                }
                                return yield Promise.all([...Object.values(Z), ...Object.values(H)]),
                                function(Y, ae) {
                                    return o._(this, void 0, void 0, function*() {
                                        const ye = {};
                                        for (const Se in Y) {
                                            ye[Se] = {};
                                            const Te = z.getImageCanvasContext((yield ae[Se]).data)
                                              , Re = (yield Y[Se]).data;
                                            for (const De in Re) {
                                                const {width: Ae, height: Be, x: qe, y: ze, sdf: Ke, pixelRatio: ht, stretchX: ot, stretchY: ut, content: mt, textFitWidth: $t, textFitHeight: jt} = Re[De];
                                                ye[Se][De] = {
                                                    data: null,
                                                    pixelRatio: ht,
                                                    sdf: Ke,
                                                    stretchX: ot,
                                                    stretchY: ut,
                                                    content: mt,
                                                    textFitWidth: $t,
                                                    textFitHeight: jt,
                                                    spriteData: {
                                                        width: Ae,
                                                        height: Be,
                                                        x: qe,
                                                        y: ze,
                                                        context: Te
                                                    }
                                                }
                                            }
                                        }
                                        return ye
                                    })
                                }(Z, H)
                            })
                        }(r, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(x => {
                            if (this._spriteRequest = null,
                            x)
                                for (const P in x) {
                                    this._spritesImagesIds[P] = [];
                                    const I = this._spritesImagesIds[P] ? this._spritesImagesIds[P].filter(A => !(A in x)) : [];
                                    for (const A of I)
                                        this.imageManager.removeImage(A),
                                        this._changedImages[A] = !0;
                                    for (const A in x[P]) {
                                        const B = P === "default" ? A : `${P}:${A}`;
                                        this._spritesImagesIds[P].push(B),
                                        B in this.imageManager.images ? this.imageManager.updateImage(B, x[P][A], !1) : this.imageManager.addImage(B, x[P][A]),
                                        a && (this._changedImages[B] = !0)
                                    }
                                }
                        }
                        ).catch(x => {
                            this._spriteRequest = null,
                            y = x,
                            this.fire(new o.k(y))
                        }
                        ).finally( () => {
                            this.imageManager.setLoaded(!0),
                            this._availableImages = this.imageManager.listImages(),
                            a && (this._changed = !0),
                            this.dispatcher.broadcast("SI", this._availableImages),
                            this.fire(new o.l("data",{
                                dataType: "style"
                            })),
                            m && m(y)
                        }
                        )
                    }
                    _unloadSprite() {
                        for (const r of Object.values(this._spritesImagesIds).flat())
                            this.imageManager.removeImage(r),
                            this._changedImages[r] = !0;
                        this._spritesImagesIds = {},
                        this._availableImages = this.imageManager.listImages(),
                        this._changed = !0,
                        this.dispatcher.broadcast("SI", this._availableImages),
                        this.fire(new o.l("data",{
                            dataType: "style"
                        }))
                    }
                    _validateLayer(r) {
                        const a = this.sourceCaches[r.source];
                        if (!a)
                            return;
                        const m = r.sourceLayer;
                        if (!m)
                            return;
                        const y = a.getSource();
                        (y.type === "geojson" || y.vectorLayerIds && y.vectorLayerIds.indexOf(m) === -1) && this.fire(new o.k(new Error(`Source layer "${m}" does not exist on source "${y.id}" as specified by style layer "${r.id}".`)))
                    }
                    loaded() {
                        if (!this._loaded || Object.keys(this._updatedSources).length)
                            return !1;
                        for (const r in this.sourceCaches)
                            if (!this.sourceCaches[r].loaded())
                                return !1;
                        return !!this.imageManager.isLoaded()
                    }
                    _serializeByIds(r, a=!1) {
                        const m = this._serializedAllLayers();
                        if (!r || r.length === 0)
                            return Object.values(a ? o.bJ(m) : m);
                        const y = [];
                        for (const x of r)
                            if (m[x]) {
                                const P = a ? o.bJ(m[x]) : m[x];
                                y.push(P)
                            }
                        return y
                    }
                    _serializedAllLayers() {
                        let r = this._serializedLayers;
                        if (r)
                            return r;
                        r = this._serializedLayers = {};
                        const a = Object.keys(this._layers);
                        for (const m of a) {
                            const y = this._layers[m];
                            y.type !== "custom" && (r[m] = y.serialize())
                        }
                        return r
                    }
                    hasTransitions() {
                        var r, a, m;
                        if (!((r = this.light) === null || r === void 0) && r.hasTransition() || !((a = this.sky) === null || a === void 0) && a.hasTransition() || !((m = this.projection) === null || m === void 0) && m.hasTransition())
                            return !0;
                        for (const y in this.sourceCaches)
                            if (this.sourceCaches[y].hasTransition())
                                return !0;
                        for (const y in this._layers)
                            if (this._layers[y].hasTransition())
                                return !0;
                        return !1
                    }
                    _checkLoaded() {
                        if (!this._loaded)
                            throw new Error("Style is not done loading.")
                    }
                    update(r) {
                        if (!this._loaded)
                            return;
                        const a = this._changed;
                        if (a) {
                            const y = Object.keys(this._updatedLayers)
                              , x = Object.keys(this._removedLayers);
                            (y.length || x.length) && this._updateWorkerLayers(y, x);
                            for (const P in this._updatedSources) {
                                const I = this._updatedSources[P];
                                if (I === "reload")
                                    this._reloadSource(P);
                                else {
                                    if (I !== "clear")
                                        throw new Error(`Invalid action ${I}`);
                                    this._clearSource(P)
                                }
                            }
                            this._updateTilesForChangedImages(),
                            this._updateTilesForChangedGlyphs();
                            for (const P in this._updatedPaintProps)
                                this._layers[P].updateTransitions(r);
                            this.light.updateTransitions(r),
                            this.sky.updateTransitions(r),
                            this._resetUpdates()
                        }
                        const m = {};
                        for (const y in this.sourceCaches) {
                            const x = this.sourceCaches[y];
                            m[y] = x.used,
                            x.used = !1
                        }
                        for (const y of this._order) {
                            const x = this._layers[y];
                            x.recalculate(r, this._availableImages),
                            !x.isHidden(r.zoom) && x.source && (this.sourceCaches[x.source].used = !0)
                        }
                        for (const y in m) {
                            const x = this.sourceCaches[y];
                            !!m[y] != !!x.used && x.fire(new o.l("data",{
                                sourceDataType: "visibility",
                                dataType: "source",
                                sourceId: y
                            }))
                        }
                        this.light.recalculate(r),
                        this.sky.recalculate(r),
                        this.projection.recalculate(r),
                        this.z = r.zoom,
                        a && this.fire(new o.l("data",{
                            dataType: "style"
                        }))
                    }
                    _updateTilesForChangedImages() {
                        const r = Object.keys(this._changedImages);
                        if (r.length) {
                            for (const a in this.sourceCaches)
                                this.sourceCaches[a].reloadTilesForDependencies(["icons", "patterns"], r);
                            this._changedImages = {}
                        }
                    }
                    _updateTilesForChangedGlyphs() {
                        if (this._glyphsDidChange) {
                            for (const r in this.sourceCaches)
                                this.sourceCaches[r].reloadTilesForDependencies(["glyphs"], [""]);
                            this._glyphsDidChange = !1
                        }
                    }
                    _updateWorkerLayers(r, a) {
                        this.dispatcher.broadcast("UL", {
                            layers: this._serializeByIds(r, !1),
                            removedIds: a
                        })
                    }
                    _resetUpdates() {
                        this._changed = !1,
                        this._updatedLayers = {},
                        this._removedLayers = {},
                        this._updatedSources = {},
                        this._updatedPaintProps = {},
                        this._changedImages = {},
                        this._glyphsDidChange = !1
                    }
                    setState(r, a={}) {
                        var m;
                        this._checkLoaded();
                        const y = this.serialize();
                        if (r = a.transformStyle ? a.transformStyle(y, r) : r,
                        ((m = a.validate) === null || m === void 0 || m) && cu(this, o.z(r)))
                            return !1;
                        (r = o.bJ(r)).layers = o.bH(r.layers);
                        const x = o.bK(y, r)
                          , P = this._getOperationsToPerform(x);
                        if (P.unimplemented.length > 0)
                            throw new Error(`Unimplemented: ${P.unimplemented.join(", ")}.`);
                        if (P.operations.length === 0)
                            return !1;
                        for (const I of P.operations)
                            I();
                        return this.stylesheet = r,
                        this._serializedLayers = null,
                        !0
                    }
                    _getOperationsToPerform(r) {
                        const a = []
                          , m = [];
                        for (const y of r)
                            switch (y.command) {
                            case "setCenter":
                            case "setZoom":
                            case "setBearing":
                            case "setPitch":
                            case "setRoll":
                                continue;
                            case "addLayer":
                                a.push( () => this.addLayer.apply(this, y.args));
                                break;
                            case "removeLayer":
                                a.push( () => this.removeLayer.apply(this, y.args));
                                break;
                            case "setPaintProperty":
                                a.push( () => this.setPaintProperty.apply(this, y.args));
                                break;
                            case "setLayoutProperty":
                                a.push( () => this.setLayoutProperty.apply(this, y.args));
                                break;
                            case "setFilter":
                                a.push( () => this.setFilter.apply(this, y.args));
                                break;
                            case "addSource":
                                a.push( () => this.addSource.apply(this, y.args));
                                break;
                            case "removeSource":
                                a.push( () => this.removeSource.apply(this, y.args));
                                break;
                            case "setLayerZoomRange":
                                a.push( () => this.setLayerZoomRange.apply(this, y.args));
                                break;
                            case "setLight":
                                a.push( () => this.setLight.apply(this, y.args));
                                break;
                            case "setGeoJSONSourceData":
                                a.push( () => this.setGeoJSONSourceData.apply(this, y.args));
                                break;
                            case "setGlyphs":
                                a.push( () => this.setGlyphs.apply(this, y.args));
                                break;
                            case "setSprite":
                                a.push( () => this.setSprite.apply(this, y.args));
                                break;
                            case "setTerrain":
                                a.push( () => this.map.setTerrain.apply(this, y.args));
                                break;
                            case "setSky":
                                a.push( () => this.setSky.apply(this, y.args));
                                break;
                            case "setProjection":
                                this.setProjection.apply(this, y.args);
                                break;
                            case "setGlobalState":
                                a.push( () => this.setGlobalState.apply(this, y.args));
                                break;
                            case "setTransition":
                                a.push( () => {}
                                );
                                break;
                            default:
                                m.push(y.command)
                            }
                        return {
                            operations: a,
                            unimplemented: m
                        }
                    }
                    addImage(r, a) {
                        if (this.getImage(r))
                            return this.fire(new o.k(new Error(`An image named "${r}" already exists.`)));
                        this.imageManager.addImage(r, a),
                        this._afterImageUpdated(r)
                    }
                    updateImage(r, a) {
                        this.imageManager.updateImage(r, a)
                    }
                    getImage(r) {
                        return this.imageManager.getImage(r)
                    }
                    removeImage(r) {
                        if (!this.getImage(r))
                            return this.fire(new o.k(new Error(`An image named "${r}" does not exist.`)));
                        this.imageManager.removeImage(r),
                        this._afterImageUpdated(r)
                    }
                    _afterImageUpdated(r) {
                        this._availableImages = this.imageManager.listImages(),
                        this._changedImages[r] = !0,
                        this._changed = !0,
                        this.dispatcher.broadcast("SI", this._availableImages),
                        this.fire(new o.l("data",{
                            dataType: "style"
                        }))
                    }
                    listImages() {
                        return this._checkLoaded(),
                        this.imageManager.listImages()
                    }
                    addSource(r, a, m={}) {
                        if (this._checkLoaded(),
                        this.sourceCaches[r] !== void 0)
                            throw new Error(`Source "${r}" already exists.`);
                        if (!a.type)
                            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(a).join(", ")}.`);
                        if (["vector", "raster", "geojson", "video", "image"].indexOf(a.type) >= 0 && this._validate(o.z.source, `sources.${r}`, a, null, m))
                            return;
                        this.map && this.map._collectResourceTiming && (a.collectResourceTiming = !0);
                        const y = this.sourceCaches[r] = new St(r,a,this.dispatcher);
                        y.style = this,
                        y.setEventedParent(this, () => ({
                            isSourceLoaded: y.loaded(),
                            source: y.serialize(),
                            sourceId: r
                        })),
                        y.onAdd(this.map),
                        this._changed = !0
                    }
                    removeSource(r) {
                        if (this._checkLoaded(),
                        this.sourceCaches[r] === void 0)
                            throw new Error("There is no source with this ID");
                        for (const m in this._layers)
                            if (this._layers[m].source === r)
                                return this.fire(new o.k(new Error(`Source "${r}" cannot be removed while layer "${m}" is using it.`)));
                        const a = this.sourceCaches[r];
                        delete this.sourceCaches[r],
                        delete this._updatedSources[r],
                        a.fire(new o.l("data",{
                            sourceDataType: "metadata",
                            dataType: "source",
                            sourceId: r
                        })),
                        a.setEventedParent(null),
                        a.onRemove(this.map),
                        this._changed = !0
                    }
                    setGeoJSONSourceData(r, a) {
                        if (this._checkLoaded(),
                        this.sourceCaches[r] === void 0)
                            throw new Error(`There is no source with this ID=${r}`);
                        const m = this.sourceCaches[r].getSource();
                        if (m.type !== "geojson")
                            throw new Error(`geojsonSource.type is ${m.type}, which is !== 'geojson`);
                        m.setData(a),
                        this._changed = !0
                    }
                    getSource(r) {
                        return this.sourceCaches[r] && this.sourceCaches[r].getSource()
                    }
                    addLayer(r, a, m={}) {
                        this._checkLoaded();
                        const y = r.id;
                        if (this.getLayer(y))
                            return void this.fire(new o.k(new Error(`Layer "${y}" already exists on this map.`)));
                        let x;
                        if (r.type === "custom") {
                            if (cu(this, o.bL(r)))
                                return;
                            x = o.bI(r)
                        } else {
                            if ("source"in r && typeof r.source == "object" && (this.addSource(y, r.source),
                            r = o.bJ(r),
                            r = o.e(r, {
                                source: y
                            })),
                            this._validate(o.z.layer, `layers.${y}`, r, {
                                arrayIndex: -1
                            }, m))
                                return;
                            x = o.bI(r),
                            this._validateLayer(x),
                            x.setEventedParent(this, {
                                layer: {
                                    id: y
                                }
                            })
                        }
                        const P = a ? this._order.indexOf(a) : this._order.length;
                        if (a && P === -1)
                            this.fire(new o.k(new Error(`Cannot add layer "${y}" before non-existing layer "${a}".`)));
                        else {
                            if (this._order.splice(P, 0, y),
                            this._layerOrderChanged = !0,
                            this._layers[y] = x,
                            this._removedLayers[y] && x.source && x.type !== "custom") {
                                const I = this._removedLayers[y];
                                delete this._removedLayers[y],
                                I.type !== x.type ? this._updatedSources[x.source] = "clear" : (this._updatedSources[x.source] = "reload",
                                this.sourceCaches[x.source].pause())
                            }
                            this._updateLayer(x),
                            x.onAdd && x.onAdd(this.map)
                        }
                    }
                    moveLayer(r, a) {
                        if (this._checkLoaded(),
                        this._changed = !0,
                        !this._layers[r])
                            return void this.fire(new o.k(new Error(`The layer '${r}' does not exist in the map's style and cannot be moved.`)));
                        if (r === a)
                            return;
                        const m = this._order.indexOf(r);
                        this._order.splice(m, 1);
                        const y = a ? this._order.indexOf(a) : this._order.length;
                        a && y === -1 ? this.fire(new o.k(new Error(`Cannot move layer "${r}" before non-existing layer "${a}".`))) : (this._order.splice(y, 0, r),
                        this._layerOrderChanged = !0)
                    }
                    removeLayer(r) {
                        this._checkLoaded();
                        const a = this._layers[r];
                        if (!a)
                            return void this.fire(new o.k(new Error(`Cannot remove non-existing layer "${r}".`)));
                        a.setEventedParent(null);
                        const m = this._order.indexOf(r);
                        this._order.splice(m, 1),
                        this._layerOrderChanged = !0,
                        this._changed = !0,
                        this._removedLayers[r] = a,
                        delete this._layers[r],
                        this._serializedLayers && delete this._serializedLayers[r],
                        delete this._updatedLayers[r],
                        delete this._updatedPaintProps[r],
                        a.onRemove && a.onRemove(this.map)
                    }
                    getLayer(r) {
                        return this._layers[r]
                    }
                    getLayersOrder() {
                        return [...this._order]
                    }
                    hasLayer(r) {
                        return r in this._layers
                    }
                    setLayerZoomRange(r, a, m) {
                        this._checkLoaded();
                        const y = this.getLayer(r);
                        y ? y.minzoom === a && y.maxzoom === m || (a != null && (y.minzoom = a),
                        m != null && (y.maxzoom = m),
                        this._updateLayer(y)) : this.fire(new o.k(new Error(`Cannot set the zoom range of non-existing layer "${r}".`)))
                    }
                    setFilter(r, a, m={}) {
                        this._checkLoaded();
                        const y = this.getLayer(r);
                        if (y) {
                            if (!o.bG(y.filter, a))
                                return a == null ? (y.setFilter(void 0),
                                void this._updateLayer(y)) : void (this._validate(o.z.filter, `layers.${y.id}.filter`, a, null, m) || (y.setFilter(o.bJ(a)),
                                this._updateLayer(y)))
                        } else
                            this.fire(new o.k(new Error(`Cannot filter non-existing layer "${r}".`)))
                    }
                    getFilter(r) {
                        return o.bJ(this.getLayer(r).filter)
                    }
                    setLayoutProperty(r, a, m, y={}) {
                        this._checkLoaded();
                        const x = this.getLayer(r);
                        x ? o.bG(x.getLayoutProperty(a), m) || (x.setLayoutProperty(a, m, y),
                        this._updateLayer(x)) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${r}".`)))
                    }
                    getLayoutProperty(r, a) {
                        const m = this.getLayer(r);
                        if (m)
                            return m.getLayoutProperty(a);
                        this.fire(new o.k(new Error(`Cannot get style of non-existing layer "${r}".`)))
                    }
                    setPaintProperty(r, a, m, y={}) {
                        this._checkLoaded();
                        const x = this.getLayer(r);
                        x ? o.bG(x.getPaintProperty(a), m) || (x.setPaintProperty(a, m, y) && this._updateLayer(x),
                        this._changed = !0,
                        this._updatedPaintProps[r] = !0,
                        this._serializedLayers = null) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${r}".`)))
                    }
                    getPaintProperty(r, a) {
                        return this.getLayer(r).getPaintProperty(a)
                    }
                    setFeatureState(r, a) {
                        this._checkLoaded();
                        const m = r.source
                          , y = r.sourceLayer
                          , x = this.sourceCaches[m];
                        if (x === void 0)
                            return void this.fire(new o.k(new Error(`The source '${m}' does not exist in the map's style.`)));
                        const P = x.getSource().type;
                        P === "geojson" && y ? this.fire(new o.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : P !== "vector" || y ? (r.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))),
                        x.setFeatureState(y, r.id, a)) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
                    }
                    removeFeatureState(r, a) {
                        this._checkLoaded();
                        const m = r.source
                          , y = this.sourceCaches[m];
                        if (y === void 0)
                            return void this.fire(new o.k(new Error(`The source '${m}' does not exist in the map's style.`)));
                        const x = y.getSource().type
                          , P = x === "vector" ? r.sourceLayer : void 0;
                        x !== "vector" || P ? a && typeof r.id != "string" && typeof r.id != "number" ? this.fire(new o.k(new Error("A feature id is required to remove its specific state property."))) : y.removeFeatureState(P, r.id, a) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
                    }
                    getFeatureState(r) {
                        this._checkLoaded();
                        const a = r.source
                          , m = r.sourceLayer
                          , y = this.sourceCaches[a];
                        if (y !== void 0)
                            return y.getSource().type !== "vector" || m ? (r.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))),
                            y.getFeatureState(m, r.id)) : void this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
                        this.fire(new o.k(new Error(`The source '${a}' does not exist in the map's style.`)))
                    }
                    getTransition() {
                        return o.e({
                            duration: 300,
                            delay: 0
                        }, this.stylesheet && this.stylesheet.transition)
                    }
                    serialize() {
                        if (!this._loaded)
                            return;
                        const r = o.bM(this.sourceCaches, x => x.serialize())
                          , a = this._serializeByIds(this._order, !0)
                          , m = this.map.getTerrain() || void 0
                          , y = this.stylesheet;
                        return o.bN({
                            version: y.version,
                            name: y.name,
                            metadata: y.metadata,
                            light: y.light,
                            sky: y.sky,
                            center: y.center,
                            zoom: y.zoom,
                            bearing: y.bearing,
                            pitch: y.pitch,
                            sprite: y.sprite,
                            glyphs: y.glyphs,
                            transition: y.transition,
                            projection: y.projection,
                            sources: r,
                            layers: a,
                            terrain: m
                        }, x => x !== void 0)
                    }
                    _updateLayer(r) {
                        this._updatedLayers[r.id] = !0,
                        r.source && !this._updatedSources[r.source] && this.sourceCaches[r.source].getSource().type !== "raster" && (this._updatedSources[r.source] = "reload",
                        this.sourceCaches[r.source].pause()),
                        this._serializedLayers = null,
                        this._changed = !0
                    }
                    _flattenAndSortRenderedFeatures(r) {
                        const a = P => this._layers[P].type === "fill-extrusion"
                          , m = {}
                          , y = [];
                        for (let P = this._order.length - 1; P >= 0; P--) {
                            const I = this._order[P];
                            if (a(I)) {
                                m[I] = P;
                                for (const A of r) {
                                    const B = A[I];
                                    if (B)
                                        for (const $ of B)
                                            y.push($)
                                }
                            }
                        }
                        y.sort( (P, I) => I.intersectionZ - P.intersectionZ);
                        const x = [];
                        for (let P = this._order.length - 1; P >= 0; P--) {
                            const I = this._order[P];
                            if (a(I))
                                for (let A = y.length - 1; A >= 0; A--) {
                                    const B = y[A].feature;
                                    if (m[B.layer.id] < P)
                                        break;
                                    x.push(B),
                                    y.pop()
                                }
                            else
                                for (const A of r) {
                                    const B = A[I];
                                    if (B)
                                        for (const $ of B)
                                            x.push($.feature)
                                }
                        }
                        return x
                    }
                    queryRenderedFeatures(r, a, m) {
                        a && a.filter && this._validate(o.z.filter, "queryRenderedFeatures.filter", a.filter, null, a);
                        const y = {};
                        if (a && a.layers) {
                            if (!(Array.isArray(a.layers) || a.layers instanceof Set))
                                return this.fire(new o.k(new Error("parameters.layers must be an Array or a Set of strings"))),
                                [];
                            for (const B of a.layers) {
                                const $ = this._layers[B];
                                if (!$)
                                    return this.fire(new o.k(new Error(`The layer '${B}' does not exist in the map's style and cannot be queried for features.`))),
                                    [];
                                y[$.source] = !0
                            }
                        }
                        const x = [];
                        a.availableImages = this._availableImages;
                        const P = this._serializedAllLayers()
                          , I = a.layers instanceof Set ? a.layers : Array.isArray(a.layers) ? new Set(a.layers) : null
                          , A = Object.assign(Object.assign({}, a), {
                            layers: I
                        });
                        for (const B in this.sourceCaches)
                            a.layers && !y[B] || x.push(Yt(this.sourceCaches[B], this._layers, P, r, A, m, this.map.terrain ? ($, Z, H) => this.map.terrain.getElevation($, Z, H) : void 0));
                        return this.placement && x.push(function(B, $, Z, H, Y, ae, ye) {
                            const Se = {}
                              , Te = ae.queryRenderedSymbols(H)
                              , Re = [];
                            for (const De of Object.keys(Te).map(Number))
                                Re.push(ye[De]);
                            Re.sort(Gr);
                            for (const De of Re) {
                                const Ae = De.featureIndex.lookupSymbolFeatures(Te[De.bucketInstanceId], $, De.bucketIndex, De.sourceLayerIndex, Y.filter, Y.layers, Y.availableImages, B);
                                for (const Be in Ae) {
                                    const qe = Se[Be] = Se[Be] || []
                                      , ze = Ae[Be];
                                    ze.sort( (Ke, ht) => {
                                        const ot = De.featureSortOrder;
                                        if (ot) {
                                            const ut = ot.indexOf(Ke.featureIndex);
                                            return ot.indexOf(ht.featureIndex) - ut
                                        }
                                        return ht.featureIndex - Ke.featureIndex
                                    }
                                    );
                                    for (const Ke of ze)
                                        qe.push(Ke)
                                }
                            }
                            return function(De, Ae, Be) {
                                for (const qe in De)
                                    for (const ze of De[qe])
                                        xr(ze, Be[Ae[qe].source]);
                                return De
                            }(Se, B, Z)
                        }(this._layers, P, this.sourceCaches, r, A, this.placement.collisionIndex, this.placement.retainedQueryData)),
                        this._flattenAndSortRenderedFeatures(x)
                    }
                    querySourceFeatures(r, a) {
                        a && a.filter && this._validate(o.z.filter, "querySourceFeatures.filter", a.filter, null, a);
                        const m = this.sourceCaches[r];
                        return m ? function(y, x) {
                            const P = y.getRenderableIds().map(B => y.getTileByID(B))
                              , I = []
                              , A = {};
                            for (let B = 0; B < P.length; B++) {
                                const $ = P[B]
                                  , Z = $.tileID.canonical.key;
                                A[Z] || (A[Z] = !0,
                                $.querySourceFeatures(I, x))
                            }
                            return I
                        }(m, a) : []
                    }
                    getLight() {
                        return this.light.getLight()
                    }
                    setLight(r, a={}) {
                        this._checkLoaded();
                        const m = this.light.getLight();
                        let y = !1;
                        for (const P in r)
                            if (!o.bG(r[P], m[P])) {
                                y = !0;
                                break
                            }
                        if (!y)
                            return;
                        const x = {
                            now: z.now(),
                            transition: o.e({
                                duration: 300,
                                delay: 0
                            }, this.stylesheet.transition)
                        };
                        this.light.setLight(r, a),
                        this.light.updateTransitions(x)
                    }
                    getProjection() {
                        var r;
                        return (r = this.stylesheet) === null || r === void 0 ? void 0 : r.projection
                    }
                    setProjection(r) {
                        if (this._checkLoaded(),
                        this.projection) {
                            if (this.projection.name === r.type)
                                return;
                            this.projection.destroy(),
                            delete this.projection
                        }
                        this.stylesheet.projection = r,
                        this._setProjectionInternal(r.type)
                    }
                    getSky() {
                        var r;
                        return (r = this.stylesheet) === null || r === void 0 ? void 0 : r.sky
                    }
                    setSky(r, a={}) {
                        this._checkLoaded();
                        const m = this.getSky();
                        let y = !1;
                        if (!r && !m)
                            return;
                        if (r && !m)
                            y = !0;
                        else if (!r && m)
                            y = !0;
                        else
                            for (const P in r)
                                if (!o.bG(r[P], m[P])) {
                                    y = !0;
                                    break
                                }
                        if (!y)
                            return;
                        const x = {
                            now: z.now(),
                            transition: o.e({
                                duration: 300,
                                delay: 0
                            }, this.stylesheet.transition)
                        };
                        this.stylesheet.sky = r,
                        this.sky.setSky(r, a),
                        this.sky.updateTransitions(x)
                    }
                    _setProjectionInternal(r) {
                        const a = function(m) {
                            if (Array.isArray(m)) {
                                const y = new Sl({
                                    type: m
                                });
                                return {
                                    projection: y,
                                    transform: new Xo,
                                    cameraHelper: new ad(y)
                                }
                            }
                            switch (m) {
                            case "mercator":
                                return {
                                    projection: new au,
                                    transform: new mi,
                                    cameraHelper: new lu
                                };
                            case "globe":
                                {
                                    const y = new Sl({
                                        type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"]
                                    });
                                    return {
                                        projection: y,
                                        transform: new Xo,
                                        cameraHelper: new ad(y)
                                    }
                                }
                            case "vertical-perspective":
                                return {
                                    projection: new od,
                                    transform: new uc,
                                    cameraHelper: new eo
                                };
                            default:
                                return o.w(`Unknown projection name: ${m}. Falling back to mercator projection.`),
                                {
                                    projection: new au,
                                    transform: new mi,
                                    cameraHelper: new lu
                                }
                            }
                        }(r);
                        this.projection = a.projection,
                        this.map.migrateProjection(a.transform, a.cameraHelper);
                        for (const m in this.sourceCaches)
                            this.sourceCaches[m].reload()
                    }
                    _validate(r, a, m, y, x={}) {
                        return (!x || x.validate !== !1) && cu(this, r.call(o.z, o.e({
                            key: a,
                            style: this.serialize(),
                            value: m,
                            styleSpec: o.v
                        }, y)))
                    }
                    _remove(r=!0) {
                        this._frameRequest && (this._frameRequest.abort(),
                        this._frameRequest = null),
                        this._loadStyleRequest && (this._loadStyleRequest.abort(),
                        this._loadStyleRequest = null),
                        this._spriteRequest && (this._spriteRequest.abort(),
                        this._spriteRequest = null),
                        sn().off(yn, this._rtlPluginLoaded);
                        for (const a in this._layers)
                            this._layers[a].setEventedParent(null);
                        for (const a in this.sourceCaches) {
                            const m = this.sourceCaches[a];
                            m.setEventedParent(null),
                            m.onRemove(this.map)
                        }
                        this.imageManager.setEventedParent(null),
                        this.setEventedParent(null),
                        r && this.dispatcher.broadcast("RM", void 0),
                        this.dispatcher.remove(r)
                    }
                    _clearSource(r) {
                        this.sourceCaches[r].clearTiles()
                    }
                    _reloadSource(r) {
                        this.sourceCaches[r].resume(),
                        this.sourceCaches[r].reload()
                    }
                    _updateSources(r) {
                        for (const a in this.sourceCaches)
                            this.sourceCaches[a].update(r, this.map.terrain)
                    }
                    _generateCollisionBoxes() {
                        for (const r in this.sourceCaches)
                            this._reloadSource(r)
                    }
                    _updatePlacement(r, a, m, y, x=!1) {
                        let P = !1
                          , I = !1;
                        const A = {};
                        for (const B of this._order) {
                            const $ = this._layers[B];
                            if ($.type !== "symbol")
                                continue;
                            if (!A[$.source]) {
                                const H = this.sourceCaches[$.source];
                                A[$.source] = H.getRenderableIds(!0).map(Y => H.getTileByID(Y)).sort( (Y, ae) => ae.tileID.overscaledZ - Y.tileID.overscaledZ || (Y.tileID.isLessThan(ae.tileID) ? -1 : 1))
                            }
                            const Z = this.crossTileSymbolIndex.addLayer($, A[$.source], r.center.lng);
                            P = P || Z
                        }
                        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
                        ((x = x || this._layerOrderChanged || m === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(z.now(), r.zoom)) && (this.pauseablePlacement = new oa(r,this.map.terrain,this._order,x,a,m,y,this.placement),
                        this._layerOrderChanged = !1),
                        this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, A),
                        this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(z.now()),
                        I = !0),
                        P && this.pauseablePlacement.placement.setStale()),
                        I || P)
                            for (const B of this._order) {
                                const $ = this._layers[B];
                                $.type === "symbol" && this.placement.updateLayerOpacities($, A[$.source])
                            }
                        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(z.now())
                    }
                    _releaseSymbolFadeTiles() {
                        for (const r in this.sourceCaches)
                            this.sourceCaches[r].releaseSymbolFadeTiles()
                    }
                    getImages(r, a) {
                        return o._(this, void 0, void 0, function*() {
                            const m = yield this.imageManager.getImages(a.icons);
                            this._updateTilesForChangedImages();
                            const y = this.sourceCaches[a.source];
                            return y && y.setDependencies(a.tileID.key, a.type, a.icons),
                            m
                        })
                    }
                    getGlyphs(r, a) {
                        return o._(this, void 0, void 0, function*() {
                            const m = yield this.glyphManager.getGlyphs(a.stacks)
                              , y = this.sourceCaches[a.source];
                            return y && y.setDependencies(a.tileID.key, a.type, [""]),
                            m
                        })
                    }
                    getGlyphsUrl() {
                        return this.stylesheet.glyphs || null
                    }
                    setGlyphs(r, a={}) {
                        this._checkLoaded(),
                        r && this._validate(o.z.glyphs, "glyphs", r, null, a) || (this._glyphsDidChange = !0,
                        this.stylesheet.glyphs = r,
                        this.glyphManager.entries = {},
                        this.glyphManager.setURL(r))
                    }
                    addSprite(r, a, m={}, y) {
                        this._checkLoaded();
                        const x = [{
                            id: r,
                            url: a
                        }]
                          , P = [...me(this.stylesheet.sprite), ...x];
                        this._validate(o.z.sprite, "sprite", P, null, m) || (this.stylesheet.sprite = P,
                        this._loadSprite(x, !0, y))
                    }
                    removeSprite(r) {
                        this._checkLoaded();
                        const a = me(this.stylesheet.sprite);
                        if (a.find(m => m.id === r)) {
                            if (this._spritesImagesIds[r])
                                for (const m of this._spritesImagesIds[r])
                                    this.imageManager.removeImage(m),
                                    this._changedImages[m] = !0;
                            a.splice(a.findIndex(m => m.id === r), 1),
                            this.stylesheet.sprite = a.length > 0 ? a : void 0,
                            delete this._spritesImagesIds[r],
                            this._availableImages = this.imageManager.listImages(),
                            this._changed = !0,
                            this.dispatcher.broadcast("SI", this._availableImages),
                            this.fire(new o.l("data",{
                                dataType: "style"
                            }))
                        } else
                            this.fire(new o.k(new Error(`Sprite "${r}" doesn't exists on this map.`)))
                    }
                    getSprite() {
                        return me(this.stylesheet.sprite)
                    }
                    setSprite(r, a={}, m) {
                        this._checkLoaded(),
                        r && this._validate(o.z.sprite, "sprite", r, null, a) || (this.stylesheet.sprite = r,
                        r ? this._loadSprite(r, !0, m) : (this._unloadSprite(),
                        m && m(null)))
                    }
                }
                var nm = o.aI([{
                    name: "a_pos",
                    type: "Int16",
                    components: 2
                }, {
                    name: "a_texture_pos",
                    type: "Int16",
                    components: 2
                }]);
                class Cf {
                    constructor() {
                        this.boundProgram = null,
                        this.boundLayoutVertexBuffer = null,
                        this.boundPaintVertexBuffers = [],
                        this.boundIndexBuffer = null,
                        this.boundVertexOffset = null,
                        this.boundDynamicVertexBuffer = null,
                        this.vao = null
                    }
                    bind(r, a, m, y, x, P, I, A, B) {
                        this.context = r;
                        let $ = this.boundPaintVertexBuffers.length !== y.length;
                        for (let Z = 0; !$ && Z < y.length; Z++)
                            this.boundPaintVertexBuffers[Z] !== y[Z] && ($ = !0);
                        !this.vao || this.boundProgram !== a || this.boundLayoutVertexBuffer !== m || $ || this.boundIndexBuffer !== x || this.boundVertexOffset !== P || this.boundDynamicVertexBuffer !== I || this.boundDynamicVertexBuffer2 !== A || this.boundDynamicVertexBuffer3 !== B ? this.freshBind(a, m, y, x, P, I, A, B) : (r.bindVertexArray.set(this.vao),
                        I && I.bind(),
                        x && x.dynamicDraw && x.bind(),
                        A && A.bind(),
                        B && B.bind())
                    }
                    freshBind(r, a, m, y, x, P, I, A) {
                        const B = r.numAttributes
                          , $ = this.context
                          , Z = $.gl;
                        this.vao && this.destroy(),
                        this.vao = $.createVertexArray(),
                        $.bindVertexArray.set(this.vao),
                        this.boundProgram = r,
                        this.boundLayoutVertexBuffer = a,
                        this.boundPaintVertexBuffers = m,
                        this.boundIndexBuffer = y,
                        this.boundVertexOffset = x,
                        this.boundDynamicVertexBuffer = P,
                        this.boundDynamicVertexBuffer2 = I,
                        this.boundDynamicVertexBuffer3 = A,
                        a.enableAttributes(Z, r);
                        for (const H of m)
                            H.enableAttributes(Z, r);
                        P && P.enableAttributes(Z, r),
                        I && I.enableAttributes(Z, r),
                        A && A.enableAttributes(Z, r),
                        a.bind(),
                        a.setVertexAttribPointers(Z, r, x);
                        for (const H of m)
                            H.bind(),
                            H.setVertexAttribPointers(Z, r, x);
                        P && (P.bind(),
                        P.setVertexAttribPointers(Z, r, x)),
                        y && y.bind(),
                        I && (I.bind(),
                        I.setVertexAttribPointers(Z, r, x)),
                        A && (A.bind(),
                        A.setVertexAttribPointers(Z, r, x)),
                        $.currentNumAttributes = B
                    }
                    destroy() {
                        this.vao && (this.context.deleteVertexArray(this.vao),
                        this.vao = null)
                    }
                }
                const im = (v, r, a, m, y) => ({
                    u_texture: 0,
                    u_ele_delta: v,
                    u_fog_matrix: r,
                    u_fog_color: a ? a.properties.get("fog-color") : o.be.white,
                    u_fog_ground_blend: a ? a.properties.get("fog-ground-blend") : 1,
                    u_fog_ground_blend_opacity: y ? 0 : a ? a.calculateFogBlendOpacity(m) : 0,
                    u_horizon_color: a ? a.properties.get("horizon-color") : o.be.white,
                    u_horizon_fog_blend: a ? a.properties.get("horizon-fog-blend") : 1,
                    u_is_globe_mode: y ? 1 : 0
                })
                  , om = {
                    mainMatrix: "u_projection_matrix",
                    tileMercatorCoords: "u_projection_tile_mercator_coords",
                    clippingPlane: "u_projection_clipping_plane",
                    projectionTransition: "u_projection_transition",
                    fallbackMatrix: "u_projection_fallback_matrix"
                };
                function uh(v) {
                    const r = [];
                    for (let a = 0; a < v.length; a++) {
                        if (v[a] === null)
                            continue;
                        const m = v[a].split(" ");
                        r.push(m.pop())
                    }
                    return r
                }
                class hh {
                    constructor(r, a, m, y, x, P, I, A, B=[]) {
                        const $ = r.gl;
                        this.program = $.createProgram();
                        const Z = uh(a.staticAttributes)
                          , H = m ? m.getBinderAttributes() : []
                          , Y = Z.concat(H)
                          , ae = ws.prelude.staticUniforms ? uh(ws.prelude.staticUniforms) : []
                          , ye = I.staticUniforms ? uh(I.staticUniforms) : []
                          , Se = a.staticUniforms ? uh(a.staticUniforms) : []
                          , Te = m ? m.getBinderUniforms() : []
                          , Re = ae.concat(ye).concat(Se).concat(Te)
                          , De = [];
                        for (const ot of Re)
                            De.indexOf(ot) < 0 && De.push(ot);
                        const Ae = m ? m.defines() : [];
                        go($) && Ae.unshift("#version 300 es"),
                        x && Ae.push("#define OVERDRAW_INSPECTOR;"),
                        P && Ae.push("#define TERRAIN3D;"),
                        A && Ae.push(A),
                        B && Ae.push(...B);
                        let Be = Ae.concat(ws.prelude.fragmentSource, I.fragmentSource, a.fragmentSource).join(`
`)
                          , qe = Ae.concat(ws.prelude.vertexSource, I.vertexSource, a.vertexSource).join(`
`);
                        go($) || (Be = function(ot) {
                            return ot.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
                        }(Be),
                        qe = function(ot) {
                            return ot.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
                        }(qe));
                        const ze = $.createShader($.FRAGMENT_SHADER);
                        if ($.isContextLost())
                            return void (this.failedToCreate = !0);
                        if ($.shaderSource(ze, Be),
                        $.compileShader(ze),
                        !$.getShaderParameter(ze, $.COMPILE_STATUS))
                            throw new Error(`Could not compile fragment shader: ${$.getShaderInfoLog(ze)}`);
                        $.attachShader(this.program, ze);
                        const Ke = $.createShader($.VERTEX_SHADER);
                        if ($.isContextLost())
                            return void (this.failedToCreate = !0);
                        if ($.shaderSource(Ke, qe),
                        $.compileShader(Ke),
                        !$.getShaderParameter(Ke, $.COMPILE_STATUS))
                            throw new Error(`Could not compile vertex shader: ${$.getShaderInfoLog(Ke)}`);
                        $.attachShader(this.program, Ke),
                        this.attributes = {};
                        const ht = {};
                        this.numAttributes = Y.length;
                        for (let ot = 0; ot < this.numAttributes; ot++)
                            Y[ot] && ($.bindAttribLocation(this.program, ot, Y[ot]),
                            this.attributes[Y[ot]] = ot);
                        if ($.linkProgram(this.program),
                        !$.getProgramParameter(this.program, $.LINK_STATUS))
                            throw new Error(`Program failed to link: ${$.getProgramInfoLog(this.program)}`);
                        $.deleteShader(Ke),
                        $.deleteShader(ze);
                        for (let ot = 0; ot < De.length; ot++) {
                            const ut = De[ot];
                            if (ut && !ht[ut]) {
                                const mt = $.getUniformLocation(this.program, ut);
                                mt && (ht[ut] = mt)
                            }
                        }
                        this.fixedUniforms = y(r, ht),
                        this.terrainUniforms = ( (ot, ut) => ({
                            u_depth: new o.bO(ot,ut.u_depth),
                            u_terrain: new o.bO(ot,ut.u_terrain),
                            u_terrain_dim: new o.bf(ot,ut.u_terrain_dim),
                            u_terrain_matrix: new o.bQ(ot,ut.u_terrain_matrix),
                            u_terrain_unpack: new o.bR(ot,ut.u_terrain_unpack),
                            u_terrain_exaggeration: new o.bf(ot,ut.u_terrain_exaggeration)
                        }))(r, ht),
                        this.projectionUniforms = ( (ot, ut) => ({
                            u_projection_matrix: new o.bQ(ot,ut.u_projection_matrix),
                            u_projection_tile_mercator_coords: new o.bR(ot,ut.u_projection_tile_mercator_coords),
                            u_projection_clipping_plane: new o.bR(ot,ut.u_projection_clipping_plane),
                            u_projection_transition: new o.bf(ot,ut.u_projection_transition),
                            u_projection_fallback_matrix: new o.bQ(ot,ut.u_projection_fallback_matrix)
                        }))(r, ht),
                        this.binderUniforms = m ? m.getUniforms(r, ht) : []
                    }
                    draw(r, a, m, y, x, P, I, A, B, $, Z, H, Y, ae, ye, Se, Te, Re, De) {
                        const Ae = r.gl;
                        if (this.failedToCreate)
                            return;
                        if (r.program.set(this.program),
                        r.setDepthMode(m),
                        r.setStencilMode(y),
                        r.setColorMode(x),
                        r.setCullFace(P),
                        A) {
                            r.activeTexture.set(Ae.TEXTURE2),
                            Ae.bindTexture(Ae.TEXTURE_2D, A.depthTexture),
                            r.activeTexture.set(Ae.TEXTURE3),
                            Ae.bindTexture(Ae.TEXTURE_2D, A.texture);
                            for (const qe in this.terrainUniforms)
                                this.terrainUniforms[qe].set(A[qe])
                        }
                        if (B)
                            for (const qe in B)
                                this.projectionUniforms[om[qe]].set(B[qe]);
                        if (I)
                            for (const qe in this.fixedUniforms)
                                this.fixedUniforms[qe].set(I[qe]);
                        Se && Se.setUniforms(r, this.binderUniforms, ae, {
                            zoom: ye
                        });
                        let Be = 0;
                        switch (a) {
                        case Ae.LINES:
                            Be = 2;
                            break;
                        case Ae.TRIANGLES:
                            Be = 3;
                            break;
                        case Ae.LINE_STRIP:
                            Be = 1
                        }
                        for (const qe of Y.get()) {
                            const ze = qe.vaos || (qe.vaos = {});
                            (ze[$] || (ze[$] = new Cf)).bind(r, this, Z, Se ? Se.getPaintVertexBuffers() : [], H, qe.vertexOffset, Te, Re, De),
                            Ae.drawElements(a, qe.primitiveLength * Be, Ae.UNSIGNED_SHORT, qe.primitiveOffset * Be * 2)
                        }
                    }
                }
                function dc(v, r, a) {
                    const m = 1 / o.aB(a, 1, r.transform.tileZoom)
                      , y = Math.pow(2, a.tileID.overscaledZ)
                      , x = a.tileSize * Math.pow(2, r.transform.tileZoom) / y
                      , P = x * (a.tileID.canonical.x + a.tileID.wrap * y)
                      , I = x * a.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_texsize: a.imageAtlasTexture.size,
                        u_scale: [m, v.fromScale, v.toScale],
                        u_fade: v.t,
                        u_pixel_coord_upper: [P >> 16, I >> 16],
                        u_pixel_coord_lower: [65535 & P, 65535 & I]
                    }
                }
                const uu = (v, r, a, m) => {
                    const y = v.style.light
                      , x = y.properties.get("position")
                      , P = [x.x, x.y, x.z]
                      , I = o.bU();
                    y.properties.get("anchor") === "viewport" && o.bV(I, v.transform.bearingInRadians),
                    o.bW(P, P, I);
                    const A = v.transform.transformLightDirection(P)
                      , B = y.properties.get("color");
                    return {
                        u_lightpos: P,
                        u_lightpos_globe: A,
                        u_lightintensity: y.properties.get("intensity"),
                        u_lightcolor: [B.r, B.g, B.b],
                        u_vertical_gradient: +r,
                        u_opacity: a,
                        u_fill_translate: m
                    }
                }
                  , cd = (v, r, a, m, y, x, P) => o.e(uu(v, r, a, m), dc(x, v, P), {
                    u_height_factor: -Math.pow(2, y.overscaledZ) / P.tileSize / 8
                })
                  , dh = (v, r, a, m) => o.e(dc(r, v, a), {
                    u_fill_translate: m
                })
                  , Ts = (v, r) => ({
                    u_world: v,
                    u_fill_translate: r
                })
                  , sm = (v, r, a, m, y) => o.e(dh(v, r, a, y), {
                    u_world: m
                })
                  , ud = (v, r, a, m, y) => {
                    const x = v.transform;
                    let P, I, A = 0;
                    if (a.paint.get("circle-pitch-alignment") === "map") {
                        const B = o.aB(r, 1, x.zoom);
                        P = !0,
                        I = [B, B],
                        A = B / (o.$ * Math.pow(2, r.tileID.overscaledZ)) * 2 * Math.PI * y
                    } else
                        P = !1,
                        I = x.pixelsToGLUnits;
                    return {
                        u_camera_to_center_distance: x.cameraToCenterDistance,
                        u_scale_with_map: +(a.paint.get("circle-pitch-scale") === "map"),
                        u_pitch_with_map: +P,
                        u_device_pixel_ratio: v.pixelRatio,
                        u_extrude_scale: I,
                        u_globe_extrude_scale: A,
                        u_translate: m
                    }
                }
                  , hu = v => ({
                    u_pixel_extrude_scale: [1 / v.width, 1 / v.height]
                })
                  , du = v => ({
                    u_viewport_size: [v.width, v.height]
                })
                  , Tf = (v, r=1) => ({
                    u_color: v,
                    u_overlay: 0,
                    u_overlay_scale: r
                })
                  , fu = (v, r, a, m) => {
                    const y = o.aB(v, 1, r) / (o.$ * Math.pow(2, v.tileID.overscaledZ)) * 2 * Math.PI * m;
                    return {
                        u_extrude_scale: o.aB(v, 1, r),
                        u_intensity: a,
                        u_globe_extrude_scale: y
                    }
                }
                  , Pf = (v, r, a, m) => {
                    const y = o.L();
                    o.bX(y, 0, v.width, v.height, 0, 0, 1);
                    const x = v.context.gl;
                    return {
                        u_matrix: y,
                        u_world: [x.drawingBufferWidth, x.drawingBufferHeight],
                        u_image: a,
                        u_color_ramp: m,
                        u_opacity: r.paint.get("heatmap-opacity")
                    }
                }
                  , Fa = (v, r, a) => {
                    const m = a.paint.get("hillshade-accent-color");
                    let y;
                    switch (a.paint.get("hillshade-method")) {
                    case "basic":
                        y = 4;
                        break;
                    case "combined":
                        y = 1;
                        break;
                    case "igor":
                        y = 2;
                        break;
                    case "multidirectional":
                        y = 3;
                        break;
                    default:
                        y = 0
                    }
                    const x = a.getIlluminationProperties();
                    for (let P = 0; P < x.directionRadians.length; P++)
                        a.paint.get("hillshade-illumination-anchor") === "viewport" && (x.directionRadians[P] += v.transform.bearingInRadians);
                    return {
                        u_image: 0,
                        u_latrange: Mf(0, r.tileID),
                        u_exaggeration: a.paint.get("hillshade-exaggeration"),
                        u_altitudes: x.altitudeRadians,
                        u_azimuths: x.directionRadians,
                        u_accent: m,
                        u_method: y,
                        u_highlights: x.highlightColor,
                        u_shadows: x.shadowColor
                    }
                }
                  , pu = (v, r) => {
                    const a = r.stride
                      , m = o.L();
                    return o.bX(m, 0, o.$, -o.$, 0, 0, 1),
                    o.M(m, m, [0, -o.$, 0]),
                    {
                        u_matrix: m,
                        u_image: 1,
                        u_dimension: [a, a],
                        u_zoom: v.overscaledZ,
                        u_unpack: r.getUnpackVector()
                    }
                }
                ;
                function Mf(v, r) {
                    const a = Math.pow(2, r.canonical.z)
                      , m = r.canonical.y;
                    return [new o.a0(0,m / a).toLngLat().lat, new o.a0(0,(m + 1) / a).toLngLat().lat]
                }
                const kf = (v, r, a=0) => ({
                    u_image: 0,
                    u_unpack: r.getUnpackVector(),
                    u_dimension: [r.stride, r.stride],
                    u_elevation_stops: 1,
                    u_color_stops: 4,
                    u_color_ramp_size: a,
                    u_opacity: v.paint.get("color-relief-opacity")
                })
                  , mu = (v, r, a, m) => {
                    const y = v.transform;
                    return {
                        u_translation: fd(v, r, a),
                        u_ratio: m / o.aB(r, 1, y.zoom),
                        u_device_pixel_ratio: v.pixelRatio,
                        u_units_to_pixels: [1 / y.pixelsToGLUnits[0], 1 / y.pixelsToGLUnits[1]]
                    }
                }
                  , fh = (v, r, a, m, y) => o.e(mu(v, r, a, m), {
                    u_image: 0,
                    u_image_height: y
                })
                  , hd = (v, r, a, m, y) => {
                    const x = v.transform
                      , P = Ba(r, x);
                    return {
                        u_translation: fd(v, r, a),
                        u_texsize: r.imageAtlasTexture.size,
                        u_ratio: m / o.aB(r, 1, x.zoom),
                        u_device_pixel_ratio: v.pixelRatio,
                        u_image: 0,
                        u_scale: [P, y.fromScale, y.toScale],
                        u_fade: y.t,
                        u_units_to_pixels: [1 / x.pixelsToGLUnits[0], 1 / x.pixelsToGLUnits[1]]
                    }
                }
                  , dd = (v, r, a, m, y, x) => {
                    const P = v.lineAtlas
                      , I = Ba(r, v.transform)
                      , A = a.layout.get("line-cap") === "round"
                      , B = P.getDash(y.from, A)
                      , $ = P.getDash(y.to, A)
                      , Z = B.width * x.fromScale
                      , H = $.width * x.toScale;
                    return o.e(mu(v, r, a, m), {
                        u_patternscale_a: [I / Z, -B.height / 2],
                        u_patternscale_b: [I / H, -$.height / 2],
                        u_sdfgamma: P.width / (256 * Math.min(Z, H) * v.pixelRatio) / 2,
                        u_image: 0,
                        u_tex_y_a: B.y,
                        u_tex_y_b: $.y,
                        u_mix: x.t
                    })
                }
                ;
                function Ba(v, r) {
                    return 1 / o.aB(v, 1, r.tileZoom)
                }
                function fd(v, r, a) {
                    return o.aC(v.transform, r, a.paint.get("line-translate"), a.paint.get("line-translate-anchor"))
                }
                const Tl = (v, r, a, m, y) => {
                    return {
                        u_tl_parent: v,
                        u_scale_parent: r,
                        u_buffer_scale: 1,
                        u_fade_t: a.mix,
                        u_opacity: a.opacity * m.paint.get("raster-opacity"),
                        u_image0: 0,
                        u_image1: 1,
                        u_brightness_low: m.paint.get("raster-brightness-min"),
                        u_brightness_high: m.paint.get("raster-brightness-max"),
                        u_saturation_factor: (P = m.paint.get("raster-saturation"),
                        P > 0 ? 1 - 1 / (1.001 - P) : -P),
                        u_contrast_factor: (x = m.paint.get("raster-contrast"),
                        x > 0 ? 1 / (1 - x) : 1 + x),
                        u_spin_weights: Ef(m.paint.get("raster-hue-rotate")),
                        u_coords_top: [y[0].x, y[0].y, y[1].x, y[1].y],
                        u_coords_bottom: [y[3].x, y[3].y, y[2].x, y[2].y]
                    };
                    var x, P
                }
                ;
                function Ef(v) {
                    v *= Math.PI / 180;
                    const r = Math.sin(v)
                      , a = Math.cos(v);
                    return [(2 * a + 1) / 3, (-Math.sqrt(3) * r - a + 1) / 3, (Math.sqrt(3) * r - a + 1) / 3]
                }
                const ph = (v, r, a, m, y, x, P, I, A, B, $, Z, H) => {
                    const Y = P.transform;
                    return {
                        u_is_size_zoom_constant: +(v === "constant" || v === "source"),
                        u_is_size_feature_constant: +(v === "constant" || v === "camera"),
                        u_size_t: r ? r.uSizeT : 0,
                        u_size: r ? r.uSize : 0,
                        u_camera_to_center_distance: Y.cameraToCenterDistance,
                        u_pitch: Y.pitch / 360 * 2 * Math.PI,
                        u_rotate_symbol: +a,
                        u_aspect_ratio: Y.width / Y.height,
                        u_fade_change: P.options.fadeDuration ? P.symbolFadeChange : 1,
                        u_label_plane_matrix: I,
                        u_coord_matrix: A,
                        u_is_text: +$,
                        u_pitch_with_map: +m,
                        u_is_along_line: y,
                        u_is_variable_anchor: x,
                        u_texsize: Z,
                        u_texture: 0,
                        u_translation: B,
                        u_pitched_scale: H
                    }
                }
                  , Pl = (v, r, a, m, y, x, P, I, A, B, $, Z, H, Y) => {
                    const ae = P.transform;
                    return o.e(ph(v, r, a, m, y, x, P, I, A, B, $, Z, Y), {
                        u_gamma_scale: m ? Math.cos(ae.pitch * Math.PI / 180) * ae.cameraToCenterDistance : 1,
                        u_device_pixel_ratio: P.pixelRatio,
                        u_is_halo: 1
                    })
                }
                  , gu = (v, r, a, m, y, x, P, I, A, B, $, Z, H) => o.e(Pl(v, r, a, m, y, x, P, I, A, B, !0, $, 0, H), {
                    u_texsize_icon: Z,
                    u_texture_icon: 1
                })
                  , ja = (v, r) => ({
                    u_opacity: v,
                    u_color: r
                })
                  , am = (v, r, a, m, y) => o.e(function(x, P, I, A) {
                    const B = I.imageManager.getPattern(x.from.toString())
                      , $ = I.imageManager.getPattern(x.to.toString())
                      , {width: Z, height: H} = I.imageManager.getPixelSize()
                      , Y = Math.pow(2, A.tileID.overscaledZ)
                      , ae = A.tileSize * Math.pow(2, I.transform.tileZoom) / Y
                      , ye = ae * (A.tileID.canonical.x + A.tileID.wrap * Y)
                      , Se = ae * A.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_pattern_tl_a: B.tl,
                        u_pattern_br_a: B.br,
                        u_pattern_tl_b: $.tl,
                        u_pattern_br_b: $.br,
                        u_texsize: [Z, H],
                        u_mix: P.t,
                        u_pattern_size_a: B.displaySize,
                        u_pattern_size_b: $.displaySize,
                        u_scale_a: P.fromScale,
                        u_scale_b: P.toScale,
                        u_tile_units_to_pixels: 1 / o.aB(A, 1, I.transform.tileZoom),
                        u_pixel_coord_upper: [ye >> 16, Se >> 16],
                        u_pixel_coord_lower: [65535 & ye, 65535 & Se]
                    }
                }(a, y, r, m), {
                    u_opacity: v
                })
                  , yu = (v, r) => {}
                  , If = {
                    fillExtrusion: (v, r) => ({
                        u_lightpos: new o.bS(v,r.u_lightpos),
                        u_lightpos_globe: new o.bS(v,r.u_lightpos_globe),
                        u_lightintensity: new o.bf(v,r.u_lightintensity),
                        u_lightcolor: new o.bS(v,r.u_lightcolor),
                        u_vertical_gradient: new o.bf(v,r.u_vertical_gradient),
                        u_opacity: new o.bf(v,r.u_opacity),
                        u_fill_translate: new o.bT(v,r.u_fill_translate)
                    }),
                    fillExtrusionPattern: (v, r) => ({
                        u_lightpos: new o.bS(v,r.u_lightpos),
                        u_lightpos_globe: new o.bS(v,r.u_lightpos_globe),
                        u_lightintensity: new o.bf(v,r.u_lightintensity),
                        u_lightcolor: new o.bS(v,r.u_lightcolor),
                        u_vertical_gradient: new o.bf(v,r.u_vertical_gradient),
                        u_height_factor: new o.bf(v,r.u_height_factor),
                        u_opacity: new o.bf(v,r.u_opacity),
                        u_fill_translate: new o.bT(v,r.u_fill_translate),
                        u_image: new o.bO(v,r.u_image),
                        u_texsize: new o.bT(v,r.u_texsize),
                        u_pixel_coord_upper: new o.bT(v,r.u_pixel_coord_upper),
                        u_pixel_coord_lower: new o.bT(v,r.u_pixel_coord_lower),
                        u_scale: new o.bS(v,r.u_scale),
                        u_fade: new o.bf(v,r.u_fade)
                    }),
                    fill: (v, r) => ({
                        u_fill_translate: new o.bT(v,r.u_fill_translate)
                    }),
                    fillPattern: (v, r) => ({
                        u_image: new o.bO(v,r.u_image),
                        u_texsize: new o.bT(v,r.u_texsize),
                        u_pixel_coord_upper: new o.bT(v,r.u_pixel_coord_upper),
                        u_pixel_coord_lower: new o.bT(v,r.u_pixel_coord_lower),
                        u_scale: new o.bS(v,r.u_scale),
                        u_fade: new o.bf(v,r.u_fade),
                        u_fill_translate: new o.bT(v,r.u_fill_translate)
                    }),
                    fillOutline: (v, r) => ({
                        u_world: new o.bT(v,r.u_world),
                        u_fill_translate: new o.bT(v,r.u_fill_translate)
                    }),
                    fillOutlinePattern: (v, r) => ({
                        u_world: new o.bT(v,r.u_world),
                        u_image: new o.bO(v,r.u_image),
                        u_texsize: new o.bT(v,r.u_texsize),
                        u_pixel_coord_upper: new o.bT(v,r.u_pixel_coord_upper),
                        u_pixel_coord_lower: new o.bT(v,r.u_pixel_coord_lower),
                        u_scale: new o.bS(v,r.u_scale),
                        u_fade: new o.bf(v,r.u_fade),
                        u_fill_translate: new o.bT(v,r.u_fill_translate)
                    }),
                    circle: (v, r) => ({
                        u_camera_to_center_distance: new o.bf(v,r.u_camera_to_center_distance),
                        u_scale_with_map: new o.bO(v,r.u_scale_with_map),
                        u_pitch_with_map: new o.bO(v,r.u_pitch_with_map),
                        u_extrude_scale: new o.bT(v,r.u_extrude_scale),
                        u_device_pixel_ratio: new o.bf(v,r.u_device_pixel_ratio),
                        u_globe_extrude_scale: new o.bf(v,r.u_globe_extrude_scale),
                        u_translate: new o.bT(v,r.u_translate)
                    }),
                    collisionBox: (v, r) => ({
                        u_pixel_extrude_scale: new o.bT(v,r.u_pixel_extrude_scale)
                    }),
                    collisionCircle: (v, r) => ({
                        u_viewport_size: new o.bT(v,r.u_viewport_size)
                    }),
                    debug: (v, r) => ({
                        u_color: new o.bP(v,r.u_color),
                        u_overlay: new o.bO(v,r.u_overlay),
                        u_overlay_scale: new o.bf(v,r.u_overlay_scale)
                    }),
                    depth: yu,
                    clippingMask: yu,
                    heatmap: (v, r) => ({
                        u_extrude_scale: new o.bf(v,r.u_extrude_scale),
                        u_intensity: new o.bf(v,r.u_intensity),
                        u_globe_extrude_scale: new o.bf(v,r.u_globe_extrude_scale)
                    }),
                    heatmapTexture: (v, r) => ({
                        u_matrix: new o.bQ(v,r.u_matrix),
                        u_world: new o.bT(v,r.u_world),
                        u_image: new o.bO(v,r.u_image),
                        u_color_ramp: new o.bO(v,r.u_color_ramp),
                        u_opacity: new o.bf(v,r.u_opacity)
                    }),
                    hillshade: (v, r) => ({
                        u_image: new o.bO(v,r.u_image),
                        u_latrange: new o.bT(v,r.u_latrange),
                        u_exaggeration: new o.bf(v,r.u_exaggeration),
                        u_altitudes: new o.bZ(v,r.u_altitudes),
                        u_azimuths: new o.bZ(v,r.u_azimuths),
                        u_accent: new o.bP(v,r.u_accent),
                        u_method: new o.bO(v,r.u_method),
                        u_shadows: new o.bY(v,r.u_shadows),
                        u_highlights: new o.bY(v,r.u_highlights)
                    }),
                    hillshadePrepare: (v, r) => ({
                        u_matrix: new o.bQ(v,r.u_matrix),
                        u_image: new o.bO(v,r.u_image),
                        u_dimension: new o.bT(v,r.u_dimension),
                        u_zoom: new o.bf(v,r.u_zoom),
                        u_unpack: new o.bR(v,r.u_unpack)
                    }),
                    colorRelief: (v, r) => ({
                        u_image: new o.bO(v,r.u_image),
                        u_unpack: new o.bR(v,r.u_unpack),
                        u_dimension: new o.bT(v,r.u_dimension),
                        u_elevation_stops: new o.bO(v,r.u_elevation_stops),
                        u_color_stops: new o.bO(v,r.u_color_stops),
                        u_color_ramp_size: new o.bO(v,r.u_color_ramp_size),
                        u_opacity: new o.bf(v,r.u_opacity)
                    }),
                    line: (v, r) => ({
                        u_translation: new o.bT(v,r.u_translation),
                        u_ratio: new o.bf(v,r.u_ratio),
                        u_device_pixel_ratio: new o.bf(v,r.u_device_pixel_ratio),
                        u_units_to_pixels: new o.bT(v,r.u_units_to_pixels)
                    }),
                    lineGradient: (v, r) => ({
                        u_translation: new o.bT(v,r.u_translation),
                        u_ratio: new o.bf(v,r.u_ratio),
                        u_device_pixel_ratio: new o.bf(v,r.u_device_pixel_ratio),
                        u_units_to_pixels: new o.bT(v,r.u_units_to_pixels),
                        u_image: new o.bO(v,r.u_image),
                        u_image_height: new o.bf(v,r.u_image_height)
                    }),
                    linePattern: (v, r) => ({
                        u_translation: new o.bT(v,r.u_translation),
                        u_texsize: new o.bT(v,r.u_texsize),
                        u_ratio: new o.bf(v,r.u_ratio),
                        u_device_pixel_ratio: new o.bf(v,r.u_device_pixel_ratio),
                        u_image: new o.bO(v,r.u_image),
                        u_units_to_pixels: new o.bT(v,r.u_units_to_pixels),
                        u_scale: new o.bS(v,r.u_scale),
                        u_fade: new o.bf(v,r.u_fade)
                    }),
                    lineSDF: (v, r) => ({
                        u_translation: new o.bT(v,r.u_translation),
                        u_ratio: new o.bf(v,r.u_ratio),
                        u_device_pixel_ratio: new o.bf(v,r.u_device_pixel_ratio),
                        u_units_to_pixels: new o.bT(v,r.u_units_to_pixels),
                        u_patternscale_a: new o.bT(v,r.u_patternscale_a),
                        u_patternscale_b: new o.bT(v,r.u_patternscale_b),
                        u_sdfgamma: new o.bf(v,r.u_sdfgamma),
                        u_image: new o.bO(v,r.u_image),
                        u_tex_y_a: new o.bf(v,r.u_tex_y_a),
                        u_tex_y_b: new o.bf(v,r.u_tex_y_b),
                        u_mix: new o.bf(v,r.u_mix)
                    }),
                    raster: (v, r) => ({
                        u_tl_parent: new o.bT(v,r.u_tl_parent),
                        u_scale_parent: new o.bf(v,r.u_scale_parent),
                        u_buffer_scale: new o.bf(v,r.u_buffer_scale),
                        u_fade_t: new o.bf(v,r.u_fade_t),
                        u_opacity: new o.bf(v,r.u_opacity),
                        u_image0: new o.bO(v,r.u_image0),
                        u_image1: new o.bO(v,r.u_image1),
                        u_brightness_low: new o.bf(v,r.u_brightness_low),
                        u_brightness_high: new o.bf(v,r.u_brightness_high),
                        u_saturation_factor: new o.bf(v,r.u_saturation_factor),
                        u_contrast_factor: new o.bf(v,r.u_contrast_factor),
                        u_spin_weights: new o.bS(v,r.u_spin_weights),
                        u_coords_top: new o.bR(v,r.u_coords_top),
                        u_coords_bottom: new o.bR(v,r.u_coords_bottom)
                    }),
                    symbolIcon: (v, r) => ({
                        u_is_size_zoom_constant: new o.bO(v,r.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new o.bO(v,r.u_is_size_feature_constant),
                        u_size_t: new o.bf(v,r.u_size_t),
                        u_size: new o.bf(v,r.u_size),
                        u_camera_to_center_distance: new o.bf(v,r.u_camera_to_center_distance),
                        u_pitch: new o.bf(v,r.u_pitch),
                        u_rotate_symbol: new o.bO(v,r.u_rotate_symbol),
                        u_aspect_ratio: new o.bf(v,r.u_aspect_ratio),
                        u_fade_change: new o.bf(v,r.u_fade_change),
                        u_label_plane_matrix: new o.bQ(v,r.u_label_plane_matrix),
                        u_coord_matrix: new o.bQ(v,r.u_coord_matrix),
                        u_is_text: new o.bO(v,r.u_is_text),
                        u_pitch_with_map: new o.bO(v,r.u_pitch_with_map),
                        u_is_along_line: new o.bO(v,r.u_is_along_line),
                        u_is_variable_anchor: new o.bO(v,r.u_is_variable_anchor),
                        u_texsize: new o.bT(v,r.u_texsize),
                        u_texture: new o.bO(v,r.u_texture),
                        u_translation: new o.bT(v,r.u_translation),
                        u_pitched_scale: new o.bf(v,r.u_pitched_scale)
                    }),
                    symbolSDF: (v, r) => ({
                        u_is_size_zoom_constant: new o.bO(v,r.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new o.bO(v,r.u_is_size_feature_constant),
                        u_size_t: new o.bf(v,r.u_size_t),
                        u_size: new o.bf(v,r.u_size),
                        u_camera_to_center_distance: new o.bf(v,r.u_camera_to_center_distance),
                        u_pitch: new o.bf(v,r.u_pitch),
                        u_rotate_symbol: new o.bO(v,r.u_rotate_symbol),
                        u_aspect_ratio: new o.bf(v,r.u_aspect_ratio),
                        u_fade_change: new o.bf(v,r.u_fade_change),
                        u_label_plane_matrix: new o.bQ(v,r.u_label_plane_matrix),
                        u_coord_matrix: new o.bQ(v,r.u_coord_matrix),
                        u_is_text: new o.bO(v,r.u_is_text),
                        u_pitch_with_map: new o.bO(v,r.u_pitch_with_map),
                        u_is_along_line: new o.bO(v,r.u_is_along_line),
                        u_is_variable_anchor: new o.bO(v,r.u_is_variable_anchor),
                        u_texsize: new o.bT(v,r.u_texsize),
                        u_texture: new o.bO(v,r.u_texture),
                        u_gamma_scale: new o.bf(v,r.u_gamma_scale),
                        u_device_pixel_ratio: new o.bf(v,r.u_device_pixel_ratio),
                        u_is_halo: new o.bO(v,r.u_is_halo),
                        u_translation: new o.bT(v,r.u_translation),
                        u_pitched_scale: new o.bf(v,r.u_pitched_scale)
                    }),
                    symbolTextAndIcon: (v, r) => ({
                        u_is_size_zoom_constant: new o.bO(v,r.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new o.bO(v,r.u_is_size_feature_constant),
                        u_size_t: new o.bf(v,r.u_size_t),
                        u_size: new o.bf(v,r.u_size),
                        u_camera_to_center_distance: new o.bf(v,r.u_camera_to_center_distance),
                        u_pitch: new o.bf(v,r.u_pitch),
                        u_rotate_symbol: new o.bO(v,r.u_rotate_symbol),
                        u_aspect_ratio: new o.bf(v,r.u_aspect_ratio),
                        u_fade_change: new o.bf(v,r.u_fade_change),
                        u_label_plane_matrix: new o.bQ(v,r.u_label_plane_matrix),
                        u_coord_matrix: new o.bQ(v,r.u_coord_matrix),
                        u_is_text: new o.bO(v,r.u_is_text),
                        u_pitch_with_map: new o.bO(v,r.u_pitch_with_map),
                        u_is_along_line: new o.bO(v,r.u_is_along_line),
                        u_is_variable_anchor: new o.bO(v,r.u_is_variable_anchor),
                        u_texsize: new o.bT(v,r.u_texsize),
                        u_texsize_icon: new o.bT(v,r.u_texsize_icon),
                        u_texture: new o.bO(v,r.u_texture),
                        u_texture_icon: new o.bO(v,r.u_texture_icon),
                        u_gamma_scale: new o.bf(v,r.u_gamma_scale),
                        u_device_pixel_ratio: new o.bf(v,r.u_device_pixel_ratio),
                        u_is_halo: new o.bO(v,r.u_is_halo),
                        u_translation: new o.bT(v,r.u_translation),
                        u_pitched_scale: new o.bf(v,r.u_pitched_scale)
                    }),
                    background: (v, r) => ({
                        u_opacity: new o.bf(v,r.u_opacity),
                        u_color: new o.bP(v,r.u_color)
                    }),
                    backgroundPattern: (v, r) => ({
                        u_opacity: new o.bf(v,r.u_opacity),
                        u_image: new o.bO(v,r.u_image),
                        u_pattern_tl_a: new o.bT(v,r.u_pattern_tl_a),
                        u_pattern_br_a: new o.bT(v,r.u_pattern_br_a),
                        u_pattern_tl_b: new o.bT(v,r.u_pattern_tl_b),
                        u_pattern_br_b: new o.bT(v,r.u_pattern_br_b),
                        u_texsize: new o.bT(v,r.u_texsize),
                        u_mix: new o.bf(v,r.u_mix),
                        u_pattern_size_a: new o.bT(v,r.u_pattern_size_a),
                        u_pattern_size_b: new o.bT(v,r.u_pattern_size_b),
                        u_scale_a: new o.bf(v,r.u_scale_a),
                        u_scale_b: new o.bf(v,r.u_scale_b),
                        u_pixel_coord_upper: new o.bT(v,r.u_pixel_coord_upper),
                        u_pixel_coord_lower: new o.bT(v,r.u_pixel_coord_lower),
                        u_tile_units_to_pixels: new o.bf(v,r.u_tile_units_to_pixels)
                    }),
                    terrain: (v, r) => ({
                        u_texture: new o.bO(v,r.u_texture),
                        u_ele_delta: new o.bf(v,r.u_ele_delta),
                        u_fog_matrix: new o.bQ(v,r.u_fog_matrix),
                        u_fog_color: new o.bP(v,r.u_fog_color),
                        u_fog_ground_blend: new o.bf(v,r.u_fog_ground_blend),
                        u_fog_ground_blend_opacity: new o.bf(v,r.u_fog_ground_blend_opacity),
                        u_horizon_color: new o.bP(v,r.u_horizon_color),
                        u_horizon_fog_blend: new o.bf(v,r.u_horizon_fog_blend),
                        u_is_globe_mode: new o.bf(v,r.u_is_globe_mode)
                    }),
                    terrainDepth: (v, r) => ({
                        u_ele_delta: new o.bf(v,r.u_ele_delta)
                    }),
                    terrainCoords: (v, r) => ({
                        u_texture: new o.bO(v,r.u_texture),
                        u_terrain_coords_id: new o.bf(v,r.u_terrain_coords_id),
                        u_ele_delta: new o.bf(v,r.u_ele_delta)
                    }),
                    projectionErrorMeasurement: (v, r) => ({
                        u_input: new o.bf(v,r.u_input),
                        u_output_expected: new o.bf(v,r.u_output_expected)
                    }),
                    atmosphere: (v, r) => ({
                        u_sun_pos: new o.bS(v,r.u_sun_pos),
                        u_atmosphere_blend: new o.bf(v,r.u_atmosphere_blend),
                        u_globe_position: new o.bS(v,r.u_globe_position),
                        u_globe_radius: new o.bf(v,r.u_globe_radius),
                        u_inv_proj_matrix: new o.bQ(v,r.u_inv_proj_matrix)
                    }),
                    sky: (v, r) => ({
                        u_sky_color: new o.bP(v,r.u_sky_color),
                        u_horizon_color: new o.bP(v,r.u_horizon_color),
                        u_horizon: new o.bT(v,r.u_horizon),
                        u_horizon_normal: new o.bT(v,r.u_horizon_normal),
                        u_sky_horizon_blend: new o.bf(v,r.u_sky_horizon_blend),
                        u_sky_blend: new o.bf(v,r.u_sky_blend)
                    })
                };
                class pd {
                    constructor(r, a, m) {
                        this.context = r;
                        const y = r.gl;
                        this.buffer = y.createBuffer(),
                        this.dynamicDraw = !!m,
                        this.context.unbindVAO(),
                        r.bindElementBuffer.set(this.buffer),
                        y.bufferData(y.ELEMENT_ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? y.DYNAMIC_DRAW : y.STATIC_DRAW),
                        this.dynamicDraw || delete a.arrayBuffer
                    }
                    bind() {
                        this.context.bindElementBuffer.set(this.buffer)
                    }
                    updateData(r) {
                        const a = this.context.gl;
                        if (!this.dynamicDraw)
                            throw new Error("Attempted to update data while not in dynamic mode.");
                        this.context.unbindVAO(),
                        this.bind(),
                        a.bufferSubData(a.ELEMENT_ARRAY_BUFFER, 0, r.arrayBuffer)
                    }
                    destroy() {
                        this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                        delete this.buffer)
                    }
                }
                const mh = {
                    Int8: "BYTE",
                    Uint8: "UNSIGNED_BYTE",
                    Int16: "SHORT",
                    Uint16: "UNSIGNED_SHORT",
                    Int32: "INT",
                    Uint32: "UNSIGNED_INT",
                    Float32: "FLOAT"
                };
                class _u {
                    constructor(r, a, m, y) {
                        this.length = a.length,
                        this.attributes = m,
                        this.itemSize = a.bytesPerElement,
                        this.dynamicDraw = y,
                        this.context = r;
                        const x = r.gl;
                        this.buffer = x.createBuffer(),
                        r.bindVertexBuffer.set(this.buffer),
                        x.bufferData(x.ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? x.DYNAMIC_DRAW : x.STATIC_DRAW),
                        this.dynamicDraw || delete a.arrayBuffer
                    }
                    bind() {
                        this.context.bindVertexBuffer.set(this.buffer)
                    }
                    updateData(r) {
                        if (r.length !== this.length)
                            throw new Error(`Length of new data is ${r.length}, which doesn't match current length of ${this.length}`);
                        const a = this.context.gl;
                        this.bind(),
                        a.bufferSubData(a.ARRAY_BUFFER, 0, r.arrayBuffer)
                    }
                    enableAttributes(r, a) {
                        for (let m = 0; m < this.attributes.length; m++) {
                            const y = a.attributes[this.attributes[m].name];
                            y !== void 0 && r.enableVertexAttribArray(y)
                        }
                    }
                    setVertexAttribPointers(r, a, m) {
                        for (let y = 0; y < this.attributes.length; y++) {
                            const x = this.attributes[y]
                              , P = a.attributes[x.name];
                            P !== void 0 && r.vertexAttribPointer(P, x.components, r[mh[x.type]], !1, this.itemSize, x.offset + this.itemSize * (m || 0))
                        }
                    }
                    destroy() {
                        this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                        delete this.buffer)
                    }
                }
                class ln {
                    constructor(r) {
                        this.gl = r.gl,
                        this.default = this.getDefault(),
                        this.current = this.default,
                        this.dirty = !1
                    }
                    get() {
                        return this.current
                    }
                    set(r) {}
                    getDefault() {
                        return this.default
                    }
                    setDefault() {
                        this.set(this.default)
                    }
                }
                class vu extends ln {
                    getDefault() {
                        return o.be.transparent
                    }
                    set(r) {
                        const a = this.current;
                        (r.r !== a.r || r.g !== a.g || r.b !== a.b || r.a !== a.a || this.dirty) && (this.gl.clearColor(r.r, r.g, r.b, r.a),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class Gs extends ln {
                    getDefault() {
                        return 1
                    }
                    set(r) {
                        (r !== this.current || this.dirty) && (this.gl.clearDepth(r),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class md extends ln {
                    getDefault() {
                        return 0
                    }
                    set(r) {
                        (r !== this.current || this.dirty) && (this.gl.clearStencil(r),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class gd extends ln {
                    getDefault() {
                        return [!0, !0, !0, !0]
                    }
                    set(r) {
                        const a = this.current;
                        (r[0] !== a[0] || r[1] !== a[1] || r[2] !== a[2] || r[3] !== a[3] || this.dirty) && (this.gl.colorMask(r[0], r[1], r[2], r[3]),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class yd extends ln {
                    getDefault() {
                        return !0
                    }
                    set(r) {
                        (r !== this.current || this.dirty) && (this.gl.depthMask(r),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class Rf extends ln {
                    getDefault() {
                        return 255
                    }
                    set(r) {
                        (r !== this.current || this.dirty) && (this.gl.stencilMask(r),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class _d extends ln {
                    getDefault() {
                        return {
                            func: this.gl.ALWAYS,
                            ref: 0,
                            mask: 255
                        }
                    }
                    set(r) {
                        const a = this.current;
                        (r.func !== a.func || r.ref !== a.ref || r.mask !== a.mask || this.dirty) && (this.gl.stencilFunc(r.func, r.ref, r.mask),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class Gi extends ln {
                    getDefault() {
                        const r = this.gl;
                        return [r.KEEP, r.KEEP, r.KEEP]
                    }
                    set(r) {
                        const a = this.current;
                        (r[0] !== a[0] || r[1] !== a[1] || r[2] !== a[2] || this.dirty) && (this.gl.stencilOp(r[0], r[1], r[2]),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class Ml extends ln {
                    getDefault() {
                        return !1
                    }
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        const a = this.gl;
                        r ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class Af extends ln {
                    getDefault() {
                        return [0, 1]
                    }
                    set(r) {
                        const a = this.current;
                        (r[0] !== a[0] || r[1] !== a[1] || this.dirty) && (this.gl.depthRange(r[0], r[1]),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class zf extends ln {
                    getDefault() {
                        return !1
                    }
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        const a = this.gl;
                        r ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class Df extends ln {
                    getDefault() {
                        return this.gl.LESS
                    }
                    set(r) {
                        (r !== this.current || this.dirty) && (this.gl.depthFunc(r),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class Lf extends ln {
                    getDefault() {
                        return !1
                    }
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        const a = this.gl;
                        r ? a.enable(a.BLEND) : a.disable(a.BLEND),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class gh extends ln {
                    getDefault() {
                        const r = this.gl;
                        return [r.ONE, r.ZERO]
                    }
                    set(r) {
                        const a = this.current;
                        (r[0] !== a[0] || r[1] !== a[1] || this.dirty) && (this.gl.blendFunc(r[0], r[1]),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class lm extends ln {
                    getDefault() {
                        return o.be.transparent
                    }
                    set(r) {
                        const a = this.current;
                        (r.r !== a.r || r.g !== a.g || r.b !== a.b || r.a !== a.a || this.dirty) && (this.gl.blendColor(r.r, r.g, r.b, r.a),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class Of extends ln {
                    getDefault() {
                        return this.gl.FUNC_ADD
                    }
                    set(r) {
                        (r !== this.current || this.dirty) && (this.gl.blendEquation(r),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class ca extends ln {
                    getDefault() {
                        return !1
                    }
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        const a = this.gl;
                        r ? a.enable(a.CULL_FACE) : a.disable(a.CULL_FACE),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class fc extends ln {
                    getDefault() {
                        return this.gl.BACK
                    }
                    set(r) {
                        (r !== this.current || this.dirty) && (this.gl.cullFace(r),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class Na extends ln {
                    getDefault() {
                        return this.gl.CCW
                    }
                    set(r) {
                        (r !== this.current || this.dirty) && (this.gl.frontFace(r),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class xu extends ln {
                    getDefault() {
                        return null
                    }
                    set(r) {
                        (r !== this.current || this.dirty) && (this.gl.useProgram(r),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class $a extends ln {
                    getDefault() {
                        return this.gl.TEXTURE0
                    }
                    set(r) {
                        (r !== this.current || this.dirty) && (this.gl.activeTexture(r),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class Va extends ln {
                    getDefault() {
                        const r = this.gl;
                        return [0, 0, r.drawingBufferWidth, r.drawingBufferHeight]
                    }
                    set(r) {
                        const a = this.current;
                        (r[0] !== a[0] || r[1] !== a[1] || r[2] !== a[2] || r[3] !== a[3] || this.dirty) && (this.gl.viewport(r[0], r[1], r[2], r[3]),
                        this.current = r,
                        this.dirty = !1)
                    }
                }
                class Ps extends ln {
                    getDefault() {
                        return null
                    }
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        const a = this.gl;
                        a.bindFramebuffer(a.FRAMEBUFFER, r),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class zo extends ln {
                    getDefault() {
                        return null
                    }
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        const a = this.gl;
                        a.bindRenderbuffer(a.RENDERBUFFER, r),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class vd extends ln {
                    getDefault() {
                        return null
                    }
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        const a = this.gl;
                        a.bindTexture(a.TEXTURE_2D, r),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class bu extends ln {
                    getDefault() {
                        return null
                    }
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        const a = this.gl;
                        a.bindBuffer(a.ARRAY_BUFFER, r),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class yh extends ln {
                    getDefault() {
                        return null
                    }
                    set(r) {
                        const a = this.gl;
                        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, r),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class Ua extends ln {
                    getDefault() {
                        return null
                    }
                    set(r) {
                        var a;
                        if (r === this.current && !this.dirty)
                            return;
                        const m = this.gl;
                        go(m) ? m.bindVertexArray(r) : (a = m.getExtension("OES_vertex_array_object")) === null || a === void 0 || a.bindVertexArrayOES(r),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class wu extends ln {
                    getDefault() {
                        return 4
                    }
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        const a = this.gl;
                        a.pixelStorei(a.UNPACK_ALIGNMENT, r),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class Su extends ln {
                    getDefault() {
                        return !1
                    }
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        const a = this.gl;
                        a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class pc extends ln {
                    getDefault() {
                        return !1
                    }
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        const a = this.gl;
                        a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, r),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class kl extends ln {
                    constructor(r, a) {
                        super(r),
                        this.context = r,
                        this.parent = a
                    }
                    getDefault() {
                        return null
                    }
                }
                class ua extends kl {
                    setDirty() {
                        this.dirty = !0
                    }
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const a = this.gl;
                        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, r, 0),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class Ga extends kl {
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const a = this.gl;
                        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, r),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                class Wa extends kl {
                    set(r) {
                        if (r === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const a = this.gl;
                        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, r),
                        this.current = r,
                        this.dirty = !1
                    }
                }
                const xd = "Framebuffer is not complete";
                class bd {
                    constructor(r, a, m, y, x) {
                        this.context = r,
                        this.width = a,
                        this.height = m;
                        const P = r.gl
                          , I = this.framebuffer = P.createFramebuffer();
                        if (this.colorAttachment = new ua(r,I),
                        y)
                            this.depthAttachment = x ? new Wa(r,I) : new Ga(r,I);
                        else if (x)
                            throw new Error("Stencil cannot be set without depth");
                        if (P.checkFramebufferStatus(P.FRAMEBUFFER) !== P.FRAMEBUFFER_COMPLETE)
                            throw new Error(xd)
                    }
                    destroy() {
                        const r = this.context.gl
                          , a = this.colorAttachment.get();
                        if (a && r.deleteTexture(a),
                        this.depthAttachment) {
                            const m = this.depthAttachment.get();
                            m && r.deleteRenderbuffer(m)
                        }
                        r.deleteFramebuffer(this.framebuffer)
                    }
                }
                class Ur {
                    constructor(r) {
                        var a, m;
                        if (this.gl = r,
                        this.clearColor = new vu(this),
                        this.clearDepth = new Gs(this),
                        this.clearStencil = new md(this),
                        this.colorMask = new gd(this),
                        this.depthMask = new yd(this),
                        this.stencilMask = new Rf(this),
                        this.stencilFunc = new _d(this),
                        this.stencilOp = new Gi(this),
                        this.stencilTest = new Ml(this),
                        this.depthRange = new Af(this),
                        this.depthTest = new zf(this),
                        this.depthFunc = new Df(this),
                        this.blend = new Lf(this),
                        this.blendFunc = new gh(this),
                        this.blendColor = new lm(this),
                        this.blendEquation = new Of(this),
                        this.cullFace = new ca(this),
                        this.cullFaceSide = new fc(this),
                        this.frontFace = new Na(this),
                        this.program = new xu(this),
                        this.activeTexture = new $a(this),
                        this.viewport = new Va(this),
                        this.bindFramebuffer = new Ps(this),
                        this.bindRenderbuffer = new zo(this),
                        this.bindTexture = new vd(this),
                        this.bindVertexBuffer = new bu(this),
                        this.bindElementBuffer = new yh(this),
                        this.bindVertexArray = new Ua(this),
                        this.pixelStoreUnpack = new wu(this),
                        this.pixelStoreUnpackPremultiplyAlpha = new Su(this),
                        this.pixelStoreUnpackFlipY = new pc(this),
                        this.extTextureFilterAnisotropic = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),
                        this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = r.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),
                        this.maxTextureSize = r.getParameter(r.MAX_TEXTURE_SIZE),
                        go(r)) {
                            this.HALF_FLOAT = r.HALF_FLOAT;
                            const y = r.getExtension("EXT_color_buffer_half_float");
                            this.RGBA16F = (a = r.RGBA16F) !== null && a !== void 0 ? a : y?.RGBA16F_EXT,
                            this.RGB16F = (m = r.RGB16F) !== null && m !== void 0 ? m : y?.RGB16F_EXT,
                            r.getExtension("EXT_color_buffer_float")
                        } else {
                            r.getExtension("EXT_color_buffer_half_float"),
                            r.getExtension("OES_texture_half_float_linear");
                            const y = r.getExtension("OES_texture_half_float");
                            this.HALF_FLOAT = y?.HALF_FLOAT_OES
                        }
                    }
                    setDefault() {
                        this.unbindVAO(),
                        this.clearColor.setDefault(),
                        this.clearDepth.setDefault(),
                        this.clearStencil.setDefault(),
                        this.colorMask.setDefault(),
                        this.depthMask.setDefault(),
                        this.stencilMask.setDefault(),
                        this.stencilFunc.setDefault(),
                        this.stencilOp.setDefault(),
                        this.stencilTest.setDefault(),
                        this.depthRange.setDefault(),
                        this.depthTest.setDefault(),
                        this.depthFunc.setDefault(),
                        this.blend.setDefault(),
                        this.blendFunc.setDefault(),
                        this.blendColor.setDefault(),
                        this.blendEquation.setDefault(),
                        this.cullFace.setDefault(),
                        this.cullFaceSide.setDefault(),
                        this.frontFace.setDefault(),
                        this.program.setDefault(),
                        this.activeTexture.setDefault(),
                        this.bindFramebuffer.setDefault(),
                        this.pixelStoreUnpack.setDefault(),
                        this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                        this.pixelStoreUnpackFlipY.setDefault()
                    }
                    setDirty() {
                        this.clearColor.dirty = !0,
                        this.clearDepth.dirty = !0,
                        this.clearStencil.dirty = !0,
                        this.colorMask.dirty = !0,
                        this.depthMask.dirty = !0,
                        this.stencilMask.dirty = !0,
                        this.stencilFunc.dirty = !0,
                        this.stencilOp.dirty = !0,
                        this.stencilTest.dirty = !0,
                        this.depthRange.dirty = !0,
                        this.depthTest.dirty = !0,
                        this.depthFunc.dirty = !0,
                        this.blend.dirty = !0,
                        this.blendFunc.dirty = !0,
                        this.blendColor.dirty = !0,
                        this.blendEquation.dirty = !0,
                        this.cullFace.dirty = !0,
                        this.cullFaceSide.dirty = !0,
                        this.frontFace.dirty = !0,
                        this.program.dirty = !0,
                        this.activeTexture.dirty = !0,
                        this.viewport.dirty = !0,
                        this.bindFramebuffer.dirty = !0,
                        this.bindRenderbuffer.dirty = !0,
                        this.bindTexture.dirty = !0,
                        this.bindVertexBuffer.dirty = !0,
                        this.bindElementBuffer.dirty = !0,
                        this.bindVertexArray.dirty = !0,
                        this.pixelStoreUnpack.dirty = !0,
                        this.pixelStoreUnpackPremultiplyAlpha.dirty = !0,
                        this.pixelStoreUnpackFlipY.dirty = !0
                    }
                    createIndexBuffer(r, a) {
                        return new pd(this,r,a)
                    }
                    createVertexBuffer(r, a, m) {
                        return new _u(this,r,a,m)
                    }
                    createRenderbuffer(r, a, m) {
                        const y = this.gl
                          , x = y.createRenderbuffer();
                        return this.bindRenderbuffer.set(x),
                        y.renderbufferStorage(y.RENDERBUFFER, r, a, m),
                        this.bindRenderbuffer.set(null),
                        x
                    }
                    createFramebuffer(r, a, m, y) {
                        return new bd(this,r,a,m,y)
                    }
                    clear({color: r, depth: a, stencil: m}) {
                        const y = this.gl;
                        let x = 0;
                        r && (x |= y.COLOR_BUFFER_BIT,
                        this.clearColor.set(r),
                        this.colorMask.set([!0, !0, !0, !0])),
                        a !== void 0 && (x |= y.DEPTH_BUFFER_BIT,
                        this.depthRange.set([0, 1]),
                        this.clearDepth.set(a),
                        this.depthMask.set(!0)),
                        m !== void 0 && (x |= y.STENCIL_BUFFER_BIT,
                        this.clearStencil.set(m),
                        this.stencilMask.set(255)),
                        y.clear(x)
                    }
                    setCullFace(r) {
                        r.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0),
                        this.cullFaceSide.set(r.mode),
                        this.frontFace.set(r.frontFace))
                    }
                    setDepthMode(r) {
                        r.func !== this.gl.ALWAYS || r.mask ? (this.depthTest.set(!0),
                        this.depthFunc.set(r.func),
                        this.depthMask.set(r.mask),
                        this.depthRange.set(r.range)) : this.depthTest.set(!1)
                    }
                    setStencilMode(r) {
                        r.test.func !== this.gl.ALWAYS || r.mask ? (this.stencilTest.set(!0),
                        this.stencilMask.set(r.mask),
                        this.stencilOp.set([r.fail, r.depthFail, r.pass]),
                        this.stencilFunc.set({
                            func: r.test.func,
                            ref: r.ref,
                            mask: r.test.mask
                        })) : this.stencilTest.set(!1)
                    }
                    setColorMode(r) {
                        o.bG(r.blendFunction, Yr.Replace) ? this.blend.set(!1) : (this.blend.set(!0),
                        this.blendFunc.set(r.blendFunction),
                        this.blendColor.set(r.blendColor)),
                        this.colorMask.set(r.mask)
                    }
                    createVertexArray() {
                        var r;
                        return go(this.gl) ? this.gl.createVertexArray() : (r = this.gl.getExtension("OES_vertex_array_object")) === null || r === void 0 ? void 0 : r.createVertexArrayOES()
                    }
                    deleteVertexArray(r) {
                        var a;
                        return go(this.gl) ? this.gl.deleteVertexArray(r) : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.deleteVertexArrayOES(r)
                    }
                    unbindVAO() {
                        this.bindVertexArray.set(null)
                    }
                }
                let El;
                function wd(v, r, a, m, y) {
                    const x = v.context
                      , P = v.transform
                      , I = x.gl
                      , A = v.useProgram("collisionBox")
                      , B = [];
                    let $ = 0
                      , Z = 0;
                    for (let Te = 0; Te < m.length; Te++) {
                        const Re = m[Te]
                          , De = r.getTile(Re).getBucket(a);
                        if (!De)
                            continue;
                        const Ae = y ? De.textCollisionBox : De.iconCollisionBox
                          , Be = De.collisionCircleArray;
                        Be.length > 0 && (B.push({
                            circleArray: Be,
                            circleOffset: Z,
                            coord: Re
                        }),
                        $ += Be.length / 4,
                        Z = $),
                        Ae && A.draw(x, I.LINES, Fr.disabled, Sr.disabled, v.colorModeForRenderPass(), jr.disabled, hu(v.transform), v.style.map.terrain && v.style.map.terrain.getTerrainData(Re), P.getProjectionData({
                            overscaledTileID: Re,
                            applyGlobeMatrix: !0,
                            applyTerrainMatrix: !0
                        }), a.id, Ae.layoutVertexBuffer, Ae.indexBuffer, Ae.segments, null, v.transform.zoom, null, null, Ae.collisionVertexBuffer)
                    }
                    if (!y || !B.length)
                        return;
                    const H = v.useProgram("collisionCircle")
                      , Y = new o.b_;
                    Y.resize(4 * $),
                    Y._trim();
                    let ae = 0;
                    for (const Te of B)
                        for (let Re = 0; Re < Te.circleArray.length / 4; Re++) {
                            const De = 4 * Re
                              , Ae = Te.circleArray[De + 0]
                              , Be = Te.circleArray[De + 1]
                              , qe = Te.circleArray[De + 2]
                              , ze = Te.circleArray[De + 3];
                            Y.emplace(ae++, Ae, Be, qe, ze, 0),
                            Y.emplace(ae++, Ae, Be, qe, ze, 1),
                            Y.emplace(ae++, Ae, Be, qe, ze, 2),
                            Y.emplace(ae++, Ae, Be, qe, ze, 3)
                        }
                    (!El || El.length < 2 * $) && (El = function(Te) {
                        const Re = 2 * Te
                          , De = new o.c0;
                        De.resize(Re),
                        De._trim();
                        for (let Ae = 0; Ae < Re; Ae++) {
                            const Be = 6 * Ae;
                            De.uint16[Be + 0] = 4 * Ae + 0,
                            De.uint16[Be + 1] = 4 * Ae + 1,
                            De.uint16[Be + 2] = 4 * Ae + 2,
                            De.uint16[Be + 3] = 4 * Ae + 2,
                            De.uint16[Be + 4] = 4 * Ae + 3,
                            De.uint16[Be + 5] = 4 * Ae + 0
                        }
                        return De
                    }($));
                    const ye = x.createIndexBuffer(El, !0)
                      , Se = x.createVertexBuffer(Y, o.b$.members, !0);
                    for (const Te of B) {
                        const Re = du(v.transform);
                        H.draw(x, I.TRIANGLES, Fr.disabled, Sr.disabled, v.colorModeForRenderPass(), jr.disabled, Re, v.style.map.terrain && v.style.map.terrain.getTerrainData(Te.coord), null, a.id, Se, ye, o.aL.simpleSegment(0, 2 * Te.circleOffset, Te.circleArray.length, Te.circleArray.length / 2), null, v.transform.zoom, null, null, null)
                    }
                    Se.destroy(),
                    ye.destroy()
                }
                const Sd = o.af(new Float32Array(16));
                function Pn(v, r, a, m, y, x) {
                    const {horizontalAlign: P, verticalAlign: I} = o.aG(v);
                    return new o.P((-(P - .5) * r / y + m[0]) * x,(-(I - .5) * a / y + m[1]) * x)
                }
                function Cd(v, r, a, m, y, x) {
                    const P = r.tileAnchorPoint.add(new o.P(r.translation[0],r.translation[1]));
                    if (r.pitchWithMap) {
                        let I = m.mult(x);
                        a || (I = I.rotate(-y));
                        const A = P.add(I);
                        return Dr(A.x, A.y, r.pitchedLabelPlaneMatrix, r.getElevation).point
                    }
                    if (a) {
                        const I = Xe(r.tileAnchorPoint.x + 1, r.tileAnchorPoint.y, r).point.sub(v)
                          , A = Math.atan(I.y / I.x) + (I.x < 0 ? Math.PI : 0);
                        return v.add(m.rotate(A))
                    }
                    return v.add(m)
                }
                function _h(v, r, a, m, y, x, P, I, A, B, $, Z) {
                    const H = v.text.placedSymbolArray
                      , Y = v.text.dynamicLayoutVertexArray
                      , ae = v.icon.dynamicLayoutVertexArray
                      , ye = {};
                    Y.clear();
                    for (let Se = 0; Se < H.length; Se++) {
                        const Te = H.get(Se)
                          , Re = Te.hidden || !Te.crossTileID || v.allowVerticalPlacement && !Te.placedOrientation ? null : m[Te.crossTileID];
                        if (Re) {
                            const De = new o.P(Te.anchorX,Te.anchorY)
                              , Ae = {
                                getElevation: Z,
                                width: y.width,
                                height: y.height,
                                pitchedLabelPlaneMatrix: x,
                                pitchWithMap: a,
                                transform: y,
                                tileAnchorPoint: De,
                                translation: B,
                                unwrappedTileID: $
                            }
                              , Be = a ? Ct(De.x, De.y, Ae) : Xe(De.x, De.y, Ae)
                              , qe = fr(y.cameraToCenterDistance, Be.signedDistanceFromCamera);
                            let ze = o.ao(v.textSizeData, I, Te) * qe / o.aA;
                            a && (ze *= v.tilePixelRatio / P);
                            const {width: Ke, height: ht, anchor: ot, textOffset: ut, textBoxScale: mt} = Re
                              , $t = Pn(ot, Ke, ht, ut, mt, ze)
                              , jt = y.getPitchedTextCorrection(De.x + B[0], De.y + B[1], $)
                              , It = Cd(Be.point, Ae, r, $t, -y.bearingInRadians, jt)
                              , or = v.allowVerticalPlacement && Te.placedOrientation === o.an.vertical ? Math.PI / 2 : 0;
                            for (let Vr = 0; Vr < Te.numGlyphs; Vr++)
                                o.au(Y, It, or);
                            A && Te.associatedIconIndex >= 0 && (ye[Te.associatedIconIndex] = {
                                shiftedAnchor: It,
                                angle: or
                            })
                        } else
                            ri(Te.numGlyphs, Y)
                    }
                    if (A) {
                        ae.clear();
                        const Se = v.icon.placedSymbolArray;
                        for (let Te = 0; Te < Se.length; Te++) {
                            const Re = Se.get(Te);
                            if (Re.hidden)
                                ri(Re.numGlyphs, ae);
                            else {
                                const De = ye[Te];
                                if (De)
                                    for (let Ae = 0; Ae < Re.numGlyphs; Ae++)
                                        o.au(ae, De.shiftedAnchor, De.angle);
                                else
                                    ri(Re.numGlyphs, ae)
                            }
                        }
                        v.icon.dynamicLayoutVertexBuffer.updateData(ae)
                    }
                    v.text.dynamicLayoutVertexBuffer.updateData(Y)
                }
                function mc(v, r, a) {
                    return a.iconsInText && r ? "symbolTextAndIcon" : v ? "symbolSDF" : "symbolIcon"
                }
                function Td(v, r, a, m, y, x, P, I, A, B, $, Z, H) {
                    const Y = v.context
                      , ae = Y.gl
                      , ye = v.transform
                      , Se = I === "map"
                      , Te = A === "map"
                      , Re = I !== "viewport" && a.layout.get("symbol-placement") !== "point"
                      , De = Se && !Te && !Re
                      , Ae = !a.layout.get("symbol-sort-key").isConstant();
                    let Be = !1;
                    const qe = v.getDepthModeForSublayer(0, Fr.ReadOnly)
                      , ze = a._unevaluatedLayout.hasValue("text-variable-anchor") || a._unevaluatedLayout.hasValue("text-variable-anchor-offset")
                      , Ke = []
                      , ht = ye.getCircleRadiusCorrection();
                    for (const ot of m) {
                        const ut = r.getTile(ot)
                          , mt = ut.getBucket(a);
                        if (!mt)
                            continue;
                        const $t = y ? mt.text : mt.icon;
                        if (!$t || !$t.segments.get().length || !$t.hasVisibleVertices)
                            continue;
                        const jt = $t.programConfigurations.get(a.id)
                          , It = y || mt.sdfIcons
                          , or = y ? mt.textSizeData : mt.iconSizeData
                          , Vr = Te || ye.pitch !== 0
                          , cn = v.useProgram(mc(It, y, mt), jt)
                          , Kn = o.am(or, ye.zoom)
                          , Sn = v.style.map.terrain && v.style.map.terrain.getTerrainData(ot);
                        let On, kn, pn, vn, zi = [0, 0], rn = null;
                        if (y)
                            kn = ut.glyphAtlasTexture,
                            pn = ae.LINEAR,
                            On = ut.glyphAtlasTexture.size,
                            mt.iconsInText && (zi = ut.imageAtlasTexture.size,
                            rn = ut.imageAtlasTexture,
                            vn = Vr || v.options.rotating || v.options.zooming || or.kind === "composite" || or.kind === "camera" ? ae.LINEAR : ae.NEAREST);
                        else {
                            const ti = a.layout.get("icon-size").constantOr(0) !== 1 || mt.iconsNeedLinear;
                            kn = ut.imageAtlasTexture,
                            pn = It || v.options.rotating || v.options.zooming || ti || Vr ? ae.LINEAR : ae.NEAREST,
                            On = ut.imageAtlasTexture.size
                        }
                        const Ti = o.aB(ut, 1, v.transform.zoom)
                          , Di = br(Se, v.transform, Ti)
                          , ma = o.L();
                        o.ap(ma, Di);
                        const ga = en(Te, Se, v.transform, Ti)
                          , Ys = o.aC(ye, ut, x, P)
                          , Is = ye.getProjectionData({
                            overscaledTileID: ot,
                            applyGlobeMatrix: !H,
                            applyTerrainMatrix: !0
                        })
                          , Ic = ze && mt.hasTextData()
                          , Rc = a.layout.get("icon-text-fit") !== "none" && Ic && mt.hasIconData();
                        if (Re) {
                            const ti = v.style.map.terrain ? (Li, Pi) => v.style.map.terrain.getElevation(ot, Li, Pi) : null
                              , Bn = a.layout.get("text-rotation-alignment") === "map";
                            le(mt, v, y, Di, ma, Te, B, Bn, ot.toUnwrapped(), ye.width, ye.height, Ys, ti)
                        }
                        const Ac = y && ze || Rc
                          , wo = Re || Ac ? Sd : Te ? Di : v.transform.clipSpaceToPixelsMatrix
                          , Rs = It && a.paint.get(y ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
                        let tl;
                        tl = It ? mt.iconsInText ? gu(or.kind, Kn, De, Te, Re, Ac, v, wo, ga, Ys, On, zi, ht) : Pl(or.kind, Kn, De, Te, Re, Ac, v, wo, ga, Ys, y, On, 0, ht) : ph(or.kind, Kn, De, Te, Re, Ac, v, wo, ga, Ys, y, On, ht);
                        const rl = {
                            program: cn,
                            buffers: $t,
                            uniformValues: tl,
                            projectionData: Is,
                            atlasTexture: kn,
                            atlasTextureIcon: rn,
                            atlasInterpolation: pn,
                            atlasInterpolationIcon: vn,
                            isSDF: It,
                            hasHalo: Rs
                        };
                        if (Ae && mt.canOverlap) {
                            Be = !0;
                            const ti = $t.segments.get();
                            for (const Bn of ti)
                                Ke.push({
                                    segments: new o.aL([Bn]),
                                    sortKey: Bn.sortKey,
                                    state: rl,
                                    terrainData: Sn
                                })
                        } else
                            Ke.push({
                                segments: $t.segments,
                                sortKey: 0,
                                state: rl,
                                terrainData: Sn
                            })
                    }
                    Be && Ke.sort( (ot, ut) => ot.sortKey - ut.sortKey);
                    for (const ot of Ke) {
                        const ut = ot.state;
                        if (Y.activeTexture.set(ae.TEXTURE0),
                        ut.atlasTexture.bind(ut.atlasInterpolation, ae.CLAMP_TO_EDGE),
                        ut.atlasTextureIcon && (Y.activeTexture.set(ae.TEXTURE1),
                        ut.atlasTextureIcon && ut.atlasTextureIcon.bind(ut.atlasInterpolationIcon, ae.CLAMP_TO_EDGE)),
                        ut.isSDF) {
                            const mt = ut.uniformValues;
                            ut.hasHalo && (mt.u_is_halo = 1,
                            gc(ut.buffers, ot.segments, a, v, ut.program, qe, $, Z, mt, ut.projectionData, ot.terrainData)),
                            mt.u_is_halo = 0
                        }
                        gc(ut.buffers, ot.segments, a, v, ut.program, qe, $, Z, ut.uniformValues, ut.projectionData, ot.terrainData)
                    }
                }
                function gc(v, r, a, m, y, x, P, I, A, B, $) {
                    const Z = m.context;
                    y.draw(Z, Z.gl.TRIANGLES, x, P, I, jr.backCCW, A, $, B, a.id, v.layoutVertexBuffer, v.indexBuffer, r, a.paint, m.transform.zoom, v.programConfigurations.get(a.id), v.dynamicLayoutVertexBuffer, v.opacityVertexBuffer)
                }
                function qa(v, r, a, m, y) {
                    const x = v.context
                      , P = x.gl
                      , I = Sr.disabled
                      , A = new Yr([P.ONE, P.ONE],o.be.transparent,[!0, !0, !0, !0])
                      , B = r.getBucket(a);
                    if (!B)
                        return;
                    const $ = m.key;
                    let Z = a.heatmapFbos.get($);
                    Z || (Z = Ws(x, r.tileSize, r.tileSize),
                    a.heatmapFbos.set($, Z)),
                    x.bindFramebuffer.set(Z.framebuffer),
                    x.viewport.set([0, 0, r.tileSize, r.tileSize]),
                    x.clear({
                        color: o.be.transparent
                    });
                    const H = B.programConfigurations.get(a.id)
                      , Y = v.useProgram("heatmap", H, !y)
                      , ae = v.transform.getProjectionData({
                        overscaledTileID: r.tileID,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                    })
                      , ye = v.style.map.terrain.getTerrainData(m);
                    Y.draw(x, P.TRIANGLES, Fr.disabled, I, A, jr.disabled, fu(r, v.transform.zoom, a.paint.get("heatmap-intensity"), 1), ye, ae, a.id, B.layoutVertexBuffer, B.indexBuffer, B.segments, a.paint, v.transform.zoom, H)
                }
                function Il(v, r, a, m, y) {
                    const x = v.context
                      , P = x.gl
                      , I = v.transform;
                    x.setColorMode(v.colorModeForRenderPass());
                    const A = Cu(x, r)
                      , B = a.key
                      , $ = r.heatmapFbos.get(B);
                    if (!$)
                        return;
                    x.activeTexture.set(P.TEXTURE0),
                    P.bindTexture(P.TEXTURE_2D, $.colorAttachment.get()),
                    x.activeTexture.set(P.TEXTURE1),
                    A.bind(P.LINEAR, P.CLAMP_TO_EDGE);
                    const Z = I.getProjectionData({
                        overscaledTileID: a,
                        applyTerrainMatrix: y,
                        applyGlobeMatrix: !m
                    });
                    v.useProgram("heatmapTexture").draw(x, P.TRIANGLES, Fr.disabled, Sr.disabled, v.colorModeForRenderPass(), jr.disabled, Pf(v, r, 0, 1), null, Z, r.id, v.rasterBoundsBuffer, v.quadTriangleIndexBuffer, v.rasterBoundsSegments, r.paint, I.zoom),
                    $.destroy(),
                    r.heatmapFbos.delete(B)
                }
                function Ws(v, r, a) {
                    var m, y;
                    const x = v.gl
                      , P = x.createTexture();
                    x.bindTexture(x.TEXTURE_2D, P),
                    x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_S, x.CLAMP_TO_EDGE),
                    x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_T, x.CLAMP_TO_EDGE),
                    x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.LINEAR),
                    x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MAG_FILTER, x.LINEAR);
                    const I = (m = v.HALF_FLOAT) !== null && m !== void 0 ? m : x.UNSIGNED_BYTE
                      , A = (y = v.RGBA16F) !== null && y !== void 0 ? y : x.RGBA;
                    x.texImage2D(x.TEXTURE_2D, 0, A, r, a, 0, x.RGBA, I, null);
                    const B = v.createFramebuffer(r, a, !1, !1);
                    return B.colorAttachment.set(P),
                    B
                }
                function Cu(v, r) {
                    return r.colorRampTexture || (r.colorRampTexture = new o.T(v,r.colorRamp,v.gl.RGBA)),
                    r.colorRampTexture
                }
                function Pd(v, r, a, m, y) {
                    if (!a || !m || !m.imageAtlas)
                        return;
                    const x = m.imageAtlas.patternPositions;
                    let P = x[a.to.toString()]
                      , I = x[a.from.toString()];
                    if (!P && I && (P = I),
                    !I && P && (I = P),
                    !P || !I) {
                        const A = y.getPaintProperty(r);
                        P = x[A],
                        I = x[A]
                    }
                    P && I && v.setConstantPatternPositions(P, I)
                }
                function Tu(v, r, a, m, y, x, P, I) {
                    const A = v.context.gl
                      , B = "fill-pattern"
                      , $ = a.paint.get(B)
                      , Z = $ && $.constantOr(1)
                      , H = a.getCrossfadeParameters();
                    let Y, ae, ye, Se, Te;
                    const Re = v.transform
                      , De = a.paint.get("fill-translate")
                      , Ae = a.paint.get("fill-translate-anchor");
                    P ? (ae = Z && !a.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline",
                    Y = A.LINES) : (ae = Z ? "fillPattern" : "fill",
                    Y = A.TRIANGLES);
                    const Be = $.constantOr(null);
                    for (const qe of m) {
                        const ze = r.getTile(qe);
                        if (Z && !ze.patternsLoaded())
                            continue;
                        const Ke = ze.getBucket(a);
                        if (!Ke)
                            continue;
                        const ht = Ke.programConfigurations.get(a.id)
                          , ot = v.useProgram(ae, ht)
                          , ut = v.style.map.terrain && v.style.map.terrain.getTerrainData(qe);
                        Z && (v.context.activeTexture.set(A.TEXTURE0),
                        ze.imageAtlasTexture.bind(A.LINEAR, A.CLAMP_TO_EDGE),
                        ht.updatePaintBuffers(H)),
                        Pd(ht, B, Be, ze, a);
                        const mt = Re.getProjectionData({
                            overscaledTileID: qe,
                            applyGlobeMatrix: !I,
                            applyTerrainMatrix: !0
                        })
                          , $t = o.aC(Re, ze, De, Ae);
                        if (P) {
                            Se = Ke.indexBuffer2,
                            Te = Ke.segments2;
                            const It = [A.drawingBufferWidth, A.drawingBufferHeight];
                            ye = ae === "fillOutlinePattern" && Z ? sm(v, H, ze, It, $t) : Ts(It, $t)
                        } else
                            Se = Ke.indexBuffer,
                            Te = Ke.segments,
                            ye = Z ? dh(v, H, ze, $t) : {
                                u_fill_translate: $t
                            };
                        const jt = v.stencilModeForClipping(qe);
                        ot.draw(v.context, Y, y, jt, x, jr.backCCW, ye, ut, mt, a.id, Ke.layoutVertexBuffer, Se, Te, a.paint, v.transform.zoom, ht)
                    }
                }
                function Rl(v, r, a, m, y, x, P, I) {
                    const A = v.context
                      , B = A.gl
                      , $ = "fill-extrusion-pattern"
                      , Z = a.paint.get($)
                      , H = Z.constantOr(1)
                      , Y = a.getCrossfadeParameters()
                      , ae = a.paint.get("fill-extrusion-opacity")
                      , ye = Z.constantOr(null)
                      , Se = v.transform;
                    for (const Te of m) {
                        const Re = r.getTile(Te)
                          , De = Re.getBucket(a);
                        if (!De)
                            continue;
                        const Ae = v.style.map.terrain && v.style.map.terrain.getTerrainData(Te)
                          , Be = De.programConfigurations.get(a.id)
                          , qe = v.useProgram(H ? "fillExtrusionPattern" : "fillExtrusion", Be);
                        H && (v.context.activeTexture.set(B.TEXTURE0),
                        Re.imageAtlasTexture.bind(B.LINEAR, B.CLAMP_TO_EDGE),
                        Be.updatePaintBuffers(Y));
                        const ze = Se.getProjectionData({
                            overscaledTileID: Te,
                            applyGlobeMatrix: !I,
                            applyTerrainMatrix: !0
                        });
                        Pd(Be, $, ye, Re, a);
                        const Ke = o.aC(Se, Re, a.paint.get("fill-extrusion-translate"), a.paint.get("fill-extrusion-translate-anchor"))
                          , ht = a.paint.get("fill-extrusion-vertical-gradient")
                          , ot = H ? cd(v, ht, ae, Ke, Te, Y, Re) : uu(v, ht, ae, Ke);
                        qe.draw(A, A.gl.TRIANGLES, y, x, P, jr.backCCW, ot, Ae, ze, a.id, De.layoutVertexBuffer, De.indexBuffer, De.segments, a.paint, v.transform.zoom, Be, v.style.map.terrain && De.centroidVertexBuffer)
                    }
                }
                function ha(v, r, a, m, y, x, P, I, A) {
                    var B;
                    const $ = v.style.projection
                      , Z = v.context
                      , H = v.transform
                      , Y = Z.gl
                      , ae = [`#define NUM_ILLUMINATION_SOURCES ${a.paint.get("hillshade-highlight-color").values.length}`]
                      , ye = v.useProgram("hillshade", null, !1, ae)
                      , Se = !v.options.moving;
                    for (const Te of m) {
                        const Re = r.getTile(Te)
                          , De = Re.fbo;
                        if (!De)
                            continue;
                        const Ae = $.getMeshFromTileID(Z, Te.canonical, I, !0, "raster")
                          , Be = (B = v.style.map.terrain) === null || B === void 0 ? void 0 : B.getTerrainData(Te);
                        Z.activeTexture.set(Y.TEXTURE0),
                        Y.bindTexture(Y.TEXTURE_2D, De.colorAttachment.get());
                        const qe = H.getProjectionData({
                            overscaledTileID: Te,
                            aligned: Se,
                            applyGlobeMatrix: !A,
                            applyTerrainMatrix: !0
                        });
                        ye.draw(Z, Y.TRIANGLES, x, y[Te.overscaledZ], P, jr.backCCW, Fa(v, Re, a), Be, qe, a.id, Ae.vertexBuffer, Ae.indexBuffer, Ae.segments)
                    }
                }
                function Ha(v, r, a, m, y, x, P, I, A) {
                    var B;
                    const $ = v.style.projection
                      , Z = v.context
                      , H = v.transform
                      , Y = Z.gl
                      , ae = v.useProgram("colorRelief")
                      , ye = !v.options.moving;
                    let Se = !0
                      , Te = 0;
                    for (const Re of m) {
                        const De = r.getTile(Re)
                          , Ae = De.dem;
                        if (Se) {
                            const ot = Y.getParameter(Y.MAX_TEXTURE_SIZE)
                              , {elevationTexture: ut, colorTexture: mt} = a.getColorRampTextures(Z, ot, Ae.getUnpackVector());
                            Z.activeTexture.set(Y.TEXTURE1),
                            ut.bind(Y.NEAREST, Y.CLAMP_TO_EDGE),
                            Z.activeTexture.set(Y.TEXTURE4),
                            mt.bind(Y.LINEAR, Y.CLAMP_TO_EDGE),
                            Se = !1,
                            Te = ut.size[0]
                        }
                        if (!Ae || !Ae.data)
                            continue;
                        const Be = Ae.stride
                          , qe = Ae.getPixels();
                        if (Z.activeTexture.set(Y.TEXTURE0),
                        Z.pixelStoreUnpackPremultiplyAlpha.set(!1),
                        De.demTexture = De.demTexture || v.getTileTexture(Be),
                        De.demTexture) {
                            const ot = De.demTexture;
                            ot.update(qe, {
                                premultiply: !1
                            }),
                            ot.bind(Y.LINEAR, Y.CLAMP_TO_EDGE)
                        } else
                            De.demTexture = new o.T(Z,qe,Y.RGBA,{
                                premultiply: !1
                            }),
                            De.demTexture.bind(Y.LINEAR, Y.CLAMP_TO_EDGE);
                        const ze = $.getMeshFromTileID(Z, Re.canonical, I, !0, "raster")
                          , Ke = (B = v.style.map.terrain) === null || B === void 0 ? void 0 : B.getTerrainData(Re)
                          , ht = H.getProjectionData({
                            overscaledTileID: Re,
                            aligned: ye,
                            applyGlobeMatrix: !A,
                            applyTerrainMatrix: !0
                        });
                        ae.draw(Z, Y.TRIANGLES, x, y[Re.overscaledZ], P, jr.backCCW, kf(a, De.dem, Te), Ke, ht, a.id, ze.vertexBuffer, ze.indexBuffer, ze.segments)
                    }
                }
                const Pu = [new o.P(0,0), new o.P(o.$,0), new o.P(o.$,o.$), new o.P(0,o.$)];
                function qs(v, r, a, m, y, x, P, I, A=!1, B=!1) {
                    const $ = m[m.length - 1].overscaledZ
                      , Z = v.context
                      , H = Z.gl
                      , Y = v.useProgram("raster")
                      , ae = v.transform
                      , ye = v.style.projection
                      , Se = v.colorModeForRenderPass()
                      , Te = !v.options.moving;
                    for (const Re of m) {
                        const De = v.getDepthModeForSublayer(Re.overscaledZ - $, a.paint.get("raster-opacity") === 1 ? Fr.ReadWrite : Fr.ReadOnly, H.LESS)
                          , Ae = r.getTile(Re);
                        Ae.registerFadeDuration(a.paint.get("raster-fade-duration"));
                        const Be = r.findLoadedParent(Re, 0)
                          , qe = r.findLoadedSibling(Re)
                          , ze = Md(Ae, Be || qe || null, r, a, v.transform, v.style.map.terrain);
                        let Ke, ht;
                        const ot = a.paint.get("raster-resampling") === "nearest" ? H.NEAREST : H.LINEAR;
                        Z.activeTexture.set(H.TEXTURE0),
                        Ae.texture.bind(ot, H.CLAMP_TO_EDGE, H.LINEAR_MIPMAP_NEAREST),
                        Z.activeTexture.set(H.TEXTURE1),
                        Be ? (Be.texture.bind(ot, H.CLAMP_TO_EDGE, H.LINEAR_MIPMAP_NEAREST),
                        Ke = Math.pow(2, Be.tileID.overscaledZ - Ae.tileID.overscaledZ),
                        ht = [Ae.tileID.canonical.x * Ke % 1, Ae.tileID.canonical.y * Ke % 1]) : Ae.texture.bind(ot, H.CLAMP_TO_EDGE, H.LINEAR_MIPMAP_NEAREST),
                        Ae.texture.useMipmap && Z.extTextureFilterAnisotropic && v.transform.pitch > 20 && H.texParameterf(H.TEXTURE_2D, Z.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Z.extTextureFilterAnisotropicMax);
                        const ut = v.style.map.terrain && v.style.map.terrain.getTerrainData(Re)
                          , mt = ae.getProjectionData({
                            overscaledTileID: Re,
                            aligned: Te,
                            applyGlobeMatrix: !B,
                            applyTerrainMatrix: !0
                        })
                          , $t = Tl(ht || [0, 0], Ke || 1, ze, a, I)
                          , jt = ye.getMeshFromTileID(Z, Re.canonical, x, P, "raster");
                        Y.draw(Z, H.TRIANGLES, De, y ? y[Re.overscaledZ] : Sr.disabled, Se, A ? jr.frontCCW : jr.backCCW, $t, ut, mt, a.id, jt.vertexBuffer, jt.indexBuffer, jt.segments)
                    }
                }
                function Md(v, r, a, m, y, x) {
                    const P = m.paint.get("raster-fade-duration");
                    if (!x && P > 0) {
                        const I = z.now()
                          , A = (I - v.timeAdded) / P
                          , B = r ? (I - r.timeAdded) / P : -1
                          , $ = a.getSource()
                          , Z = _t(y, {
                            tileSize: $.tileSize,
                            roundZoom: $.roundZoom
                        })
                          , H = !r || Math.abs(r.tileID.overscaledZ - Z) > Math.abs(v.tileID.overscaledZ - Z)
                          , Y = H && v.refreshedUponExpiration ? 1 : o.ag(H ? A : 1 - B, 0, 1);
                        return v.refreshedUponExpiration && A >= 1 && (v.refreshedUponExpiration = !1),
                        r ? {
                            opacity: 1,
                            mix: 1 - Y
                        } : {
                            opacity: Y,
                            mix: 0
                        }
                    }
                    return {
                        opacity: 1,
                        mix: 0
                    }
                }
                const vh = new o.be(1,0,0,1)
                  , xh = new o.be(0,1,0,1)
                  , bh = new o.be(0,0,1,1)
                  , Ff = new o.be(1,0,1,1)
                  , Bf = new o.be(0,1,1,1);
                function Al(v, r, a, m) {
                    Mu(v, 0, r + a / 2, v.transform.width, a, m)
                }
                function Ms(v, r, a, m) {
                    Mu(v, r - a / 2, 0, a, v.transform.height, m)
                }
                function Mu(v, r, a, m, y, x) {
                    const P = v.context
                      , I = P.gl;
                    I.enable(I.SCISSOR_TEST),
                    I.scissor(r * v.pixelRatio, a * v.pixelRatio, m * v.pixelRatio, y * v.pixelRatio),
                    P.clear({
                        color: x
                    }),
                    I.disable(I.SCISSOR_TEST)
                }
                function zl(v, r, a) {
                    const m = v.context
                      , y = m.gl
                      , x = v.useProgram("debug")
                      , P = Fr.disabled
                      , I = Sr.disabled
                      , A = v.colorModeForRenderPass()
                      , B = "$debug"
                      , $ = v.style.map.terrain && v.style.map.terrain.getTerrainData(a);
                    m.activeTexture.set(y.TEXTURE0);
                    const Z = r.getTileByID(a.key).latestRawTileData
                      , H = Math.floor((Z && Z.byteLength || 0) / 1024)
                      , Y = r.getTile(a).tileSize
                      , ae = 512 / Math.min(Y, 512) * (a.overscaledZ / v.transform.zoom) * .5;
                    let ye = a.canonical.toString();
                    a.overscaledZ !== a.canonical.z && (ye += ` => ${a.overscaledZ}`),
                    function(Te, Re) {
                        Te.initDebugOverlayCanvas();
                        const De = Te.debugOverlayCanvas
                          , Ae = Te.context.gl
                          , Be = Te.debugOverlayCanvas.getContext("2d");
                        Be.clearRect(0, 0, De.width, De.height),
                        Be.shadowColor = "white",
                        Be.shadowBlur = 2,
                        Be.lineWidth = 1.5,
                        Be.strokeStyle = "white",
                        Be.textBaseline = "top",
                        Be.font = "bold 36px Open Sans, sans-serif",
                        Be.fillText(Re, 5, 5),
                        Be.strokeText(Re, 5, 5),
                        Te.debugOverlayTexture.update(De),
                        Te.debugOverlayTexture.bind(Ae.LINEAR, Ae.CLAMP_TO_EDGE)
                    }(v, `${ye} ${H}kB`);
                    const Se = v.transform.getProjectionData({
                        overscaledTileID: a,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                    });
                    x.draw(m, y.TRIANGLES, P, I, Yr.alphaBlended, jr.disabled, Tf(o.be.transparent, ae), null, Se, B, v.debugBuffer, v.quadTriangleIndexBuffer, v.debugSegments),
                    x.draw(m, y.LINE_STRIP, P, I, A, jr.disabled, Tf(o.be.red), $, Se, B, v.debugBuffer, v.tileBorderIndexBuffer, v.debugSegments)
                }
                function fn(v, r, a, m) {
                    const {isRenderingGlobe: y} = m
                      , x = v.context
                      , P = x.gl
                      , I = v.transform
                      , A = v.colorModeForRenderPass()
                      , B = v.getDepthModeFor3D()
                      , $ = v.useProgram("terrain");
                    x.bindFramebuffer.set(null),
                    x.viewport.set([0, 0, v.width, v.height]);
                    for (const Z of a) {
                        const H = r.getTerrainMesh(Z.tileID)
                          , Y = v.renderToTexture.getTexture(Z)
                          , ae = r.getTerrainData(Z.tileID);
                        x.activeTexture.set(P.TEXTURE0),
                        P.bindTexture(P.TEXTURE_2D, Y.texture);
                        const ye = r.getMeshFrameDelta(I.zoom)
                          , Se = I.calculateFogMatrix(Z.tileID.toUnwrapped())
                          , Te = im(ye, Se, v.style.sky, I.pitch, y)
                          , Re = I.getProjectionData({
                            overscaledTileID: Z.tileID,
                            applyTerrainMatrix: !1,
                            applyGlobeMatrix: !0
                        });
                        $.draw(x, P.TRIANGLES, B, Sr.disabled, A, jr.backCCW, Te, ae, Re, "terrain", H.vertexBuffer, H.indexBuffer, H.segments)
                    }
                }
                function ds(v, r) {
                    if (!r.mesh) {
                        const a = new o.aK;
                        a.emplaceBack(-1, -1),
                        a.emplaceBack(1, -1),
                        a.emplaceBack(1, 1),
                        a.emplaceBack(-1, 1);
                        const m = new o.aM;
                        m.emplaceBack(0, 1, 2),
                        m.emplaceBack(0, 2, 3),
                        r.mesh = new Ss(v.createVertexBuffer(a, Ns.members),v.createIndexBuffer(m),o.aL.simpleSegment(0, 0, a.length, m.length))
                    }
                    return r.mesh
                }
                class gi {
                    constructor(r, a) {
                        this.context = new Ur(r),
                        this.transform = a,
                        this._tileTextures = {},
                        this.terrainFacilitator = {
                            dirty: !0,
                            matrix: o.af(new Float64Array(16)),
                            renderTime: 0
                        },
                        this.setup(),
                        this.numSublayers = St.maxUnderzooming + St.maxOverzooming + 1,
                        this.depthEpsilon = 1 / Math.pow(2, 16),
                        this.crossTileSymbolIndex = new ic
                    }
                    resize(r, a, m) {
                        if (this.width = Math.floor(r * m),
                        this.height = Math.floor(a * m),
                        this.pixelRatio = m,
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.style)
                            for (const y of this.style._order)
                                this.style._layers[y].resize()
                    }
                    setup() {
                        const r = this.context
                          , a = new o.aK;
                        a.emplaceBack(0, 0),
                        a.emplaceBack(o.$, 0),
                        a.emplaceBack(0, o.$),
                        a.emplaceBack(o.$, o.$),
                        this.tileExtentBuffer = r.createVertexBuffer(a, Ns.members),
                        this.tileExtentSegments = o.aL.simpleSegment(0, 0, 4, 2);
                        const m = new o.aK;
                        m.emplaceBack(0, 0),
                        m.emplaceBack(o.$, 0),
                        m.emplaceBack(0, o.$),
                        m.emplaceBack(o.$, o.$),
                        this.debugBuffer = r.createVertexBuffer(m, Ns.members),
                        this.debugSegments = o.aL.simpleSegment(0, 0, 4, 5);
                        const y = new o.c5;
                        y.emplaceBack(0, 0, 0, 0),
                        y.emplaceBack(o.$, 0, o.$, 0),
                        y.emplaceBack(0, o.$, 0, o.$),
                        y.emplaceBack(o.$, o.$, o.$, o.$),
                        this.rasterBoundsBuffer = r.createVertexBuffer(y, nm.members),
                        this.rasterBoundsSegments = o.aL.simpleSegment(0, 0, 4, 2);
                        const x = new o.aK;
                        x.emplaceBack(0, 0),
                        x.emplaceBack(o.$, 0),
                        x.emplaceBack(0, o.$),
                        x.emplaceBack(o.$, o.$),
                        this.rasterBoundsBufferPosOnly = r.createVertexBuffer(x, Ns.members),
                        this.rasterBoundsSegmentsPosOnly = o.aL.simpleSegment(0, 0, 4, 5);
                        const P = new o.aK;
                        P.emplaceBack(0, 0),
                        P.emplaceBack(1, 0),
                        P.emplaceBack(0, 1),
                        P.emplaceBack(1, 1),
                        this.viewportBuffer = r.createVertexBuffer(P, Ns.members),
                        this.viewportSegments = o.aL.simpleSegment(0, 0, 4, 2);
                        const I = new o.c6;
                        I.emplaceBack(0),
                        I.emplaceBack(1),
                        I.emplaceBack(3),
                        I.emplaceBack(2),
                        I.emplaceBack(0),
                        this.tileBorderIndexBuffer = r.createIndexBuffer(I);
                        const A = new o.aM;
                        A.emplaceBack(1, 0, 2),
                        A.emplaceBack(1, 2, 3),
                        this.quadTriangleIndexBuffer = r.createIndexBuffer(A);
                        const B = this.context.gl;
                        this.stencilClearMode = new Sr({
                            func: B.ALWAYS,
                            mask: 0
                        },0,255,B.ZERO,B.ZERO,B.ZERO),
                        this.tileExtentMesh = new Ss(this.tileExtentBuffer,this.quadTriangleIndexBuffer,this.tileExtentSegments)
                    }
                    clearStencil() {
                        const r = this.context
                          , a = r.gl;
                        this.nextStencilID = 1,
                        this.currentStencilSource = void 0;
                        const m = o.L();
                        o.bX(m, 0, this.width, this.height, 0, 0, 1),
                        o.N(m, m, [a.drawingBufferWidth, a.drawingBufferHeight, 0]);
                        const y = {
                            mainMatrix: m,
                            tileMercatorCoords: [0, 0, 1, 1],
                            clippingPlane: [0, 0, 0, 0],
                            projectionTransition: 0,
                            fallbackMatrix: m
                        };
                        this.useProgram("clippingMask", null, !0).draw(r, a.TRIANGLES, Fr.disabled, this.stencilClearMode, Yr.disabled, jr.disabled, null, null, y, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
                    }
                    _renderTileClippingMasks(r, a, m) {
                        if (this.currentStencilSource === r.source || !r.isTileClipped() || !a || !a.length)
                            return;
                        this.currentStencilSource = r.source,
                        this.nextStencilID + a.length > 256 && this.clearStencil();
                        const y = this.context;
                        y.setColorMode(Yr.disabled),
                        y.setDepthMode(Fr.disabled);
                        const x = {};
                        for (const P of a)
                            x[P.key] = this.nextStencilID++;
                        this._renderTileMasks(x, a, m, !0),
                        this._renderTileMasks(x, a, m, !1),
                        this._tileClippingMaskIDs = x
                    }
                    _renderTileMasks(r, a, m, y) {
                        const x = this.context
                          , P = x.gl
                          , I = this.style.projection
                          , A = this.transform
                          , B = this.useProgram("clippingMask");
                        for (const $ of a) {
                            const Z = r[$.key]
                              , H = this.style.map.terrain && this.style.map.terrain.getTerrainData($)
                              , Y = I.getMeshFromTileID(this.context, $.canonical, y, !0, "stencil")
                              , ae = A.getProjectionData({
                                overscaledTileID: $,
                                applyGlobeMatrix: !m,
                                applyTerrainMatrix: !0
                            });
                            B.draw(x, P.TRIANGLES, Fr.disabled, new Sr({
                                func: P.ALWAYS,
                                mask: 0
                            },Z,255,P.KEEP,P.KEEP,P.REPLACE), Yr.disabled, m ? jr.disabled : jr.backCCW, null, H, ae, "$clipping", Y.vertexBuffer, Y.indexBuffer, Y.segments)
                        }
                    }
                    _renderTilesDepthBuffer() {
                        const r = this.context
                          , a = r.gl
                          , m = this.style.projection
                          , y = this.transform
                          , x = this.useProgram("depth")
                          , P = this.getDepthModeFor3D()
                          , I = dt(y, {
                            tileSize: y.tileSize
                        });
                        for (const A of I) {
                            const B = this.style.map.terrain && this.style.map.terrain.getTerrainData(A)
                              , $ = m.getMeshFromTileID(this.context, A.canonical, !0, !0, "raster")
                              , Z = y.getProjectionData({
                                overscaledTileID: A,
                                applyGlobeMatrix: !0,
                                applyTerrainMatrix: !0
                            });
                            x.draw(r, a.TRIANGLES, P, Sr.disabled, Yr.disabled, jr.backCCW, null, B, Z, "$clipping", $.vertexBuffer, $.indexBuffer, $.segments)
                        }
                    }
                    stencilModeFor3D() {
                        this.currentStencilSource = void 0,
                        this.nextStencilID + 1 > 256 && this.clearStencil();
                        const r = this.nextStencilID++
                          , a = this.context.gl;
                        return new Sr({
                            func: a.NOTEQUAL,
                            mask: 255
                        },r,255,a.KEEP,a.KEEP,a.REPLACE)
                    }
                    stencilModeForClipping(r) {
                        const a = this.context.gl;
                        return new Sr({
                            func: a.EQUAL,
                            mask: 255
                        },this._tileClippingMaskIDs[r.key],0,a.KEEP,a.KEEP,a.REPLACE)
                    }
                    getStencilConfigForOverlapAndUpdateStencilID(r) {
                        const a = this.context.gl
                          , m = r.sort( (P, I) => I.overscaledZ - P.overscaledZ)
                          , y = m[m.length - 1].overscaledZ
                          , x = m[0].overscaledZ - y + 1;
                        if (x > 1) {
                            this.currentStencilSource = void 0,
                            this.nextStencilID + x > 256 && this.clearStencil();
                            const P = {};
                            for (let I = 0; I < x; I++)
                                P[I + y] = new Sr({
                                    func: a.GEQUAL,
                                    mask: 255
                                },I + this.nextStencilID,255,a.KEEP,a.KEEP,a.REPLACE);
                            return this.nextStencilID += x,
                            [P, m]
                        }
                        return [{
                            [y]: Sr.disabled
                        }, m]
                    }
                    stencilConfigForOverlapTwoPass(r) {
                        const a = this.context.gl
                          , m = r.sort( (P, I) => I.overscaledZ - P.overscaledZ)
                          , y = m[m.length - 1].overscaledZ
                          , x = m[0].overscaledZ - y + 1;
                        if (this.clearStencil(),
                        x > 1) {
                            const P = {}
                              , I = {};
                            for (let A = 0; A < x; A++)
                                P[A + y] = new Sr({
                                    func: a.GREATER,
                                    mask: 255
                                },x + 1 + A,255,a.KEEP,a.KEEP,a.REPLACE),
                                I[A + y] = new Sr({
                                    func: a.GREATER,
                                    mask: 255
                                },1 + A,255,a.KEEP,a.KEEP,a.REPLACE);
                            return this.nextStencilID = 2 * x + 1,
                            [P, I, m]
                        }
                        return this.nextStencilID = 3,
                        [{
                            [y]: new Sr({
                                func: a.GREATER,
                                mask: 255
                            },2,255,a.KEEP,a.KEEP,a.REPLACE)
                        }, {
                            [y]: new Sr({
                                func: a.GREATER,
                                mask: 255
                            },1,255,a.KEEP,a.KEEP,a.REPLACE)
                        }, m]
                    }
                    colorModeForRenderPass() {
                        const r = this.context.gl;
                        return this._showOverdrawInspector ? new Yr([r.CONSTANT_COLOR, r.ONE],new o.be(.125,.125,.125,0),[!0, !0, !0, !0]) : this.renderPass === "opaque" ? Yr.unblended : Yr.alphaBlended
                    }
                    getDepthModeForSublayer(r, a, m) {
                        if (!this.opaquePassEnabledForLayer())
                            return Fr.disabled;
                        const y = 1 - ((1 + this.currentLayer) * this.numSublayers + r) * this.depthEpsilon;
                        return new Fr(m || this.context.gl.LEQUAL,a,[y, y])
                    }
                    getDepthModeFor3D() {
                        return new Fr(this.context.gl.LEQUAL,Fr.ReadWrite,this.depthRangeFor3D)
                    }
                    opaquePassEnabledForLayer() {
                        return this.currentLayer < this.opaquePassCutoff
                    }
                    render(r, a) {
                        var m, y;
                        this.style = r,
                        this.options = a,
                        this.lineAtlas = r.lineAtlas,
                        this.imageManager = r.imageManager,
                        this.glyphManager = r.glyphManager,
                        this.symbolFadeChange = r.placement.symbolFadeChange(z.now()),
                        this.imageManager.beginFrame();
                        const x = this.style._order
                          , P = this.style.sourceCaches
                          , I = {}
                          , A = {}
                          , B = {}
                          , $ = {
                            isRenderingToTexture: !1,
                            isRenderingGlobe: ((m = r.projection) === null || m === void 0 ? void 0 : m.transitionState) > 0
                        };
                        for (const H in P) {
                            const Y = P[H];
                            Y.used && Y.prepare(this.context),
                            I[H] = Y.getVisibleCoordinates(!1),
                            A[H] = I[H].slice().reverse(),
                            B[H] = Y.getVisibleCoordinates(!0).reverse()
                        }
                        this.opaquePassCutoff = 1 / 0;
                        for (let H = 0; H < x.length; H++)
                            if (this.style._layers[x[H]].is3D()) {
                                this.opaquePassCutoff = H;
                                break
                            }
                        this.maybeDrawDepthAndCoords(!1),
                        this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom),
                        this.opaquePassCutoff = 0),
                        this.renderPass = "offscreen";
                        for (const H of x) {
                            const Y = this.style._layers[H];
                            if (!Y.hasOffscreenPass() || Y.isHidden(this.transform.zoom))
                                continue;
                            const ae = A[Y.source];
                            (Y.type === "custom" || ae.length) && this.renderLayer(this, P[Y.source], Y, ae, $)
                        }
                        if ((y = this.style.projection) === null || y === void 0 || y.updateGPUdependent({
                            context: this.context,
                            useProgram: H => this.useProgram(H)
                        }),
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.context.bindFramebuffer.set(null),
                        this.context.clear({
                            color: a.showOverdrawInspector ? o.be.black : o.be.transparent,
                            depth: 1
                        }),
                        this.clearStencil(),
                        this.style.sky && function(H, Y) {
                            const ae = H.context
                              , ye = ae.gl
                              , Se = ( (qe, ze, Ke) => {
                                const ht = Math.cos(ze.rollInRadians)
                                  , ot = Math.sin(ze.rollInRadians)
                                  , ut = fe(ze)
                                  , mt = ze.getProjectionData({
                                    overscaledTileID: null,
                                    applyGlobeMatrix: !0,
                                    applyTerrainMatrix: !0
                                }).projectionTransition;
                                return {
                                    u_sky_color: qe.properties.get("sky-color"),
                                    u_horizon_color: qe.properties.get("horizon-color"),
                                    u_horizon: [(ze.width / 2 - ut * ot) * Ke, (ze.height / 2 + ut * ht) * Ke],
                                    u_horizon_normal: [-ot, ht],
                                    u_sky_horizon_blend: qe.properties.get("sky-horizon-blend") * ze.height / 2 * Ke,
                                    u_sky_blend: mt
                                }
                            }
                            )(Y, H.style.map.transform, H.pixelRatio)
                              , Te = new Fr(ye.LEQUAL,Fr.ReadWrite,[0, 1])
                              , Re = Sr.disabled
                              , De = H.colorModeForRenderPass()
                              , Ae = H.useProgram("sky")
                              , Be = ds(ae, Y);
                            Ae.draw(ae, ye.TRIANGLES, Te, Re, De, jr.disabled, Se, null, void 0, "sky", Be.vertexBuffer, Be.indexBuffer, Be.segments)
                        }(this, this.style.sky),
                        this._showOverdrawInspector = a.showOverdrawInspector,
                        this.depthRangeFor3D = [0, 1 - (r._order.length + 2) * this.numSublayers * this.depthEpsilon],
                        !this.renderToTexture)
                            for (this.renderPass = "opaque",
                            this.currentLayer = x.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                                const H = this.style._layers[x[this.currentLayer]]
                                  , Y = P[H.source]
                                  , ae = I[H.source];
                                this._renderTileClippingMasks(H, ae, !1),
                                this.renderLayer(this, Y, H, ae, $)
                            }
                        this.renderPass = "translucent";
                        let Z = !1;
                        for (this.currentLayer = 0; this.currentLayer < x.length; this.currentLayer++) {
                            const H = this.style._layers[x[this.currentLayer]]
                              , Y = P[H.source];
                            if (this.renderToTexture && this.renderToTexture.renderLayer(H, $))
                                continue;
                            this.opaquePassEnabledForLayer() || Z || (Z = !0,
                            $.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
                            const ae = (H.type === "symbol" ? B : A)[H.source];
                            this._renderTileClippingMasks(H, I[H.source], !!this.renderToTexture),
                            this.renderLayer(this, Y, H, ae, $)
                        }
                        if ($.isRenderingGlobe && function(H, Y, ae) {
                            const ye = H.context
                              , Se = ye.gl
                              , Te = H.useProgram("atmosphere")
                              , Re = new Fr(Se.LEQUAL,Fr.ReadOnly,[0, 1])
                              , De = H.transform
                              , Ae = function(mt, $t) {
                                const jt = mt.properties.get("position")
                                  , It = [-jt.x, -jt.y, -jt.z]
                                  , or = o.af(new Float64Array(16));
                                return mt.properties.get("anchor") === "map" && (o.b5(or, or, $t.rollInRadians),
                                o.b6(or, or, -$t.pitchInRadians),
                                o.b5(or, or, $t.bearingInRadians),
                                o.b6(or, or, $t.center.lat * Math.PI / 180),
                                o.by(or, or, -$t.center.lng * Math.PI / 180)),
                                o.c4(It, It, or),
                                It
                            }(ae, H.transform)
                              , Be = De.getProjectionData({
                                overscaledTileID: null,
                                applyGlobeMatrix: !0,
                                applyTerrainMatrix: !0
                            })
                              , qe = Y.properties.get("atmosphere-blend") * Be.projectionTransition;
                            if (qe === 0)
                                return;
                            const ze = aa(De.worldSize, De.center.lat)
                              , Ke = De.inverseProjectionMatrix
                              , ht = new Float64Array(4);
                            ht[3] = 1,
                            o.av(ht, ht, De.modelViewProjectionMatrix),
                            ht[0] /= ht[3],
                            ht[1] /= ht[3],
                            ht[2] /= ht[3],
                            ht[3] = 1,
                            o.av(ht, ht, Ke),
                            ht[0] /= ht[3],
                            ht[1] /= ht[3],
                            ht[2] /= ht[3],
                            ht[3] = 1;
                            const ot = ( (mt, $t, jt, It, or) => ({
                                u_sun_pos: mt,
                                u_atmosphere_blend: $t,
                                u_globe_position: jt,
                                u_globe_radius: It,
                                u_inv_proj_matrix: or
                            }))(Ae, qe, [ht[0], ht[1], ht[2]], ze, Ke)
                              , ut = ds(ye, Y);
                            Te.draw(ye, Se.TRIANGLES, Re, Sr.disabled, Yr.alphaBlended, jr.disabled, ot, null, null, "atmosphere", ut.vertexBuffer, ut.indexBuffer, ut.segments)
                        }(this, this.style.sky, this.style.light),
                        this.options.showTileBoundaries) {
                            const H = function(Y, ae) {
                                let ye = null;
                                const Se = Object.values(Y._layers).flatMap(Ae => Ae.source && !Ae.isHidden(ae) ? [Y.sourceCaches[Ae.source]] : [])
                                  , Te = Se.filter(Ae => Ae.getSource().type === "vector")
                                  , Re = Se.filter(Ae => Ae.getSource().type !== "vector")
                                  , De = Ae => {
                                    (!ye || ye.getSource().maxzoom < Ae.getSource().maxzoom) && (ye = Ae)
                                }
                                ;
                                return Te.forEach(Ae => De(Ae)),
                                ye || Re.forEach(Ae => De(Ae)),
                                ye
                            }(this.style, this.transform.zoom);
                            H && function(Y, ae, ye) {
                                for (let Se = 0; Se < ye.length; Se++)
                                    zl(Y, ae, ye[Se])
                            }(this, H, H.getVisibleCoordinates())
                        }
                        this.options.showPadding && function(H) {
                            const Y = H.transform.padding;
                            Al(H, H.transform.height - (Y.top || 0), 3, vh),
                            Al(H, Y.bottom || 0, 3, xh),
                            Ms(H, Y.left || 0, 3, bh),
                            Ms(H, H.transform.width - (Y.right || 0), 3, Ff);
                            const ae = H.transform.centerPoint;
                            (function(ye, Se, Te, Re) {
                                Mu(ye, Se - 1, Te - 10, 2, 20, Re),
                                Mu(ye, Se - 10, Te - 1, 20, 2, Re)
                            }
                            )(H, ae.x, H.transform.height - ae.y, Bf)
                        }(this),
                        this.context.setDefault()
                    }
                    maybeDrawDepthAndCoords(r) {
                        if (!this.style || !this.style.map || !this.style.map.terrain)
                            return;
                        const a = this.terrainFacilitator.matrix
                          , m = this.transform.modelViewProjectionMatrix;
                        let y = this.terrainFacilitator.dirty;
                        y || (y = r ? !o.c7(a, m) : !o.c8(a, m)),
                        y || (y = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)),
                        y && (o.c9(a, m),
                        this.terrainFacilitator.renderTime = Date.now(),
                        this.terrainFacilitator.dirty = !1,
                        function(x, P) {
                            const I = x.context
                              , A = I.gl
                              , B = x.transform
                              , $ = Yr.unblended
                              , Z = new Fr(A.LEQUAL,Fr.ReadWrite,[0, 1])
                              , H = P.sourceCache.getRenderableTiles()
                              , Y = x.useProgram("terrainDepth");
                            I.bindFramebuffer.set(P.getFramebuffer("depth").framebuffer),
                            I.viewport.set([0, 0, x.width / devicePixelRatio, x.height / devicePixelRatio]),
                            I.clear({
                                color: o.be.transparent,
                                depth: 1
                            });
                            for (const ae of H) {
                                const ye = P.getTerrainMesh(ae.tileID)
                                  , Se = P.getTerrainData(ae.tileID)
                                  , Te = B.getProjectionData({
                                    overscaledTileID: ae.tileID,
                                    applyTerrainMatrix: !1,
                                    applyGlobeMatrix: !0
                                })
                                  , Re = {
                                    u_ele_delta: P.getMeshFrameDelta(B.zoom)
                                };
                                Y.draw(I, A.TRIANGLES, Z, Sr.disabled, $, jr.backCCW, Re, Se, Te, "terrain", ye.vertexBuffer, ye.indexBuffer, ye.segments)
                            }
                            I.bindFramebuffer.set(null),
                            I.viewport.set([0, 0, x.width, x.height])
                        }(this, this.style.map.terrain),
                        function(x, P) {
                            const I = x.context
                              , A = I.gl
                              , B = x.transform
                              , $ = Yr.unblended
                              , Z = new Fr(A.LEQUAL,Fr.ReadWrite,[0, 1])
                              , H = P.getCoordsTexture()
                              , Y = P.sourceCache.getRenderableTiles()
                              , ae = x.useProgram("terrainCoords");
                            I.bindFramebuffer.set(P.getFramebuffer("coords").framebuffer),
                            I.viewport.set([0, 0, x.width / devicePixelRatio, x.height / devicePixelRatio]),
                            I.clear({
                                color: o.be.transparent,
                                depth: 1
                            }),
                            P.coordsIndex = [];
                            for (const ye of Y) {
                                const Se = P.getTerrainMesh(ye.tileID)
                                  , Te = P.getTerrainData(ye.tileID);
                                I.activeTexture.set(A.TEXTURE0),
                                A.bindTexture(A.TEXTURE_2D, H.texture);
                                const Re = {
                                    u_terrain_coords_id: (255 - P.coordsIndex.length) / 255,
                                    u_texture: 0,
                                    u_ele_delta: P.getMeshFrameDelta(B.zoom)
                                }
                                  , De = B.getProjectionData({
                                    overscaledTileID: ye.tileID,
                                    applyTerrainMatrix: !1,
                                    applyGlobeMatrix: !0
                                });
                                ae.draw(I, A.TRIANGLES, Z, Sr.disabled, $, jr.backCCW, Re, Te, De, "terrain", Se.vertexBuffer, Se.indexBuffer, Se.segments),
                                P.coordsIndex.push(ye.tileID.key)
                            }
                            I.bindFramebuffer.set(null),
                            I.viewport.set([0, 0, x.width, x.height])
                        }(this, this.style.map.terrain))
                    }
                    renderLayer(r, a, m, y, x) {
                        m.isHidden(this.transform.zoom) || (m.type === "background" || m.type === "custom" || (y || []).length) && (this.id = m.id,
                        o.ca(m) ? function(P, I, A, B, $, Z) {
                            if (P.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: H} = Z
                              , Y = Sr.disabled
                              , ae = P.colorModeForRenderPass();
                            (A._unevaluatedLayout.hasValue("text-variable-anchor") || A._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(ye, Se, Te, Re, De, Ae, Be, qe, ze) {
                                const Ke = Se.transform
                                  , ht = Se.style.map.terrain
                                  , ot = De === "map"
                                  , ut = Ae === "map";
                                for (const mt of ye) {
                                    const $t = Re.getTile(mt)
                                      , jt = $t.getBucket(Te);
                                    if (!jt || !jt.text || !jt.text.segments.get().length)
                                        continue;
                                    const It = o.am(jt.textSizeData, Ke.zoom)
                                      , or = o.aB($t, 1, Se.transform.zoom)
                                      , Vr = br(ot, Se.transform, or)
                                      , cn = Te.layout.get("icon-text-fit") !== "none" && jt.hasIconData();
                                    if (It) {
                                        const Kn = Math.pow(2, Ke.zoom - $t.tileID.overscaledZ)
                                          , Sn = ht ? (On, kn) => ht.getElevation(mt, On, kn) : null;
                                        _h(jt, ot, ut, ze, Ke, Vr, Kn, It, cn, o.aC(Ke, $t, Be, qe), mt.toUnwrapped(), Sn)
                                    }
                                }
                            }(B, P, A, I, A.layout.get("text-rotation-alignment"), A.layout.get("text-pitch-alignment"), A.paint.get("text-translate"), A.paint.get("text-translate-anchor"), $),
                            A.paint.get("icon-opacity").constantOr(1) !== 0 && Td(P, I, A, B, !1, A.paint.get("icon-translate"), A.paint.get("icon-translate-anchor"), A.layout.get("icon-rotation-alignment"), A.layout.get("icon-pitch-alignment"), A.layout.get("icon-keep-upright"), Y, ae, H),
                            A.paint.get("text-opacity").constantOr(1) !== 0 && Td(P, I, A, B, !0, A.paint.get("text-translate"), A.paint.get("text-translate-anchor"), A.layout.get("text-rotation-alignment"), A.layout.get("text-pitch-alignment"), A.layout.get("text-keep-upright"), Y, ae, H),
                            I.map.showCollisionBoxes && (wd(P, I, A, B, !0),
                            wd(P, I, A, B, !1))
                        }(r, a, m, y, this.style.placement.variableOffsets, x) : o.cb(m) ? function(P, I, A, B, $) {
                            if (P.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: Z} = $
                              , H = A.paint.get("circle-opacity")
                              , Y = A.paint.get("circle-stroke-width")
                              , ae = A.paint.get("circle-stroke-opacity")
                              , ye = !A.layout.get("circle-sort-key").isConstant();
                            if (H.constantOr(1) === 0 && (Y.constantOr(1) === 0 || ae.constantOr(1) === 0))
                                return;
                            const Se = P.context
                              , Te = Se.gl
                              , Re = P.transform
                              , De = P.getDepthModeForSublayer(0, Fr.ReadOnly)
                              , Ae = Sr.disabled
                              , Be = P.colorModeForRenderPass()
                              , qe = []
                              , ze = Re.getCircleRadiusCorrection();
                            for (let Ke = 0; Ke < B.length; Ke++) {
                                const ht = B[Ke]
                                  , ot = I.getTile(ht)
                                  , ut = ot.getBucket(A);
                                if (!ut)
                                    continue;
                                const mt = A.paint.get("circle-translate")
                                  , $t = A.paint.get("circle-translate-anchor")
                                  , jt = o.aC(Re, ot, mt, $t)
                                  , It = ut.programConfigurations.get(A.id)
                                  , or = P.useProgram("circle", It)
                                  , Vr = ut.layoutVertexBuffer
                                  , cn = ut.indexBuffer
                                  , Kn = P.style.map.terrain && P.style.map.terrain.getTerrainData(ht)
                                  , Sn = {
                                    programConfiguration: It,
                                    program: or,
                                    layoutVertexBuffer: Vr,
                                    indexBuffer: cn,
                                    uniformValues: ud(P, ot, A, jt, ze),
                                    terrainData: Kn,
                                    projectionData: Re.getProjectionData({
                                        overscaledTileID: ht,
                                        applyGlobeMatrix: !Z,
                                        applyTerrainMatrix: !0
                                    })
                                };
                                if (ye) {
                                    const On = ut.segments.get();
                                    for (const kn of On)
                                        qe.push({
                                            segments: new o.aL([kn]),
                                            sortKey: kn.sortKey,
                                            state: Sn
                                        })
                                } else
                                    qe.push({
                                        segments: ut.segments,
                                        sortKey: 0,
                                        state: Sn
                                    })
                            }
                            ye && qe.sort( (Ke, ht) => Ke.sortKey - ht.sortKey);
                            for (const Ke of qe) {
                                const {programConfiguration: ht, program: ot, layoutVertexBuffer: ut, indexBuffer: mt, uniformValues: $t, terrainData: jt, projectionData: It} = Ke.state;
                                ot.draw(Se, Te.TRIANGLES, De, Ae, Be, jr.backCCW, $t, jt, It, A.id, ut, mt, Ke.segments, A.paint, P.transform.zoom, ht)
                            }
                        }(r, a, m, y, x) : o.cc(m) ? function(P, I, A, B, $) {
                            if (A.paint.get("heatmap-opacity") === 0)
                                return;
                            const Z = P.context
                              , {isRenderingToTexture: H, isRenderingGlobe: Y} = $;
                            if (P.style.map.terrain) {
                                for (const ae of B) {
                                    const ye = I.getTile(ae);
                                    I.hasRenderableParent(ae) || (P.renderPass === "offscreen" ? qa(P, ye, A, ae, Y) : P.renderPass === "translucent" && Il(P, A, ae, H, Y))
                                }
                                Z.viewport.set([0, 0, P.width, P.height])
                            } else
                                P.renderPass === "offscreen" ? function(ae, ye, Se, Te) {
                                    const Re = ae.context
                                      , De = Re.gl
                                      , Ae = ae.transform
                                      , Be = Sr.disabled
                                      , qe = new Yr([De.ONE, De.ONE],o.be.transparent,[!0, !0, !0, !0]);
                                    (function(ze, Ke, ht) {
                                        const ot = ze.gl;
                                        ze.activeTexture.set(ot.TEXTURE1),
                                        ze.viewport.set([0, 0, Ke.width / 4, Ke.height / 4]);
                                        let ut = ht.heatmapFbos.get(o.c1);
                                        ut ? (ot.bindTexture(ot.TEXTURE_2D, ut.colorAttachment.get()),
                                        ze.bindFramebuffer.set(ut.framebuffer)) : (ut = Ws(ze, Ke.width / 4, Ke.height / 4),
                                        ht.heatmapFbos.set(o.c1, ut))
                                    }
                                    )(Re, ae, Se),
                                    Re.clear({
                                        color: o.be.transparent
                                    });
                                    for (let ze = 0; ze < Te.length; ze++) {
                                        const Ke = Te[ze];
                                        if (ye.hasRenderableParent(Ke))
                                            continue;
                                        const ht = ye.getTile(Ke)
                                          , ot = ht.getBucket(Se);
                                        if (!ot)
                                            continue;
                                        const ut = ot.programConfigurations.get(Se.id)
                                          , mt = ae.useProgram("heatmap", ut)
                                          , $t = Ae.getProjectionData({
                                            overscaledTileID: Ke,
                                            applyGlobeMatrix: !0,
                                            applyTerrainMatrix: !1
                                        })
                                          , jt = Ae.getCircleRadiusCorrection();
                                        mt.draw(Re, De.TRIANGLES, Fr.disabled, Be, qe, jr.backCCW, fu(ht, Ae.zoom, Se.paint.get("heatmap-intensity"), jt), null, $t, Se.id, ot.layoutVertexBuffer, ot.indexBuffer, ot.segments, Se.paint, Ae.zoom, ut)
                                    }
                                    Re.viewport.set([0, 0, ae.width, ae.height])
                                }(P, I, A, B) : P.renderPass === "translucent" && function(ae, ye) {
                                    const Se = ae.context
                                      , Te = Se.gl;
                                    Se.setColorMode(ae.colorModeForRenderPass());
                                    const Re = ye.heatmapFbos.get(o.c1);
                                    Re && (Se.activeTexture.set(Te.TEXTURE0),
                                    Te.bindTexture(Te.TEXTURE_2D, Re.colorAttachment.get()),
                                    Se.activeTexture.set(Te.TEXTURE1),
                                    Cu(Se, ye).bind(Te.LINEAR, Te.CLAMP_TO_EDGE),
                                    ae.useProgram("heatmapTexture").draw(Se, Te.TRIANGLES, Fr.disabled, Sr.disabled, ae.colorModeForRenderPass(), jr.disabled, Pf(ae, ye, 0, 1), null, null, ye.id, ae.viewportBuffer, ae.quadTriangleIndexBuffer, ae.viewportSegments, ye.paint, ae.transform.zoom))
                                }(P, A)
                        }(r, a, m, y, x) : o.cd(m) ? function(P, I, A, B, $) {
                            if (P.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: Z} = $
                              , H = A.paint.get("line-opacity")
                              , Y = A.paint.get("line-width");
                            if (H.constantOr(1) === 0 || Y.constantOr(1) === 0)
                                return;
                            const ae = P.getDepthModeForSublayer(0, Fr.ReadOnly)
                              , ye = P.colorModeForRenderPass()
                              , Se = A.paint.get("line-dasharray")
                              , Te = A.paint.get("line-pattern")
                              , Re = Te.constantOr(1)
                              , De = A.paint.get("line-gradient")
                              , Ae = A.getCrossfadeParameters()
                              , Be = Re ? "linePattern" : Se ? "lineSDF" : De ? "lineGradient" : "line"
                              , qe = P.context
                              , ze = qe.gl
                              , Ke = P.transform;
                            let ht = !0;
                            for (const ot of B) {
                                const ut = I.getTile(ot);
                                if (Re && !ut.patternsLoaded())
                                    continue;
                                const mt = ut.getBucket(A);
                                if (!mt)
                                    continue;
                                const $t = mt.programConfigurations.get(A.id)
                                  , jt = P.context.program.get()
                                  , It = P.useProgram(Be, $t)
                                  , or = ht || It.program !== jt
                                  , Vr = P.style.map.terrain && P.style.map.terrain.getTerrainData(ot)
                                  , cn = Te.constantOr(null);
                                if (cn && ut.imageAtlas) {
                                    const pn = ut.imageAtlas
                                      , vn = pn.patternPositions[cn.to.toString()]
                                      , zi = pn.patternPositions[cn.from.toString()];
                                    vn && zi && $t.setConstantPatternPositions(vn, zi)
                                }
                                const Kn = Ke.getProjectionData({
                                    overscaledTileID: ot,
                                    applyGlobeMatrix: !Z,
                                    applyTerrainMatrix: !0
                                })
                                  , Sn = Ke.getPixelScale()
                                  , On = Re ? hd(P, ut, A, Sn, Ae) : Se ? dd(P, ut, A, Sn, Se, Ae) : De ? fh(P, ut, A, Sn, mt.lineClipsArray.length) : mu(P, ut, A, Sn);
                                if (Re)
                                    qe.activeTexture.set(ze.TEXTURE0),
                                    ut.imageAtlasTexture.bind(ze.LINEAR, ze.CLAMP_TO_EDGE),
                                    $t.updatePaintBuffers(Ae);
                                else if (Se && (or || P.lineAtlas.dirty))
                                    qe.activeTexture.set(ze.TEXTURE0),
                                    P.lineAtlas.bind(qe);
                                else if (De) {
                                    const pn = mt.gradients[A.id];
                                    let vn = pn.texture;
                                    if (A.gradientVersion !== pn.version) {
                                        let zi = 256;
                                        if (A.stepInterpolant) {
                                            const rn = I.getSource().maxzoom
                                              , Ti = ot.canonical.z === rn ? Math.ceil(1 << P.transform.maxZoom - ot.canonical.z) : 1;
                                            zi = o.ag(o.c2(mt.maxLineLength / o.$ * 1024 * Ti), 256, qe.maxTextureSize)
                                        }
                                        pn.gradient = o.c3({
                                            expression: A.gradientExpression(),
                                            evaluationKey: "lineProgress",
                                            resolution: zi,
                                            image: pn.gradient || void 0,
                                            clips: mt.lineClipsArray
                                        }),
                                        pn.texture ? pn.texture.update(pn.gradient) : pn.texture = new o.T(qe,pn.gradient,ze.RGBA),
                                        pn.version = A.gradientVersion,
                                        vn = pn.texture
                                    }
                                    qe.activeTexture.set(ze.TEXTURE0),
                                    vn.bind(A.stepInterpolant ? ze.NEAREST : ze.LINEAR, ze.CLAMP_TO_EDGE)
                                }
                                const kn = P.stencilModeForClipping(ot);
                                It.draw(qe, ze.TRIANGLES, ae, kn, ye, jr.disabled, On, Vr, Kn, A.id, mt.layoutVertexBuffer, mt.indexBuffer, mt.segments, A.paint, P.transform.zoom, $t, mt.layoutVertexBuffer2),
                                ht = !1
                            }
                        }(r, a, m, y, x) : o.ce(m) ? function(P, I, A, B, $) {
                            const Z = A.paint.get("fill-color")
                              , H = A.paint.get("fill-opacity");
                            if (H.constantOr(1) === 0)
                                return;
                            const {isRenderingToTexture: Y} = $
                              , ae = P.colorModeForRenderPass()
                              , ye = A.paint.get("fill-pattern")
                              , Se = P.opaquePassEnabledForLayer() && !ye.constantOr(1) && Z.constantOr(o.be.transparent).a === 1 && H.constantOr(0) === 1 ? "opaque" : "translucent";
                            if (P.renderPass === Se) {
                                const Te = P.getDepthModeForSublayer(1, P.renderPass === "opaque" ? Fr.ReadWrite : Fr.ReadOnly);
                                Tu(P, I, A, B, Te, ae, !1, Y)
                            }
                            if (P.renderPass === "translucent" && A.paint.get("fill-antialias")) {
                                const Te = P.getDepthModeForSublayer(A.getPaintProperty("fill-outline-color") ? 2 : 0, Fr.ReadOnly);
                                Tu(P, I, A, B, Te, ae, !0, Y)
                            }
                        }(r, a, m, y, x) : o.cf(m) ? function(P, I, A, B, $) {
                            const Z = A.paint.get("fill-extrusion-opacity");
                            if (Z === 0)
                                return;
                            const {isRenderingToTexture: H} = $;
                            if (P.renderPass === "translucent") {
                                const Y = new Fr(P.context.gl.LEQUAL,Fr.ReadWrite,P.depthRangeFor3D);
                                if (Z !== 1 || A.paint.get("fill-extrusion-pattern").constantOr(1))
                                    Rl(P, I, A, B, Y, Sr.disabled, Yr.disabled, H),
                                    Rl(P, I, A, B, Y, P.stencilModeFor3D(), P.colorModeForRenderPass(), H);
                                else {
                                    const ae = P.colorModeForRenderPass();
                                    Rl(P, I, A, B, Y, Sr.disabled, ae, H)
                                }
                            }
                        }(r, a, m, y, x) : o.cg(m) ? function(P, I, A, B, $) {
                            if (P.renderPass !== "offscreen" && P.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: Z} = $
                              , H = P.context
                              , Y = P.style.projection.useSubdivision
                              , ae = P.getDepthModeForSublayer(0, Fr.ReadOnly)
                              , ye = P.colorModeForRenderPass();
                            if (P.renderPass === "offscreen")
                                (function(Se, Te, Re, De, Ae, Be, qe) {
                                    const ze = Se.context
                                      , Ke = ze.gl;
                                    for (const ht of Re) {
                                        const ot = Te.getTile(ht)
                                          , ut = ot.dem;
                                        if (!ut || !ut.data || !ot.needsHillshadePrepare)
                                            continue;
                                        const mt = ut.dim
                                          , $t = ut.stride
                                          , jt = ut.getPixels();
                                        if (ze.activeTexture.set(Ke.TEXTURE1),
                                        ze.pixelStoreUnpackPremultiplyAlpha.set(!1),
                                        ot.demTexture = ot.demTexture || Se.getTileTexture($t),
                                        ot.demTexture) {
                                            const or = ot.demTexture;
                                            or.update(jt, {
                                                premultiply: !1
                                            }),
                                            or.bind(Ke.NEAREST, Ke.CLAMP_TO_EDGE)
                                        } else
                                            ot.demTexture = new o.T(ze,jt,Ke.RGBA,{
                                                premultiply: !1
                                            }),
                                            ot.demTexture.bind(Ke.NEAREST, Ke.CLAMP_TO_EDGE);
                                        ze.activeTexture.set(Ke.TEXTURE0);
                                        let It = ot.fbo;
                                        if (!It) {
                                            const or = new o.T(ze,{
                                                width: mt,
                                                height: mt,
                                                data: null
                                            },Ke.RGBA);
                                            or.bind(Ke.LINEAR, Ke.CLAMP_TO_EDGE),
                                            It = ot.fbo = ze.createFramebuffer(mt, mt, !0, !1),
                                            It.colorAttachment.set(or.texture)
                                        }
                                        ze.bindFramebuffer.set(It.framebuffer),
                                        ze.viewport.set([0, 0, mt, mt]),
                                        Se.useProgram("hillshadePrepare").draw(ze, Ke.TRIANGLES, Ae, Be, qe, jr.disabled, pu(ot.tileID, ut), null, null, De.id, Se.rasterBoundsBuffer, Se.quadTriangleIndexBuffer, Se.rasterBoundsSegments),
                                        ot.needsHillshadePrepare = !1
                                    }
                                }
                                )(P, I, B, A, ae, Sr.disabled, ye),
                                H.viewport.set([0, 0, P.width, P.height]);
                            else if (P.renderPass === "translucent")
                                if (Y) {
                                    const [Se,Te,Re] = P.stencilConfigForOverlapTwoPass(B);
                                    ha(P, I, A, Re, Se, ae, ye, !1, Z),
                                    ha(P, I, A, Re, Te, ae, ye, !0, Z)
                                } else {
                                    const [Se,Te] = P.getStencilConfigForOverlapAndUpdateStencilID(B);
                                    ha(P, I, A, Te, Se, ae, ye, !1, Z)
                                }
                        }(r, a, m, y, x) : o.ch(m) ? function(P, I, A, B, $) {
                            if (P.renderPass !== "translucent" || !B.length)
                                return;
                            const {isRenderingToTexture: Z} = $
                              , H = P.style.projection.useSubdivision
                              , Y = P.getDepthModeForSublayer(0, Fr.ReadOnly)
                              , ae = P.colorModeForRenderPass();
                            if (H) {
                                const [ye,Se,Te] = P.stencilConfigForOverlapTwoPass(B);
                                Ha(P, I, A, Te, ye, Y, ae, !1, Z),
                                Ha(P, I, A, Te, Se, Y, ae, !0, Z)
                            } else {
                                const [ye,Se] = P.getStencilConfigForOverlapAndUpdateStencilID(B);
                                Ha(P, I, A, Se, ye, Y, ae, !1, Z)
                            }
                        }(r, a, m, y, x) : o.ci(m) ? function(P, I, A, B, $) {
                            if (P.renderPass !== "translucent" || A.paint.get("raster-opacity") === 0 || !B.length)
                                return;
                            const {isRenderingToTexture: Z} = $
                              , H = I.getSource()
                              , Y = P.style.projection.useSubdivision;
                            if (H instanceof gn)
                                qs(P, I, A, B, null, !1, !1, H.tileCoords, H.flippedWindingOrder, Z);
                            else if (Y) {
                                const [ae,ye,Se] = P.stencilConfigForOverlapTwoPass(B);
                                qs(P, I, A, Se, ae, !1, !0, Pu, !1, Z),
                                qs(P, I, A, Se, ye, !0, !0, Pu, !1, Z)
                            } else {
                                const [ae,ye] = P.getStencilConfigForOverlapAndUpdateStencilID(B);
                                qs(P, I, A, ye, ae, !1, !0, Pu, !1, Z)
                            }
                        }(r, a, m, y, x) : o.cj(m) ? function(P, I, A, B, $) {
                            const Z = A.paint.get("background-color")
                              , H = A.paint.get("background-opacity");
                            if (H === 0)
                                return;
                            const {isRenderingToTexture: Y} = $
                              , ae = P.context
                              , ye = ae.gl
                              , Se = P.style.projection
                              , Te = P.transform
                              , Re = Te.tileSize
                              , De = A.paint.get("background-pattern");
                            if (P.isPatternMissing(De))
                                return;
                            const Ae = !De && Z.a === 1 && H === 1 && P.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                            if (P.renderPass !== Ae)
                                return;
                            const Be = Sr.disabled
                              , qe = P.getDepthModeForSublayer(0, Ae === "opaque" ? Fr.ReadWrite : Fr.ReadOnly)
                              , ze = P.colorModeForRenderPass()
                              , Ke = P.useProgram(De ? "backgroundPattern" : "background")
                              , ht = B || dt(Te, {
                                tileSize: Re,
                                terrain: P.style.map.terrain
                            });
                            De && (ae.activeTexture.set(ye.TEXTURE0),
                            P.imageManager.bind(P.context));
                            const ot = A.getCrossfadeParameters();
                            for (const ut of ht) {
                                const mt = Te.getProjectionData({
                                    overscaledTileID: ut,
                                    applyGlobeMatrix: !Y,
                                    applyTerrainMatrix: !0
                                })
                                  , $t = De ? am(H, P, De, {
                                    tileID: ut,
                                    tileSize: Re
                                }, ot) : ja(H, Z)
                                  , jt = P.style.map.terrain && P.style.map.terrain.getTerrainData(ut)
                                  , It = Se.getMeshFromTileID(ae, ut.canonical, !1, !0, "raster");
                                Ke.draw(ae, ye.TRIANGLES, qe, Be, ze, jr.backCCW, $t, jt, mt, A.id, It.vertexBuffer, It.indexBuffer, It.segments)
                            }
                        }(r, 0, m, y, x) : o.ck(m) && function(P, I, A, B) {
                            const {isRenderingGlobe: $} = B
                              , Z = P.context
                              , H = A.implementation
                              , Y = P.style.projection
                              , ae = P.transform
                              , ye = ae.getProjectionDataForCustomLayer($)
                              , Se = {
                                farZ: ae.farZ,
                                nearZ: ae.nearZ,
                                fov: ae.fov * Math.PI / 180,
                                modelViewProjectionMatrix: ae.modelViewProjectionMatrix,
                                projectionMatrix: ae.projectionMatrix,
                                shaderData: {
                                    variantName: Y.shaderVariantName,
                                    vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${Y.shaderPreludeCode.vertexSource}`,
                                    define: Y.shaderDefine
                                },
                                defaultProjectionData: ye
                            }
                              , Te = H.renderingMode ? H.renderingMode : "2d";
                            if (P.renderPass === "offscreen") {
                                const Re = H.prerender;
                                Re && (P.setCustomLayerDefaults(),
                                Z.setColorMode(P.colorModeForRenderPass()),
                                Re.call(H, Z.gl, Se),
                                Z.setDirty(),
                                P.setBaseState())
                            } else if (P.renderPass === "translucent") {
                                P.setCustomLayerDefaults(),
                                Z.setColorMode(P.colorModeForRenderPass()),
                                Z.setStencilMode(Sr.disabled);
                                const Re = Te === "3d" ? P.getDepthModeFor3D() : P.getDepthModeForSublayer(0, Fr.ReadOnly);
                                Z.setDepthMode(Re),
                                H.render(Z.gl, Se),
                                Z.setDirty(),
                                P.setBaseState(),
                                Z.bindFramebuffer.set(null)
                            }
                        }(r, 0, m, x))
                    }
                    saveTileTexture(r) {
                        const a = this._tileTextures[r.size[0]];
                        a ? a.push(r) : this._tileTextures[r.size[0]] = [r]
                    }
                    getTileTexture(r) {
                        const a = this._tileTextures[r];
                        return a && a.length > 0 ? a.pop() : null
                    }
                    isPatternMissing(r) {
                        if (!r)
                            return !1;
                        if (!r.from || !r.to)
                            return !0;
                        const a = this.imageManager.getPattern(r.from.toString())
                          , m = this.imageManager.getPattern(r.to.toString());
                        return !a || !m
                    }
                    useProgram(r, a, m=!1, y=[]) {
                        this.cache = this.cache || {};
                        const x = !!this.style.map.terrain
                          , P = this.style.projection
                          , I = m ? ws.projectionMercator : P.shaderPreludeCode
                          , A = m ? Da : P.shaderDefine
                          , B = r + (a ? a.cacheKey : "") + `/${m ? ch : P.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (x ? "/terrain" : "") + (y ? `/${y.join("/")}` : "");
                        return this.cache[B] || (this.cache[B] = new hh(this.context,ws[r],a,If[r],this._showOverdrawInspector,x,I,A,y)),
                        this.cache[B]
                    }
                    setCustomLayerDefaults() {
                        this.context.unbindVAO(),
                        this.context.cullFace.setDefault(),
                        this.context.activeTexture.setDefault(),
                        this.context.pixelStoreUnpack.setDefault(),
                        this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                        this.context.pixelStoreUnpackFlipY.setDefault()
                    }
                    setBaseState() {
                        const r = this.context.gl;
                        this.context.cullFace.set(!1),
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.context.blendEquation.set(r.FUNC_ADD)
                    }
                    initDebugOverlayCanvas() {
                        this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"),
                        this.debugOverlayCanvas.width = 512,
                        this.debugOverlayCanvas.height = 512,
                        this.debugOverlayTexture = new o.T(this.context,this.debugOverlayCanvas,this.context.gl.RGBA))
                    }
                    destroy() {
                        this.debugOverlayTexture && this.debugOverlayTexture.destroy()
                    }
                    overLimit() {
                        const {drawingBufferWidth: r, drawingBufferHeight: a} = this.context.gl;
                        return this.width !== r || this.height !== a
                    }
                }
                function yc(v, r) {
                    let a, m = !1, y = null, x = null;
                    const P = () => {
                        y = null,
                        m && (v.apply(x, a),
                        y = setTimeout(P, r),
                        m = !1)
                    }
                    ;
                    return (...I) => (m = !0,
                    x = this,
                    a = I,
                    y || P(),
                    y)
                }
                class ku {
                    constructor(r) {
                        this._getCurrentHash = () => {
                            const a = window.location.hash.replace("#", "");
                            if (this._hashName) {
                                let m;
                                return a.split("&").map(y => y.split("=")).forEach(y => {
                                    y[0] === this._hashName && (m = y)
                                }
                                ),
                                (m && m[1] || "").split("/")
                            }
                            return a.split("/")
                        }
                        ,
                        this._onHashChange = () => {
                            const a = this._getCurrentHash();
                            if (!this._isValidHash(a))
                                return !1;
                            const m = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(a[3] || 0) : this._map.getBearing();
                            return this._map.jumpTo({
                                center: [+a[2], +a[1]],
                                zoom: +a[0],
                                bearing: m,
                                pitch: +(a[4] || 0)
                            }),
                            !0
                        }
                        ,
                        this._updateHashUnthrottled = () => {
                            const a = window.location.href.replace(/(#.*)?$/, this.getHashString());
                            window.history.replaceState(window.history.state, null, a)
                        }
                        ,
                        this._removeHash = () => {
                            const a = this._getCurrentHash();
                            if (a.length === 0)
                                return;
                            const m = a.join("/");
                            let y = m;
                            y.split("&").length > 0 && (y = y.split("&")[0]),
                            this._hashName && (y = `${this._hashName}=${m}`);
                            let x = window.location.hash.replace(y, "");
                            x.startsWith("#&") ? x = x.slice(0, 1) + x.slice(2) : x === "#" && (x = "");
                            let P = window.location.href.replace(/(#.+)?$/, x);
                            P = P.replace("&&", "&"),
                            window.history.replaceState(window.history.state, null, P)
                        }
                        ,
                        this._updateHash = yc(this._updateHashUnthrottled, 300),
                        this._hashName = r && encodeURIComponent(r)
                    }
                    addTo(r) {
                        return this._map = r,
                        addEventListener("hashchange", this._onHashChange, !1),
                        this._map.on("moveend", this._updateHash),
                        this
                    }
                    remove() {
                        return removeEventListener("hashchange", this._onHashChange, !1),
                        this._map.off("moveend", this._updateHash),
                        clearTimeout(this._updateHash()),
                        this._removeHash(),
                        delete this._map,
                        this
                    }
                    getHashString(r) {
                        const a = this._map.getCenter()
                          , m = Math.round(100 * this._map.getZoom()) / 100
                          , y = Math.ceil((m * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10)
                          , x = Math.pow(10, y)
                          , P = Math.round(a.lng * x) / x
                          , I = Math.round(a.lat * x) / x
                          , A = this._map.getBearing()
                          , B = this._map.getPitch();
                        let $ = "";
                        if ($ += r ? `/${P}/${I}/${m}` : `${m}/${I}/${P}`,
                        (A || B) && ($ += "/" + Math.round(10 * A) / 10),
                        B && ($ += `/${Math.round(B)}`),
                        this._hashName) {
                            const Z = this._hashName;
                            let H = !1;
                            const Y = window.location.hash.slice(1).split("&").map(ae => {
                                const ye = ae.split("=")[0];
                                return ye === Z ? (H = !0,
                                `${ye}=${$}`) : ae
                            }
                            ).filter(ae => ae);
                            return H || Y.push(`${Z}=${$}`),
                            `#${Y.join("&")}`
                        }
                        return `#${$}`
                    }
                    _isValidHash(r) {
                        if (r.length < 3 || r.some(isNaN))
                            return !1;
                        try {
                            new o.S(+r[2],+r[1])
                        } catch {
                            return !1
                        }
                        const a = +r[0]
                          , m = +(r[3] || 0)
                          , y = +(r[4] || 0);
                        return a >= this._map.getMinZoom() && a <= this._map.getMaxZoom() && m >= -180 && m <= 180 && y >= this._map.getMinPitch() && y <= this._map.getMaxPitch()
                    }
                }
                const _c = {
                    linearity: .3,
                    easing: o.cl(0, 0, .3, 1)
                }
                  , fs = o.e({
                    deceleration: 2500,
                    maxSpeed: 1400
                }, _c)
                  , Dl = o.e({
                    deceleration: 20,
                    maxSpeed: 1400
                }, _c)
                  , Hs = o.e({
                    deceleration: 1e3,
                    maxSpeed: 360
                }, _c)
                  , vc = o.e({
                    deceleration: 1e3,
                    maxSpeed: 90
                }, _c)
                  , wh = o.e({
                    deceleration: 1e3,
                    maxSpeed: 360
                }, _c);
                class Ll {
                    constructor(r) {
                        this._map = r,
                        this.clear()
                    }
                    clear() {
                        this._inertiaBuffer = []
                    }
                    record(r) {
                        this._drainInertiaBuffer(),
                        this._inertiaBuffer.push({
                            time: z.now(),
                            settings: r
                        })
                    }
                    _drainInertiaBuffer() {
                        const r = this._inertiaBuffer
                          , a = z.now();
                        for (; r.length > 0 && a - r[0].time > 160; )
                            r.shift()
                    }
                    _onMoveEnd(r) {
                        if (this._drainInertiaBuffer(),
                        this._inertiaBuffer.length < 2)
                            return;
                        const a = {
                            zoom: 0,
                            bearing: 0,
                            pitch: 0,
                            roll: 0,
                            pan: new o.P(0,0),
                            pinchAround: void 0,
                            around: void 0
                        };
                        for (const {settings: x} of this._inertiaBuffer)
                            a.zoom += x.zoomDelta || 0,
                            a.bearing += x.bearingDelta || 0,
                            a.pitch += x.pitchDelta || 0,
                            a.roll += x.rollDelta || 0,
                            x.panDelta && a.pan._add(x.panDelta),
                            x.around && (a.around = x.around),
                            x.pinchAround && (a.pinchAround = x.pinchAround);
                        const m = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time
                          , y = {};
                        if (a.pan.mag()) {
                            const x = wn(a.pan.mag(), m, o.e({}, fs, r || {}))
                              , P = a.pan.mult(x.amount / a.pan.mag())
                              , I = this._map.cameraHelper.handlePanInertia(P, this._map.transform);
                            y.center = I.easingCenter,
                            y.offset = I.easingOffset,
                            Yo(y, x)
                        }
                        if (a.zoom) {
                            const x = wn(a.zoom, m, Dl);
                            y.zoom = this._map.transform.zoom + x.amount,
                            Yo(y, x)
                        }
                        if (a.bearing) {
                            const x = wn(a.bearing, m, Hs);
                            y.bearing = this._map.transform.bearing + o.ag(x.amount, -179, 179),
                            Yo(y, x)
                        }
                        if (a.pitch) {
                            const x = wn(a.pitch, m, vc);
                            y.pitch = this._map.transform.pitch + x.amount,
                            Yo(y, x)
                        }
                        if (a.roll) {
                            const x = wn(a.roll, m, wh);
                            y.roll = this._map.transform.roll + o.ag(x.amount, -179, 179),
                            Yo(y, x)
                        }
                        if (y.zoom || y.bearing) {
                            const x = a.pinchAround === void 0 ? a.around : a.pinchAround;
                            y.around = x ? this._map.unproject(x) : this._map.getCenter()
                        }
                        return this.clear(),
                        o.e(y, {
                            noMoveStart: !0
                        })
                    }
                }
                function Yo(v, r) {
                    (!v.duration || v.duration < r.duration) && (v.duration = r.duration,
                    v.easing = r.easing)
                }
                function wn(v, r, a) {
                    const {maxSpeed: m, linearity: y, deceleration: x} = a
                      , P = o.ag(v * y / (r / 1e3), -m, m)
                      , I = Math.abs(P) / (x * y);
                    return {
                        easing: a.easing,
                        duration: 1e3 * I,
                        amount: P * (I / 2)
                    }
                }
                class tn extends o.l {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(r, a, m, y={}) {
                        m = m instanceof MouseEvent ? m : new MouseEvent(r,m);
                        const x = D.mousePos(a.getCanvas(), m)
                          , P = a.unproject(x);
                        super(r, o.e({
                            point: x,
                            lngLat: P,
                            originalEvent: m
                        }, y)),
                        this._defaultPrevented = !1,
                        this.target = a
                    }
                }
                class Ri extends o.l {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(r, a, m) {
                        const y = r === "touchend" ? m.changedTouches : m.touches
                          , x = D.touchPos(a.getCanvasContainer(), y)
                          , P = x.map(A => a.unproject(A))
                          , I = x.reduce( (A, B, $, Z) => A.add(B.div(Z.length)), new o.P(0,0));
                        super(r, {
                            points: x,
                            point: I,
                            lngLats: P,
                            lngLat: a.unproject(I),
                            originalEvent: m
                        }),
                        this._defaultPrevented = !1
                    }
                }
                class Ai extends o.l {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(r, a, m) {
                        super(r, {
                            originalEvent: m
                        }),
                        this._defaultPrevented = !1
                    }
                }
                class _o {
                    constructor(r, a) {
                        this._map = r,
                        this._clickTolerance = a.clickTolerance
                    }
                    reset() {
                        delete this._mousedownPos
                    }
                    wheel(r) {
                        return this._firePreventable(new Ai(r.type,this._map,r))
                    }
                    mousedown(r, a) {
                        return this._mousedownPos = a,
                        this._firePreventable(new tn(r.type,this._map,r))
                    }
                    mouseup(r) {
                        this._map.fire(new tn(r.type,this._map,r))
                    }
                    click(r, a) {
                        this._mousedownPos && this._mousedownPos.dist(a) >= this._clickTolerance || this._map.fire(new tn(r.type,this._map,r))
                    }
                    dblclick(r) {
                        return this._firePreventable(new tn(r.type,this._map,r))
                    }
                    mouseover(r) {
                        this._map.fire(new tn(r.type,this._map,r))
                    }
                    mouseout(r) {
                        this._map.fire(new tn(r.type,this._map,r))
                    }
                    touchstart(r) {
                        return this._firePreventable(new Ri(r.type,this._map,r))
                    }
                    touchmove(r) {
                        this._map.fire(new Ri(r.type,this._map,r))
                    }
                    touchend(r) {
                        this._map.fire(new Ri(r.type,this._map,r))
                    }
                    touchcancel(r) {
                        this._map.fire(new Ri(r.type,this._map,r))
                    }
                    _firePreventable(r) {
                        if (this._map.fire(r),
                        r.defaultPrevented)
                            return {}
                    }
                    isEnabled() {
                        return !0
                    }
                    isActive() {
                        return !1
                    }
                    enable() {}
                    disable() {}
                }
                class Za {
                    constructor(r) {
                        this._map = r
                    }
                    reset() {
                        this._delayContextMenu = !1,
                        this._ignoreContextMenu = !0,
                        delete this._contextMenuEvent
                    }
                    mousemove(r) {
                        this._map.fire(new tn(r.type,this._map,r))
                    }
                    mousedown() {
                        this._delayContextMenu = !0,
                        this._ignoreContextMenu = !1
                    }
                    mouseup() {
                        this._delayContextMenu = !1,
                        this._contextMenuEvent && (this._map.fire(new tn("contextmenu",this._map,this._contextMenuEvent)),
                        delete this._contextMenuEvent)
                    }
                    contextmenu(r) {
                        this._delayContextMenu ? this._contextMenuEvent = r : this._ignoreContextMenu || this._map.fire(new tn(r.type,this._map,r)),
                        this._map.listens("contextmenu") && r.preventDefault()
                    }
                    isEnabled() {
                        return !0
                    }
                    isActive() {
                        return !1
                    }
                    enable() {}
                    disable() {}
                }
                class ks {
                    constructor(r) {
                        this._map = r
                    }
                    get transform() {
                        return this._map._requestedCameraState || this._map.transform
                    }
                    get center() {
                        return {
                            lng: this.transform.center.lng,
                            lat: this.transform.center.lat
                        }
                    }
                    get zoom() {
                        return this.transform.zoom
                    }
                    get pitch() {
                        return this.transform.pitch
                    }
                    get bearing() {
                        return this.transform.bearing
                    }
                    unproject(r) {
                        return this.transform.screenPointToLocation(o.P.convert(r), this._map.terrain)
                    }
                }
                class to {
                    constructor(r, a) {
                        this._map = r,
                        this._tr = new ks(r),
                        this._el = r.getCanvasContainer(),
                        this._container = r.getContainer(),
                        this._clickTolerance = a.clickTolerance || 1
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active
                    }
                    enable() {
                        this.isEnabled() || (this._enabled = !0)
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1)
                    }
                    mousedown(r, a) {
                        this.isEnabled() && r.shiftKey && r.button === 0 && (D.disableDrag(),
                        this._startPos = this._lastPos = a,
                        this._active = !0)
                    }
                    mousemoveWindow(r, a) {
                        if (!this._active)
                            return;
                        const m = a;
                        if (this._lastPos.equals(m) || !this._box && m.dist(this._startPos) < this._clickTolerance)
                            return;
                        const y = this._startPos;
                        this._lastPos = m,
                        this._box || (this._box = D.create("div", "maplibregl-boxzoom", this._container),
                        this._container.classList.add("maplibregl-crosshair"),
                        this._fireEvent("boxzoomstart", r));
                        const x = Math.min(y.x, m.x)
                          , P = Math.max(y.x, m.x)
                          , I = Math.min(y.y, m.y)
                          , A = Math.max(y.y, m.y);
                        D.setTransform(this._box, `translate(${x}px,${I}px)`),
                        this._box.style.width = P - x + "px",
                        this._box.style.height = A - I + "px"
                    }
                    mouseupWindow(r, a) {
                        if (!this._active || r.button !== 0)
                            return;
                        const m = this._startPos
                          , y = a;
                        if (this.reset(),
                        D.suppressClick(),
                        m.x !== y.x || m.y !== y.y)
                            return this._map.fire(new o.l("boxzoomend",{
                                originalEvent: r
                            })),
                            {
                                cameraAnimation: x => x.fitScreenCoordinates(m, y, this._tr.bearing, {
                                    linear: !0
                                })
                            };
                        this._fireEvent("boxzoomcancel", r)
                    }
                    keydown(r) {
                        this._active && r.keyCode === 27 && (this.reset(),
                        this._fireEvent("boxzoomcancel", r))
                    }
                    reset() {
                        this._active = !1,
                        this._container.classList.remove("maplibregl-crosshair"),
                        this._box && (D.remove(this._box),
                        this._box = null),
                        D.enableDrag(),
                        delete this._startPos,
                        delete this._lastPos
                    }
                    _fireEvent(r, a) {
                        return this._map.fire(new o.l(r,{
                            originalEvent: a
                        }))
                    }
                }
                function Ol(v, r) {
                    if (v.length !== r.length)
                        throw new Error(`The number of touches and points are not equal - touches ${v.length}, points ${r.length}`);
                    const a = {};
                    for (let m = 0; m < v.length; m++)
                        a[v[m].identifier] = r[m];
                    return a
                }
                class kd {
                    constructor(r) {
                        this.reset(),
                        this.numTouches = r.numTouches
                    }
                    reset() {
                        delete this.centroid,
                        delete this.startTime,
                        delete this.touches,
                        this.aborted = !1
                    }
                    touchstart(r, a, m) {
                        (this.centroid || m.length > this.numTouches) && (this.aborted = !0),
                        this.aborted || (this.startTime === void 0 && (this.startTime = r.timeStamp),
                        m.length === this.numTouches && (this.centroid = function(y) {
                            const x = new o.P(0,0);
                            for (const P of y)
                                x._add(P);
                            return x.div(y.length)
                        }(a),
                        this.touches = Ol(m, a)))
                    }
                    touchmove(r, a, m) {
                        if (this.aborted || !this.centroid)
                            return;
                        const y = Ol(m, a);
                        for (const x in this.touches) {
                            const P = y[x];
                            (!P || P.dist(this.touches[x]) > 30) && (this.aborted = !0)
                        }
                    }
                    touchend(r, a, m) {
                        if ((!this.centroid || r.timeStamp - this.startTime > 500) && (this.aborted = !0),
                        m.length === 0) {
                            const y = !this.aborted && this.centroid;
                            if (this.reset(),
                            y)
                                return y
                        }
                    }
                }
                class Eu {
                    constructor(r) {
                        this.singleTap = new kd(r),
                        this.numTaps = r.numTaps,
                        this.reset()
                    }
                    reset() {
                        this.lastTime = 1 / 0,
                        delete this.lastTap,
                        this.count = 0,
                        this.singleTap.reset()
                    }
                    touchstart(r, a, m) {
                        this.singleTap.touchstart(r, a, m)
                    }
                    touchmove(r, a, m) {
                        this.singleTap.touchmove(r, a, m)
                    }
                    touchend(r, a, m) {
                        const y = this.singleTap.touchend(r, a, m);
                        if (y) {
                            const x = r.timeStamp - this.lastTime < 500
                              , P = !this.lastTap || this.lastTap.dist(y) < 30;
                            if (x && P || this.reset(),
                            this.count++,
                            this.lastTime = r.timeStamp,
                            this.lastTap = y,
                            this.count === this.numTaps)
                                return this.reset(),
                                y
                        }
                    }
                }
                class Fl {
                    constructor(r) {
                        this._tr = new ks(r),
                        this._zoomIn = new Eu({
                            numTouches: 1,
                            numTaps: 2
                        }),
                        this._zoomOut = new Eu({
                            numTouches: 2,
                            numTaps: 1
                        }),
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._zoomIn.reset(),
                        this._zoomOut.reset()
                    }
                    touchstart(r, a, m) {
                        this._zoomIn.touchstart(r, a, m),
                        this._zoomOut.touchstart(r, a, m)
                    }
                    touchmove(r, a, m) {
                        this._zoomIn.touchmove(r, a, m),
                        this._zoomOut.touchmove(r, a, m)
                    }
                    touchend(r, a, m) {
                        const y = this._zoomIn.touchend(r, a, m)
                          , x = this._zoomOut.touchend(r, a, m)
                          , P = this._tr;
                        return y ? (this._active = !0,
                        r.preventDefault(),
                        setTimeout( () => this.reset(), 0),
                        {
                            cameraAnimation: I => I.easeTo({
                                duration: 300,
                                zoom: P.zoom + 1,
                                around: P.unproject(y)
                            }, {
                                originalEvent: r
                            })
                        }) : x ? (this._active = !0,
                        r.preventDefault(),
                        setTimeout( () => this.reset(), 0),
                        {
                            cameraAnimation: I => I.easeTo({
                                duration: 300,
                                zoom: P.zoom - 1,
                                around: P.unproject(x)
                            }, {
                                originalEvent: r
                            })
                        }) : void 0
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class Bl {
                    constructor(r) {
                        this._enabled = !!r.enable,
                        this._moveStateManager = r.moveStateManager,
                        this._clickTolerance = r.clickTolerance || 1,
                        this._moveFunction = r.move,
                        this._activateOnStart = !!r.activateOnStart,
                        r.assignEvents(this),
                        this.reset()
                    }
                    reset(r) {
                        this._active = !1,
                        this._moved = !1,
                        delete this._lastPoint,
                        this._moveStateManager.endMove(r)
                    }
                    _move(...r) {
                        const a = this._moveFunction(...r);
                        if (a.bearingDelta || a.pitchDelta || a.rollDelta || a.around || a.panDelta)
                            return this._active = !0,
                            a
                    }
                    dragStart(r, a) {
                        this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(r) && (this._moveStateManager.startMove(r),
                        this._lastPoint = Array.isArray(a) ? a[0] : a,
                        this._activateOnStart && this._lastPoint && (this._active = !0))
                    }
                    dragMove(r, a) {
                        if (!this.isEnabled())
                            return;
                        const m = this._lastPoint;
                        if (!m)
                            return;
                        if (r.preventDefault(),
                        !this._moveStateManager.isValidMoveEvent(r))
                            return void this.reset(r);
                        const y = Array.isArray(a) ? a[0] : a;
                        return !this._moved && y.dist(m) < this._clickTolerance ? void 0 : (this._moved = !0,
                        this._lastPoint = y,
                        this._move(m, y))
                    }
                    dragEnd(r) {
                        this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(r) && (this._moved && D.suppressClick(),
                        this.reset(r))
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                    getClickTolerance() {
                        return this._clickTolerance
                    }
                }
                const yi = 0
                  , Do = 2
                  , Sh = {
                    [yi]: 1,
                    [Do]: 2
                };
                class ro {
                    constructor(r) {
                        this._correctEvent = r.checkCorrectEvent
                    }
                    startMove(r) {
                        const a = D.mouseButton(r);
                        this._eventButton = a
                    }
                    endMove(r) {
                        delete this._eventButton
                    }
                    isValidStartEvent(r) {
                        return this._correctEvent(r)
                    }
                    isValidMoveEvent(r) {
                        return !function(a, m) {
                            const y = Sh[m];
                            return a.buttons === void 0 || (a.buttons & y) !== y
                        }(r, this._eventButton)
                    }
                    isValidEndEvent(r) {
                        return D.mouseButton(r) === this._eventButton
                    }
                }
                class xc {
                    constructor() {
                        this._firstTouch = void 0
                    }
                    _isOneFingerTouch(r) {
                        return r.targetTouches.length === 1
                    }
                    _isSameTouchEvent(r) {
                        return r.targetTouches[0].identifier === this._firstTouch
                    }
                    startMove(r) {
                        this._firstTouch = r.targetTouches[0].identifier
                    }
                    endMove(r) {
                        delete this._firstTouch
                    }
                    isValidStartEvent(r) {
                        return this._isOneFingerTouch(r)
                    }
                    isValidMoveEvent(r) {
                        return this._isOneFingerTouch(r) && this._isSameTouchEvent(r)
                    }
                    isValidEndEvent(r) {
                        return this._isOneFingerTouch(r) && this._isSameTouchEvent(r)
                    }
                }
                class Xa {
                    constructor(r=new ro({
                        checkCorrectEvent: () => !0
                    }), a=new xc) {
                        this.mouseMoveStateManager = r,
                        this.oneFingerTouchMoveStateManager = a
                    }
                    _executeRelevantHandler(r, a, m) {
                        return r instanceof MouseEvent ? a(r) : typeof TouchEvent < "u" && r instanceof TouchEvent ? m(r) : void 0
                    }
                    startMove(r) {
                        this._executeRelevantHandler(r, a => this.mouseMoveStateManager.startMove(a), a => this.oneFingerTouchMoveStateManager.startMove(a))
                    }
                    endMove(r) {
                        this._executeRelevantHandler(r, a => this.mouseMoveStateManager.endMove(a), a => this.oneFingerTouchMoveStateManager.endMove(a))
                    }
                    isValidStartEvent(r) {
                        return this._executeRelevantHandler(r, a => this.mouseMoveStateManager.isValidStartEvent(a), a => this.oneFingerTouchMoveStateManager.isValidStartEvent(a))
                    }
                    isValidMoveEvent(r) {
                        return this._executeRelevantHandler(r, a => this.mouseMoveStateManager.isValidMoveEvent(a), a => this.oneFingerTouchMoveStateManager.isValidMoveEvent(a))
                    }
                    isValidEndEvent(r) {
                        return this._executeRelevantHandler(r, a => this.mouseMoveStateManager.isValidEndEvent(a), a => this.oneFingerTouchMoveStateManager.isValidEndEvent(a))
                    }
                }
                const da = v => {
                    v.mousedown = v.dragStart,
                    v.mousemoveWindow = v.dragMove,
                    v.mouseup = v.dragEnd,
                    v.contextmenu = r => {
                        r.preventDefault()
                    }
                }
                ;
                class bc {
                    constructor(r, a) {
                        this._clickTolerance = r.clickTolerance || 1,
                        this._map = a,
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._touches = {},
                        this._sum = new o.P(0,0)
                    }
                    _shouldBePrevented(r) {
                        return r < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
                    }
                    touchstart(r, a, m) {
                        return this._calculateTransform(r, a, m)
                    }
                    touchmove(r, a, m) {
                        if (this._active) {
                            if (!this._shouldBePrevented(m.length))
                                return r.preventDefault(),
                                this._calculateTransform(r, a, m);
                            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", r)
                        }
                    }
                    touchend(r, a, m) {
                        this._calculateTransform(r, a, m),
                        this._active && this._shouldBePrevented(m.length) && this.reset()
                    }
                    touchcancel() {
                        this.reset()
                    }
                    _calculateTransform(r, a, m) {
                        m.length > 0 && (this._active = !0);
                        const y = Ol(m, a)
                          , x = new o.P(0,0)
                          , P = new o.P(0,0);
                        let I = 0;
                        for (const B in y) {
                            const $ = y[B]
                              , Z = this._touches[B];
                            Z && (x._add($),
                            P._add($.sub(Z)),
                            I++,
                            y[B] = $)
                        }
                        if (this._touches = y,
                        this._shouldBePrevented(I) || !P.mag())
                            return;
                        const A = P.div(I);
                        return this._sum._add(A),
                        this._sum.mag() < this._clickTolerance ? void 0 : {
                            around: x.div(I),
                            panDelta: A
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class wc {
                    constructor() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        delete this._firstTwoTouches
                    }
                    touchstart(r, a, m) {
                        this._firstTwoTouches || m.length < 2 || (this._firstTwoTouches = [m[0].identifier, m[1].identifier],
                        this._start([a[0], a[1]]))
                    }
                    touchmove(r, a, m) {
                        if (!this._firstTwoTouches)
                            return;
                        r.preventDefault();
                        const [y,x] = this._firstTwoTouches
                          , P = Ya(m, a, y)
                          , I = Ya(m, a, x);
                        if (!P || !I)
                            return;
                        const A = this._aroundCenter ? null : P.add(I).div(2);
                        return this._move([P, I], A, r)
                    }
                    touchend(r, a, m) {
                        if (!this._firstTwoTouches)
                            return;
                        const [y,x] = this._firstTwoTouches
                          , P = Ya(m, a, y)
                          , I = Ya(m, a, x);
                        P && I || (this._active && D.suppressClick(),
                        this.reset())
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable(r) {
                        this._enabled = !0,
                        this._aroundCenter = !!r && r.around === "center"
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active
                    }
                }
                function Ya(v, r, a) {
                    for (let m = 0; m < v.length; m++)
                        if (v[m].identifier === a)
                            return r[m]
                }
                function Wi(v, r) {
                    return Math.log(v / r) / Math.LN2
                }
                class hi extends wc {
                    reset() {
                        super.reset(),
                        delete this._distance,
                        delete this._startDistance
                    }
                    _start(r) {
                        this._startDistance = this._distance = r[0].dist(r[1])
                    }
                    _move(r, a) {
                        const m = this._distance;
                        if (this._distance = r[0].dist(r[1]),
                        this._active || !(Math.abs(Wi(this._distance, this._startDistance)) < .1))
                            return this._active = !0,
                            {
                                zoomDelta: Wi(this._distance, m),
                                pinchAround: a
                            }
                    }
                }
                function Kt(v, r) {
                    return 180 * v.angleWith(r) / Math.PI
                }
                class Es extends wc {
                    reset() {
                        super.reset(),
                        delete this._minDiameter,
                        delete this._startVector,
                        delete this._vector
                    }
                    _start(r) {
                        this._startVector = this._vector = r[0].sub(r[1]),
                        this._minDiameter = r[0].dist(r[1])
                    }
                    _move(r, a, m) {
                        const y = this._vector;
                        if (this._vector = r[0].sub(r[1]),
                        this._active || !this._isBelowThreshold(this._vector))
                            return this._active = !0,
                            {
                                bearingDelta: Kt(this._vector, y),
                                pinchAround: a
                            }
                    }
                    _isBelowThreshold(r) {
                        this._minDiameter = Math.min(this._minDiameter, r.mag());
                        const a = 25 / (Math.PI * this._minDiameter) * 360
                          , m = Kt(r, this._startVector);
                        return Math.abs(m) < a
                    }
                }
                function Ko(v) {
                    return Math.abs(v.y) > Math.abs(v.x)
                }
                class fa extends wc {
                    constructor(r) {
                        super(),
                        this._currentTouchCount = 0,
                        this._map = r
                    }
                    reset() {
                        super.reset(),
                        this._valid = void 0,
                        delete this._firstMove,
                        delete this._lastPoints
                    }
                    touchstart(r, a, m) {
                        super.touchstart(r, a, m),
                        this._currentTouchCount = m.length
                    }
                    _start(r) {
                        this._lastPoints = r,
                        Ko(r[0].sub(r[1])) && (this._valid = !1)
                    }
                    _move(r, a, m) {
                        if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3)
                            return;
                        const y = r[0].sub(this._lastPoints[0])
                          , x = r[1].sub(this._lastPoints[1]);
                        return this._valid = this.gestureBeginsVertically(y, x, m.timeStamp),
                        this._valid ? (this._lastPoints = r,
                        this._active = !0,
                        {
                            pitchDelta: (y.y + x.y) / 2 * -.5
                        }) : void 0
                    }
                    gestureBeginsVertically(r, a, m) {
                        if (this._valid !== void 0)
                            return this._valid;
                        const y = r.mag() >= 2
                          , x = a.mag() >= 2;
                        if (!y && !x)
                            return;
                        if (!y || !x)
                            return this._firstMove === void 0 && (this._firstMove = m),
                            m - this._firstMove < 100 && void 0;
                        const P = r.y > 0 == a.y > 0;
                        return Ko(r) && Ko(a) && P
                    }
                }
                const Sc = {
                    panStep: 100,
                    bearingStep: 15,
                    pitchStep: 10
                };
                class Ka {
                    constructor(r) {
                        this._tr = new ks(r);
                        const a = Sc;
                        this._panStep = a.panStep,
                        this._bearingStep = a.bearingStep,
                        this._pitchStep = a.pitchStep,
                        this._rotationDisabled = !1
                    }
                    reset() {
                        this._active = !1
                    }
                    keydown(r) {
                        if (r.altKey || r.ctrlKey || r.metaKey)
                            return;
                        let a = 0
                          , m = 0
                          , y = 0
                          , x = 0
                          , P = 0;
                        switch (r.keyCode) {
                        case 61:
                        case 107:
                        case 171:
                        case 187:
                            a = 1;
                            break;
                        case 189:
                        case 109:
                        case 173:
                            a = -1;
                            break;
                        case 37:
                            r.shiftKey ? m = -1 : (r.preventDefault(),
                            x = -1);
                            break;
                        case 39:
                            r.shiftKey ? m = 1 : (r.preventDefault(),
                            x = 1);
                            break;
                        case 38:
                            r.shiftKey ? y = 1 : (r.preventDefault(),
                            P = -1);
                            break;
                        case 40:
                            r.shiftKey ? y = -1 : (r.preventDefault(),
                            P = 1);
                            break;
                        default:
                            return
                        }
                        return this._rotationDisabled && (m = 0,
                        y = 0),
                        {
                            cameraAnimation: I => {
                                const A = this._tr;
                                I.easeTo({
                                    duration: 300,
                                    easeId: "keyboardHandler",
                                    easing: Iu,
                                    zoom: a ? Math.round(A.zoom) + a * (r.shiftKey ? 2 : 1) : A.zoom,
                                    bearing: A.bearing + m * this._bearingStep,
                                    pitch: A.pitch + y * this._pitchStep,
                                    offset: [-x * this._panStep, -P * this._panStep],
                                    center: A.center
                                }, {
                                    originalEvent: r
                                })
                            }
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                    disableRotation() {
                        this._rotationDisabled = !0
                    }
                    enableRotation() {
                        this._rotationDisabled = !1
                    }
                }
                function Iu(v) {
                    return v * (2 - v)
                }
                const Ir = 4.000244140625
                  , vo = 1 / 450;
                class Xn {
                    constructor(r, a) {
                        this._onTimeout = m => {
                            this._type = "wheel",
                            this._delta -= this._lastValue,
                            this._active || this._start(m)
                        }
                        ,
                        this._map = r,
                        this._tr = new ks(r),
                        this._triggerRenderFrame = a,
                        this._delta = 0,
                        this._defaultZoomRate = .01,
                        this._wheelZoomRate = vo
                    }
                    setZoomRate(r) {
                        this._defaultZoomRate = r
                    }
                    setWheelZoomRate(r) {
                        this._wheelZoomRate = r
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active || this._finishTimeout !== void 0
                    }
                    isZooming() {
                        return !!this._zooming
                    }
                    enable(r) {
                        this.isEnabled() || (this._enabled = !0,
                        this._aroundCenter = !!r && r.around === "center")
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1)
                    }
                    _shouldBePrevented(r) {
                        return !!this._map.cooperativeGestures.isEnabled() && !(r.ctrlKey || this._map.cooperativeGestures.isBypassed(r))
                    }
                    wheel(r) {
                        if (!this.isEnabled())
                            return;
                        if (this._shouldBePrevented(r))
                            return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", r);
                        let a = r.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * r.deltaY : r.deltaY;
                        const m = z.now()
                          , y = m - (this._lastWheelEventTime || 0);
                        this._lastWheelEventTime = m,
                        a !== 0 && a % Ir == 0 ? this._type = "wheel" : a !== 0 && Math.abs(a) < 4 ? this._type = "trackpad" : y > 400 ? (this._type = null,
                        this._lastValue = a,
                        this._timeout = setTimeout(this._onTimeout, 40, r)) : this._type || (this._type = Math.abs(y * a) < 200 ? "trackpad" : "wheel",
                        this._timeout && (clearTimeout(this._timeout),
                        this._timeout = null,
                        a += this._lastValue)),
                        r.shiftKey && a && (a /= 4),
                        this._type && (this._lastWheelEvent = r,
                        this._delta -= a,
                        this._active || this._start(r)),
                        r.preventDefault()
                    }
                    _start(r) {
                        if (!this._delta)
                            return;
                        this._frameId && (this._frameId = null),
                        this._active = !0,
                        this.isZooming() || (this._zooming = !0),
                        this._finishTimeout && (clearTimeout(this._finishTimeout),
                        delete this._finishTimeout);
                        const a = D.mousePos(this._map.getCanvas(), r)
                          , m = this._tr;
                        this._aroundPoint = this._aroundCenter ? m.transform.locationToScreenPoint(o.S.convert(m.center)) : a,
                        this._frameId || (this._frameId = !0,
                        this._triggerRenderFrame())
                    }
                    renderFrame() {
                        if (!this._frameId || (this._frameId = null,
                        !this.isActive()))
                            return;
                        const r = this._tr.transform;
                        if (typeof this._lastExpectedZoom == "number") {
                            const I = r.zoom - this._lastExpectedZoom;
                            typeof this._startZoom == "number" && (this._startZoom += I),
                            typeof this._targetZoom == "number" && (this._targetZoom += I)
                        }
                        if (this._delta !== 0) {
                            const I = this._type === "wheel" && Math.abs(this._delta) > Ir ? this._wheelZoomRate : this._defaultZoomRate;
                            let A = 2 / (1 + Math.exp(-Math.abs(this._delta * I)));
                            this._delta < 0 && A !== 0 && (A = 1 / A);
                            const B = typeof this._targetZoom != "number" ? r.scale : o.ae(this._targetZoom);
                            this._targetZoom = r.getConstrained(r.getCameraLngLat(), o.aj(B * A)).zoom,
                            this._type === "wheel" && (this._startZoom = r.zoom,
                            this._easing = this._smoothOutEasing(200)),
                            this._delta = 0
                        }
                        const a = typeof this._targetZoom != "number" ? r.zoom : this._targetZoom
                          , m = this._startZoom
                          , y = this._easing;
                        let x, P = !1;
                        if (this._type === "wheel" && m && y) {
                            const I = z.now() - this._lastWheelEventTime
                              , A = Math.min((I + 5) / 200, 1)
                              , B = y(A);
                            x = o.C.number(m, a, B),
                            A < 1 ? this._frameId || (this._frameId = !0) : P = !0
                        } else
                            x = a,
                            P = !0;
                        return this._active = !0,
                        P && (this._active = !1,
                        this._finishTimeout = setTimeout( () => {
                            this._zooming = !1,
                            this._triggerRenderFrame(),
                            delete this._targetZoom,
                            delete this._lastExpectedZoom,
                            delete this._finishTimeout
                        }
                        , 200)),
                        this._lastExpectedZoom = x,
                        {
                            noInertia: !0,
                            needsRenderFrame: !P,
                            zoomDelta: x - r.zoom,
                            around: this._aroundPoint,
                            originalEvent: this._lastWheelEvent
                        }
                    }
                    _smoothOutEasing(r) {
                        let a = o.cn;
                        if (this._prevEase) {
                            const m = this._prevEase
                              , y = (z.now() - m.start) / m.duration
                              , x = m.easing(y + .01) - m.easing(y)
                              , P = .27 / Math.sqrt(x * x + 1e-4) * .01
                              , I = Math.sqrt(.0729 - P * P);
                            a = o.cl(P, I, .25, 1)
                        }
                        return this._prevEase = {
                            start: z.now(),
                            duration: r,
                            easing: a
                        },
                        a
                    }
                    reset() {
                        this._active = !1,
                        this._zooming = !1,
                        delete this._targetZoom,
                        delete this._lastExpectedZoom,
                        this._finishTimeout && (clearTimeout(this._finishTimeout),
                        delete this._finishTimeout)
                    }
                }
                class Lo {
                    constructor(r, a) {
                        this._clickZoom = r,
                        this._tapZoom = a
                    }
                    enable() {
                        this._clickZoom.enable(),
                        this._tapZoom.enable()
                    }
                    disable() {
                        this._clickZoom.disable(),
                        this._tapZoom.disable()
                    }
                    isEnabled() {
                        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
                    }
                    isActive() {
                        return this._clickZoom.isActive() || this._tapZoom.isActive()
                    }
                }
                class jf {
                    constructor(r) {
                        this._tr = new ks(r),
                        this.reset()
                    }
                    reset() {
                        this._active = !1
                    }
                    dblclick(r, a) {
                        return r.preventDefault(),
                        {
                            cameraAnimation: m => {
                                m.easeTo({
                                    duration: 300,
                                    zoom: this._tr.zoom + (r.shiftKey ? -1 : 1),
                                    around: this._tr.unproject(a)
                                }, {
                                    originalEvent: r
                                })
                            }
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class Nf {
                    constructor() {
                        this._tap = new Eu({
                            numTouches: 1,
                            numTaps: 1
                        }),
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        delete this._swipePoint,
                        delete this._swipeTouch,
                        delete this._tapTime,
                        delete this._tapPoint,
                        this._tap.reset()
                    }
                    touchstart(r, a, m) {
                        if (!this._swipePoint)
                            if (this._tapTime) {
                                const y = a[0]
                                  , x = r.timeStamp - this._tapTime < 500
                                  , P = this._tapPoint.dist(y) < 30;
                                x && P ? m.length > 0 && (this._swipePoint = y,
                                this._swipeTouch = m[0].identifier) : this.reset()
                            } else
                                this._tap.touchstart(r, a, m)
                    }
                    touchmove(r, a, m) {
                        if (this._tapTime) {
                            if (this._swipePoint) {
                                if (m[0].identifier !== this._swipeTouch)
                                    return;
                                const y = a[0]
                                  , x = y.y - this._swipePoint.y;
                                return this._swipePoint = y,
                                r.preventDefault(),
                                this._active = !0,
                                {
                                    zoomDelta: x / 128
                                }
                            }
                        } else
                            this._tap.touchmove(r, a, m)
                    }
                    touchend(r, a, m) {
                        if (this._tapTime)
                            this._swipePoint && m.length === 0 && this.reset();
                        else {
                            const y = this._tap.touchend(r, a, m);
                            y && (this._tapTime = r.timeStamp,
                            this._tapPoint = y)
                        }
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class Ru {
                    constructor(r, a, m) {
                        this._el = r,
                        this._mousePan = a,
                        this._touchPan = m
                    }
                    enable(r) {
                        this._inertiaOptions = r || {},
                        this._mousePan.enable(),
                        this._touchPan.enable(),
                        this._el.classList.add("maplibregl-touch-drag-pan")
                    }
                    disable() {
                        this._mousePan.disable(),
                        this._touchPan.disable(),
                        this._el.classList.remove("maplibregl-touch-drag-pan")
                    }
                    isEnabled() {
                        return this._mousePan.isEnabled() && this._touchPan.isEnabled()
                    }
                    isActive() {
                        return this._mousePan.isActive() || this._touchPan.isActive()
                    }
                }
                class Cc {
                    constructor(r, a, m, y) {
                        this._pitchWithRotate = r.pitchWithRotate,
                        this._rollEnabled = r.rollEnabled,
                        this._mouseRotate = a,
                        this._mousePitch = m,
                        this._mouseRoll = y
                    }
                    enable() {
                        this._mouseRotate.enable(),
                        this._pitchWithRotate && this._mousePitch.enable(),
                        this._rollEnabled && this._mouseRoll.enable()
                    }
                    disable() {
                        this._mouseRotate.disable(),
                        this._mousePitch.disable(),
                        this._mouseRoll.disable()
                    }
                    isEnabled() {
                        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
                    }
                    isActive() {
                        return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
                    }
                }
                class Ch {
                    constructor(r, a, m, y) {
                        this._el = r,
                        this._touchZoom = a,
                        this._touchRotate = m,
                        this._tapDragZoom = y,
                        this._rotationDisabled = !1,
                        this._enabled = !0
                    }
                    enable(r) {
                        this._touchZoom.enable(r),
                        this._rotationDisabled || this._touchRotate.enable(r),
                        this._tapDragZoom.enable(),
                        this._el.classList.add("maplibregl-touch-zoom-rotate")
                    }
                    disable() {
                        this._touchZoom.disable(),
                        this._touchRotate.disable(),
                        this._tapDragZoom.disable(),
                        this._el.classList.remove("maplibregl-touch-zoom-rotate")
                    }
                    isEnabled() {
                        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
                    }
                    isActive() {
                        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
                    }
                    disableRotation() {
                        this._rotationDisabled = !0,
                        this._touchRotate.disable()
                    }
                    enableRotation() {
                        this._rotationDisabled = !1,
                        this._touchZoom.isEnabled() && this._touchRotate.enable()
                    }
                }
                class Au {
                    constructor(r, a) {
                        this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey",
                        this._map = r,
                        this._options = a,
                        this._enabled = !1
                    }
                    isActive() {
                        return !1
                    }
                    reset() {}
                    _setupUI() {
                        if (this._container)
                            return;
                        const r = this._map.getCanvasContainer();
                        r.classList.add("maplibregl-cooperative-gestures"),
                        this._container = D.create("div", "maplibregl-cooperative-gesture-screen", r);
                        let a = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
                        this._bypassKey === "metaKey" && (a = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
                        const m = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText")
                          , y = document.createElement("div");
                        y.className = "maplibregl-desktop-message",
                        y.textContent = a,
                        this._container.appendChild(y);
                        const x = document.createElement("div");
                        x.className = "maplibregl-mobile-message",
                        x.textContent = m,
                        this._container.appendChild(x),
                        this._container.setAttribute("aria-hidden", "true")
                    }
                    _destroyUI() {
                        this._container && (D.remove(this._container),
                        this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")),
                        delete this._container
                    }
                    enable() {
                        this._setupUI(),
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this._destroyUI()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isBypassed(r) {
                        return r[this._bypassKey]
                    }
                    notifyGestureBlocked(r, a) {
                        this._enabled && (this._map.fire(new o.l("cooperativegestureprevented",{
                            gestureType: r,
                            originalEvent: a
                        })),
                        this._container.classList.add("maplibregl-show"),
                        setTimeout( () => {
                            this._container.classList.remove("maplibregl-show")
                        }
                        , 100))
                    }
                }
                const Tc = v => v.zoom || v.drag || v.roll || v.pitch || v.rotate;
                class Pc extends o.l {
                }
                function zu(v) {
                    return v.panDelta && v.panDelta.mag() || v.zoomDelta || v.bearingDelta || v.pitchDelta || v.rollDelta
                }
                class Qa {
                    constructor(r, a) {
                        this.handleWindowEvent = y => {
                            this.handleEvent(y, `${y.type}Window`)
                        }
                        ,
                        this.handleEvent = (y, x) => {
                            if (y.type === "blur")
                                return void this.stop(!0);
                            this._updatingCamera = !0;
                            const P = y.type === "renderFrame" ? void 0 : y
                              , I = {
                                needsRenderFrame: !1
                            }
                              , A = {}
                              , B = {};
                            for (const {handlerName: H, handler: Y, allowed: ae} of this._handlers) {
                                if (!Y.isEnabled())
                                    continue;
                                let ye;
                                if (this._blockedByActive(B, ae, H))
                                    Y.reset();
                                else if (Y[x || y.type]) {
                                    if (o.co(y, x || y.type)) {
                                        const Se = D.mousePos(this._map.getCanvas(), y);
                                        ye = Y[x || y.type](y, Se)
                                    } else if (o.cp(y, x || y.type)) {
                                        const Se = this._getMapTouches(y.touches)
                                          , Te = D.touchPos(this._map.getCanvas(), Se);
                                        ye = Y[x || y.type](y, Te, Se)
                                    } else
                                        o.cq(x || y.type) || (ye = Y[x || y.type](y));
                                    this.mergeHandlerResult(I, A, ye, H, P),
                                    ye && ye.needsRenderFrame && this._triggerRenderFrame()
                                }
                                (ye || Y.isActive()) && (B[H] = Y)
                            }
                            const $ = {};
                            for (const H in this._previousActiveHandlers)
                                B[H] || ($[H] = P);
                            this._previousActiveHandlers = B,
                            (Object.keys($).length || zu(I)) && (this._changes.push([I, A, $]),
                            this._triggerRenderFrame()),
                            (Object.keys(B).length || zu(I)) && this._map._stop(!0),
                            this._updatingCamera = !1;
                            const {cameraAnimation: Z} = I;
                            Z && (this._inertia.clear(),
                            this._fireEvents({}, {}, !0),
                            this._changes = [],
                            Z(this._map))
                        }
                        ,
                        this._map = r,
                        this._el = this._map.getCanvasContainer(),
                        this._handlers = [],
                        this._handlersById = {},
                        this._changes = [],
                        this._inertia = new Ll(r),
                        this._bearingSnap = a.bearingSnap,
                        this._previousActiveHandlers = {},
                        this._eventsInProgress = {},
                        this._addDefaultHandlers(a);
                        const m = this._el;
                        this._listeners = [[m, "touchstart", {
                            passive: !0
                        }], [m, "touchmove", {
                            passive: !1
                        }], [m, "touchend", void 0], [m, "touchcancel", void 0], [m, "mousedown", void 0], [m, "mousemove", void 0], [m, "mouseup", void 0], [document, "mousemove", {
                            capture: !0
                        }], [document, "mouseup", void 0], [m, "mouseover", void 0], [m, "mouseout", void 0], [m, "dblclick", void 0], [m, "click", void 0], [m, "keydown", {
                            capture: !1
                        }], [m, "keyup", void 0], [m, "wheel", {
                            passive: !1
                        }], [m, "contextmenu", void 0], [window, "blur", void 0]];
                        for (const [y,x,P] of this._listeners)
                            D.addEventListener(y, x, y === document ? this.handleWindowEvent : this.handleEvent, P)
                    }
                    destroy() {
                        for (const [r,a,m] of this._listeners)
                            D.removeEventListener(r, a, r === document ? this.handleWindowEvent : this.handleEvent, m)
                    }
                    _addDefaultHandlers(r) {
                        const a = this._map
                          , m = a.getCanvasContainer();
                        this._add("mapEvent", new _o(a,r));
                        const y = a.boxZoom = new to(a,r);
                        this._add("boxZoom", y),
                        r.interactive && r.boxZoom && y.enable();
                        const x = a.cooperativeGestures = new Au(a,r.cooperativeGestures);
                        this._add("cooperativeGestures", x),
                        r.cooperativeGestures && x.enable();
                        const P = new Fl(a)
                          , I = new jf(a);
                        a.doubleClickZoom = new Lo(I,P),
                        this._add("tapZoom", P),
                        this._add("clickZoom", I),
                        r.interactive && r.doubleClickZoom && a.doubleClickZoom.enable();
                        const A = new Nf;
                        this._add("tapDragZoom", A);
                        const B = a.touchPitch = new fa(a);
                        this._add("touchPitch", B),
                        r.interactive && r.touchPitch && a.touchPitch.enable(r.touchPitch);
                        const $ = () => a.project(a.getCenter())
                          , Z = function({enable: Ae, clickTolerance: Be, aroundCenter: qe=!0, minPixelCenterThreshold: ze=100, rotateDegreesPerPixelMoved: Ke=.8}, ht) {
                            const ot = new ro({
                                checkCorrectEvent: ut => D.mouseButton(ut) === 0 && ut.ctrlKey || D.mouseButton(ut) === 2 && !ut.ctrlKey
                            });
                            return new Bl({
                                clickTolerance: Be,
                                move: (ut, mt) => {
                                    const $t = ht();
                                    if (qe && Math.abs($t.y - ut.y) > ze)
                                        return {
                                            bearingDelta: o.cm(new o.P(ut.x,mt.y), mt, $t)
                                        };
                                    let jt = (mt.x - ut.x) * Ke;
                                    return qe && mt.y < $t.y && (jt = -jt),
                                    {
                                        bearingDelta: jt
                                    }
                                }
                                ,
                                moveStateManager: ot,
                                enable: Ae,
                                assignEvents: da
                            })
                        }(r, $)
                          , H = function({enable: Ae, clickTolerance: Be, pitchDegreesPerPixelMoved: qe=-.5}) {
                            const ze = new ro({
                                checkCorrectEvent: Ke => D.mouseButton(Ke) === 0 && Ke.ctrlKey || D.mouseButton(Ke) === 2
                            });
                            return new Bl({
                                clickTolerance: Be,
                                move: (Ke, ht) => ({
                                    pitchDelta: (ht.y - Ke.y) * qe
                                }),
                                moveStateManager: ze,
                                enable: Ae,
                                assignEvents: da
                            })
                        }(r)
                          , Y = function({enable: Ae, clickTolerance: Be, rollDegreesPerPixelMoved: qe=.3}, ze) {
                            const Ke = new ro({
                                checkCorrectEvent: ht => D.mouseButton(ht) === 2 && ht.ctrlKey
                            });
                            return new Bl({
                                clickTolerance: Be,
                                move: (ht, ot) => {
                                    const ut = ze();
                                    let mt = (ot.x - ht.x) * qe;
                                    return ot.y < ut.y && (mt = -mt),
                                    {
                                        rollDelta: mt
                                    }
                                }
                                ,
                                moveStateManager: Ke,
                                enable: Ae,
                                assignEvents: da
                            })
                        }(r, $);
                        a.dragRotate = new Cc(r,Z,H,Y),
                        this._add("mouseRotate", Z, ["mousePitch"]),
                        this._add("mousePitch", H, ["mouseRotate", "mouseRoll"]),
                        this._add("mouseRoll", Y, ["mousePitch"]),
                        r.interactive && r.dragRotate && a.dragRotate.enable();
                        const ae = function({enable: Ae, clickTolerance: Be}) {
                            const qe = new ro({
                                checkCorrectEvent: ze => D.mouseButton(ze) === 0 && !ze.ctrlKey
                            });
                            return new Bl({
                                clickTolerance: Be,
                                move: (ze, Ke) => ({
                                    around: Ke,
                                    panDelta: Ke.sub(ze)
                                }),
                                activateOnStart: !0,
                                moveStateManager: qe,
                                enable: Ae,
                                assignEvents: da
                            })
                        }(r)
                          , ye = new bc(r,a);
                        a.dragPan = new Ru(m,ae,ye),
                        this._add("mousePan", ae),
                        this._add("touchPan", ye, ["touchZoom", "touchRotate"]),
                        r.interactive && r.dragPan && a.dragPan.enable(r.dragPan);
                        const Se = new Es
                          , Te = new hi;
                        a.touchZoomRotate = new Ch(m,Te,Se,A),
                        this._add("touchRotate", Se, ["touchPan", "touchZoom"]),
                        this._add("touchZoom", Te, ["touchPan", "touchRotate"]),
                        r.interactive && r.touchZoomRotate && a.touchZoomRotate.enable(r.touchZoomRotate);
                        const Re = a.scrollZoom = new Xn(a, () => this._triggerRenderFrame());
                        this._add("scrollZoom", Re, ["mousePan"]),
                        r.interactive && r.scrollZoom && a.scrollZoom.enable(r.scrollZoom);
                        const De = a.keyboard = new Ka(a);
                        this._add("keyboard", De),
                        r.interactive && r.keyboard && a.keyboard.enable(),
                        this._add("blockableMapEvent", new Za(a))
                    }
                    _add(r, a, m) {
                        this._handlers.push({
                            handlerName: r,
                            handler: a,
                            allowed: m
                        }),
                        this._handlersById[r] = a
                    }
                    stop(r) {
                        if (!this._updatingCamera) {
                            for (const {handler: a} of this._handlers)
                                a.reset();
                            this._inertia.clear(),
                            this._fireEvents({}, {}, r),
                            this._changes = []
                        }
                    }
                    isActive() {
                        for (const {handler: r} of this._handlers)
                            if (r.isActive())
                                return !0;
                        return !1
                    }
                    isZooming() {
                        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
                    }
                    isRotating() {
                        return !!this._eventsInProgress.rotate
                    }
                    isMoving() {
                        return !!Tc(this._eventsInProgress) || this.isZooming()
                    }
                    _blockedByActive(r, a, m) {
                        for (const y in r)
                            if (y !== m && (!a || a.indexOf(y) < 0))
                                return !0;
                        return !1
                    }
                    _getMapTouches(r) {
                        const a = [];
                        for (const m of r)
                            this._el.contains(m.target) && a.push(m);
                        return a
                    }
                    mergeHandlerResult(r, a, m, y, x) {
                        if (!m)
                            return;
                        o.e(r, m);
                        const P = {
                            handlerName: y,
                            originalEvent: m.originalEvent || x
                        };
                        m.zoomDelta !== void 0 && (a.zoom = P),
                        m.panDelta !== void 0 && (a.drag = P),
                        m.rollDelta !== void 0 && (a.roll = P),
                        m.pitchDelta !== void 0 && (a.pitch = P),
                        m.bearingDelta !== void 0 && (a.rotate = P)
                    }
                    _applyChanges() {
                        const r = {}
                          , a = {}
                          , m = {};
                        for (const [y,x,P] of this._changes)
                            y.panDelta && (r.panDelta = (r.panDelta || new o.P(0,0))._add(y.panDelta)),
                            y.zoomDelta && (r.zoomDelta = (r.zoomDelta || 0) + y.zoomDelta),
                            y.bearingDelta && (r.bearingDelta = (r.bearingDelta || 0) + y.bearingDelta),
                            y.pitchDelta && (r.pitchDelta = (r.pitchDelta || 0) + y.pitchDelta),
                            y.rollDelta && (r.rollDelta = (r.rollDelta || 0) + y.rollDelta),
                            y.around !== void 0 && (r.around = y.around),
                            y.pinchAround !== void 0 && (r.pinchAround = y.pinchAround),
                            y.noInertia && (r.noInertia = y.noInertia),
                            o.e(a, x),
                            o.e(m, P);
                        this._updateMapTransform(r, a, m),
                        this._changes = []
                    }
                    _updateMapTransform(r, a, m) {
                        const y = this._map
                          , x = y._getTransformForUpdate()
                          , P = y.terrain;
                        if (!(zu(r) || P && this._terrainMovement))
                            return this._fireEvents(a, m, !0);
                        y._stop(!0);
                        let {panDelta: I, zoomDelta: A, bearingDelta: B, pitchDelta: $, rollDelta: Z, around: H, pinchAround: Y} = r;
                        Y !== void 0 && (H = Y),
                        H = H || y.transform.centerPoint,
                        P && !x.isPointOnMapSurface(H) && (H = x.centerPoint);
                        const ae = {
                            panDelta: I,
                            zoomDelta: A,
                            rollDelta: Z,
                            pitchDelta: $,
                            bearingDelta: B,
                            around: H
                        };
                        this._map.cameraHelper.useGlobeControls && !x.isPointOnMapSurface(H) && (H = x.centerPoint);
                        const ye = H.distSqr(x.centerPoint) < .01 ? x.center : x.screenPointToLocation(I ? H.sub(I) : H);
                        P ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(ae, x),
                        this._terrainMovement || !a.drag && !a.zoom ? a.drag && this._terrainMovement ? x.setCenter(x.screenPointToLocation(x.centerPoint.sub(I))) : this._map.cameraHelper.handleMapControlsPan(ae, x, ye) : (this._terrainMovement = !0,
                        this._map._elevationFreeze = !0,
                        this._map.cameraHelper.handleMapControlsPan(ae, x, ye))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(ae, x),
                        this._map.cameraHelper.handleMapControlsPan(ae, x, ye)),
                        y._applyUpdatedTransform(x),
                        this._map._update(),
                        r.noInertia || this._inertia.record(r),
                        this._fireEvents(a, m, !0)
                    }
                    _fireEvents(r, a, m) {
                        const y = Tc(this._eventsInProgress)
                          , x = Tc(r)
                          , P = {};
                        for (const Z in r) {
                            const {originalEvent: H} = r[Z];
                            this._eventsInProgress[Z] || (P[`${Z}start`] = H),
                            this._eventsInProgress[Z] = r[Z]
                        }
                        !y && x && this._fireEvent("movestart", x.originalEvent);
                        for (const Z in P)
                            this._fireEvent(Z, P[Z]);
                        x && this._fireEvent("move", x.originalEvent);
                        for (const Z in r) {
                            const {originalEvent: H} = r[Z];
                            this._fireEvent(Z, H)
                        }
                        const I = {};
                        let A;
                        for (const Z in this._eventsInProgress) {
                            const {handlerName: H, originalEvent: Y} = this._eventsInProgress[Z];
                            this._handlersById[H].isActive() || (delete this._eventsInProgress[Z],
                            A = a[H] || Y,
                            I[`${Z}end`] = A)
                        }
                        for (const Z in I)
                            this._fireEvent(Z, I[Z]);
                        const B = Tc(this._eventsInProgress)
                          , $ = (y || x) && !B;
                        if ($ && this._terrainMovement) {
                            this._map._elevationFreeze = !1,
                            this._terrainMovement = !1;
                            const Z = this._map._getTransformForUpdate();
                            this._map.getCenterClampedToGround() && Z.recalculateZoomAndCenter(this._map.terrain),
                            this._map._applyUpdatedTransform(Z)
                        }
                        if (m && $) {
                            this._updatingCamera = !0;
                            const Z = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions)
                              , H = Y => Y !== 0 && -this._bearingSnap < Y && Y < this._bearingSnap;
                            !Z || !Z.essential && z.prefersReducedMotion ? (this._map.fire(new o.l("moveend",{
                                originalEvent: A
                            })),
                            H(this._map.getBearing()) && this._map.resetNorth()) : (H(Z.bearing || this._map.getBearing()) && (Z.bearing = 0),
                            Z.freezeElevation = !0,
                            this._map.easeTo(Z, {
                                originalEvent: A
                            })),
                            this._updatingCamera = !1
                        }
                    }
                    _fireEvent(r, a) {
                        this._map.fire(new o.l(r,a ? {
                            originalEvent: a
                        } : {}))
                    }
                    _requestFrame() {
                        return this._map.triggerRepaint(),
                        this._map._renderTaskQueue.add(r => {
                            delete this._frameId,
                            this.handleEvent(new Pc("renderFrame",{
                                timeStamp: r
                            })),
                            this._applyChanges()
                        }
                        )
                    }
                    _triggerRenderFrame() {
                        this._frameId === void 0 && (this._frameId = this._requestFrame())
                    }
                }
                class Mn extends o.E {
                    constructor(r, a, m) {
                        super(),
                        this._renderFrameCallback = () => {
                            const y = Math.min((z.now() - this._easeStart) / this._easeOptions.duration, 1);
                            this._onEaseFrame(this._easeOptions.easing(y)),
                            y < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
                        }
                        ,
                        this._moving = !1,
                        this._zooming = !1,
                        this.transform = r,
                        this._bearingSnap = m.bearingSnap,
                        this.cameraHelper = a,
                        this.on("moveend", () => {
                            delete this._requestedCameraState
                        }
                        )
                    }
                    migrateProjection(r, a) {
                        r.apply(this.transform),
                        this.transform = r,
                        this.cameraHelper = a
                    }
                    getCenter() {
                        return new o.S(this.transform.center.lng,this.transform.center.lat)
                    }
                    setCenter(r, a) {
                        return this.jumpTo({
                            center: r
                        }, a)
                    }
                    getCenterElevation() {
                        return this.transform.elevation
                    }
                    setCenterElevation(r, a) {
                        return this.jumpTo({
                            elevation: r
                        }, a),
                        this
                    }
                    getCenterClampedToGround() {
                        return this._centerClampedToGround
                    }
                    setCenterClampedToGround(r) {
                        this._centerClampedToGround = r
                    }
                    panBy(r, a, m) {
                        return r = o.P.convert(r).mult(-1),
                        this.panTo(this.transform.center, o.e({
                            offset: r
                        }, a), m)
                    }
                    panTo(r, a, m) {
                        return this.easeTo(o.e({
                            center: r
                        }, a), m)
                    }
                    getZoom() {
                        return this.transform.zoom
                    }
                    setZoom(r, a) {
                        return this.jumpTo({
                            zoom: r
                        }, a),
                        this
                    }
                    zoomTo(r, a, m) {
                        return this.easeTo(o.e({
                            zoom: r
                        }, a), m)
                    }
                    zoomIn(r, a) {
                        return this.zoomTo(this.getZoom() + 1, r, a),
                        this
                    }
                    zoomOut(r, a) {
                        return this.zoomTo(this.getZoom() - 1, r, a),
                        this
                    }
                    getVerticalFieldOfView() {
                        return this.transform.fov
                    }
                    setVerticalFieldOfView(r, a) {
                        return r != this.transform.fov && (this.transform.setFov(r),
                        this.fire(new o.l("movestart",a)).fire(new o.l("move",a)).fire(new o.l("moveend",a))),
                        this
                    }
                    getBearing() {
                        return this.transform.bearing
                    }
                    setBearing(r, a) {
                        return this.jumpTo({
                            bearing: r
                        }, a),
                        this
                    }
                    getPadding() {
                        return this.transform.padding
                    }
                    setPadding(r, a) {
                        return this.jumpTo({
                            padding: r
                        }, a),
                        this
                    }
                    rotateTo(r, a, m) {
                        return this.easeTo(o.e({
                            bearing: r
                        }, a), m)
                    }
                    resetNorth(r, a) {
                        return this.rotateTo(0, o.e({
                            duration: 1e3
                        }, r), a),
                        this
                    }
                    resetNorthPitch(r, a) {
                        return this.easeTo(o.e({
                            bearing: 0,
                            pitch: 0,
                            roll: 0,
                            duration: 1e3
                        }, r), a),
                        this
                    }
                    snapToNorth(r, a) {
                        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(r, a) : this
                    }
                    getPitch() {
                        return this.transform.pitch
                    }
                    setPitch(r, a) {
                        return this.jumpTo({
                            pitch: r
                        }, a),
                        this
                    }
                    getRoll() {
                        return this.transform.roll
                    }
                    setRoll(r, a) {
                        return this.jumpTo({
                            roll: r
                        }, a),
                        this
                    }
                    cameraForBounds(r, a) {
                        r = ur.convert(r).adjustAntiMeridian();
                        const m = a && a.bearing || 0;
                        return this._cameraForBoxAndBearing(r.getNorthWest(), r.getSouthEast(), m, a)
                    }
                    _cameraForBoxAndBearing(r, a, m, y) {
                        const x = {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                        if (typeof (y = o.e({
                            padding: x,
                            offset: [0, 0],
                            maxZoom: this.transform.maxZoom
                        }, y)).padding == "number") {
                            const B = y.padding;
                            y.padding = {
                                top: B,
                                bottom: B,
                                right: B,
                                left: B
                            }
                        }
                        const P = o.e(x, y.padding);
                        y.padding = P;
                        const I = this.transform
                          , A = new ur(r,a);
                        return this.cameraHelper.cameraForBoxAndBearing(y, P, A, m, I)
                    }
                    fitBounds(r, a, m) {
                        return this._fitInternal(this.cameraForBounds(r, a), a, m)
                    }
                    fitScreenCoordinates(r, a, m, y, x) {
                        return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(o.P.convert(r)), this.transform.screenPointToLocation(o.P.convert(a)), m, y), y, x)
                    }
                    _fitInternal(r, a, m) {
                        return r ? (delete (a = o.e(r, a)).padding,
                        a.linear ? this.easeTo(a, m) : this.flyTo(a, m)) : this
                    }
                    jumpTo(r, a) {
                        this.stop();
                        const m = this._getTransformForUpdate();
                        let y = !1
                          , x = !1
                          , P = !1;
                        const I = m.zoom;
                        this.cameraHelper.handleJumpToCenterZoom(m, r);
                        const A = m.zoom !== I;
                        return "elevation"in r && m.elevation !== +r.elevation && m.setElevation(+r.elevation),
                        "bearing"in r && m.bearing !== +r.bearing && (y = !0,
                        m.setBearing(+r.bearing)),
                        "pitch"in r && m.pitch !== +r.pitch && (x = !0,
                        m.setPitch(+r.pitch)),
                        "roll"in r && m.roll !== +r.roll && (P = !0,
                        m.setRoll(+r.roll)),
                        r.padding == null || m.isPaddingEqual(r.padding) || m.setPadding(r.padding),
                        this._applyUpdatedTransform(m),
                        this.fire(new o.l("movestart",a)).fire(new o.l("move",a)),
                        A && this.fire(new o.l("zoomstart",a)).fire(new o.l("zoom",a)).fire(new o.l("zoomend",a)),
                        y && this.fire(new o.l("rotatestart",a)).fire(new o.l("rotate",a)).fire(new o.l("rotateend",a)),
                        x && this.fire(new o.l("pitchstart",a)).fire(new o.l("pitch",a)).fire(new o.l("pitchend",a)),
                        P && this.fire(new o.l("rollstart",a)).fire(new o.l("roll",a)).fire(new o.l("rollend",a)),
                        this.fire(new o.l("moveend",a))
                    }
                    calculateCameraOptionsFromTo(r, a, m, y=0) {
                        const x = o.a0.fromLngLat(r, a)
                          , P = o.a0.fromLngLat(m, y)
                          , I = P.x - x.x
                          , A = P.y - x.y
                          , B = P.z - x.z
                          , $ = Math.hypot(I, A, B);
                        if ($ === 0)
                            throw new Error("Can't calculate camera options with same From and To");
                        const Z = Math.hypot(I, A)
                          , H = o.aj(this.transform.cameraToCenterDistance / $ / this.transform.tileSize)
                          , Y = 180 * Math.atan2(I, -A) / Math.PI;
                        let ae = 180 * Math.acos(Z / $) / Math.PI;
                        return ae = B < 0 ? 90 - ae : 90 + ae,
                        {
                            center: P.toLngLat(),
                            elevation: y,
                            zoom: H,
                            pitch: ae,
                            bearing: Y
                        }
                    }
                    calculateCameraOptionsFromCameraLngLatAltRotation(r, a, m, y, x) {
                        const P = this.transform.calculateCenterFromCameraLngLatAlt(r, a, m, y);
                        return {
                            center: P.center,
                            elevation: P.elevation,
                            zoom: P.zoom,
                            bearing: m,
                            pitch: y,
                            roll: x
                        }
                    }
                    easeTo(r, a) {
                        this._stop(!1, r.easeId),
                        ((r = o.e({
                            offset: [0, 0],
                            duration: 500,
                            easing: o.cn
                        }, r)).animate === !1 || !r.essential && z.prefersReducedMotion) && (r.duration = 0);
                        const m = this._getTransformForUpdate()
                          , y = this.getBearing()
                          , x = m.pitch
                          , P = m.roll
                          , I = "bearing"in r ? this._normalizeBearing(r.bearing, y) : y
                          , A = "pitch"in r ? +r.pitch : x
                          , B = "roll"in r ? this._normalizeBearing(r.roll, P) : P
                          , $ = "padding"in r ? r.padding : m.padding
                          , Z = o.P.convert(r.offset);
                        let H, Y;
                        r.around && (H = o.S.convert(r.around),
                        Y = m.locationToScreenPoint(H));
                        const ae = {
                            moving: this._moving,
                            zooming: this._zooming,
                            rotating: this._rotating,
                            pitching: this._pitching,
                            rolling: this._rolling
                        }
                          , ye = this.cameraHelper.handleEaseTo(m, {
                            bearing: I,
                            pitch: A,
                            roll: B,
                            padding: $,
                            around: H,
                            aroundPoint: Y,
                            offsetAsPoint: Z,
                            offset: r.offset,
                            zoom: r.zoom,
                            center: r.center
                        });
                        return this._rotating = this._rotating || y !== I,
                        this._pitching = this._pitching || A !== x,
                        this._rolling = this._rolling || B !== P,
                        this._padding = !m.isPaddingEqual($),
                        this._zooming = this._zooming || ye.isZooming,
                        this._easeId = r.easeId,
                        this._prepareEase(a, r.noMoveStart, ae),
                        this.terrain && this._prepareElevation(ye.elevationCenter),
                        this._ease(Se => {
                            ye.easeFunc(Se),
                            this.terrain && !r.freezeElevation && this._updateElevation(Se),
                            this._applyUpdatedTransform(m),
                            this._fireMoveEvents(a)
                        }
                        , Se => {
                            this.terrain && r.freezeElevation && this._finalizeElevation(),
                            this._afterEase(a, Se)
                        }
                        , r),
                        this
                    }
                    _prepareEase(r, a, m={}) {
                        this._moving = !0,
                        a || m.moving || this.fire(new o.l("movestart",r)),
                        this._zooming && !m.zooming && this.fire(new o.l("zoomstart",r)),
                        this._rotating && !m.rotating && this.fire(new o.l("rotatestart",r)),
                        this._pitching && !m.pitching && this.fire(new o.l("pitchstart",r)),
                        this._rolling && !m.rolling && this.fire(new o.l("rollstart",r))
                    }
                    _prepareElevation(r) {
                        this._elevationCenter = r,
                        this._elevationStart = this.transform.elevation,
                        this._elevationTarget = this.terrain.getElevationForLngLatZoom(r, this.transform.tileZoom),
                        this._elevationFreeze = !0
                    }
                    _updateElevation(r) {
                        this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
                        const a = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
                        if (r < 1 && a !== this._elevationTarget) {
                            const m = this._elevationTarget - this._elevationStart;
                            this._elevationStart += r * (m - (a - (m * r + this._elevationStart)) / (1 - r)),
                            this._elevationTarget = a
                        }
                        this.transform.setElevation(o.C.number(this._elevationStart, this._elevationTarget, r))
                    }
                    _finalizeElevation() {
                        this._elevationFreeze = !1,
                        this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
                    }
                    _getTransformForUpdate() {
                        return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()),
                        this._requestedCameraState) : this.transform
                    }
                    _elevateCameraIfInsideTerrain(r) {
                        if (!this.terrain && r.elevation >= 0 && r.pitch <= 90)
                            return {};
                        const a = r.getCameraLngLat()
                          , m = r.getCameraAltitude()
                          , y = this.terrain ? this.terrain.getElevationForLngLatZoom(a, r.zoom) : 0;
                        if (m < y) {
                            const x = this.calculateCameraOptionsFromTo(a, y, r.center, r.elevation);
                            return {
                                pitch: x.pitch,
                                zoom: x.zoom
                            }
                        }
                        return {}
                    }
                    _applyUpdatedTransform(r) {
                        const a = [];
                        if (a.push(y => this._elevateCameraIfInsideTerrain(y)),
                        this.transformCameraUpdate && a.push(y => this.transformCameraUpdate(y)),
                        !a.length)
                            return;
                        const m = r.clone();
                        for (const y of a) {
                            const x = m.clone()
                              , {center: P, zoom: I, roll: A, pitch: B, bearing: $, elevation: Z} = y(x);
                            P && x.setCenter(P),
                            Z !== void 0 && x.setElevation(Z),
                            I !== void 0 && x.setZoom(I),
                            A !== void 0 && x.setRoll(A),
                            B !== void 0 && x.setPitch(B),
                            $ !== void 0 && x.setBearing($),
                            m.apply(x)
                        }
                        this.transform.apply(m)
                    }
                    _fireMoveEvents(r) {
                        this.fire(new o.l("move",r)),
                        this._zooming && this.fire(new o.l("zoom",r)),
                        this._rotating && this.fire(new o.l("rotate",r)),
                        this._pitching && this.fire(new o.l("pitch",r)),
                        this._rolling && this.fire(new o.l("roll",r))
                    }
                    _afterEase(r, a) {
                        if (this._easeId && a && this._easeId === a)
                            return;
                        delete this._easeId;
                        const m = this._zooming
                          , y = this._rotating
                          , x = this._pitching
                          , P = this._rolling;
                        this._moving = !1,
                        this._zooming = !1,
                        this._rotating = !1,
                        this._pitching = !1,
                        this._rolling = !1,
                        this._padding = !1,
                        m && this.fire(new o.l("zoomend",r)),
                        y && this.fire(new o.l("rotateend",r)),
                        x && this.fire(new o.l("pitchend",r)),
                        P && this.fire(new o.l("rollend",r)),
                        this.fire(new o.l("moveend",r))
                    }
                    flyTo(r, a) {
                        if (!r.essential && z.prefersReducedMotion) {
                            const mt = o.Q(r, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
                            return this.jumpTo(mt, a)
                        }
                        this.stop(),
                        r = o.e({
                            offset: [0, 0],
                            speed: 1.2,
                            curve: 1.42,
                            easing: o.cn
                        }, r);
                        const m = this._getTransformForUpdate()
                          , y = m.bearing
                          , x = m.pitch
                          , P = m.roll
                          , I = m.padding
                          , A = "bearing"in r ? this._normalizeBearing(r.bearing, y) : y
                          , B = "pitch"in r ? +r.pitch : x
                          , $ = "roll"in r ? this._normalizeBearing(r.roll, P) : P
                          , Z = "padding"in r ? r.padding : m.padding
                          , H = o.P.convert(r.offset);
                        let Y = m.centerPoint.add(H);
                        const ae = m.screenPointToLocation(Y)
                          , ye = this.cameraHelper.handleFlyTo(m, {
                            bearing: A,
                            pitch: B,
                            roll: $,
                            padding: Z,
                            locationAtOffset: ae,
                            offsetAsPoint: H,
                            center: r.center,
                            minZoom: r.minZoom,
                            zoom: r.zoom
                        });
                        let Se = r.curve;
                        const Te = Math.max(m.width, m.height)
                          , Re = Te / ye.scaleOfZoom
                          , De = ye.pixelPathLength;
                        typeof ye.scaleOfMinZoom == "number" && (Se = Math.sqrt(Te / ye.scaleOfMinZoom / De * 2));
                        const Ae = Se * Se;
                        function Be(mt) {
                            const $t = (Re * Re - Te * Te + (mt ? -1 : 1) * Ae * Ae * De * De) / (2 * (mt ? Re : Te) * Ae * De);
                            return Math.log(Math.sqrt($t * $t + 1) - $t)
                        }
                        function qe(mt) {
                            return (Math.exp(mt) - Math.exp(-mt)) / 2
                        }
                        function ze(mt) {
                            return (Math.exp(mt) + Math.exp(-mt)) / 2
                        }
                        const Ke = Be(!1);
                        let ht = function(mt) {
                            return ze(Ke) / ze(Ke + Se * mt)
                        }
                          , ot = function(mt) {
                            return Te * ((ze(Ke) * (qe($t = Ke + Se * mt) / ze($t)) - qe(Ke)) / Ae) / De;
                            var $t
                        }
                          , ut = (Be(!0) - Ke) / Se;
                        if (Math.abs(De) < 2e-6 || !isFinite(ut)) {
                            if (Math.abs(Te - Re) < 1e-6)
                                return this.easeTo(r, a);
                            const mt = Re < Te ? -1 : 1;
                            ut = Math.abs(Math.log(Re / Te)) / Se,
                            ot = () => 0,
                            ht = $t => Math.exp(mt * Se * $t)
                        }
                        return r.duration = "duration"in r ? +r.duration : 1e3 * ut / ("screenSpeed"in r ? +r.screenSpeed / Se : +r.speed),
                        r.maxDuration && r.duration > r.maxDuration && (r.duration = 0),
                        this._zooming = !0,
                        this._rotating = y !== A,
                        this._pitching = B !== x,
                        this._rolling = $ !== P,
                        this._padding = !m.isPaddingEqual(Z),
                        this._prepareEase(a, !1),
                        this.terrain && this._prepareElevation(ye.targetCenter),
                        this._ease(mt => {
                            const $t = mt * ut
                              , jt = 1 / ht($t)
                              , It = ot($t);
                            this._rotating && m.setBearing(o.C.number(y, A, mt)),
                            this._pitching && m.setPitch(o.C.number(x, B, mt)),
                            this._rolling && m.setRoll(o.C.number(P, $, mt)),
                            this._padding && (m.interpolatePadding(I, Z, mt),
                            Y = m.centerPoint.add(H)),
                            ye.easeFunc(mt, jt, It, Y),
                            this.terrain && !r.freezeElevation && this._updateElevation(mt),
                            this._applyUpdatedTransform(m),
                            this._fireMoveEvents(a)
                        }
                        , () => {
                            this.terrain && r.freezeElevation && this._finalizeElevation(),
                            this._afterEase(a)
                        }
                        , r),
                        this
                    }
                    isEasing() {
                        return !!this._easeFrameId
                    }
                    stop() {
                        return this._stop()
                    }
                    _stop(r, a) {
                        var m;
                        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId),
                        delete this._easeFrameId,
                        delete this._onEaseFrame),
                        this._onEaseEnd) {
                            const y = this._onEaseEnd;
                            delete this._onEaseEnd,
                            y.call(this, a)
                        }
                        return r || (m = this.handlers) === null || m === void 0 || m.stop(!1),
                        this
                    }
                    _ease(r, a, m) {
                        m.animate === !1 || m.duration === 0 ? (r(1),
                        a()) : (this._easeStart = z.now(),
                        this._easeOptions = m,
                        this._onEaseFrame = r,
                        this._onEaseEnd = a,
                        this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
                    }
                    _normalizeBearing(r, a) {
                        r = o.aN(r, -180, 180);
                        const m = Math.abs(r - a);
                        return Math.abs(r - 360 - a) < m && (r -= 360),
                        Math.abs(r + 360 - a) < m && (r += 360),
                        r
                    }
                    queryTerrainElevation(r) {
                        return this.terrain ? this.terrain.getElevationForLngLatZoom(o.S.convert(r), this.transform.tileZoom) : null
                    }
                }
                const Ja = {
                    compact: !0,
                    customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
                };
                class Du {
                    constructor(r=Ja) {
                        this._toggleAttribution = () => {
                            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""),
                            this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"),
                            this._container.removeAttribute("open")))
                        }
                        ,
                        this._updateData = a => {
                            !a || a.sourceDataType !== "metadata" && a.sourceDataType !== "visibility" && a.dataType !== "style" && a.type !== "terrain" || this._updateAttributions()
                        }
                        ,
                        this._updateCompact = () => {
                            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""),
                            this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""),
                            this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
                        }
                        ,
                        this._updateCompactMinimize = () => {
                            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
                        }
                        ,
                        this.options = r
                    }
                    getDefaultPosition() {
                        return "bottom-right"
                    }
                    onAdd(r) {
                        return this._map = r,
                        this._compact = this.options.compact,
                        this._container = D.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"),
                        this._compactButton = D.create("summary", "maplibregl-ctrl-attrib-button", this._container),
                        this._compactButton.addEventListener("click", this._toggleAttribution),
                        this._setElementTitle(this._compactButton, "ToggleAttribution"),
                        this._innerContainer = D.create("div", "maplibregl-ctrl-attrib-inner", this._container),
                        this._updateAttributions(),
                        this._updateCompact(),
                        this._map.on("styledata", this._updateData),
                        this._map.on("sourcedata", this._updateData),
                        this._map.on("terrain", this._updateData),
                        this._map.on("resize", this._updateCompact),
                        this._map.on("drag", this._updateCompactMinimize),
                        this._container
                    }
                    onRemove() {
                        D.remove(this._container),
                        this._map.off("styledata", this._updateData),
                        this._map.off("sourcedata", this._updateData),
                        this._map.off("terrain", this._updateData),
                        this._map.off("resize", this._updateCompact),
                        this._map.off("drag", this._updateCompactMinimize),
                        this._map = void 0,
                        this._compact = void 0,
                        this._attribHTML = void 0
                    }
                    _setElementTitle(r, a) {
                        const m = this._map._getUIString(`AttributionControl.${a}`);
                        r.title = m,
                        r.setAttribute("aria-label", m)
                    }
                    _updateAttributions() {
                        if (!this._map.style)
                            return;
                        let r = [];
                        if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? r = r.concat(this.options.customAttribution.map(y => typeof y != "string" ? "" : y)) : typeof this.options.customAttribution == "string" && r.push(this.options.customAttribution)),
                        this._map.style.stylesheet) {
                            const y = this._map.style.stylesheet;
                            this.styleOwner = y.owner,
                            this.styleId = y.id
                        }
                        const a = this._map.style.sourceCaches;
                        for (const y in a) {
                            const x = a[y];
                            if (x.used || x.usedForTerrain) {
                                const P = x.getSource();
                                P.attribution && r.indexOf(P.attribution) < 0 && r.push(P.attribution)
                            }
                        }
                        r = r.filter(y => String(y).trim()),
                        r.sort( (y, x) => y.length - x.length),
                        r = r.filter( (y, x) => {
                            for (let P = x + 1; P < r.length; P++)
                                if (r[P].indexOf(y) >= 0)
                                    return !1;
                            return !0
                        }
                        );
                        const m = r.join(" | ");
                        m !== this._attribHTML && (this._attribHTML = m,
                        r.length ? (this._innerContainer.innerHTML = D.sanitize(m),
                        this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"),
                        this._updateCompact(),
                        this._editLink = null)
                    }
                }
                class Th {
                    constructor(r={}) {
                        this._updateCompact = () => {
                            const a = this._container.children;
                            if (a.length) {
                                const m = a[0];
                                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && m.classList.add("maplibregl-compact") : m.classList.remove("maplibregl-compact")
                            }
                        }
                        ,
                        this.options = r
                    }
                    getDefaultPosition() {
                        return "bottom-left"
                    }
                    onAdd(r) {
                        this._map = r,
                        this._compact = this.options && this.options.compact,
                        this._container = D.create("div", "maplibregl-ctrl");
                        const a = D.create("a", "maplibregl-ctrl-logo");
                        return a.target = "_blank",
                        a.rel = "noopener nofollow",
                        a.href = "https://maplibre.org/",
                        a.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")),
                        a.setAttribute("rel", "noopener nofollow"),
                        this._container.appendChild(a),
                        this._container.style.display = "block",
                        this._map.on("resize", this._updateCompact),
                        this._updateCompact(),
                        this._container
                    }
                    onRemove() {
                        D.remove(this._container),
                        this._map.off("resize", this._updateCompact),
                        this._map = void 0,
                        this._compact = void 0
                    }
                }
                class jl {
                    constructor() {
                        this._queue = [],
                        this._id = 0,
                        this._cleared = !1,
                        this._currentlyRunning = !1
                    }
                    add(r) {
                        const a = ++this._id;
                        return this._queue.push({
                            callback: r,
                            id: a,
                            cancelled: !1
                        }),
                        a
                    }
                    remove(r) {
                        const a = this._currentlyRunning
                          , m = a ? this._queue.concat(a) : this._queue;
                        for (const y of m)
                            if (y.id === r)
                                return void (y.cancelled = !0)
                    }
                    run(r=0) {
                        if (this._currentlyRunning)
                            throw new Error("Attempting to run(), but is already running.");
                        const a = this._currentlyRunning = this._queue;
                        this._queue = [];
                        for (const m of a)
                            if (!m.cancelled && (m.callback(r),
                            this._cleared))
                                break;
                        this._cleared = !1,
                        this._currentlyRunning = !1
                    }
                    clear() {
                        this._currentlyRunning && (this._cleared = !0),
                        this._queue = []
                    }
                }
                var Ed = o.aI([{
                    name: "a_pos3d",
                    type: "Int16",
                    components: 3
                }]);
                class Ph extends o.E {
                    constructor(r) {
                        super(),
                        this._lastTilesetChange = z.now(),
                        this.sourceCache = r,
                        this._tiles = {},
                        this._renderableTilesKeys = [],
                        this._sourceTileCache = {},
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.deltaZoom = 1,
                        this.tileSize = r._source.tileSize * 2 ** this.deltaZoom,
                        r.usedForTerrain = !0,
                        r.tileSize = this.tileSize
                    }
                    destruct() {
                        this.sourceCache.usedForTerrain = !1,
                        this.sourceCache.tileSize = null
                    }
                    update(r, a) {
                        this.sourceCache.update(r, a),
                        this._renderableTilesKeys = [];
                        const m = {};
                        for (const y of dt(r, {
                            tileSize: this.tileSize,
                            minzoom: this.minzoom,
                            maxzoom: this.maxzoom,
                            reparseOverscaled: !1,
                            terrain: a,
                            calculateTileZoom: this.sourceCache._source.calculateTileZoom
                        }))
                            m[y.key] = !0,
                            this._renderableTilesKeys.push(y.key),
                            this._tiles[y.key] || (y.terrainRttPosMatrix32f = new Float64Array(16),
                            o.bX(y.terrainRttPosMatrix32f, 0, o.$, o.$, 0, 0, 1),
                            this._tiles[y.key] = new Mt(y,this.tileSize),
                            this._lastTilesetChange = z.now());
                        for (const y in this._tiles)
                            m[y] || delete this._tiles[y]
                    }
                    freeRtt(r) {
                        for (const a in this._tiles) {
                            const m = this._tiles[a];
                            (!r || m.tileID.equals(r) || m.tileID.isChildOf(r) || r.isChildOf(m.tileID)) && (m.rtt = [])
                        }
                    }
                    getRenderableTiles() {
                        return this._renderableTilesKeys.map(r => this.getTileByID(r))
                    }
                    getTileByID(r) {
                        return this._tiles[r]
                    }
                    getTerrainCoords(r, a) {
                        return a ? this._getTerrainCoordsForTileRanges(r, a) : this._getTerrainCoordsForRegularTile(r)
                    }
                    _getTerrainCoordsForRegularTile(r) {
                        const a = {};
                        for (const m of this._renderableTilesKeys) {
                            const y = this._tiles[m].tileID
                              , x = r.clone()
                              , P = o.b9();
                            if (y.canonical.equals(r.canonical))
                                o.bX(P, 0, o.$, o.$, 0, 0, 1);
                            else if (y.canonical.isChildOf(r.canonical)) {
                                const I = y.canonical.z - r.canonical.z
                                  , A = y.canonical.x - (y.canonical.x >> I << I)
                                  , B = y.canonical.y - (y.canonical.y >> I << I)
                                  , $ = o.$ >> I;
                                o.bX(P, 0, $, $, 0, 0, 1),
                                o.M(P, P, [-A * $, -B * $, 0])
                            } else {
                                if (!r.canonical.isChildOf(y.canonical))
                                    continue;
                                {
                                    const I = r.canonical.z - y.canonical.z
                                      , A = r.canonical.x - (r.canonical.x >> I << I)
                                      , B = r.canonical.y - (r.canonical.y >> I << I)
                                      , $ = o.$ >> I;
                                    o.bX(P, 0, o.$, o.$, 0, 0, 1),
                                    o.M(P, P, [A * $, B * $, 0]),
                                    o.N(P, P, [1 / 2 ** I, 1 / 2 ** I, 0])
                                }
                            }
                            x.terrainRttPosMatrix32f = new Float32Array(P),
                            a[m] = x
                        }
                        return a
                    }
                    _getTerrainCoordsForTileRanges(r, a) {
                        const m = {};
                        for (const y of this._renderableTilesKeys) {
                            const x = this._tiles[y].tileID;
                            if (!this._isWithinTileRanges(x, a))
                                continue;
                            const P = r.clone()
                              , I = o.b9();
                            if (x.canonical.z === r.canonical.z) {
                                const A = r.canonical.x - x.canonical.x
                                  , B = r.canonical.y - x.canonical.y;
                                o.bX(I, 0, o.$, o.$, 0, 0, 1),
                                o.M(I, I, [A * o.$, B * o.$, 0])
                            } else if (x.canonical.z > r.canonical.z) {
                                const A = x.canonical.z - r.canonical.z
                                  , B = x.canonical.x - (x.canonical.x >> A << A)
                                  , $ = x.canonical.y - (x.canonical.y >> A << A)
                                  , Z = r.canonical.x - (x.canonical.x >> A)
                                  , H = r.canonical.y - (x.canonical.y >> A)
                                  , Y = o.$ >> A;
                                o.bX(I, 0, Y, Y, 0, 0, 1),
                                o.M(I, I, [-B * Y + Z * o.$, -$ * Y + H * o.$, 0])
                            } else {
                                const A = r.canonical.z - x.canonical.z
                                  , B = r.canonical.x - (r.canonical.x >> A << A)
                                  , $ = r.canonical.y - (r.canonical.y >> A << A)
                                  , Z = (r.canonical.x >> A) - x.canonical.x
                                  , H = (r.canonical.y >> A) - x.canonical.y
                                  , Y = o.$ << A;
                                o.bX(I, 0, Y, Y, 0, 0, 1),
                                o.M(I, I, [B * o.$ + Z * Y, $ * o.$ + H * Y, 0])
                            }
                            P.terrainRttPosMatrix32f = new Float32Array(I),
                            m[y] = P
                        }
                        return m
                    }
                    getSourceTile(r, a) {
                        const m = this.sourceCache._source;
                        let y = r.overscaledZ - this.deltaZoom;
                        if (y > m.maxzoom && (y = m.maxzoom),
                        y < m.minzoom)
                            return null;
                        this._sourceTileCache[r.key] || (this._sourceTileCache[r.key] = r.scaledTo(y).key);
                        let x = this.sourceCache.getTileByID(this._sourceTileCache[r.key]);
                        if ((!x || !x.dem) && a)
                            for (; y >= m.minzoom && (!x || !x.dem); )
                                x = this.sourceCache.getTileByID(r.scaledTo(y--).key);
                        return x
                    }
                    anyTilesAfterTime(r=Date.now()) {
                        return this._lastTilesetChange >= r
                    }
                    _isWithinTileRanges(r, a) {
                        return a[r.canonical.z] && r.canonical.x >= a[r.canonical.z].minTileX && r.canonical.x <= a[r.canonical.z].maxTileX && r.canonical.y >= a[r.canonical.z].minTileY && r.canonical.y <= a[r.canonical.z].maxTileY
                    }
                }
                class Qo {
                    constructor(r, a, m) {
                        this._meshCache = {},
                        this.painter = r,
                        this.sourceCache = new Ph(a),
                        this.options = m,
                        this.exaggeration = typeof m.exaggeration == "number" ? m.exaggeration : 1,
                        this.qualityFactor = 2,
                        this.meshSize = 128,
                        this._demMatrixCache = {},
                        this.coordsIndex = [],
                        this._coordsTextureSize = 1024
                    }
                    getDEMElevation(r, a, m, y=o.$) {
                        var x;
                        if (!(a >= 0 && a < y && m >= 0 && m < y))
                            return 0;
                        const P = this.getTerrainData(r)
                          , I = (x = P.tile) === null || x === void 0 ? void 0 : x.dem;
                        if (!I)
                            return 0;
                        const A = o.cr([], [a / y * o.$, m / y * o.$], P.u_terrain_matrix)
                          , B = [A[0] * I.dim, A[1] * I.dim]
                          , $ = Math.floor(B[0])
                          , Z = Math.floor(B[1])
                          , H = B[0] - $
                          , Y = B[1] - Z;
                        return I.get($, Z) * (1 - H) * (1 - Y) + I.get($ + 1, Z) * H * (1 - Y) + I.get($, Z + 1) * (1 - H) * Y + I.get($ + 1, Z + 1) * H * Y
                    }
                    getElevationForLngLatZoom(r, a) {
                        if (!o.cs(a, r.wrap()))
                            return 0;
                        const {tileID: m, mercatorX: y, mercatorY: x} = this._getOverscaledTileIDFromLngLatZoom(r, a);
                        return this.getElevation(m, y % o.$, x % o.$, o.$)
                    }
                    getElevation(r, a, m, y=o.$) {
                        return this.getDEMElevation(r, a, m, y) * this.exaggeration
                    }
                    getTerrainData(r) {
                        if (!this._emptyDemTexture) {
                            const y = this.painter.context
                              , x = new o.R({
                                width: 1,
                                height: 1
                            },new Uint8Array(4));
                            this._emptyDepthTexture = new o.T(y,x,y.gl.RGBA,{
                                premultiply: !1
                            }),
                            this._emptyDemUnpack = [0, 0, 0, 0],
                            this._emptyDemTexture = new o.T(y,new o.R({
                                width: 1,
                                height: 1
                            }),y.gl.RGBA,{
                                premultiply: !1
                            }),
                            this._emptyDemTexture.bind(y.gl.NEAREST, y.gl.CLAMP_TO_EDGE),
                            this._emptyDemMatrix = o.af([])
                        }
                        const a = this.sourceCache.getSourceTile(r, !0);
                        if (a && a.dem && (!a.demTexture || a.needsTerrainPrepare)) {
                            const y = this.painter.context;
                            a.demTexture = this.painter.getTileTexture(a.dem.stride),
                            a.demTexture ? a.demTexture.update(a.dem.getPixels(), {
                                premultiply: !1
                            }) : a.demTexture = new o.T(y,a.dem.getPixels(),y.gl.RGBA,{
                                premultiply: !1
                            }),
                            a.demTexture.bind(y.gl.NEAREST, y.gl.CLAMP_TO_EDGE),
                            a.needsTerrainPrepare = !1
                        }
                        const m = a && a + a.tileID.key + r.key;
                        if (m && !this._demMatrixCache[m]) {
                            const y = this.sourceCache.sourceCache._source.maxzoom;
                            let x = r.canonical.z - a.tileID.canonical.z;
                            r.overscaledZ > r.canonical.z && (r.canonical.z >= y ? x = r.canonical.z - y : o.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
                            const P = r.canonical.x - (r.canonical.x >> x << x)
                              , I = r.canonical.y - (r.canonical.y >> x << x)
                              , A = o.ct(new Float64Array(16), [1 / (o.$ << x), 1 / (o.$ << x), 0]);
                            o.M(A, A, [P * o.$, I * o.$, 0]),
                            this._demMatrixCache[r.key] = {
                                matrix: A,
                                coord: r
                            }
                        }
                        return {
                            u_depth: 2,
                            u_terrain: 3,
                            u_terrain_dim: a && a.dem && a.dem.dim || 1,
                            u_terrain_matrix: m ? this._demMatrixCache[r.key].matrix : this._emptyDemMatrix,
                            u_terrain_unpack: a && a.dem && a.dem.getUnpackVector() || this._emptyDemUnpack,
                            u_terrain_exaggeration: this.exaggeration,
                            texture: (a && a.demTexture || this._emptyDemTexture).texture,
                            depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
                            tile: a
                        }
                    }
                    getFramebuffer(r) {
                        const a = this.painter
                          , m = a.width / devicePixelRatio
                          , y = a.height / devicePixelRatio;
                        return !this._fbo || this._fbo.width === m && this._fbo.height === y || (this._fbo.destroy(),
                        this._fboCoordsTexture.destroy(),
                        this._fboDepthTexture.destroy(),
                        delete this._fbo,
                        delete this._fboDepthTexture,
                        delete this._fboCoordsTexture),
                        this._fboCoordsTexture || (this._fboCoordsTexture = new o.T(a.context,{
                            width: m,
                            height: y,
                            data: null
                        },a.context.gl.RGBA,{
                            premultiply: !1
                        }),
                        this._fboCoordsTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)),
                        this._fboDepthTexture || (this._fboDepthTexture = new o.T(a.context,{
                            width: m,
                            height: y,
                            data: null
                        },a.context.gl.RGBA,{
                            premultiply: !1
                        }),
                        this._fboDepthTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)),
                        this._fbo || (this._fbo = a.context.createFramebuffer(m, y, !0, !1),
                        this._fbo.depthAttachment.set(a.context.createRenderbuffer(a.context.gl.DEPTH_COMPONENT16, m, y))),
                        this._fbo.colorAttachment.set(r === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture),
                        this._fbo
                    }
                    getCoordsTexture() {
                        const r = this.painter.context;
                        if (this._coordsTexture)
                            return this._coordsTexture;
                        const a = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
                        for (let x = 0, P = 0; x < this._coordsTextureSize; x++)
                            for (let I = 0; I < this._coordsTextureSize; I++,
                            P += 4)
                                a[P + 0] = 255 & I,
                                a[P + 1] = 255 & x,
                                a[P + 2] = I >> 8 << 4 | x >> 8,
                                a[P + 3] = 0;
                        const m = new o.R({
                            width: this._coordsTextureSize,
                            height: this._coordsTextureSize
                        },new Uint8Array(a.buffer))
                          , y = new o.T(r,m,r.gl.RGBA,{
                            premultiply: !1
                        });
                        return y.bind(r.gl.NEAREST, r.gl.CLAMP_TO_EDGE),
                        this._coordsTexture = y,
                        y
                    }
                    pointCoordinate(r) {
                        this.painter.maybeDrawDepthAndCoords(!0);
                        const a = new Uint8Array(4)
                          , m = this.painter.context
                          , y = m.gl
                          , x = Math.round(r.x * this.painter.pixelRatio / devicePixelRatio)
                          , P = Math.round(r.y * this.painter.pixelRatio / devicePixelRatio)
                          , I = Math.round(this.painter.height / devicePixelRatio);
                        m.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer),
                        y.readPixels(x, I - P - 1, 1, 1, y.RGBA, y.UNSIGNED_BYTE, a),
                        m.bindFramebuffer.set(null);
                        const A = a[0] + (a[2] >> 4 << 8)
                          , B = a[1] + ((15 & a[2]) << 8)
                          , $ = this.coordsIndex[255 - a[3]]
                          , Z = $ && this.sourceCache.getTileByID($);
                        if (!Z)
                            return null;
                        const H = this._coordsTextureSize
                          , Y = (1 << Z.tileID.canonical.z) * H;
                        return new o.a0((Z.tileID.canonical.x * H + A) / Y + Z.tileID.wrap,(Z.tileID.canonical.y * H + B) / Y,this.getElevation(Z.tileID, A, B, H))
                    }
                    depthAtPoint(r) {
                        const a = new Uint8Array(4)
                          , m = this.painter.context
                          , y = m.gl;
                        return m.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer),
                        y.readPixels(r.x, this.painter.height / devicePixelRatio - r.y - 1, 1, 1, y.RGBA, y.UNSIGNED_BYTE, a),
                        m.bindFramebuffer.set(null),
                        (a[0] / 16777216 + a[1] / 65536 + a[2] / 256 + a[3]) / 256
                    }
                    getTerrainMesh(r) {
                        var a;
                        const m = ((a = this.painter.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0
                          , y = m && r.canonical.y === 0
                          , x = m && r.canonical.y === (1 << r.canonical.z) - 1
                          , P = `m_${y ? "n" : ""}_${x ? "s" : ""}`;
                        if (this._meshCache[P])
                            return this._meshCache[P];
                        const I = this.painter.context
                          , A = new o.cu
                          , B = new o.aM
                          , $ = this.meshSize
                          , Z = o.$ / $
                          , H = $ * $;
                        for (let ze = 0; ze <= $; ze++)
                            for (let Ke = 0; Ke <= $; Ke++)
                                A.emplaceBack(Ke * Z, ze * Z, 0);
                        for (let ze = 0; ze < H; ze += $ + 1)
                            for (let Ke = 0; Ke < $; Ke++)
                                B.emplaceBack(Ke + ze, $ + Ke + ze + 1, $ + Ke + ze + 2),
                                B.emplaceBack(Ke + ze, $ + Ke + ze + 2, Ke + ze + 1);
                        const Y = A.length
                          , ae = Y + ($ + 1)
                          , ye = ($ + 1) * $
                          , Se = y ? o.bg : 0
                          , Te = y ? 0 : 1
                          , Re = x ? o.bh : o.$
                          , De = x ? 0 : 1;
                        for (let ze = 0; ze <= $; ze++)
                            A.emplaceBack(ze * Z, Se, Te);
                        for (let ze = 0; ze <= $; ze++)
                            A.emplaceBack(ze * Z, Re, De);
                        for (let ze = 0; ze < $; ze++)
                            B.emplaceBack(ye + ze, ae + ze, ae + ze + 1),
                            B.emplaceBack(ye + ze, ae + ze + 1, ye + ze + 1),
                            B.emplaceBack(0 + ze, Y + ze + 1, Y + ze),
                            B.emplaceBack(0 + ze, 0 + ze + 1, Y + ze + 1);
                        const Ae = A.length
                          , Be = Ae + 2 * ($ + 1);
                        for (const ze of [0, 1])
                            for (let Ke = 0; Ke <= $; Ke++)
                                for (const ht of [0, 1])
                                    A.emplaceBack(ze * o.$, Ke * Z, ht);
                        for (let ze = 0; ze < 2 * $; ze += 2)
                            B.emplaceBack(Ae + ze, Ae + ze + 1, Ae + ze + 3),
                            B.emplaceBack(Ae + ze, Ae + ze + 3, Ae + ze + 2),
                            B.emplaceBack(Be + ze, Be + ze + 3, Be + ze + 1),
                            B.emplaceBack(Be + ze, Be + ze + 2, Be + ze + 3);
                        const qe = new Ss(I.createVertexBuffer(A, Ed.members),I.createIndexBuffer(B),o.aL.simpleSegment(0, 0, A.length, B.length));
                        return this._meshCache[P] = qe,
                        qe
                    }
                    getMeshFrameDelta(r) {
                        return 2 * Math.PI * o.bt / Math.pow(2, Math.max(r, 0)) / 5
                    }
                    getMinTileElevationForLngLatZoom(r, a) {
                        var m;
                        const {tileID: y} = this._getOverscaledTileIDFromLngLatZoom(r, a);
                        return (m = this.getMinMaxElevation(y).minElevation) !== null && m !== void 0 ? m : 0
                    }
                    getMinMaxElevation(r) {
                        const a = this.getTerrainData(r).tile
                          , m = {
                            minElevation: null,
                            maxElevation: null
                        };
                        return a && a.dem && (m.minElevation = a.dem.min * this.exaggeration,
                        m.maxElevation = a.dem.max * this.exaggeration),
                        m
                    }
                    _getOverscaledTileIDFromLngLatZoom(r, a) {
                        const m = o.a0.fromLngLat(r.wrap())
                          , y = (1 << a) * o.$
                          , x = m.x * y
                          , P = m.y * y
                          , I = Math.floor(x / o.$)
                          , A = Math.floor(P / o.$);
                        return {
                            tileID: new o.Z(a,0,a,I,A),
                            mercatorX: x,
                            mercatorY: P
                        }
                    }
                }
                class pa {
                    constructor(r, a, m) {
                        this._context = r,
                        this._size = a,
                        this._tileSize = m,
                        this._objects = [],
                        this._recentlyUsed = [],
                        this._stamp = 0
                    }
                    destruct() {
                        for (const r of this._objects)
                            r.texture.destroy(),
                            r.fbo.destroy()
                    }
                    _createObject(r) {
                        const a = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0)
                          , m = new o.T(this._context,{
                            width: this._tileSize,
                            height: this._tileSize,
                            data: null
                        },this._context.gl.RGBA);
                        return m.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE),
                        this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax),
                        a.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)),
                        a.colorAttachment.set(m.texture),
                        {
                            id: r,
                            fbo: a,
                            texture: m,
                            stamp: -1,
                            inUse: !1
                        }
                    }
                    getObjectForId(r) {
                        return this._objects[r]
                    }
                    useObject(r) {
                        r.inUse = !0,
                        this._recentlyUsed = this._recentlyUsed.filter(a => r.id !== a),
                        this._recentlyUsed.push(r.id)
                    }
                    stampObject(r) {
                        r.stamp = ++this._stamp
                    }
                    getOrCreateFreeObject() {
                        for (const a of this._recentlyUsed)
                            if (!this._objects[a].inUse)
                                return this._objects[a];
                        if (this._objects.length >= this._size)
                            throw new Error("No free RenderPool available, call freeAllObjects() required!");
                        const r = this._createObject(this._objects.length);
                        return this._objects.push(r),
                        r
                    }
                    freeObject(r) {
                        r.inUse = !1
                    }
                    freeAllObjects() {
                        for (const r of this._objects)
                            this.freeObject(r)
                    }
                    isFull() {
                        return !(this._objects.length < this._size) && this._objects.some(r => !r.inUse) === !1
                    }
                }
                const ir = {
                    background: !0,
                    fill: !0,
                    line: !0,
                    raster: !0,
                    hillshade: !0,
                    "color-relief": !0
                };
                class Cr {
                    constructor(r, a) {
                        this.painter = r,
                        this.terrain = a,
                        this.pool = new pa(r.context,30,a.sourceCache.tileSize * a.qualityFactor)
                    }
                    destruct() {
                        this.pool.destruct()
                    }
                    getTexture(r) {
                        return this.pool.getObjectForId(r.rtt[this._stacks.length - 1].id).texture
                    }
                    prepareForRender(r, a) {
                        this._stacks = [],
                        this._prevType = null,
                        this._rttTiles = [],
                        this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(),
                        this._renderableLayerIds = r._order.filter(m => !r._layers[m].isHidden(a)),
                        this._coordsAscending = {};
                        for (const m in r.sourceCaches) {
                            this._coordsAscending[m] = {};
                            const y = r.sourceCaches[m].getVisibleCoordinates()
                              , x = r.sourceCaches[m].getSource()
                              , P = x instanceof gn ? x.terrainTileRanges : null;
                            for (const I of y) {
                                const A = this.terrain.sourceCache.getTerrainCoords(I, P);
                                for (const B in A)
                                    this._coordsAscending[m][B] || (this._coordsAscending[m][B] = []),
                                    this._coordsAscending[m][B].push(A[B])
                            }
                        }
                        this._coordsAscendingStr = {};
                        for (const m of r._order) {
                            const y = r._layers[m]
                              , x = y.source;
                            if (ir[y.type] && !this._coordsAscendingStr[x]) {
                                this._coordsAscendingStr[x] = {};
                                for (const P in this._coordsAscending[x])
                                    this._coordsAscendingStr[x][P] = this._coordsAscending[x][P].map(I => I.key).sort().join()
                            }
                        }
                        for (const m of this._renderableTiles)
                            for (const y in this._coordsAscendingStr) {
                                const x = this._coordsAscendingStr[y][m.tileID.key];
                                x && x !== m.rttCoords[y] && (m.rtt = [])
                            }
                    }
                    renderLayer(r, a) {
                        if (r.isHidden(this.painter.transform.zoom))
                            return !1;
                        const m = Object.assign(Object.assign({}, a), {
                            isRenderingToTexture: !0
                        })
                          , y = r.type
                          , x = this.painter
                          , P = this._renderableLayerIds[this._renderableLayerIds.length - 1] === r.id;
                        if (ir[y] && (this._prevType && ir[this._prevType] || this._stacks.push([]),
                        this._prevType = y,
                        this._stacks[this._stacks.length - 1].push(r.id),
                        !P))
                            return !0;
                        if (ir[this._prevType] || ir[y] && P) {
                            this._prevType = y;
                            const I = this._stacks.length - 1
                              , A = this._stacks[I] || [];
                            for (const B of this._renderableTiles) {
                                if (this.pool.isFull() && (fn(this.painter, this.terrain, this._rttTiles, m),
                                this._rttTiles = [],
                                this.pool.freeAllObjects()),
                                this._rttTiles.push(B),
                                B.rtt[I]) {
                                    const Z = this.pool.getObjectForId(B.rtt[I].id);
                                    if (Z.stamp === B.rtt[I].stamp) {
                                        this.pool.useObject(Z);
                                        continue
                                    }
                                }
                                const $ = this.pool.getOrCreateFreeObject();
                                this.pool.useObject($),
                                this.pool.stampObject($),
                                B.rtt[I] = {
                                    id: $.id,
                                    stamp: $.stamp
                                },
                                x.context.bindFramebuffer.set($.fbo.framebuffer),
                                x.context.clear({
                                    color: o.be.transparent,
                                    stencil: 0
                                }),
                                x.currentStencilSource = void 0;
                                for (let Z = 0; Z < A.length; Z++) {
                                    const H = x.style._layers[A[Z]]
                                      , Y = H.source ? this._coordsAscending[H.source][B.tileID.key] : [B.tileID];
                                    x.context.viewport.set([0, 0, $.fbo.width, $.fbo.height]),
                                    x._renderTileClippingMasks(H, Y, !0),
                                    x.renderLayer(x, x.style.sourceCaches[H.source], H, Y, m),
                                    H.source && (B.rttCoords[H.source] = this._coordsAscendingStr[H.source][B.tileID.key])
                                }
                            }
                            return fn(this.painter, this.terrain, this._rttTiles, m),
                            this._rttTiles = [],
                            this.pool.freeAllObjects(),
                            ir[y]
                        }
                        return !1
                    }
                }
                const Mc = {
                    "AttributionControl.ToggleAttribution": "Toggle attribution",
                    "AttributionControl.MapFeedback": "Map feedback",
                    "FullscreenControl.Enter": "Enter fullscreen",
                    "FullscreenControl.Exit": "Exit fullscreen",
                    "GeolocateControl.FindMyLocation": "Find my location",
                    "GeolocateControl.LocationNotAvailable": "Location not available",
                    "LogoControl.Title": "MapLibre logo",
                    "Map.Title": "Map",
                    "Marker.Title": "Map marker",
                    "NavigationControl.ResetBearing": "Reset bearing to north",
                    "NavigationControl.ZoomIn": "Zoom in",
                    "NavigationControl.ZoomOut": "Zoom out",
                    "Popup.Close": "Close popup",
                    "ScaleControl.Feet": "ft",
                    "ScaleControl.Meters": "m",
                    "ScaleControl.Kilometers": "km",
                    "ScaleControl.Miles": "mi",
                    "ScaleControl.NauticalMiles": "nm",
                    "GlobeControl.Enable": "Enable globe",
                    "GlobeControl.Disable": "Disable globe",
                    "TerrainControl.Enable": "Enable terrain",
                    "TerrainControl.Disable": "Disable terrain",
                    "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
                    "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map",
                    "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
                }
                  , Lu = w
                  , Zs = {
                    hash: !1,
                    interactive: !0,
                    bearingSnap: 7,
                    attributionControl: Ja,
                    maplibreLogo: !1,
                    refreshExpiredTiles: !0,
                    canvasContextAttributes: {
                        antialias: !1,
                        preserveDrawingBuffer: !1,
                        powerPreference: "high-performance",
                        failIfMajorPerformanceCaveat: !1,
                        desynchronized: !1,
                        contextType: void 0
                    },
                    scrollZoom: !0,
                    minZoom: -2,
                    maxZoom: 22,
                    minPitch: 0,
                    maxPitch: 60,
                    boxZoom: !0,
                    dragRotate: !0,
                    dragPan: !0,
                    keyboard: !0,
                    doubleClickZoom: !0,
                    touchZoomRotate: !0,
                    touchPitch: !0,
                    cooperativeGestures: !1,
                    trackResize: !0,
                    center: [0, 0],
                    elevation: 0,
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    roll: 0,
                    renderWorldCopies: !0,
                    maxTileCacheSize: null,
                    maxTileCacheZoomLevels: o.a.MAX_TILE_CACHE_ZOOM_LEVELS,
                    transformRequest: null,
                    transformCameraUpdate: null,
                    fadeDuration: 300,
                    crossSourceCollisions: !0,
                    clickTolerance: 3,
                    localIdeographFontFamily: "sans-serif",
                    pitchWithRotate: !0,
                    rollEnabled: !1,
                    validateStyle: !0,
                    maxCanvasSize: [4096, 4096],
                    cancelPendingTileRequestsWhileZooming: !0,
                    centerClampedToGround: !0
                }
                  , Vn = {
                    showCompass: !0,
                    showZoom: !0,
                    visualizePitch: !1,
                    visualizeRoll: !0
                };
                class el {
                    constructor(r, a, m=!1) {
                        this.mousedown = x => {
                            this.startMove(x, D.mousePos(this.element, x)),
                            D.addEventListener(window, "mousemove", this.mousemove),
                            D.addEventListener(window, "mouseup", this.mouseup)
                        }
                        ,
                        this.mousemove = x => {
                            this.move(x, D.mousePos(this.element, x))
                        }
                        ,
                        this.mouseup = x => {
                            this._rotatePitchHanlder.dragEnd(x),
                            this.offTemp()
                        }
                        ,
                        this.touchstart = x => {
                            x.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = D.touchPos(this.element, x.targetTouches)[0],
                            this.startMove(x, this._startPos),
                            D.addEventListener(window, "touchmove", this.touchmove, {
                                passive: !1
                            }),
                            D.addEventListener(window, "touchend", this.touchend))
                        }
                        ,
                        this.touchmove = x => {
                            x.targetTouches.length !== 1 ? this.reset() : (this._lastPos = D.touchPos(this.element, x.targetTouches)[0],
                            this.move(x, this._lastPos))
                        }
                        ,
                        this.touchend = x => {
                            x.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(),
                            delete this._startPos,
                            delete this._lastPos,
                            this.offTemp()
                        }
                        ,
                        this.reset = () => {
                            this._rotatePitchHanlder.reset(),
                            delete this._startPos,
                            delete this._lastPos,
                            this.offTemp()
                        }
                        ,
                        this._clickTolerance = 10,
                        this.element = a;
                        const y = new Xa;
                        this._rotatePitchHanlder = new Bl({
                            clickTolerance: 3,
                            move: (x, P) => {
                                const I = a.getBoundingClientRect()
                                  , A = new o.P((I.bottom - I.top) / 2,(I.right - I.left) / 2);
                                return {
                                    bearingDelta: o.cm(new o.P(x.x,P.y), P, A),
                                    pitchDelta: m ? -.5 * (P.y - x.y) : void 0
                                }
                            }
                            ,
                            moveStateManager: y,
                            enable: !0,
                            assignEvents: () => {}
                        }),
                        this.map = r,
                        D.addEventListener(a, "mousedown", this.mousedown),
                        D.addEventListener(a, "touchstart", this.touchstart, {
                            passive: !1
                        }),
                        D.addEventListener(a, "touchcancel", this.reset)
                    }
                    startMove(r, a) {
                        this._rotatePitchHanlder.dragStart(r, a),
                        D.disableDrag()
                    }
                    move(r, a) {
                        const m = this.map
                          , {bearingDelta: y, pitchDelta: x} = this._rotatePitchHanlder.dragMove(r, a) || {};
                        y && m.setBearing(m.getBearing() + y),
                        x && m.setPitch(m.getPitch() + x)
                    }
                    off() {
                        const r = this.element;
                        D.removeEventListener(r, "mousedown", this.mousedown),
                        D.removeEventListener(r, "touchstart", this.touchstart, {
                            passive: !1
                        }),
                        D.removeEventListener(window, "touchmove", this.touchmove, {
                            passive: !1
                        }),
                        D.removeEventListener(window, "touchend", this.touchend),
                        D.removeEventListener(r, "touchcancel", this.reset),
                        this.offTemp()
                    }
                    offTemp() {
                        D.enableDrag(),
                        D.removeEventListener(window, "mousemove", this.mousemove),
                        D.removeEventListener(window, "mouseup", this.mouseup),
                        D.removeEventListener(window, "touchmove", this.touchmove, {
                            passive: !1
                        }),
                        D.removeEventListener(window, "touchend", this.touchend)
                    }
                }
                let Ci;
                function Id(v, r, a, m=!1) {
                    if (m || !a.getCoveringTilesDetailsProvider().allowWorldCopies())
                        return v?.wrap();
                    const y = new o.S(v.lng,v.lat);
                    if (v = new o.S(v.lng,v.lat),
                    r) {
                        const x = new o.S(v.lng - 360,v.lat)
                          , P = new o.S(v.lng + 360,v.lat)
                          , I = a.locationToScreenPoint(v).distSqr(r);
                        a.locationToScreenPoint(x).distSqr(r) < I ? v = x : a.locationToScreenPoint(P).distSqr(r) < I && (v = P)
                    }
                    for (; Math.abs(v.lng - a.center.lng) > 180; ) {
                        const x = a.locationToScreenPoint(v);
                        if (x.x >= 0 && x.y >= 0 && x.x <= a.width && x.y <= a.height)
                            break;
                        v.lng > a.center.lng ? v.lng -= 360 : v.lng += 360
                    }
                    return v.lng !== y.lng && a.isPointOnMapSurface(a.locationToScreenPoint(v)) ? v : y
                }
                const xo = {
                    center: "translate(-50%,-50%)",
                    top: "translate(-50%,0)",
                    "top-left": "translate(0,0)",
                    "top-right": "translate(-100%,0)",
                    bottom: "translate(-50%,-100%)",
                    "bottom-left": "translate(0,-100%)",
                    "bottom-right": "translate(-100%,-100%)",
                    left: "translate(0,-50%)",
                    right: "translate(-100%,-50%)"
                };
                function _n(v, r, a) {
                    const m = v.classList;
                    for (const y in xo)
                        m.remove(`maplibregl-${a}-anchor-${y}`);
                    m.add(`maplibregl-${a}-anchor-${r}`)
                }
                class Yn extends o.E {
                    constructor(r) {
                        if (super(),
                        this._onKeyPress = a => {
                            const m = a.code
                              , y = a.charCode || a.keyCode;
                            m !== "Space" && m !== "Enter" && y !== 32 && y !== 13 || this.togglePopup()
                        }
                        ,
                        this._onMapClick = a => {
                            const m = a.originalEvent.target
                              , y = this._element;
                            this._popup && (m === y || y.contains(m)) && this.togglePopup()
                        }
                        ,
                        this._update = a => {
                            if (!this._map)
                                return;
                            const m = this._map.loaded() && !this._map.isMoving();
                            (a?.type === "terrain" || a?.type === "render" && !m) && this._map.once("render", this._update),
                            this._lngLat = Id(this._lngLat, this._flatPos, this._map.transform),
                            this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset),
                            this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                            let y = "";
                            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? y = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (y = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
                            let x = "";
                            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? x = "rotateX(0deg)" : this._pitchAlignment === "map" && (x = `rotateX(${this._map.getPitch()}deg)`),
                            this._subpixelPositioning || a && a.type !== "moveend" || (this._pos = this._pos.round()),
                            D.setTransform(this._element, `${xo[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${x} ${y}`),
                            z.frameAsync(new AbortController).then( () => {
                                this._updateOpacity(a && a.type === "moveend")
                            }
                            ).catch( () => {}
                            )
                        }
                        ,
                        this._onMove = a => {
                            if (!this._isDragging) {
                                const m = this._clickTolerance || this._map._clickTolerance;
                                this._isDragging = a.point.dist(this._pointerdownPos) >= m
                            }
                            this._isDragging && (this._pos = a.point.sub(this._positionDelta),
                            this._lngLat = this._map.unproject(this._pos),
                            this.setLngLat(this._lngLat),
                            this._element.style.pointerEvents = "none",
                            this._state === "pending" && (this._state = "active",
                            this.fire(new o.l("dragstart"))),
                            this.fire(new o.l("drag")))
                        }
                        ,
                        this._onUp = () => {
                            this._element.style.pointerEvents = "auto",
                            this._positionDelta = null,
                            this._pointerdownPos = null,
                            this._isDragging = !1,
                            this._map.off("mousemove", this._onMove),
                            this._map.off("touchmove", this._onMove),
                            this._state === "active" && this.fire(new o.l("dragend")),
                            this._state = "inactive"
                        }
                        ,
                        this._addDragHandler = a => {
                            this._element.contains(a.originalEvent.target) && (a.preventDefault(),
                            this._positionDelta = a.point.sub(this._pos).add(this._offset),
                            this._pointerdownPos = a.point,
                            this._state = "pending",
                            this._map.on("mousemove", this._onMove),
                            this._map.on("touchmove", this._onMove),
                            this._map.once("mouseup", this._onUp),
                            this._map.once("touchend", this._onUp))
                        }
                        ,
                        this._anchor = r && r.anchor || "center",
                        this._color = r && r.color || "#3FB1CE",
                        this._scale = r && r.scale || 1,
                        this._draggable = r && r.draggable || !1,
                        this._clickTolerance = r && r.clickTolerance || 0,
                        this._subpixelPositioning = r && r.subpixelPositioning || !1,
                        this._isDragging = !1,
                        this._state = "inactive",
                        this._rotation = r && r.rotation || 0,
                        this._rotationAlignment = r && r.rotationAlignment || "auto",
                        this._pitchAlignment = r && r.pitchAlignment && r.pitchAlignment !== "auto" ? r.pitchAlignment : this._rotationAlignment,
                        this.setOpacity(r?.opacity, r?.opacityWhenCovered),
                        r && r.element)
                            this._element = r.element,
                            this._offset = o.P.convert(r && r.offset || [0, 0]);
                        else {
                            this._defaultMarker = !0,
                            this._element = D.create("div");
                            const a = D.createNS("http://www.w3.org/2000/svg", "svg")
                              , m = 41
                              , y = 27;
                            a.setAttributeNS(null, "display", "block"),
                            a.setAttributeNS(null, "height", `${m}px`),
                            a.setAttributeNS(null, "width", `${y}px`),
                            a.setAttributeNS(null, "viewBox", `0 0 ${y} ${m}`);
                            const x = D.createNS("http://www.w3.org/2000/svg", "g");
                            x.setAttributeNS(null, "stroke", "none"),
                            x.setAttributeNS(null, "stroke-width", "1"),
                            x.setAttributeNS(null, "fill", "none"),
                            x.setAttributeNS(null, "fill-rule", "evenodd");
                            const P = D.createNS("http://www.w3.org/2000/svg", "g");
                            P.setAttributeNS(null, "fill-rule", "nonzero");
                            const I = D.createNS("http://www.w3.org/2000/svg", "g");
                            I.setAttributeNS(null, "transform", "translate(3.0, 29.0)"),
                            I.setAttributeNS(null, "fill", "#000000");
                            const A = [{
                                rx: "10.5",
                                ry: "5.25002273"
                            }, {
                                rx: "10.5",
                                ry: "5.25002273"
                            }, {
                                rx: "9.5",
                                ry: "4.77275007"
                            }, {
                                rx: "8.5",
                                ry: "4.29549936"
                            }, {
                                rx: "7.5",
                                ry: "3.81822308"
                            }, {
                                rx: "6.5",
                                ry: "3.34094679"
                            }, {
                                rx: "5.5",
                                ry: "2.86367051"
                            }, {
                                rx: "4.5",
                                ry: "2.38636864"
                            }];
                            for (const Te of A) {
                                const Re = D.createNS("http://www.w3.org/2000/svg", "ellipse");
                                Re.setAttributeNS(null, "opacity", "0.04"),
                                Re.setAttributeNS(null, "cx", "10.5"),
                                Re.setAttributeNS(null, "cy", "5.80029008"),
                                Re.setAttributeNS(null, "rx", Te.rx),
                                Re.setAttributeNS(null, "ry", Te.ry),
                                I.appendChild(Re)
                            }
                            const B = D.createNS("http://www.w3.org/2000/svg", "g");
                            B.setAttributeNS(null, "fill", this._color);
                            const $ = D.createNS("http://www.w3.org/2000/svg", "path");
                            $.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"),
                            B.appendChild($);
                            const Z = D.createNS("http://www.w3.org/2000/svg", "g");
                            Z.setAttributeNS(null, "opacity", "0.25"),
                            Z.setAttributeNS(null, "fill", "#000000");
                            const H = D.createNS("http://www.w3.org/2000/svg", "path");
                            H.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"),
                            Z.appendChild(H);
                            const Y = D.createNS("http://www.w3.org/2000/svg", "g");
                            Y.setAttributeNS(null, "transform", "translate(6.0, 7.0)"),
                            Y.setAttributeNS(null, "fill", "#FFFFFF");
                            const ae = D.createNS("http://www.w3.org/2000/svg", "g");
                            ae.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                            const ye = D.createNS("http://www.w3.org/2000/svg", "circle");
                            ye.setAttributeNS(null, "fill", "#000000"),
                            ye.setAttributeNS(null, "opacity", "0.25"),
                            ye.setAttributeNS(null, "cx", "5.5"),
                            ye.setAttributeNS(null, "cy", "5.5"),
                            ye.setAttributeNS(null, "r", "5.4999962");
                            const Se = D.createNS("http://www.w3.org/2000/svg", "circle");
                            Se.setAttributeNS(null, "fill", "#FFFFFF"),
                            Se.setAttributeNS(null, "cx", "5.5"),
                            Se.setAttributeNS(null, "cy", "5.5"),
                            Se.setAttributeNS(null, "r", "5.4999962"),
                            ae.appendChild(ye),
                            ae.appendChild(Se),
                            P.appendChild(I),
                            P.appendChild(B),
                            P.appendChild(Z),
                            P.appendChild(Y),
                            P.appendChild(ae),
                            a.appendChild(P),
                            a.setAttributeNS(null, "height", m * this._scale + "px"),
                            a.setAttributeNS(null, "width", y * this._scale + "px"),
                            this._element.appendChild(a),
                            this._offset = o.P.convert(r && r.offset || [0, -14])
                        }
                        if (this._element.classList.add("maplibregl-marker"),
                        this._element.addEventListener("dragstart", a => {
                            a.preventDefault()
                        }
                        ),
                        this._element.addEventListener("mousedown", a => {
                            a.preventDefault()
                        }
                        ),
                        _n(this._element, this._anchor, "marker"),
                        r && r.className)
                            for (const a of r.className.split(" "))
                                this._element.classList.add(a);
                        this._popup = null
                    }
                    addTo(r) {
                        return this.remove(),
                        this._map = r,
                        this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", r._getUIString("Marker.Title")),
                        r.getCanvasContainer().appendChild(this._element),
                        r.on("move", this._update),
                        r.on("moveend", this._update),
                        r.on("terrain", this._update),
                        r.on("projectiontransition", this._update),
                        this.setDraggable(this._draggable),
                        this._update(),
                        this._map.on("click", this._onMapClick),
                        this
                    }
                    remove() {
                        return this._opacityTimeout && (clearTimeout(this._opacityTimeout),
                        delete this._opacityTimeout),
                        this._map && (this._map.off("click", this._onMapClick),
                        this._map.off("move", this._update),
                        this._map.off("moveend", this._update),
                        this._map.off("terrain", this._update),
                        this._map.off("projectiontransition", this._update),
                        this._map.off("mousedown", this._addDragHandler),
                        this._map.off("touchstart", this._addDragHandler),
                        this._map.off("mouseup", this._onUp),
                        this._map.off("touchend", this._onUp),
                        this._map.off("mousemove", this._onMove),
                        this._map.off("touchmove", this._onMove),
                        delete this._map),
                        D.remove(this._element),
                        this._popup && this._popup.remove(),
                        this
                    }
                    getLngLat() {
                        return this._lngLat
                    }
                    setLngLat(r) {
                        return this._lngLat = o.S.convert(r),
                        this._pos = null,
                        this._popup && this._popup.setLngLat(this._lngLat),
                        this._update(),
                        this
                    }
                    getElement() {
                        return this._element
                    }
                    setPopup(r) {
                        if (this._popup && (this._popup.remove(),
                        this._popup = null,
                        this._element.removeEventListener("keypress", this._onKeyPress),
                        this._originalTabIndex || this._element.removeAttribute("tabindex")),
                        r) {
                            if (!("offset"in r.options)) {
                                const y = Math.abs(13.5) / Math.SQRT2;
                                r.options.offset = this._defaultMarker ? {
                                    top: [0, 0],
                                    "top-left": [0, 0],
                                    "top-right": [0, 0],
                                    bottom: [0, -38.1],
                                    "bottom-left": [y, -1 * (38.1 - 13.5 + y)],
                                    "bottom-right": [-y, -1 * (38.1 - 13.5 + y)],
                                    left: [13.5, -1 * (38.1 - 13.5)],
                                    right: [-13.5, -1 * (38.1 - 13.5)]
                                } : this._offset
                            }
                            this._popup = r,
                            this._originalTabIndex = this._element.getAttribute("tabindex"),
                            this._originalTabIndex || this._element.setAttribute("tabindex", "0"),
                            this._element.addEventListener("keypress", this._onKeyPress)
                        }
                        return this
                    }
                    setSubpixelPositioning(r) {
                        return this._subpixelPositioning = r,
                        this
                    }
                    getPopup() {
                        return this._popup
                    }
                    togglePopup() {
                        const r = this._popup;
                        return this._element.style.opacity === this._opacityWhenCovered ? this : r ? (r.isOpen() ? r.remove() : (r.setLngLat(this._lngLat),
                        r.addTo(this._map)),
                        this) : this
                    }
                    _updateOpacity(r=!1) {
                        var a, m;
                        const y = (a = this._map) === null || a === void 0 ? void 0 : a.terrain
                          , x = this._map.transform.isLocationOccluded(this._lngLat);
                        if (!y || x) {
                            const Y = x ? this._opacityWhenCovered : this._opacity;
                            return void (this._element.style.opacity !== Y && (this._element.style.opacity = Y))
                        }
                        if (r)
                            this._opacityTimeout = null;
                        else {
                            if (this._opacityTimeout)
                                return;
                            this._opacityTimeout = setTimeout( () => {
                                this._opacityTimeout = null
                            }
                            , 100)
                        }
                        const P = this._map
                          , I = P.terrain.depthAtPoint(this._pos)
                          , A = P.terrain.getElevationForLngLatZoom(this._lngLat, P.transform.tileZoom);
                        if (P.transform.lngLatToCameraDepth(this._lngLat, A) - I < .006)
                            return void (this._element.style.opacity = this._opacity);
                        const B = -this._offset.y / P.transform.pixelsPerMeter
                          , $ = Math.sin(P.getPitch() * Math.PI / 180) * B
                          , Z = P.terrain.depthAtPoint(new o.P(this._pos.x,this._pos.y - this._offset.y))
                          , H = P.transform.lngLatToCameraDepth(this._lngLat, A + $) - Z > .006;
                        !((m = this._popup) === null || m === void 0) && m.isOpen() && H && this._popup.remove(),
                        this._element.style.opacity = H ? this._opacityWhenCovered : this._opacity
                    }
                    getOffset() {
                        return this._offset
                    }
                    setOffset(r) {
                        return this._offset = o.P.convert(r),
                        this._update(),
                        this
                    }
                    addClassName(r) {
                        this._element.classList.add(r)
                    }
                    removeClassName(r) {
                        this._element.classList.remove(r)
                    }
                    toggleClassName(r) {
                        return this._element.classList.toggle(r)
                    }
                    setDraggable(r) {
                        return this._draggable = !!r,
                        this._map && (r ? (this._map.on("mousedown", this._addDragHandler),
                        this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler),
                        this._map.off("touchstart", this._addDragHandler))),
                        this
                    }
                    isDraggable() {
                        return this._draggable
                    }
                    setRotation(r) {
                        return this._rotation = r || 0,
                        this._update(),
                        this
                    }
                    getRotation() {
                        return this._rotation
                    }
                    setRotationAlignment(r) {
                        return this._rotationAlignment = r || "auto",
                        this._update(),
                        this
                    }
                    getRotationAlignment() {
                        return this._rotationAlignment
                    }
                    setPitchAlignment(r) {
                        return this._pitchAlignment = r && r !== "auto" ? r : this._rotationAlignment,
                        this._update(),
                        this
                    }
                    getPitchAlignment() {
                        return this._pitchAlignment
                    }
                    setOpacity(r, a) {
                        return (this._opacity === void 0 || r === void 0 && a === void 0) && (this._opacity = "1",
                        this._opacityWhenCovered = "0.2"),
                        r !== void 0 && (this._opacity = r),
                        a !== void 0 && (this._opacityWhenCovered = a),
                        this._map && this._updateOpacity(!0),
                        this
                    }
                }
                const Rd = {
                    positionOptions: {
                        enableHighAccuracy: !1,
                        maximumAge: 0,
                        timeout: 6e3
                    },
                    fitBoundsOptions: {
                        maxZoom: 15
                    },
                    trackUserLocation: !1,
                    showAccuracyCircle: !0,
                    showUserLocation: !0
                };
                let no = 0
                  , bo = !1;
                const kc = {
                    maxWidth: 100,
                    unit: "metric"
                };
                function Ou(v, r, a) {
                    const m = a && a.maxWidth || 100
                      , y = v._container.clientHeight / 2
                      , x = v._container.clientWidth / 2
                      , P = v.unproject([x - m / 2, y])
                      , I = v.unproject([x + m / 2, y])
                      , A = Math.round(v.project(I).x - v.project(P).x)
                      , B = Math.min(m, A, v._container.clientWidth)
                      , $ = P.distanceTo(I);
                    if (a && a.unit === "imperial") {
                        const Z = 3.2808 * $;
                        Z > 5280 ? Xs(r, B, Z / 5280, v._getUIString("ScaleControl.Miles")) : Xs(r, B, Z, v._getUIString("ScaleControl.Feet"))
                    } else
                        a && a.unit === "nautical" ? Xs(r, B, $ / 1852, v._getUIString("ScaleControl.NauticalMiles")) : $ >= 1e3 ? Xs(r, B, $ / 1e3, v._getUIString("ScaleControl.Kilometers")) : Xs(r, B, $, v._getUIString("ScaleControl.Meters"))
                }
                function Xs(v, r, a, m) {
                    const y = function(x) {
                        const P = Math.pow(10, `${Math.floor(x)}`.length - 1);
                        let I = x / P;
                        return I = I >= 10 ? 10 : I >= 5 ? 5 : I >= 3 ? 3 : I >= 2 ? 2 : I >= 1 ? 1 : function(A) {
                            const B = Math.pow(10, Math.ceil(-Math.log(A) / Math.LN10));
                            return Math.round(A * B) / B
                        }(I),
                        P * I
                    }(a);
                    v.style.width = r * (y / a) + "px",
                    v.innerHTML = `${y}&nbsp;${m}`
                }
                const Ec = {
                    closeButton: !0,
                    closeOnClick: !0,
                    focusAfterOpen: !0,
                    className: "",
                    maxWidth: "240px",
                    subpixelPositioning: !1,
                    locationOccludedOpacity: void 0
                }
                  , Nl = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
                function Jo(v) {
                    if (v) {
                        if (typeof v == "number") {
                            const r = Math.round(Math.abs(v) / Math.SQRT2);
                            return {
                                center: new o.P(0,0),
                                top: new o.P(0,v),
                                "top-left": new o.P(r,r),
                                "top-right": new o.P(-r,r),
                                bottom: new o.P(0,-v),
                                "bottom-left": new o.P(r,-r),
                                "bottom-right": new o.P(-r,-r),
                                left: new o.P(v,0),
                                right: new o.P(-v,0)
                            }
                        }
                        if (v instanceof o.P || Array.isArray(v)) {
                            const r = o.P.convert(v);
                            return {
                                center: r,
                                top: r,
                                "top-left": r,
                                "top-right": r,
                                bottom: r,
                                "bottom-left": r,
                                "bottom-right": r,
                                left: r,
                                right: r
                            }
                        }
                        return {
                            center: o.P.convert(v.center || [0, 0]),
                            top: o.P.convert(v.top || [0, 0]),
                            "top-left": o.P.convert(v["top-left"] || [0, 0]),
                            "top-right": o.P.convert(v["top-right"] || [0, 0]),
                            bottom: o.P.convert(v.bottom || [0, 0]),
                            "bottom-left": o.P.convert(v["bottom-left"] || [0, 0]),
                            "bottom-right": o.P.convert(v["bottom-right"] || [0, 0]),
                            left: o.P.convert(v.left || [0, 0]),
                            right: o.P.convert(v.right || [0, 0])
                        }
                    }
                    return Jo(new o.P(0,0))
                }
                const $l = w;
                f.AJAXError = o.cy,
                f.Event = o.l,
                f.Evented = o.E,
                f.LngLat = o.S,
                f.MercatorCoordinate = o.a0,
                f.Point = o.P,
                f.addProtocol = o.cz,
                f.config = o.a,
                f.removeProtocol = o.cA,
                f.AttributionControl = Du,
                f.BoxZoomHandler = to,
                f.CanvasSource = Wr,
                f.CooperativeGesturesHandler = Au,
                f.DoubleClickZoomHandler = Lo,
                f.DragPanHandler = Ru,
                f.DragRotateHandler = Cc,
                f.EdgeInsets = po,
                f.FullscreenControl = class extends o.E {
                    constructor(v={}) {
                        super(),
                        this._onFullscreenChange = () => {
                            var r;
                            let a = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
                            for (; !((r = a?.shadowRoot) === null || r === void 0) && r.fullscreenElement; )
                                a = a.shadowRoot.fullscreenElement;
                            a === this._container !== this._fullscreen && this._handleFullscreenChange()
                        }
                        ,
                        this._onClickFullscreen = () => {
                            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
                        }
                        ,
                        this._fullscreen = !1,
                        v && v.container && (v.container instanceof HTMLElement ? this._container = v.container : o.w("Full screen control 'container' must be a DOM element.")),
                        "onfullscreenchange"in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange"in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange"in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange"in document && (this._fullscreenchange = "MSFullscreenChange")
                    }
                    onAdd(v) {
                        return this._map = v,
                        this._container || (this._container = this._map.getContainer()),
                        this._controlContainer = D.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._setupUI(),
                        this._controlContainer
                    }
                    onRemove() {
                        D.remove(this._controlContainer),
                        this._map = null,
                        window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
                    }
                    _setupUI() {
                        const v = this._fullscreenButton = D.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
                        D.create("span", "maplibregl-ctrl-icon", v).setAttribute("aria-hidden", "true"),
                        v.type = "button",
                        this._updateTitle(),
                        this._fullscreenButton.addEventListener("click", this._onClickFullscreen),
                        window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
                    }
                    _updateTitle() {
                        const v = this._getTitle();
                        this._fullscreenButton.setAttribute("aria-label", v),
                        this._fullscreenButton.title = v
                    }
                    _getTitle() {
                        return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
                    }
                    _isFullscreen() {
                        return this._fullscreen
                    }
                    _handleFullscreenChange() {
                        this._fullscreen = !this._fullscreen,
                        this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"),
                        this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"),
                        this._updateTitle(),
                        this._fullscreen ? (this.fire(new o.l("fullscreenstart")),
                        this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(),
                        this._map.cooperativeGestures.disable()) : (this.fire(new o.l("fullscreenend")),
                        this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
                    }
                    _exitFullscreen() {
                        window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
                    }
                    _requestFullscreen() {
                        this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
                    }
                    _togglePseudoFullScreen() {
                        this._container.classList.toggle("maplibregl-pseudo-fullscreen"),
                        this._handleFullscreenChange(),
                        this._map.resize()
                    }
                }
                ,
                f.GeoJSONSource = $r,
                f.GeolocateControl = class extends o.E {
                    constructor(v) {
                        super(),
                        this._onSuccess = r => {
                            if (this._map) {
                                if (this._isOutOfMapMaxBounds(r))
                                    return this._setErrorState(),
                                    this.fire(new o.l("outofmaxbounds",r)),
                                    this._updateMarker(),
                                    void this._finish();
                                if (this.options.trackUserLocation)
                                    switch (this._lastKnownPosition = r,
                                    this._watchState) {
                                    case "WAITING_ACTIVE":
                                    case "ACTIVE_LOCK":
                                    case "ACTIVE_ERROR":
                                        this._watchState = "ACTIVE_LOCK",
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"),
                                        this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                        break;
                                    case "BACKGROUND":
                                    case "BACKGROUND_ERROR":
                                        this._watchState = "BACKGROUND",
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"),
                                        this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                                        break;
                                    default:
                                        throw new Error(`Unexpected watchState ${this._watchState}`)
                                    }
                                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(r),
                                this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(r),
                                this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"),
                                this.fire(new o.l("geolocate",r)),
                                this._finish()
                            }
                        }
                        ,
                        this._updateCamera = r => {
                            const a = new o.S(r.coords.longitude,r.coords.latitude)
                              , m = r.coords.accuracy
                              , y = this._map.getBearing()
                              , x = o.e({
                                bearing: y
                            }, this.options.fitBoundsOptions)
                              , P = ur.fromLngLat(a, m);
                            this._map.fitBounds(P, x, {
                                geolocateSource: !0
                            })
                        }
                        ,
                        this._updateMarker = r => {
                            if (r) {
                                const a = new o.S(r.coords.longitude,r.coords.latitude);
                                this._accuracyCircleMarker.setLngLat(a).addTo(this._map),
                                this._userLocationDotMarker.setLngLat(a).addTo(this._map),
                                this._accuracy = r.coords.accuracy,
                                this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                            } else
                                this._userLocationDotMarker.remove(),
                                this._accuracyCircleMarker.remove()
                        }
                        ,
                        this._onZoom = () => {
                            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                        }
                        ,
                        this._onError = r => {
                            if (this._map) {
                                if (r.code === 1) {
                                    this._watchState = "OFF",
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"),
                                    this._geolocateButton.disabled = !0;
                                    const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.title = a,
                                    this._geolocateButton.setAttribute("aria-label", a),
                                    this._geolocationWatchID !== void 0 && this._clearWatch()
                                } else {
                                    if (r.code === 3 && bo)
                                        return;
                                    this.options.trackUserLocation && this._setErrorState()
                                }
                                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"),
                                this.fire(new o.l("error",r)),
                                this._finish()
                            }
                        }
                        ,
                        this._finish = () => {
                            this._timeoutId && clearTimeout(this._timeoutId),
                            this._timeoutId = void 0
                        }
                        ,
                        this._setupUI = () => {
                            this._map && (this._container.addEventListener("contextmenu", r => r.preventDefault()),
                            this._geolocateButton = D.create("button", "maplibregl-ctrl-geolocate", this._container),
                            D.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"),
                            this._geolocateButton.type = "button",
                            this._geolocateButton.disabled = !0)
                        }
                        ,
                        this._finishSetupUI = r => {
                            if (this._map) {
                                if (r === !1) {
                                    o.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                                    const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.disabled = !0,
                                    this._geolocateButton.title = a,
                                    this._geolocateButton.setAttribute("aria-label", a)
                                } else {
                                    const a = this._map._getUIString("GeolocateControl.FindMyLocation");
                                    this._geolocateButton.disabled = !1,
                                    this._geolocateButton.title = a,
                                    this._geolocateButton.setAttribute("aria-label", a)
                                }
                                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"),
                                this._watchState = "OFF"),
                                this.options.showUserLocation && (this._dotElement = D.create("div", "maplibregl-user-location-dot"),
                                this._userLocationDotMarker = new Yn({
                                    element: this._dotElement
                                }),
                                this._circleElement = D.create("div", "maplibregl-user-location-accuracy-circle"),
                                this._accuracyCircleMarker = new Yn({
                                    element: this._circleElement,
                                    pitchAlignment: "map"
                                }),
                                this.options.trackUserLocation && (this._watchState = "OFF"),
                                this._map.on("zoom", this._onZoom)),
                                this._geolocateButton.addEventListener("click", () => this.trigger()),
                                this._setup = !0,
                                this.options.trackUserLocation && this._map.on("movestart", a => {
                                    a.geolocateSource || this._watchState !== "ACTIVE_LOCK" || a.originalEvent && a.originalEvent.type === "resize" || (this._watchState = "BACKGROUND",
                                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                                    this.fire(new o.l("trackuserlocationend")),
                                    this.fire(new o.l("userlocationlostfocus")))
                                }
                                )
                            }
                        }
                        ,
                        this.options = o.e({}, Rd, v)
                    }
                    onAdd(v) {
                        return this._map = v,
                        this._container = D.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._setupUI(),
                        function() {
                            return o._(this, arguments, void 0, function*(r=!1) {
                                if (Ci !== void 0 && !r)
                                    return Ci;
                                if (window.navigator.permissions === void 0)
                                    return Ci = !!window.navigator.geolocation,
                                    Ci;
                                try {
                                    Ci = (yield window.navigator.permissions.query({
                                        name: "geolocation"
                                    })).state !== "denied"
                                } catch {
                                    Ci = !!window.navigator.geolocation
                                }
                                return Ci
                            })
                        }().then(r => this._finishSetupUI(r)),
                        this._container
                    }
                    onRemove() {
                        this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID),
                        this._geolocationWatchID = void 0),
                        this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(),
                        this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(),
                        D.remove(this._container),
                        this._map.off("zoom", this._onZoom),
                        this._map = void 0,
                        no = 0,
                        bo = !1
                    }
                    _isOutOfMapMaxBounds(v) {
                        const r = this._map.getMaxBounds()
                          , a = v.coords;
                        return r && (a.longitude < r.getWest() || a.longitude > r.getEast() || a.latitude < r.getSouth() || a.latitude > r.getNorth())
                    }
                    _setErrorState() {
                        switch (this._watchState) {
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR",
                            this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR",
                            this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR",
                            this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                            break;
                        case "ACTIVE_ERROR":
                            break;
                        default:
                            throw new Error(`Unexpected watchState ${this._watchState}`)
                        }
                    }
                    _updateCircleRadius() {
                        const v = this._map.getBounds()
                          , r = v.getSouthEast()
                          , a = v.getNorthEast()
                          , m = r.distanceTo(a)
                          , y = Math.ceil(this._accuracy / (m / this._map._container.clientHeight) * 2);
                        this._circleElement.style.width = `${y}px`,
                        this._circleElement.style.height = `${y}px`
                    }
                    trigger() {
                        if (!this._setup)
                            return o.w("Geolocate control triggered before added to a map"),
                            !1;
                        if (this.options.trackUserLocation) {
                            switch (this._watchState) {
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE",
                                this.fire(new o.l("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                no--,
                                bo = !1,
                                this._watchState = "OFF",
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"),
                                this.fire(new o.l("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK",
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                                this._lastKnownPosition && this._updateCamera(this._lastKnownPosition),
                                this.fire(new o.l("trackuserlocationstart")),
                                this.fire(new o.l("userlocationfocus"));
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`)
                            }
                            switch (this._watchState) {
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                break;
                            case "OFF":
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`)
                            }
                            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
                                this._clearWatch();
                            else if (this._geolocationWatchID === void 0) {
                                let v;
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"),
                                this._geolocateButton.setAttribute("aria-pressed", "true"),
                                no++,
                                no > 1 ? (v = {
                                    maximumAge: 6e5,
                                    timeout: 0
                                },
                                bo = !0) : (v = this.options.positionOptions,
                                bo = !1),
                                this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, v)
                            }
                        } else
                            window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions),
                            this._timeoutId = setTimeout(this._finish, 1e4);
                        return !0
                    }
                    _clearWatch() {
                        window.navigator.geolocation.clearWatch(this._geolocationWatchID),
                        this._geolocationWatchID = void 0,
                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                        this._geolocateButton.setAttribute("aria-pressed", "false"),
                        this.options.showUserLocation && this._updateMarker(null)
                    }
                }
                ,
                f.GlobeControl = class {
                    constructor() {
                        this._toggleProjection = () => {
                            var v;
                            const r = (v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type;
                            this._map.setProjection(r !== "mercator" && r ? {
                                type: "mercator"
                            } : {
                                type: "globe"
                            }),
                            this._updateGlobeIcon()
                        }
                        ,
                        this._updateGlobeIcon = () => {
                            var v;
                            this._globeButton.classList.remove("maplibregl-ctrl-globe"),
                            this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"),
                            ((v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"),
                            this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"),
                            this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
                        }
                    }
                    onAdd(v) {
                        return this._map = v,
                        this._container = D.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._globeButton = D.create("button", "maplibregl-ctrl-globe", this._container),
                        D.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"),
                        this._globeButton.type = "button",
                        this._globeButton.addEventListener("click", this._toggleProjection),
                        this._updateGlobeIcon(),
                        this._map.on("styledata", this._updateGlobeIcon),
                        this._container
                    }
                    onRemove() {
                        D.remove(this._container),
                        this._map.off("styledata", this._updateGlobeIcon),
                        this._globeButton.removeEventListener("click", this._toggleProjection),
                        this._map = void 0
                    }
                }
                ,
                f.Hash = ku,
                f.ImageSource = gn,
                f.KeyboardHandler = Ka,
                f.LngLatBounds = ur,
                f.LogoControl = Th,
                f.Map = class extends Mn {
                    constructor(v) {
                        var r, a;
                        o.cv.mark(o.cw.create);
                        const m = Object.assign(Object.assign(Object.assign({}, Zs), v), {
                            canvasContextAttributes: Object.assign(Object.assign({}, Zs.canvasContextAttributes), v.canvasContextAttributes)
                        });
                        if (m.minZoom != null && m.maxZoom != null && m.minZoom > m.maxZoom)
                            throw new Error("maxZoom must be greater than or equal to minZoom");
                        if (m.minPitch != null && m.maxPitch != null && m.minPitch > m.maxPitch)
                            throw new Error("maxPitch must be greater than or equal to minPitch");
                        if (m.minPitch != null && m.minPitch < 0)
                            throw new Error("minPitch must be greater than or equal to 0");
                        if (m.maxPitch != null && m.maxPitch > 180)
                            throw new Error("maxPitch must be less than or equal to 180");
                        const y = new mi
                          , x = new lu;
                        if (m.minZoom !== void 0 && y.setMinZoom(m.minZoom),
                        m.maxZoom !== void 0 && y.setMaxZoom(m.maxZoom),
                        m.minPitch !== void 0 && y.setMinPitch(m.minPitch),
                        m.maxPitch !== void 0 && y.setMaxPitch(m.maxPitch),
                        m.renderWorldCopies !== void 0 && y.setRenderWorldCopies(m.renderWorldCopies),
                        super(y, x, {
                            bearingSnap: m.bearingSnap
                        }),
                        this._idleTriggered = !1,
                        this._crossFadingFactor = 1,
                        this._renderTaskQueue = new jl,
                        this._controls = [],
                        this._mapId = o.a6(),
                        this._contextLost = I => {
                            I.preventDefault(),
                            this._frameRequest && (this._frameRequest.abort(),
                            this._frameRequest = null),
                            this.fire(new o.l("webglcontextlost",{
                                originalEvent: I
                            }))
                        }
                        ,
                        this._contextRestored = I => {
                            this._setupPainter(),
                            this.resize(),
                            this._update(),
                            this.fire(new o.l("webglcontextrestored",{
                                originalEvent: I
                            }))
                        }
                        ,
                        this._onMapScroll = I => {
                            if (I.target === this._container)
                                return this._container.scrollTop = 0,
                                this._container.scrollLeft = 0,
                                !1
                        }
                        ,
                        this._onWindowOnline = () => {
                            this._update()
                        }
                        ,
                        this._interactive = m.interactive,
                        this._maxTileCacheSize = m.maxTileCacheSize,
                        this._maxTileCacheZoomLevels = m.maxTileCacheZoomLevels,
                        this._canvasContextAttributes = Object.assign({}, m.canvasContextAttributes),
                        this._trackResize = m.trackResize === !0,
                        this._bearingSnap = m.bearingSnap,
                        this._centerClampedToGround = m.centerClampedToGround,
                        this._refreshExpiredTiles = m.refreshExpiredTiles === !0,
                        this._fadeDuration = m.fadeDuration,
                        this._crossSourceCollisions = m.crossSourceCollisions === !0,
                        this._collectResourceTiming = m.collectResourceTiming === !0,
                        this._locale = Object.assign(Object.assign({}, Mc), m.locale),
                        this._clickTolerance = m.clickTolerance,
                        this._overridePixelRatio = m.pixelRatio,
                        this._maxCanvasSize = m.maxCanvasSize,
                        this.transformCameraUpdate = m.transformCameraUpdate,
                        this.cancelPendingTileRequestsWhileZooming = m.cancelPendingTileRequestsWhileZooming === !0,
                        this._imageQueueHandle = ce.addThrottleControl( () => this.isMoving()),
                        this._requestManager = new X(m.transformRequest),
                        typeof m.container == "string") {
                            if (this._container = document.getElementById(m.container),
                            !this._container)
                                throw new Error(`Container '${m.container}' not found.`)
                        } else {
                            if (!(m.container instanceof HTMLElement))
                                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                            this._container = m.container
                        }
                        if (m.maxBounds && this.setMaxBounds(m.maxBounds),
                        this._setupContainer(),
                        this._setupPainter(),
                        this.on("move", () => this._update(!1)),
                        this.on("moveend", () => this._update(!1)),
                        this.on("zoom", () => this._update(!0)),
                        this.on("terrain", () => {
                            this.painter.terrainFacilitator.dirty = !0,
                            this._update(!0)
                        }
                        ),
                        this.once("idle", () => {
                            this._idleTriggered = !0
                        }
                        ),
                        typeof window < "u") {
                            addEventListener("online", this._onWindowOnline, !1);
                            let I = !1;
                            const A = yc(B => {
                                this._trackResize && !this._removed && (this.resize(B),
                                this.redraw())
                            }
                            , 50);
                            this._resizeObserver = new ResizeObserver(B => {
                                I ? A(B) : I = !0
                            }
                            ),
                            this._resizeObserver.observe(this._container)
                        }
                        this.handlers = new Qa(this,m),
                        this._hash = m.hash && new ku(typeof m.hash == "string" && m.hash || void 0).addTo(this),
                        this._hash && this._hash._onHashChange() || (this.jumpTo({
                            center: m.center,
                            elevation: m.elevation,
                            zoom: m.zoom,
                            bearing: m.bearing,
                            pitch: m.pitch,
                            roll: m.roll
                        }),
                        m.bounds && (this.resize(),
                        this.fitBounds(m.bounds, o.e({}, m.fitBoundsOptions, {
                            duration: 0
                        }))));
                        const P = typeof m.style == "string" || ((a = (r = m.style) === null || r === void 0 ? void 0 : r.projection) === null || a === void 0 ? void 0 : a.type) !== "globe";
                        this.resize(null, P),
                        this._localIdeographFontFamily = m.localIdeographFontFamily,
                        this._validateStyle = m.validateStyle,
                        m.style && this.setStyle(m.style, {
                            localIdeographFontFamily: m.localIdeographFontFamily
                        }),
                        m.attributionControl && this.addControl(new Du(typeof m.attributionControl == "boolean" ? void 0 : m.attributionControl)),
                        m.maplibreLogo && this.addControl(new Th, m.logoPosition),
                        this.on("style.load", () => {
                            if (P || this._resizeTransform(),
                            this.transform.unmodified) {
                                const I = o.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                                this.jumpTo(I)
                            }
                        }
                        ),
                        this.on("data", I => {
                            this._update(I.dataType === "style"),
                            this.fire(new o.l(`${I.dataType}data`,I))
                        }
                        ),
                        this.on("dataloading", I => {
                            this.fire(new o.l(`${I.dataType}dataloading`,I))
                        }
                        ),
                        this.on("dataabort", I => {
                            this.fire(new o.l("sourcedataabort",I))
                        }
                        )
                    }
                    _getMapId() {
                        return this._mapId
                    }
                    setGlobalStateProperty(v, r) {
                        return this.style.setGlobalStateProperty(v, r),
                        this._update(!0)
                    }
                    getGlobalState() {
                        return this.style.getGlobalState()
                    }
                    addControl(v, r) {
                        if (r === void 0 && (r = v.getDefaultPosition ? v.getDefaultPosition() : "top-right"),
                        !v || !v.onAdd)
                            return this.fire(new o.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                        const a = v.onAdd(this);
                        this._controls.push(v);
                        const m = this._controlPositions[r];
                        return r.indexOf("bottom") !== -1 ? m.insertBefore(a, m.firstChild) : m.appendChild(a),
                        this
                    }
                    removeControl(v) {
                        if (!v || !v.onRemove)
                            return this.fire(new o.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                        const r = this._controls.indexOf(v);
                        return r > -1 && this._controls.splice(r, 1),
                        v.onRemove(this),
                        this
                    }
                    hasControl(v) {
                        return this._controls.indexOf(v) > -1
                    }
                    calculateCameraOptionsFromTo(v, r, a, m) {
                        return m == null && this.terrain && (m = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom)),
                        super.calculateCameraOptionsFromTo(v, r, a, m)
                    }
                    resize(v, r=!0) {
                        const [a,m] = this._containerDimensions()
                          , y = this._getClampedPixelRatio(a, m);
                        if (this._resizeCanvas(a, m, y),
                        this.painter.resize(a, m, y),
                        this.painter.overLimit()) {
                            const P = this.painter.context.gl;
                            this._maxCanvasSize = [P.drawingBufferWidth, P.drawingBufferHeight];
                            const I = this._getClampedPixelRatio(a, m);
                            this._resizeCanvas(a, m, I),
                            this.painter.resize(a, m, I)
                        }
                        this._resizeTransform(r);
                        const x = !this._moving;
                        return x && (this.stop(),
                        this.fire(new o.l("movestart",v)).fire(new o.l("move",v))),
                        this.fire(new o.l("resize",v)),
                        x && this.fire(new o.l("moveend",v)),
                        this
                    }
                    _resizeTransform(v=!0) {
                        var r;
                        const [a,m] = this._containerDimensions();
                        this.transform.resize(a, m, v),
                        (r = this._requestedCameraState) === null || r === void 0 || r.resize(a, m, v)
                    }
                    _getClampedPixelRatio(v, r) {
                        const {0: a, 1: m} = this._maxCanvasSize
                          , y = this.getPixelRatio()
                          , x = v * y
                          , P = r * y;
                        return Math.min(x > a ? a / x : 1, P > m ? m / P : 1) * y
                    }
                    getPixelRatio() {
                        var v;
                        return (v = this._overridePixelRatio) !== null && v !== void 0 ? v : devicePixelRatio
                    }
                    setPixelRatio(v) {
                        this._overridePixelRatio = v,
                        this.resize()
                    }
                    getBounds() {
                        return this.transform.getBounds()
                    }
                    getMaxBounds() {
                        return this.transform.getMaxBounds()
                    }
                    setMaxBounds(v) {
                        return this.transform.setMaxBounds(ur.convert(v)),
                        this._update()
                    }
                    setMinZoom(v) {
                        if ((v = v ?? -2) >= -2 && v <= this.transform.maxZoom)
                            return this.transform.setMinZoom(v),
                            this._update(),
                            this.getZoom() < v && this.setZoom(v),
                            this;
                        throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
                    }
                    getMinZoom() {
                        return this.transform.minZoom
                    }
                    setMaxZoom(v) {
                        if ((v = v ?? 22) >= this.transform.minZoom)
                            return this.transform.setMaxZoom(v),
                            this._update(),
                            this.getZoom() > v && this.setZoom(v),
                            this;
                        throw new Error("maxZoom must be greater than the current minZoom")
                    }
                    getMaxZoom() {
                        return this.transform.maxZoom
                    }
                    setMinPitch(v) {
                        if ((v = v ?? 0) < 0)
                            throw new Error("minPitch must be greater than or equal to 0");
                        if (v >= 0 && v <= this.transform.maxPitch)
                            return this.transform.setMinPitch(v),
                            this._update(),
                            this.getPitch() < v && this.setPitch(v),
                            this;
                        throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
                    }
                    getMinPitch() {
                        return this.transform.minPitch
                    }
                    setMaxPitch(v) {
                        if ((v = v ?? 60) > 180)
                            throw new Error("maxPitch must be less than or equal to 180");
                        if (v >= this.transform.minPitch)
                            return this.transform.setMaxPitch(v),
                            this._update(),
                            this.getPitch() > v && this.setPitch(v),
                            this;
                        throw new Error("maxPitch must be greater than the current minPitch")
                    }
                    getMaxPitch() {
                        return this.transform.maxPitch
                    }
                    getRenderWorldCopies() {
                        return this.transform.renderWorldCopies
                    }
                    setRenderWorldCopies(v) {
                        return this.transform.setRenderWorldCopies(v),
                        this._update()
                    }
                    project(v) {
                        return this.transform.locationToScreenPoint(o.S.convert(v), this.style && this.terrain)
                    }
                    unproject(v) {
                        return this.transform.screenPointToLocation(o.P.convert(v), this.terrain)
                    }
                    isMoving() {
                        var v;
                        return this._moving || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isMoving())
                    }
                    isZooming() {
                        var v;
                        return this._zooming || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isZooming())
                    }
                    isRotating() {
                        var v;
                        return this._rotating || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isRotating())
                    }
                    _createDelegatedListener(v, r, a) {
                        if (v === "mouseenter" || v === "mouseover") {
                            let m = !1;
                            return {
                                layers: r,
                                listener: a,
                                delegates: {
                                    mousemove: x => {
                                        const P = r.filter(A => this.getLayer(A))
                                          , I = P.length !== 0 ? this.queryRenderedFeatures(x.point, {
                                            layers: P
                                        }) : [];
                                        I.length ? m || (m = !0,
                                        a.call(this, new tn(v,this,x.originalEvent,{
                                            features: I
                                        }))) : m = !1
                                    }
                                    ,
                                    mouseout: () => {
                                        m = !1
                                    }
                                }
                            }
                        }
                        if (v === "mouseleave" || v === "mouseout") {
                            let m = !1;
                            return {
                                layers: r,
                                listener: a,
                                delegates: {
                                    mousemove: P => {
                                        const I = r.filter(A => this.getLayer(A));
                                        (I.length !== 0 ? this.queryRenderedFeatures(P.point, {
                                            layers: I
                                        }) : []).length ? m = !0 : m && (m = !1,
                                        a.call(this, new tn(v,this,P.originalEvent)))
                                    }
                                    ,
                                    mouseout: P => {
                                        m && (m = !1,
                                        a.call(this, new tn(v,this,P.originalEvent)))
                                    }
                                }
                            }
                        }
                        {
                            const m = y => {
                                const x = r.filter(I => this.getLayer(I))
                                  , P = x.length !== 0 ? this.queryRenderedFeatures(y.point, {
                                    layers: x
                                }) : [];
                                P.length && (y.features = P,
                                a.call(this, y),
                                delete y.features)
                            }
                            ;
                            return {
                                layers: r,
                                listener: a,
                                delegates: {
                                    [v]: m
                                }
                            }
                        }
                    }
                    _saveDelegatedListener(v, r) {
                        this._delegatedListeners = this._delegatedListeners || {},
                        this._delegatedListeners[v] = this._delegatedListeners[v] || [],
                        this._delegatedListeners[v].push(r)
                    }
                    _removeDelegatedListener(v, r, a) {
                        if (!this._delegatedListeners || !this._delegatedListeners[v])
                            return;
                        const m = this._delegatedListeners[v];
                        for (let y = 0; y < m.length; y++) {
                            const x = m[y];
                            if (x.listener === a && x.layers.length === r.length && x.layers.every(P => r.includes(P))) {
                                for (const P in x.delegates)
                                    this.off(P, x.delegates[P]);
                                return void m.splice(y, 1)
                            }
                        }
                    }
                    on(v, r, a) {
                        if (a === void 0)
                            return super.on(v, r);
                        const m = typeof r == "string" ? [r] : r
                          , y = this._createDelegatedListener(v, m, a);
                        this._saveDelegatedListener(v, y);
                        for (const x in y.delegates)
                            this.on(x, y.delegates[x]);
                        return {
                            unsubscribe: () => {
                                this._removeDelegatedListener(v, m, a)
                            }
                        }
                    }
                    once(v, r, a) {
                        if (a === void 0)
                            return super.once(v, r);
                        const m = typeof r == "string" ? [r] : r
                          , y = this._createDelegatedListener(v, m, a);
                        for (const x in y.delegates) {
                            const P = y.delegates[x];
                            y.delegates[x] = (...I) => {
                                this._removeDelegatedListener(v, m, a),
                                P(...I)
                            }
                        }
                        this._saveDelegatedListener(v, y);
                        for (const x in y.delegates)
                            this.once(x, y.delegates[x]);
                        return this
                    }
                    off(v, r, a) {
                        return a === void 0 ? super.off(v, r) : (this._removeDelegatedListener(v, typeof r == "string" ? [r] : r, a),
                        this)
                    }
                    queryRenderedFeatures(v, r) {
                        if (!this.style)
                            return [];
                        let a;
                        const m = v instanceof o.P || Array.isArray(v)
                          , y = m ? v : [[0, 0], [this.transform.width, this.transform.height]];
                        if (r = r || (m ? {} : v) || {},
                        y instanceof o.P || typeof y[0] == "number")
                            a = [o.P.convert(y)];
                        else {
                            const x = o.P.convert(y[0])
                              , P = o.P.convert(y[1]);
                            a = [x, new o.P(P.x,x.y), P, new o.P(x.x,P.y), x]
                        }
                        return this.style.queryRenderedFeatures(a, r, this.transform)
                    }
                    querySourceFeatures(v, r) {
                        return this.style.querySourceFeatures(v, r)
                    }
                    setStyle(v, r) {
                        return (r = o.e({}, {
                            localIdeographFontFamily: this._localIdeographFontFamily,
                            validate: this._validateStyle
                        }, r)).diff !== !1 && r.localIdeographFontFamily === this._localIdeographFontFamily && this.style && v ? (this._diffStyle(v, r),
                        this) : (this._localIdeographFontFamily = r.localIdeographFontFamily,
                        this._updateStyle(v, r))
                    }
                    setTransformRequest(v) {
                        return this._requestManager.setTransformRequest(v),
                        this
                    }
                    _getUIString(v) {
                        const r = this._locale[v];
                        if (r == null)
                            throw new Error(`Missing UI string '${v}'`);
                        return r
                    }
                    _updateStyle(v, r) {
                        var a, m;
                        if (r.transformStyle && this.style && !this.style._loaded)
                            return void this.style.once("style.load", () => this._updateStyle(v, r));
                        const y = this.style && r.transformStyle ? this.style.serialize() : void 0;
                        return this.style && (this.style.setEventedParent(null),
                        this.style._remove(!v)),
                        v ? (this.style = new ld(this,r || {}),
                        this.style.setEventedParent(this, {
                            style: this.style
                        }),
                        typeof v == "string" ? this.style.loadURL(v, r, y) : this.style.loadJSON(v, r, y),
                        this) : ((m = (a = this.style) === null || a === void 0 ? void 0 : a.projection) === null || m === void 0 || m.destroy(),
                        delete this.style,
                        this)
                    }
                    _lazyInitEmptyStyle() {
                        this.style || (this.style = new ld(this,{}),
                        this.style.setEventedParent(this, {
                            style: this.style
                        }),
                        this.style.loadEmpty())
                    }
                    _diffStyle(v, r) {
                        if (typeof v == "string") {
                            const a = this._requestManager.transformRequest(v, "Style");
                            o.j(a, new AbortController).then(m => {
                                this._updateDiff(m.data, r)
                            }
                            ).catch(m => {
                                m && this.fire(new o.k(m))
                            }
                            )
                        } else
                            typeof v == "object" && this._updateDiff(v, r)
                    }
                    _updateDiff(v, r) {
                        try {
                            this.style.setState(v, r) && this._update(!0)
                        } catch (a) {
                            o.w(`Unable to perform style diff: ${a.message || a.error || a}.  Rebuilding the style from scratch.`),
                            this._updateStyle(v, r)
                        }
                    }
                    getStyle() {
                        if (this.style)
                            return this.style.serialize()
                    }
                    isStyleLoaded() {
                        return this.style ? this.style.loaded() : o.w("There is no style added to the map.")
                    }
                    addSource(v, r) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addSource(v, r),
                        this._update(!0)
                    }
                    isSourceLoaded(v) {
                        const r = this.style && this.style.sourceCaches[v];
                        if (r !== void 0)
                            return r.loaded();
                        this.fire(new o.k(new Error(`There is no source with ID '${v}'`)))
                    }
                    setTerrain(v) {
                        if (this.style._checkLoaded(),
                        this._terrainDataCallback && this.style.off("data", this._terrainDataCallback),
                        v) {
                            const r = this.style.sourceCaches[v.source];
                            if (!r)
                                throw new Error(`cannot load terrain, because there exists no source with ID: ${v.source}`);
                            this.terrain === null && r.reload();
                            for (const a in this.style._layers) {
                                const m = this.style._layers[a];
                                m.type === "hillshade" && m.source === v.source && o.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."),
                                m.type === "color-relief" && m.source === v.source && o.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
                            }
                            this.terrain = new Qo(this.painter,r,v),
                            this.painter.renderToTexture = new Cr(this.painter,this.terrain),
                            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                            this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                            this._terrainDataCallback = a => {
                                var m;
                                a.dataType === "style" ? this.terrain.sourceCache.freeRtt() : a.dataType === "source" && a.tile && (a.sourceId !== v.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                                this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))),
                                ((m = a.source) === null || m === void 0 ? void 0 : m.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(a.tile.tileID))
                            }
                            ,
                            this.style.on("data", this._terrainDataCallback)
                        } else
                            this.terrain && this.terrain.sourceCache.destruct(),
                            this.terrain = null,
                            this.painter.renderToTexture && this.painter.renderToTexture.destruct(),
                            this.painter.renderToTexture = null,
                            this.transform.setMinElevationForCurrentTile(0),
                            this._centerClampedToGround && this.transform.setElevation(0);
                        return this.fire(new o.l("terrain",{
                            terrain: v
                        })),
                        this
                    }
                    getTerrain() {
                        var v, r;
                        return (r = (v = this.terrain) === null || v === void 0 ? void 0 : v.options) !== null && r !== void 0 ? r : null
                    }
                    areTilesLoaded() {
                        const v = this.style && this.style.sourceCaches;
                        for (const r in v) {
                            const a = v[r]._tiles;
                            for (const m in a) {
                                const y = a[m];
                                if (y.state !== "loaded" && y.state !== "errored")
                                    return !1
                            }
                        }
                        return !0
                    }
                    removeSource(v) {
                        return this.style.removeSource(v),
                        this._update(!0)
                    }
                    getSource(v) {
                        return this.style.getSource(v)
                    }
                    setSourceTileLodParams(v, r, a) {
                        if (a) {
                            const m = this.getSource(a);
                            if (!m)
                                throw new Error(`There is no source with ID "${a}", cannot set LOD parameters`);
                            m.calculateTileZoom = at(Math.max(1, v), Math.max(1, r))
                        } else
                            for (const m in this.style.sourceCaches)
                                this.style.sourceCaches[m].getSource().calculateTileZoom = at(Math.max(1, v), Math.max(1, r));
                        return this._update(!0),
                        this
                    }
                    refreshTiles(v, r) {
                        const a = this.style.sourceCaches[v];
                        if (!a)
                            throw new Error(`There is no source cache with ID "${v}", cannot refresh tile`);
                        r === void 0 ? a.reload(!0) : a.refreshTiles(r.map(m => new o.a3(m.z,m.x,m.y)))
                    }
                    addImage(v, r, a={}) {
                        const {pixelRatio: m=1, sdf: y=!1, stretchX: x, stretchY: P, content: I, textFitWidth: A, textFitHeight: B} = a;
                        if (this._lazyInitEmptyStyle(),
                        !(r instanceof HTMLImageElement || o.b(r))) {
                            if (r.width === void 0 || r.height === void 0)
                                return this.fire(new o.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                            {
                                const {width: $, height: Z, data: H} = r
                                  , Y = r;
                                return this.style.addImage(v, {
                                    data: new o.R({
                                        width: $,
                                        height: Z
                                    },new Uint8Array(H)),
                                    pixelRatio: m,
                                    stretchX: x,
                                    stretchY: P,
                                    content: I,
                                    textFitWidth: A,
                                    textFitHeight: B,
                                    sdf: y,
                                    version: 0,
                                    userImage: Y
                                }),
                                Y.onAdd && Y.onAdd(this, v),
                                this
                            }
                        }
                        {
                            const {width: $, height: Z, data: H} = z.getImageData(r);
                            this.style.addImage(v, {
                                data: new o.R({
                                    width: $,
                                    height: Z
                                },H),
                                pixelRatio: m,
                                stretchX: x,
                                stretchY: P,
                                content: I,
                                textFitWidth: A,
                                textFitHeight: B,
                                sdf: y,
                                version: 0
                            })
                        }
                    }
                    updateImage(v, r) {
                        const a = this.style.getImage(v);
                        if (!a)
                            return this.fire(new o.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                        const m = r instanceof HTMLImageElement || o.b(r) ? z.getImageData(r) : r
                          , {width: y, height: x, data: P} = m;
                        if (y === void 0 || x === void 0)
                            return this.fire(new o.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                        if (y !== a.data.width || x !== a.data.height)
                            return this.fire(new o.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
                        const I = !(r instanceof HTMLImageElement || o.b(r));
                        return a.data.replace(P, I),
                        this.style.updateImage(v, a),
                        this
                    }
                    getImage(v) {
                        return this.style.getImage(v)
                    }
                    hasImage(v) {
                        return v ? !!this.style.getImage(v) : (this.fire(new o.k(new Error("Missing required image id"))),
                        !1)
                    }
                    removeImage(v) {
                        this.style.removeImage(v)
                    }
                    loadImage(v) {
                        return ce.getImage(this._requestManager.transformRequest(v, "Image"), new AbortController)
                    }
                    listImages() {
                        return this.style.listImages()
                    }
                    addLayer(v, r) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addLayer(v, r),
                        this._update(!0)
                    }
                    moveLayer(v, r) {
                        return this.style.moveLayer(v, r),
                        this._update(!0)
                    }
                    removeLayer(v) {
                        return this.style.removeLayer(v),
                        this._update(!0)
                    }
                    getLayer(v) {
                        return this.style.getLayer(v)
                    }
                    getLayersOrder() {
                        return this.style.getLayersOrder()
                    }
                    setLayerZoomRange(v, r, a) {
                        return this.style.setLayerZoomRange(v, r, a),
                        this._update(!0)
                    }
                    setFilter(v, r, a={}) {
                        return this.style.setFilter(v, r, a),
                        this._update(!0)
                    }
                    getFilter(v) {
                        return this.style.getFilter(v)
                    }
                    setPaintProperty(v, r, a, m={}) {
                        return this.style.setPaintProperty(v, r, a, m),
                        this._update(!0)
                    }
                    getPaintProperty(v, r) {
                        return this.style.getPaintProperty(v, r)
                    }
                    setLayoutProperty(v, r, a, m={}) {
                        return this.style.setLayoutProperty(v, r, a, m),
                        this._update(!0)
                    }
                    getLayoutProperty(v, r) {
                        return this.style.getLayoutProperty(v, r)
                    }
                    setGlyphs(v, r={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setGlyphs(v, r),
                        this._update(!0)
                    }
                    getGlyphs() {
                        return this.style.getGlyphsUrl()
                    }
                    addSprite(v, r, a={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addSprite(v, r, a, m => {
                            m || this._update(!0)
                        }
                        ),
                        this
                    }
                    removeSprite(v) {
                        return this._lazyInitEmptyStyle(),
                        this.style.removeSprite(v),
                        this._update(!0)
                    }
                    getSprite() {
                        return this.style.getSprite()
                    }
                    setSprite(v, r={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setSprite(v, r, a => {
                            a || this._update(!0)
                        }
                        ),
                        this
                    }
                    setLight(v, r={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setLight(v, r),
                        this._update(!0)
                    }
                    getLight() {
                        return this.style.getLight()
                    }
                    setSky(v, r={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setSky(v, r),
                        this._update(!0)
                    }
                    getSky() {
                        return this.style.getSky()
                    }
                    setFeatureState(v, r) {
                        return this.style.setFeatureState(v, r),
                        this._update()
                    }
                    removeFeatureState(v, r) {
                        return this.style.removeFeatureState(v, r),
                        this._update()
                    }
                    getFeatureState(v) {
                        return this.style.getFeatureState(v)
                    }
                    getContainer() {
                        return this._container
                    }
                    getCanvasContainer() {
                        return this._canvasContainer
                    }
                    getCanvas() {
                        return this._canvas
                    }
                    _containerDimensions() {
                        let v = 0
                          , r = 0;
                        return this._container && (v = this._container.clientWidth || 400,
                        r = this._container.clientHeight || 300),
                        [v, r]
                    }
                    _setupContainer() {
                        const v = this._container;
                        v.classList.add("maplibregl-map");
                        const r = this._canvasContainer = D.create("div", "maplibregl-canvas-container", v);
                        this._interactive && r.classList.add("maplibregl-interactive"),
                        this._canvas = D.create("canvas", "maplibregl-canvas", r),
                        this._canvas.addEventListener("webglcontextlost", this._contextLost, !1),
                        this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1),
                        this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"),
                        this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")),
                        this._canvas.setAttribute("role", "region");
                        const a = this._containerDimensions()
                          , m = this._getClampedPixelRatio(a[0], a[1]);
                        this._resizeCanvas(a[0], a[1], m);
                        const y = this._controlContainer = D.create("div", "maplibregl-control-container", v)
                          , x = this._controlPositions = {};
                        ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(P => {
                            x[P] = D.create("div", `maplibregl-ctrl-${P} `, y)
                        }
                        ),
                        this._container.addEventListener("scroll", this._onMapScroll, !1)
                    }
                    _resizeCanvas(v, r, a) {
                        this._canvas.width = Math.floor(a * v),
                        this._canvas.height = Math.floor(a * r),
                        this._canvas.style.width = `${v}px`,
                        this._canvas.style.height = `${r}px`
                    }
                    _setupPainter() {
                        const v = Object.assign(Object.assign({}, this._canvasContextAttributes), {
                            alpha: !0,
                            depth: !0,
                            stencil: !0,
                            premultipliedAlpha: !0
                        });
                        let r = null;
                        this._canvas.addEventListener("webglcontextcreationerror", m => {
                            r = {
                                requestedAttributes: v
                            },
                            m && (r.statusMessage = m.statusMessage,
                            r.type = m.type)
                        }
                        , {
                            once: !0
                        });
                        let a = null;
                        if (a = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, v) : this._canvas.getContext("webgl2", v) || this._canvas.getContext("webgl", v),
                        !a) {
                            const m = "Failed to initialize WebGL";
                            throw r ? (r.message = m,
                            new Error(JSON.stringify(r))) : new Error(m)
                        }
                        this.painter = new gi(a,this.transform),
                        N.testSupport(a)
                    }
                    migrateProjection(v, r) {
                        super.migrateProjection(v, r),
                        this.painter.transform = v,
                        this.fire(new o.l("projectiontransition",{
                            newProjection: this.style.projection.name
                        }))
                    }
                    loaded() {
                        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
                    }
                    _update(v) {
                        return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || v,
                        this._sourcesDirty = !0,
                        this.triggerRepaint(),
                        this) : this
                    }
                    _requestRenderFrame(v) {
                        return this._update(),
                        this._renderTaskQueue.add(v)
                    }
                    _cancelRenderFrame(v) {
                        this._renderTaskQueue.remove(v)
                    }
                    _render(v) {
                        var r, a, m, y, x;
                        const P = this._idleTriggered ? this._fadeDuration : 0
                          , I = ((r = this.style.projection) === null || r === void 0 ? void 0 : r.transitionState) > 0;
                        if (this.painter.context.setDirty(),
                        this.painter.setBaseState(),
                        this._renderTaskQueue.run(v),
                        this._removed)
                            return;
                        let A = !1;
                        if (this.style && this._styleDirty) {
                            this._styleDirty = !1;
                            const Z = this.transform.zoom
                              , H = z.now();
                            this.style.zoomHistory.update(Z, H);
                            const Y = new o.F(Z,{
                                now: H,
                                fadeDuration: P,
                                zoomHistory: this.style.zoomHistory,
                                transition: this.style.getTransition(),
                                globalState: this.style.getGlobalState()
                            })
                              , ae = Y.crossFadingFactor();
                            ae === 1 && ae === this._crossFadingFactor || (A = !0,
                            this._crossFadingFactor = ae),
                            this.style.update(Y)
                        }
                        const B = ((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0 !== I;
                        (m = this.style.projection) === null || m === void 0 || m.setErrorQueryLatitudeDegrees(this.transform.center.lat),
                        this.transform.setTransitionState((y = this.style.projection) === null || y === void 0 ? void 0 : y.transitionState, (x = this.style.projection) === null || x === void 0 ? void 0 : x.latitudeErrorCorrectionRadians),
                        this.style && (this._sourcesDirty || B) && (this._sourcesDirty = !1,
                        this.style._updateSources(this.transform)),
                        this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain),
                        this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                        !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0),
                        this._centerClampedToGround && this.transform.setElevation(0)),
                        this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, P, this._crossSourceCollisions, B),
                        this.painter.render(this.style, {
                            showTileBoundaries: this.showTileBoundaries,
                            showOverdrawInspector: this._showOverdrawInspector,
                            rotating: this.isRotating(),
                            zooming: this.isZooming(),
                            moving: this.isMoving(),
                            fadeDuration: P,
                            showPadding: this.showPadding
                        }),
                        this.fire(new o.l("render")),
                        this.loaded() && !this._loaded && (this._loaded = !0,
                        o.cv.mark(o.cw.load),
                        this.fire(new o.l("load"))),
                        this.style && (this.style.hasTransitions() || A) && (this._styleDirty = !0),
                        this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
                        const $ = this._sourcesDirty || this._styleDirty || this._placementDirty;
                        return $ || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.l("idle")),
                        !this._loaded || this._fullyLoaded || $ || (this._fullyLoaded = !0,
                        o.cv.mark(o.cw.fullLoad)),
                        this
                    }
                    redraw() {
                        return this.style && (this._frameRequest && (this._frameRequest.abort(),
                        this._frameRequest = null),
                        this._render(0)),
                        this
                    }
                    remove() {
                        var v;
                        this._hash && this._hash.remove();
                        for (const a of this._controls)
                            a.onRemove(this);
                        this._controls = [],
                        this._frameRequest && (this._frameRequest.abort(),
                        this._frameRequest = null),
                        this._renderTaskQueue.clear(),
                        this.painter.destroy(),
                        this.handlers.destroy(),
                        delete this.handlers,
                        this.setStyle(null),
                        typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1),
                        ce.removeThrottleControl(this._imageQueueHandle),
                        (v = this._resizeObserver) === null || v === void 0 || v.disconnect();
                        const r = this.painter.context.gl.getExtension("WEBGL_lose_context");
                        r?.loseContext && r.loseContext(),
                        this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1),
                        this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1),
                        D.remove(this._canvasContainer),
                        D.remove(this._controlContainer),
                        this._container.removeEventListener("scroll", this._onMapScroll, !1),
                        this._container.classList.remove("maplibregl-map"),
                        o.cv.clearMetrics(),
                        this._removed = !0,
                        this.fire(new o.l("remove"))
                    }
                    triggerRepaint() {
                        this.style && !this._frameRequest && (this._frameRequest = new AbortController,
                        z.frame(this._frameRequest, v => {
                            o.cv.frame(v),
                            this._frameRequest = null;
                            try {
                                this._render(v)
                            } catch (r) {
                                if (!o.cx(r) && !function(a) {
                                    return a.message === xd
                                }(r))
                                    throw r
                            }
                        }
                        , () => {}
                        ))
                    }
                    get showTileBoundaries() {
                        return !!this._showTileBoundaries
                    }
                    set showTileBoundaries(v) {
                        this._showTileBoundaries !== v && (this._showTileBoundaries = v,
                        this._update())
                    }
                    get showPadding() {
                        return !!this._showPadding
                    }
                    set showPadding(v) {
                        this._showPadding !== v && (this._showPadding = v,
                        this._update())
                    }
                    get showCollisionBoxes() {
                        return !!this._showCollisionBoxes
                    }
                    set showCollisionBoxes(v) {
                        this._showCollisionBoxes !== v && (this._showCollisionBoxes = v,
                        v ? this.style._generateCollisionBoxes() : this._update())
                    }
                    get showOverdrawInspector() {
                        return !!this._showOverdrawInspector
                    }
                    set showOverdrawInspector(v) {
                        this._showOverdrawInspector !== v && (this._showOverdrawInspector = v,
                        this._update())
                    }
                    get repaint() {
                        return !!this._repaint
                    }
                    set repaint(v) {
                        this._repaint !== v && (this._repaint = v,
                        this.triggerRepaint())
                    }
                    get vertices() {
                        return !!this._vertices
                    }
                    set vertices(v) {
                        this._vertices = v,
                        this._update()
                    }
                    get version() {
                        return Lu
                    }
                    getCameraTargetElevation() {
                        return this.transform.elevation
                    }
                    getProjection() {
                        return this.style.getProjection()
                    }
                    setProjection(v) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setProjection(v),
                        this._update(!0)
                    }
                }
                ,
                f.MapMouseEvent = tn,
                f.MapTouchEvent = Ri,
                f.MapWheelEvent = Ai,
                f.Marker = Yn,
                f.NavigationControl = class {
                    constructor(v) {
                        this._updateZoomButtons = () => {
                            const r = this._map.getZoom()
                              , a = r === this._map.getMaxZoom()
                              , m = r === this._map.getMinZoom();
                            this._zoomInButton.disabled = a,
                            this._zoomOutButton.disabled = m,
                            this._zoomInButton.setAttribute("aria-disabled", a.toString()),
                            this._zoomOutButton.setAttribute("aria-disabled", m.toString())
                        }
                        ,
                        this._rotateCompassArrow = () => {
                            this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
                        }
                        ,
                        this._setButtonTitle = (r, a) => {
                            const m = this._map._getUIString(`NavigationControl.${a}`);
                            r.title = m,
                            r.setAttribute("aria-label", m)
                        }
                        ,
                        this.options = o.e({}, Vn, v),
                        this._container = D.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._container.addEventListener("contextmenu", r => r.preventDefault()),
                        this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", r => this._map.zoomIn({}, {
                            originalEvent: r
                        })),
                        D.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"),
                        this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", r => this._map.zoomOut({}, {
                            originalEvent: r
                        })),
                        D.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")),
                        this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", r => {
                            this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                                originalEvent: r
                            }) : this._map.resetNorth({}, {
                                originalEvent: r
                            })
                        }
                        ),
                        this._compassIcon = D.create("span", "maplibregl-ctrl-icon", this._compass),
                        this._compassIcon.setAttribute("aria-hidden", "true"))
                    }
                    onAdd(v) {
                        return this._map = v,
                        this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                        this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                        this._map.on("zoom", this._updateZoomButtons),
                        this._updateZoomButtons()),
                        this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"),
                        this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow),
                        this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow),
                        this._map.on("rotate", this._rotateCompassArrow),
                        this._rotateCompassArrow(),
                        this._handler = new el(this._map,this._compass,this.options.visualizePitch)),
                        this._container
                    }
                    onRemove() {
                        D.remove(this._container),
                        this.options.showZoom && this._map.off("zoom", this._updateZoomButtons),
                        this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow),
                        this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow),
                        this._map.off("rotate", this._rotateCompassArrow),
                        this._handler.off(),
                        delete this._handler),
                        delete this._map
                    }
                    _createButton(v, r) {
                        const a = D.create("button", v, this._container);
                        return a.type = "button",
                        a.addEventListener("click", r),
                        a
                    }
                }
                ,
                f.Popup = class extends o.E {
                    constructor(v) {
                        super(),
                        this._updateOpacity = () => {
                            this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
                        }
                        ,
                        this.remove = () => (this._content && D.remove(this._content),
                        this._container && (D.remove(this._container),
                        delete this._container),
                        this._map && (this._map.off("move", this._update),
                        this._map.off("move", this._onClose),
                        this._map.off("click", this._onClose),
                        this._map.off("remove", this.remove),
                        this._map.off("mousemove", this._onMouseMove),
                        this._map.off("mouseup", this._onMouseUp),
                        this._map.off("drag", this._onDrag),
                        this._map._canvasContainer.classList.remove("maplibregl-track-pointer"),
                        delete this._map,
                        this.fire(new o.l("close"))),
                        this),
                        this._onMouseUp = r => {
                            this._update(r.point)
                        }
                        ,
                        this._onMouseMove = r => {
                            this._update(r.point)
                        }
                        ,
                        this._onDrag = r => {
                            this._update(r.point)
                        }
                        ,
                        this._update = r => {
                            if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
                                return;
                            if (!this._container) {
                                if (this._container = D.create("div", "maplibregl-popup", this._map.getContainer()),
                                this._tip = D.create("div", "maplibregl-popup-tip", this._container),
                                this._container.appendChild(this._content),
                                this.options.className)
                                    for (const P of this.options.className.split(" "))
                                        this._container.classList.add(P);
                                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")),
                                this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
                            }
                            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth),
                            this._lngLat = Id(this._lngLat, this._flatPos, this._map.transform, this._trackPointer),
                            this._trackPointer && !r)
                                return;
                            const a = this._flatPos = this._pos = this._trackPointer && r ? r : this._map.project(this._lngLat);
                            this._map.terrain && (this._flatPos = this._trackPointer && r ? r : this._map.transform.locationToScreenPoint(this._lngLat));
                            let m = this.options.anchor;
                            const y = Jo(this.options.offset);
                            if (!m) {
                                const P = this._container.offsetWidth
                                  , I = this._container.offsetHeight;
                                let A;
                                A = a.y + y.bottom.y < I ? ["top"] : a.y > this._map.transform.height - I ? ["bottom"] : [],
                                a.x < P / 2 ? A.push("left") : a.x > this._map.transform.width - P / 2 && A.push("right"),
                                m = A.length === 0 ? "bottom" : A.join("-")
                            }
                            let x = a.add(y[m]);
                            this.options.subpixelPositioning || (x = x.round()),
                            D.setTransform(this._container, `${xo[m]} translate(${x.x}px,${x.y}px)`),
                            _n(this._container, m, "popup"),
                            this._updateOpacity()
                        }
                        ,
                        this._onClose = () => {
                            this.remove()
                        }
                        ,
                        this.options = o.e(Object.create(Ec), v)
                    }
                    addTo(v) {
                        return this._map && this.remove(),
                        this._map = v,
                        this.options.closeOnClick && this._map.on("click", this._onClose),
                        this.options.closeOnMove && this._map.on("move", this._onClose),
                        this._map.on("remove", this.remove),
                        this._update(),
                        this._focusFirstElement(),
                        this._trackPointer ? (this._map.on("mousemove", this._onMouseMove),
                        this._map.on("mouseup", this._onMouseUp),
                        this._container && this._container.classList.add("maplibregl-popup-track-pointer"),
                        this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update),
                        this.fire(new o.l("open")),
                        this
                    }
                    isOpen() {
                        return !!this._map
                    }
                    getLngLat() {
                        return this._lngLat
                    }
                    setLngLat(v) {
                        return this._lngLat = o.S.convert(v),
                        this._pos = null,
                        this._flatPos = null,
                        this._trackPointer = !1,
                        this._update(),
                        this._map && (this._map.on("move", this._update),
                        this._map.off("mousemove", this._onMouseMove),
                        this._container && this._container.classList.remove("maplibregl-popup-track-pointer"),
                        this._map._canvasContainer.classList.remove("maplibregl-track-pointer")),
                        this
                    }
                    trackPointer() {
                        return this._trackPointer = !0,
                        this._pos = null,
                        this._flatPos = null,
                        this._update(),
                        this._map && (this._map.off("move", this._update),
                        this._map.on("mousemove", this._onMouseMove),
                        this._map.on("drag", this._onDrag),
                        this._container && this._container.classList.add("maplibregl-popup-track-pointer"),
                        this._map._canvasContainer.classList.add("maplibregl-track-pointer")),
                        this
                    }
                    getElement() {
                        return this._container
                    }
                    setText(v) {
                        return this.setDOMContent(document.createTextNode(v))
                    }
                    setHTML(v) {
                        const r = document.createDocumentFragment()
                          , a = document.createElement("body");
                        let m;
                        for (a.innerHTML = v; m = a.firstChild,
                        m; )
                            r.appendChild(m);
                        return this.setDOMContent(r)
                    }
                    getMaxWidth() {
                        var v;
                        return (v = this._container) === null || v === void 0 ? void 0 : v.style.maxWidth
                    }
                    setMaxWidth(v) {
                        return this.options.maxWidth = v,
                        this._update(),
                        this
                    }
                    setDOMContent(v) {
                        if (this._content)
                            for (; this._content.hasChildNodes(); )
                                this._content.firstChild && this._content.removeChild(this._content.firstChild);
                        else
                            this._content = D.create("div", "maplibregl-popup-content", this._container);
                        return this._content.appendChild(v),
                        this._createCloseButton(),
                        this._update(),
                        this._focusFirstElement(),
                        this
                    }
                    addClassName(v) {
                        return this._container && this._container.classList.add(v),
                        this
                    }
                    removeClassName(v) {
                        return this._container && this._container.classList.remove(v),
                        this
                    }
                    setOffset(v) {
                        return this.options.offset = v,
                        this._update(),
                        this
                    }
                    toggleClassName(v) {
                        if (this._container)
                            return this._container.classList.toggle(v)
                    }
                    setSubpixelPositioning(v) {
                        this.options.subpixelPositioning = v
                    }
                    _createCloseButton() {
                        this.options.closeButton && (this._closeButton = D.create("button", "maplibregl-popup-close-button", this._content),
                        this._closeButton.type = "button",
                        this._closeButton.innerHTML = "&#215;",
                        this._closeButton.addEventListener("click", this._onClose))
                    }
                    _focusFirstElement() {
                        if (!this.options.focusAfterOpen || !this._container)
                            return;
                        const v = this._container.querySelector(Nl);
                        v && v.focus()
                    }
                }
                ,
                f.RasterDEMTileSource = Zr,
                f.RasterTileSource = hn,
                f.ScaleControl = class {
                    constructor(v) {
                        this._onMove = () => {
                            Ou(this._map, this._container, this.options)
                        }
                        ,
                        this.setUnit = r => {
                            this.options.unit = r,
                            Ou(this._map, this._container, this.options)
                        }
                        ,
                        this.options = Object.assign(Object.assign({}, kc), v)
                    }
                    getDefaultPosition() {
                        return "bottom-left"
                    }
                    onAdd(v) {
                        return this._map = v,
                        this._container = D.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", v.getContainer()),
                        this._map.on("move", this._onMove),
                        this._onMove(),
                        this._container
                    }
                    onRemove() {
                        D.remove(this._container),
                        this._map.off("move", this._onMove),
                        this._map = void 0
                    }
                }
                ,
                f.ScrollZoomHandler = Xn,
                f.Style = ld,
                f.TerrainControl = class {
                    constructor(v) {
                        this._toggleTerrain = () => {
                            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options),
                            this._updateTerrainIcon()
                        }
                        ,
                        this._updateTerrainIcon = () => {
                            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"),
                            this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"),
                            this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"),
                            this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"),
                            this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
                        }
                        ,
                        this.options = v
                    }
                    onAdd(v) {
                        return this._map = v,
                        this._container = D.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._terrainButton = D.create("button", "maplibregl-ctrl-terrain", this._container),
                        D.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"),
                        this._terrainButton.type = "button",
                        this._terrainButton.addEventListener("click", this._toggleTerrain),
                        this._updateTerrainIcon(),
                        this._map.on("terrain", this._updateTerrainIcon),
                        this._container
                    }
                    onRemove() {
                        D.remove(this._container),
                        this._map.off("terrain", this._updateTerrainIcon),
                        this._map = void 0
                    }
                }
                ,
                f.TwoFingersTouchPitchHandler = fa,
                f.TwoFingersTouchRotateHandler = Es,
                f.TwoFingersTouchZoomHandler = hi,
                f.TwoFingersTouchZoomRotateHandler = Ch,
                f.VectorTileSource = gr,
                f.VideoSource = zr,
                f.addSourceType = (v, r) => o._(void 0, void 0, void 0, function*() {
                    if (Dn(v))
                        throw new Error(`A source type called "${v}" already exists.`);
                    ( (a, m) => {
                        $n[a] = m
                    }
                    )(v, r)
                }),
                f.clearPrewarmedResources = function() {
                    const v = Nt;
                    v && (v.isPreloaded() && v.numActive() === 1 ? (v.release(Pt),
                    Nt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
                }
                ,
                f.createTileMesh = sc,
                f.getMaxParallelImageRequests = function() {
                    return o.a.MAX_PARALLEL_IMAGE_REQUESTS
                }
                ,
                f.getRTLTextPluginStatus = function() {
                    return sn().getRTLTextPluginStatus()
                }
                ,
                f.getVersion = function() {
                    return $l
                }
                ,
                f.getWorkerCount = function() {
                    return We.workerCount
                }
                ,
                f.getWorkerUrl = function() {
                    return o.a.WORKER_URL
                }
                ,
                f.importScriptInWorkers = function(v) {
                    return tr().broadcast("IS", v)
                }
                ,
                f.prewarm = function() {
                    Qt().acquire(Pt)
                }
                ,
                f.setMaxParallelImageRequests = function(v) {
                    o.a.MAX_PARALLEL_IMAGE_REQUESTS = v
                }
                ,
                f.setRTLTextPlugin = function(v, r) {
                    return sn().setRTLTextPlugin(v, r)
                }
                ,
                f.setWorkerCount = function(v) {
                    We.workerCount = v
                }
                ,
                f.setWorkerUrl = function(v) {
                    o.a.WORKER_URL = v
                }
            });
            var d = i;
            return d
        })
    }(R_)),
    R_.exports
}
var Ea = ck();
const uk = Ni(Ea)
  , hk = fC({
    __proto__: null,
    default: uk
}, [Ea]);
var Xy = {}
  , a0 = {
    exports: {}
}
  , ea = {}
  , l0 = {
    exports: {}
}
  , c0 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var y1;
function dk() {
    return y1 || (y1 = 1,
    function(e) {
        function t(je, lt) {
            var Pt = je.length;
            je.push(lt);
            e: for (; 0 < Pt; ) {
                var We = Pt - 1 >>> 1
                  , st = je[We];
                if (0 < u(st, lt))
                    je[We] = lt,
                    je[Pt] = st,
                    Pt = We;
                else
                    break e
            }
        }
        function i(je) {
            return je.length === 0 ? null : je[0]
        }
        function s(je) {
            if (je.length === 0)
                return null;
            var lt = je[0]
              , Pt = je.pop();
            if (Pt !== lt) {
                je[0] = Pt;
                e: for (var We = 0, st = je.length, Nt = st >>> 1; We < Nt; ) {
                    var zt = 2 * (We + 1) - 1
                      , Qt = je[zt]
                      , Wt = zt + 1
                      , tr = je[Wt];
                    if (0 > u(Qt, Pt))
                        Wt < st && 0 > u(tr, Qt) ? (je[We] = tr,
                        je[Wt] = Pt,
                        We = Wt) : (je[We] = Qt,
                        je[zt] = Pt,
                        We = zt);
                    else if (Wt < st && 0 > u(tr, Pt))
                        je[We] = tr,
                        je[Wt] = Pt,
                        We = Wt;
                    else
                        break e
                }
            }
            return lt
        }
        function u(je, lt) {
            var Pt = je.sortIndex - lt.sortIndex;
            return Pt !== 0 ? Pt : je.id - lt.id
        }
        if (typeof performance == "object" && typeof performance.now == "function") {
            var d = performance;
            e.unstable_now = function() {
                return d.now()
            }
        } else {
            var f = Date
              , o = f.now();
            e.unstable_now = function() {
                return f.now() - o
            }
        }
        var w = []
          , T = []
          , k = 1
          , L = null
          , z = 3
          , D = !1
          , N = !1
          , U = !1
          , V = typeof setTimeout == "function" ? setTimeout : null
          , re = typeof clearTimeout == "function" ? clearTimeout : null
          , ie = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function ue(je) {
            for (var lt = i(T); lt !== null; ) {
                if (lt.callback === null)
                    s(T);
                else if (lt.startTime <= je)
                    s(T),
                    lt.sortIndex = lt.expirationTime,
                    t(w, lt);
                else
                    break;
                lt = i(T)
            }
        }
        function ce(je) {
            if (U = !1,
            ue(je),
            !N)
                if (i(w) !== null)
                    N = !0,
                    ve(X);
                else {
                    var lt = i(T);
                    lt !== null && Ne(ce, lt.startTime - je)
                }
        }
        function X(je, lt) {
            N = !1,
            U && (U = !1,
            re(be),
            be = -1),
            D = !0;
            var Pt = z;
            try {
                for (ue(lt),
                L = i(w); L !== null && (!(L.expirationTime > lt) || je && !He()); ) {
                    var We = L.callback;
                    if (typeof We == "function") {
                        L.callback = null,
                        z = L.priorityLevel;
                        var st = We(L.expirationTime <= lt);
                        lt = e.unstable_now(),
                        typeof st == "function" ? L.callback = st : L === i(w) && s(w),
                        ue(lt)
                    } else
                        s(w);
                    L = i(w)
                }
                if (L !== null)
                    var Nt = !0;
                else {
                    var zt = i(T);
                    zt !== null && Ne(ce, zt.startTime - lt),
                    Nt = !1
                }
                return Nt
            } finally {
                L = null,
                z = Pt,
                D = !1
            }
        }
        var me = !1
          , K = null
          , be = -1
          , Ee = 5
          , Ce = -1;
        function He() {
            return !(e.unstable_now() - Ce < Ee)
        }
        function ct() {
            if (K !== null) {
                var je = e.unstable_now();
                Ce = je;
                var lt = !0;
                try {
                    lt = K(!0, je)
                } finally {
                    lt ? nt() : (me = !1,
                    K = null)
                }
            } else
                me = !1
        }
        var nt;
        if (typeof ie == "function")
            nt = function() {
                ie(ct)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var J = new MessageChannel
              , he = J.port2;
            J.port1.onmessage = ct,
            nt = function() {
                he.postMessage(null)
            }
        } else
            nt = function() {
                V(ct, 0)
            }
            ;
        function ve(je) {
            K = je,
            me || (me = !0,
            nt())
        }
        function Ne(je, lt) {
            be = V(function() {
                je(e.unstable_now())
            }, lt)
        }
        e.unstable_IdlePriority = 5,
        e.unstable_ImmediatePriority = 1,
        e.unstable_LowPriority = 4,
        e.unstable_NormalPriority = 3,
        e.unstable_Profiling = null,
        e.unstable_UserBlockingPriority = 2,
        e.unstable_cancelCallback = function(je) {
            je.callback = null
        }
        ,
        e.unstable_continueExecution = function() {
            N || D || (N = !0,
            ve(X))
        }
        ,
        e.unstable_forceFrameRate = function(je) {
            0 > je || 125 < je ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Ee = 0 < je ? Math.floor(1e3 / je) : 5
        }
        ,
        e.unstable_getCurrentPriorityLevel = function() {
            return z
        }
        ,
        e.unstable_getFirstCallbackNode = function() {
            return i(w)
        }
        ,
        e.unstable_next = function(je) {
            switch (z) {
            case 1:
            case 2:
            case 3:
                var lt = 3;
                break;
            default:
                lt = z
            }
            var Pt = z;
            z = lt;
            try {
                return je()
            } finally {
                z = Pt
            }
        }
        ,
        e.unstable_pauseExecution = function() {}
        ,
        e.unstable_requestPaint = function() {}
        ,
        e.unstable_runWithPriority = function(je, lt) {
            switch (je) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                je = 3
            }
            var Pt = z;
            z = je;
            try {
                return lt()
            } finally {
                z = Pt
            }
        }
        ,
        e.unstable_scheduleCallback = function(je, lt, Pt) {
            var We = e.unstable_now();
            switch (typeof Pt == "object" && Pt !== null ? (Pt = Pt.delay,
            Pt = typeof Pt == "number" && 0 < Pt ? We + Pt : We) : Pt = We,
            je) {
            case 1:
                var st = -1;
                break;
            case 2:
                st = 250;
                break;
            case 5:
                st = 1073741823;
                break;
            case 4:
                st = 1e4;
                break;
            default:
                st = 5e3
            }
            return st = Pt + st,
            je = {
                id: k++,
                callback: lt,
                priorityLevel: je,
                startTime: Pt,
                expirationTime: st,
                sortIndex: -1
            },
            Pt > We ? (je.sortIndex = Pt,
            t(T, je),
            i(w) === null && je === i(T) && (U ? (re(be),
            be = -1) : U = !0,
            Ne(ce, Pt - We))) : (je.sortIndex = st,
            t(w, je),
            N || D || (N = !0,
            ve(X))),
            je
        }
        ,
        e.unstable_shouldYield = He,
        e.unstable_wrapCallback = function(je) {
            var lt = z;
            return function() {
                var Pt = z;
                z = lt;
                try {
                    return je.apply(this, arguments)
                } finally {
                    z = Pt
                }
            }
        }
    }(c0)),
    c0
}
var _1;
function fk() {
    return _1 || (_1 = 1,
    l0.exports = dk()),
    l0.exports
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var v1;
function pk() {
    if (v1)
        return ea;
    v1 = 1;
    var e = iy()
      , t = fk();
    function i(h) {
        for (var g = "https://reactjs.org/docs/error-decoder.html?invariant=" + h, S = 1; S < arguments.length; S++)
            g += "&args[]=" + encodeURIComponent(arguments[S]);
        return "Minified React error #" + h + "; visit " + g + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var s = new Set
      , u = {};
    function d(h, g) {
        f(h, g),
        f(h + "Capture", g)
    }
    function f(h, g) {
        for (u[h] = g,
        h = 0; h < g.length; h++)
            s.add(g[h])
    }
    var o = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
      , w = Object.prototype.hasOwnProperty
      , T = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
      , k = {}
      , L = {};
    function z(h) {
        return w.call(L, h) ? !0 : w.call(k, h) ? !1 : T.test(h) ? L[h] = !0 : (k[h] = !0,
        !1)
    }
    function D(h, g, S, E) {
        if (S !== null && S.type === 0)
            return !1;
        switch (typeof g) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return E ? !1 : S !== null ? !S.acceptsBooleans : (h = h.toLowerCase().slice(0, 5),
            h !== "data-" && h !== "aria-");
        default:
            return !1
        }
    }
    function N(h, g, S, E) {
        if (g === null || typeof g > "u" || D(h, g, S, E))
            return !0;
        if (E)
            return !1;
        if (S !== null)
            switch (S.type) {
            case 3:
                return !g;
            case 4:
                return g === !1;
            case 5:
                return isNaN(g);
            case 6:
                return isNaN(g) || 1 > g
            }
        return !1
    }
    function U(h, g, S, E, F, W, pe) {
        this.acceptsBooleans = g === 2 || g === 3 || g === 4,
        this.attributeName = E,
        this.attributeNamespace = F,
        this.mustUseProperty = S,
        this.propertyName = h,
        this.type = g,
        this.sanitizeURL = W,
        this.removeEmptyString = pe
    }
    var V = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(h) {
        V[h] = new U(h,0,!1,h,null,!1,!1)
    }),
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(h) {
        var g = h[0];
        V[g] = new U(g,1,!1,h[1],null,!1,!1)
    }),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(h) {
        V[h] = new U(h,2,!1,h.toLowerCase(),null,!1,!1)
    }),
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(h) {
        V[h] = new U(h,2,!1,h,null,!1,!1)
    }),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(h) {
        V[h] = new U(h,3,!1,h.toLowerCase(),null,!1,!1)
    }),
    ["checked", "multiple", "muted", "selected"].forEach(function(h) {
        V[h] = new U(h,3,!0,h,null,!1,!1)
    }),
    ["capture", "download"].forEach(function(h) {
        V[h] = new U(h,4,!1,h,null,!1,!1)
    }),
    ["cols", "rows", "size", "span"].forEach(function(h) {
        V[h] = new U(h,6,!1,h,null,!1,!1)
    }),
    ["rowSpan", "start"].forEach(function(h) {
        V[h] = new U(h,5,!1,h.toLowerCase(),null,!1,!1)
    });
    var re = /[\-:]([a-z])/g;
    function ie(h) {
        return h[1].toUpperCase()
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(h) {
        var g = h.replace(re, ie);
        V[g] = new U(g,1,!1,h,null,!1,!1)
    }),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(h) {
        var g = h.replace(re, ie);
        V[g] = new U(g,1,!1,h,"http://www.w3.org/1999/xlink",!1,!1)
    }),
    ["xml:base", "xml:lang", "xml:space"].forEach(function(h) {
        var g = h.replace(re, ie);
        V[g] = new U(g,1,!1,h,"http://www.w3.org/XML/1998/namespace",!1,!1)
    }),
    ["tabIndex", "crossOrigin"].forEach(function(h) {
        V[h] = new U(h,1,!1,h.toLowerCase(),null,!1,!1)
    }),
    V.xlinkHref = new U("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),
    ["src", "href", "action", "formAction"].forEach(function(h) {
        V[h] = new U(h,1,!1,h.toLowerCase(),null,!0,!0)
    });
    function ue(h, g, S, E) {
        var F = V.hasOwnProperty(g) ? V[g] : null;
        (F !== null ? F.type !== 0 : E || !(2 < g.length) || g[0] !== "o" && g[0] !== "O" || g[1] !== "n" && g[1] !== "N") && (N(g, S, F, E) && (S = null),
        E || F === null ? z(g) && (S === null ? h.removeAttribute(g) : h.setAttribute(g, "" + S)) : F.mustUseProperty ? h[F.propertyName] = S === null ? F.type === 3 ? !1 : "" : S : (g = F.attributeName,
        E = F.attributeNamespace,
        S === null ? h.removeAttribute(g) : (F = F.type,
        S = F === 3 || F === 4 && S === !0 ? "" : "" + S,
        E ? h.setAttributeNS(E, g, S) : h.setAttribute(g, S))))
    }
    var ce = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      , X = Symbol.for("react.element")
      , me = Symbol.for("react.portal")
      , K = Symbol.for("react.fragment")
      , be = Symbol.for("react.strict_mode")
      , Ee = Symbol.for("react.profiler")
      , Ce = Symbol.for("react.provider")
      , He = Symbol.for("react.context")
      , ct = Symbol.for("react.forward_ref")
      , nt = Symbol.for("react.suspense")
      , J = Symbol.for("react.suspense_list")
      , he = Symbol.for("react.memo")
      , ve = Symbol.for("react.lazy")
      , Ne = Symbol.for("react.offscreen")
      , je = Symbol.iterator;
    function lt(h) {
        return h === null || typeof h != "object" ? null : (h = je && h[je] || h["@@iterator"],
        typeof h == "function" ? h : null)
    }
    var Pt = Object.assign, We;
    function st(h) {
        if (We === void 0)
            try {
                throw Error()
            } catch (S) {
                var g = S.stack.trim().match(/\n( *(at )?)/);
                We = g && g[1] || ""
            }
        return `
` + We + h
    }
    var Nt = !1;
    function zt(h, g) {
        if (!h || Nt)
            return "";
        Nt = !0;
        var S = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (g)
                if (g = function() {
                    throw Error()
                }
                ,
                Object.defineProperty(g.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }),
                typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(g, [])
                    } catch (xt) {
                        var E = xt
                    }
                    Reflect.construct(h, [], g)
                } else {
                    try {
                        g.call()
                    } catch (xt) {
                        E = xt
                    }
                    h.call(g.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (xt) {
                    E = xt
                }
                h()
            }
        } catch (xt) {
            if (xt && E && typeof xt.stack == "string") {
                for (var F = xt.stack.split(`
`), W = E.stack.split(`
`), pe = F.length - 1, Fe = W.length - 1; 1 <= pe && 0 <= Fe && F[pe] !== W[Fe]; )
                    Fe--;
                for (; 1 <= pe && 0 <= Fe; pe--,
                Fe--)
                    if (F[pe] !== W[Fe]) {
                        if (pe !== 1 || Fe !== 1)
                            do
                                if (pe--,
                                Fe--,
                                0 > Fe || F[pe] !== W[Fe]) {
                                    var Je = `
` + F[pe].replace(" at new ", " at ");
                                    return h.displayName && Je.includes("<anonymous>") && (Je = Je.replace("<anonymous>", h.displayName)),
                                    Je
                                }
                            while (1 <= pe && 0 <= Fe);
                        break
                    }
            }
        } finally {
            Nt = !1,
            Error.prepareStackTrace = S
        }
        return (h = h ? h.displayName || h.name : "") ? st(h) : ""
    }
    function Qt(h) {
        switch (h.tag) {
        case 5:
            return st(h.type);
        case 16:
            return st("Lazy");
        case 13:
            return st("Suspense");
        case 19:
            return st("SuspenseList");
        case 0:
        case 2:
        case 15:
            return h = zt(h.type, !1),
            h;
        case 11:
            return h = zt(h.type.render, !1),
            h;
        case 1:
            return h = zt(h.type, !0),
            h;
        default:
            return ""
        }
    }
    function Wt(h) {
        if (h == null)
            return null;
        if (typeof h == "function")
            return h.displayName || h.name || null;
        if (typeof h == "string")
            return h;
        switch (h) {
        case K:
            return "Fragment";
        case me:
            return "Portal";
        case Ee:
            return "Profiler";
        case be:
            return "StrictMode";
        case nt:
            return "Suspense";
        case J:
            return "SuspenseList"
        }
        if (typeof h == "object")
            switch (h.$$typeof) {
            case He:
                return (h.displayName || "Context") + ".Consumer";
            case Ce:
                return (h._context.displayName || "Context") + ".Provider";
            case ct:
                var g = h.render;
                return h = h.displayName,
                h || (h = g.displayName || g.name || "",
                h = h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef"),
                h;
            case he:
                return g = h.displayName || null,
                g !== null ? g : Wt(h.type) || "Memo";
            case ve:
                g = h._payload,
                h = h._init;
                try {
                    return Wt(h(g))
                } catch {}
            }
        return null
    }
    function tr(h) {
        var g = h.type;
        switch (h.tag) {
        case 24:
            return "Cache";
        case 9:
            return (g.displayName || "Context") + ".Consumer";
        case 10:
            return (g._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return h = g.render,
            h = h.displayName || h.name || "",
            g.displayName || (h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return g;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return Wt(g);
        case 8:
            return g === be ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof g == "function")
                return g.displayName || g.name || null;
            if (typeof g == "string")
                return g
        }
        return null
    }
    function cr(h) {
        switch (typeof h) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return h;
        case "object":
            return h;
        default:
            return ""
        }
    }
    function Yt(h) {
        var g = h.type;
        return (h = h.nodeName) && h.toLowerCase() === "input" && (g === "checkbox" || g === "radio")
    }
    function Gr(h) {
        var g = Yt(h) ? "checked" : "value"
          , S = Object.getOwnPropertyDescriptor(h.constructor.prototype, g)
          , E = "" + h[g];
        if (!h.hasOwnProperty(g) && typeof S < "u" && typeof S.get == "function" && typeof S.set == "function") {
            var F = S.get
              , W = S.set;
            return Object.defineProperty(h, g, {
                configurable: !0,
                get: function() {
                    return F.call(this)
                },
                set: function(pe) {
                    E = "" + pe,
                    W.call(this, pe)
                }
            }),
            Object.defineProperty(h, g, {
                enumerable: S.enumerable
            }),
            {
                getValue: function() {
                    return E
                },
                setValue: function(pe) {
                    E = "" + pe
                },
                stopTracking: function() {
                    h._valueTracker = null,
                    delete h[g]
                }
            }
        }
    }
    function xr(h) {
        h._valueTracker || (h._valueTracker = Gr(h))
    }
    function Nr(h) {
        if (!h)
            return !1;
        var g = h._valueTracker;
        if (!g)
            return !0;
        var S = g.getValue()
          , E = "";
        return h && (E = Yt(h) ? h.checked ? "true" : "false" : h.value),
        h = E,
        h !== S ? (g.setValue(h),
        !0) : !1
    }
    function ur(h) {
        if (h = h || (typeof document < "u" ? document : void 0),
        typeof h > "u")
            return null;
        try {
            return h.activeElement || h.body
        } catch {
            return h.body
        }
    }
    function vr(h, g) {
        var S = g.checked;
        return Pt({}, g, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: S ?? h._wrapperState.initialChecked
        })
    }
    function gr(h, g) {
        var S = g.defaultValue == null ? "" : g.defaultValue
          , E = g.checked != null ? g.checked : g.defaultChecked;
        S = cr(g.value != null ? g.value : S),
        h._wrapperState = {
            initialChecked: E,
            initialValue: S,
            controlled: g.type === "checkbox" || g.type === "radio" ? g.checked != null : g.value != null
        }
    }
    function hn(h, g) {
        g = g.checked,
        g != null && ue(h, "checked", g, !1)
    }
    function Zr(h, g) {
        hn(h, g);
        var S = cr(g.value)
          , E = g.type;
        if (S != null)
            E === "number" ? (S === 0 && h.value === "" || h.value != S) && (h.value = "" + S) : h.value !== "" + S && (h.value = "" + S);
        else if (E === "submit" || E === "reset") {
            h.removeAttribute("value");
            return
        }
        g.hasOwnProperty("value") ? gn(h, g.type, S) : g.hasOwnProperty("defaultValue") && gn(h, g.type, cr(g.defaultValue)),
        g.checked == null && g.defaultChecked != null && (h.defaultChecked = !!g.defaultChecked)
    }
    function $r(h, g, S) {
        if (g.hasOwnProperty("value") || g.hasOwnProperty("defaultValue")) {
            var E = g.type;
            if (!(E !== "submit" && E !== "reset" || g.value !== void 0 && g.value !== null))
                return;
            g = "" + h._wrapperState.initialValue,
            S || g === h.value || (h.value = g),
            h.defaultValue = g
        }
        S = h.name,
        S !== "" && (h.name = ""),
        h.defaultChecked = !!h._wrapperState.initialChecked,
        S !== "" && (h.name = S)
    }
    function gn(h, g, S) {
        (g !== "number" || ur(h.ownerDocument) !== h) && (S == null ? h.defaultValue = "" + h._wrapperState.initialValue : h.defaultValue !== "" + S && (h.defaultValue = "" + S))
    }
    var zr = Array.isArray;
    function Wr(h, g, S, E) {
        if (h = h.options,
        g) {
            g = {};
            for (var F = 0; F < S.length; F++)
                g["$" + S[F]] = !0;
            for (S = 0; S < h.length; S++)
                F = g.hasOwnProperty("$" + h[S].value),
                h[S].selected !== F && (h[S].selected = F),
                F && E && (h[S].defaultSelected = !0)
        } else {
            for (S = "" + cr(S),
            g = null,
            F = 0; F < h.length; F++) {
                if (h[F].value === S) {
                    h[F].selected = !0,
                    E && (h[F].defaultSelected = !0);
                    return
                }
                g !== null || h[F].disabled || (g = h[F])
            }
            g !== null && (g.selected = !0)
        }
    }
    function $n(h, g) {
        if (g.dangerouslySetInnerHTML != null)
            throw Error(i(91));
        return Pt({}, g, {
            value: void 0,
            defaultValue: void 0,
            children: "" + h._wrapperState.initialValue
        })
    }
    function Dn(h, g) {
        var S = g.value;
        if (S == null) {
            if (S = g.children,
            g = g.defaultValue,
            S != null) {
                if (g != null)
                    throw Error(i(92));
                if (zr(S)) {
                    if (1 < S.length)
                        throw Error(i(93));
                    S = S[0]
                }
                g = S
            }
            g == null && (g = ""),
            S = g
        }
        h._wrapperState = {
            initialValue: cr(S)
        }
    }
    function yn(h, g) {
        var S = cr(g.value)
          , E = cr(g.defaultValue);
        S != null && (S = "" + S,
        S !== h.value && (h.value = S),
        g.defaultValue == null && h.defaultValue !== S && (h.defaultValue = S)),
        E != null && (h.defaultValue = "" + E)
    }
    function Tn(h) {
        var g = h.textContent;
        g === h._wrapperState.initialValue && g !== "" && g !== null && (h.value = g)
    }
    function bn(h) {
        switch (h) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
        }
    }
    function sn(h, g) {
        return h == null || h === "http://www.w3.org/1999/xhtml" ? bn(g) : h === "http://www.w3.org/2000/svg" && g === "foreignObject" ? "http://www.w3.org/1999/xhtml" : h
    }
    var Mt, kt = function(h) {
        return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(g, S, E, F) {
            MSApp.execUnsafeLocalFunction(function() {
                return h(g, S, E, F)
            })
        }
        : h
    }(function(h, g) {
        if (h.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in h)
            h.innerHTML = g;
        else {
            for (Mt = Mt || document.createElement("div"),
            Mt.innerHTML = "<svg>" + g.valueOf().toString() + "</svg>",
            g = Mt.firstChild; h.firstChild; )
                h.removeChild(h.firstChild);
            for (; g.firstChild; )
                h.appendChild(g.firstChild)
        }
    });
    function er(h, g) {
        if (g) {
            var S = h.firstChild;
            if (S && S === h.lastChild && S.nodeType === 3) {
                S.nodeValue = g;
                return
            }
        }
        h.textContent = g
    }
    var Er = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    }
      , Ue = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Er).forEach(function(h) {
        Ue.forEach(function(g) {
            g = g + h.charAt(0).toUpperCase() + h.substring(1),
            Er[g] = Er[h]
        })
    });
    function se(h, g, S) {
        return g == null || typeof g == "boolean" || g === "" ? "" : S || typeof g != "number" || g === 0 || Er.hasOwnProperty(h) && Er[h] ? ("" + g).trim() : g + "px"
    }
    function fe(h, g) {
        h = h.style;
        for (var S in g)
            if (g.hasOwnProperty(S)) {
                var E = S.indexOf("--") === 0
                  , F = se(S, g[S], E);
                S === "float" && (S = "cssFloat"),
                E ? h.setProperty(S, F) : h[S] = F
            }
    }
    var ge = Pt({
        menuitem: !0
    }, {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    });
    function Me(h, g) {
        if (g) {
            if (ge[h] && (g.children != null || g.dangerouslySetInnerHTML != null))
                throw Error(i(137, h));
            if (g.dangerouslySetInnerHTML != null) {
                if (g.children != null)
                    throw Error(i(60));
                if (typeof g.dangerouslySetInnerHTML != "object" || !("__html"in g.dangerouslySetInnerHTML))
                    throw Error(i(61))
            }
            if (g.style != null && typeof g.style != "object")
                throw Error(i(62))
        }
    }
    function $e(h, g) {
        if (h.indexOf("-") === -1)
            return typeof g.is == "string";
        switch (h) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    var et = null;
    function at(h) {
        return h = h.target || h.srcElement || window,
        h.correspondingUseElement && (h = h.correspondingUseElement),
        h.nodeType === 3 ? h.parentNode : h
    }
    var Qe = null
      , _t = null
      , dt = null;
    function tt(h) {
        if (h = Dl(h)) {
            if (typeof Qe != "function")
                throw Error(i(280));
            var g = h.stateNode;
            g && (g = vc(g),
            Qe(h.stateNode, h.type, g))
        }
    }
    function St(h) {
        _t ? dt ? dt.push(h) : dt = [h] : _t = h
    }
    function Ve() {
        if (_t) {
            var h = _t
              , g = dt;
            if (dt = _t = null,
            tt(h),
            g)
                for (h = 0; h < g.length; h++)
                    tt(g[h])
        }
    }
    function Ut(h, g) {
        return h(g)
    }
    function yr() {}
    var Ht = !1;
    function sr(h, g, S) {
        if (Ht)
            return h(g, S);
        Ht = !0;
        try {
            return Ut(h, g, S)
        } finally {
            Ht = !1,
            (_t !== null || dt !== null) && (yr(),
            Ve())
        }
    }
    function br(h, g) {
        var S = h.stateNode;
        if (S === null)
            return null;
        var E = vc(S);
        if (E === null)
            return null;
        S = E[g];
        e: switch (g) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (E = !E.disabled) || (h = h.type,
            E = !(h === "button" || h === "input" || h === "select" || h === "textarea")),
            h = !E;
            break e;
        default:
            h = !1
        }
        if (h)
            return null;
        if (S && typeof S != "function")
            throw Error(i(231, g, typeof S));
        return S
    }
    var en = !1;
    if (o)
        try {
            var qr = {};
            Object.defineProperty(qr, "passive", {
                get: function() {
                    en = !0
                }
            }),
            window.addEventListener("test", qr, qr),
            window.removeEventListener("test", qr, qr)
        } catch {
            en = !1
        }
    function Dr(h, g, S, E, F, W, pe, Fe, Je) {
        var xt = Array.prototype.slice.call(arguments, 3);
        try {
            g.apply(S, xt)
        } catch (Bt) {
            this.onError(Bt)
        }
    }
    var fr = !1
      , ke = null
      , le = !1
      , ee = null
      , Ze = {
        onError: function(h) {
            fr = !0,
            ke = h
        }
    };
    function Ge(h, g, S, E, F, W, pe, Fe, Je) {
        fr = !1,
        ke = null,
        Dr.apply(Ze, arguments)
    }
    function vt(h, g, S, E, F, W, pe, Fe, Je) {
        if (Ge.apply(this, arguments),
        fr) {
            if (fr) {
                var xt = ke;
                fr = !1,
                ke = null
            } else
                throw Error(i(198));
            le || (le = !0,
            ee = xt)
        }
    }
    function it(h) {
        var g = h
          , S = h;
        if (h.alternate)
            for (; g.return; )
                g = g.return;
        else {
            h = g;
            do
                g = h,
                (g.flags & 4098) !== 0 && (S = g.return),
                h = g.return;
            while (h)
        }
        return g.tag === 3 ? S : null
    }
    function Xe(h) {
        if (h.tag === 13) {
            var g = h.memoizedState;
            if (g === null && (h = h.alternate,
            h !== null && (g = h.memoizedState)),
            g !== null)
                return g.dehydrated
        }
        return null
    }
    function wt(h) {
        if (it(h) !== h)
            throw Error(i(188))
    }
    function Ct(h) {
        var g = h.alternate;
        if (!g) {
            if (g = it(h),
            g === null)
                throw Error(i(188));
            return g !== h ? null : h
        }
        for (var S = h, E = g; ; ) {
            var F = S.return;
            if (F === null)
                break;
            var W = F.alternate;
            if (W === null) {
                if (E = F.return,
                E !== null) {
                    S = E;
                    continue
                }
                break
            }
            if (F.child === W.child) {
                for (W = F.child; W; ) {
                    if (W === S)
                        return wt(F),
                        h;
                    if (W === E)
                        return wt(F),
                        g;
                    W = W.sibling
                }
                throw Error(i(188))
            }
            if (S.return !== E.return)
                S = F,
                E = W;
            else {
                for (var pe = !1, Fe = F.child; Fe; ) {
                    if (Fe === S) {
                        pe = !0,
                        S = F,
                        E = W;
                        break
                    }
                    if (Fe === E) {
                        pe = !0,
                        E = F,
                        S = W;
                        break
                    }
                    Fe = Fe.sibling
                }
                if (!pe) {
                    for (Fe = W.child; Fe; ) {
                        if (Fe === S) {
                            pe = !0,
                            S = W,
                            E = F;
                            break
                        }
                        if (Fe === E) {
                            pe = !0,
                            E = W,
                            S = F;
                            break
                        }
                        Fe = Fe.sibling
                    }
                    if (!pe)
                        throw Error(i(189))
                }
            }
            if (S.alternate !== E)
                throw Error(i(190))
        }
        if (S.tag !== 3)
            throw Error(i(188));
        return S.stateNode.current === S ? h : g
    }
    function Gt(h) {
        return h = Ct(h),
        h !== null ? Xt(h) : null
    }
    function Xt(h) {
        if (h.tag === 5 || h.tag === 6)
            return h;
        for (h = h.child; h !== null; ) {
            var g = Xt(h);
            if (g !== null)
                return g;
            h = h.sibling
        }
        return null
    }
    var lr = t.unstable_scheduleCallback
      , _r = t.unstable_cancelCallback
      , ri = t.unstable_shouldYield
      , ni = t.unstable_requestPaint
      , kr = t.unstable_now
      , ci = t.unstable_getCurrentPriorityLevel
      , Si = t.unstable_ImmediatePriority
      , $i = t.unstable_UserBlockingPriority
      , Ro = t.unstable_NormalPriority
      , Ln = t.unstable_LowPriority
      , an = t.unstable_IdlePriority
      , qn = null
      , Ei = null;
    function Ao(h) {
        if (Ei && typeof Ei.onCommitFiberRoot == "function")
            try {
                Ei.onCommitFiberRoot(qn, h, void 0, (h.current.flags & 128) === 128)
            } catch {}
    }
    var Hn = Math.clz32 ? Math.clz32 : Wo
      , Go = Math.log
      , xl = Math.LN2;
    function Wo(h) {
        return h >>>= 0,
        h === 0 ? 32 : 31 - (Go(h) / xl | 0) | 0
    }
    var qo = 64
      , Ho = 4194304;
    function xs(h) {
        switch (h & -h) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return h & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return h & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return h
        }
    }
    function bs(h, g) {
        var S = h.pendingLanes;
        if (S === 0)
            return 0;
        var E = 0
          , F = h.suspendedLanes
          , W = h.pingedLanes
          , pe = S & 268435455;
        if (pe !== 0) {
            var Fe = pe & ~F;
            Fe !== 0 ? E = xs(Fe) : (W &= pe,
            W !== 0 && (E = xs(W)))
        } else
            pe = S & ~F,
            pe !== 0 ? E = xs(pe) : W !== 0 && (E = xs(W));
        if (E === 0)
            return 0;
        if (g !== 0 && g !== E && (g & F) === 0 && (F = E & -E,
        W = g & -g,
        F >= W || F === 16 && (W & 4194240) !== 0))
            return g;
        if ((E & 4) !== 0 && (E |= S & 16),
        g = h.entangledLanes,
        g !== 0)
            for (h = h.entanglements,
            g &= E; 0 < g; )
                S = 31 - Hn(g),
                F = 1 << S,
                E |= h[S],
                g &= ~F;
        return E
    }
    function Zo(h, g) {
        switch (h) {
        case 1:
        case 2:
        case 4:
            return g + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return g + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function Vi(h, g) {
        for (var S = h.suspendedLanes, E = h.pingedLanes, F = h.expirationTimes, W = h.pendingLanes; 0 < W; ) {
            var pe = 31 - Hn(W)
              , Fe = 1 << pe
              , Je = F[pe];
            Je === -1 ? ((Fe & S) === 0 || (Fe & E) !== 0) && (F[pe] = Zo(Fe, g)) : Je <= g && (h.expiredLanes |= Fe),
            W &= ~Fe
        }
    }
    function oa(h) {
        return h = h.pendingLanes & -1073741825,
        h !== 0 ? h : h & 1073741824 ? 1073741824 : 0
    }
    function Ki() {
        var h = qo;
        return qo <<= 1,
        (qo & 4194240) === 0 && (qo = 64),
        h
    }
    function su(h) {
        for (var g = [], S = 0; 31 > S; S++)
            g.push(h);
        return g
    }
    function bl(h, g, S) {
        h.pendingLanes |= g,
        g !== 536870912 && (h.suspendedLanes = 0,
        h.pingedLanes = 0),
        h = h.eventTimes,
        g = 31 - Hn(g),
        h[g] = S
    }
    function wf(h, g) {
        var S = h.pendingLanes & ~g;
        h.pendingLanes = g,
        h.suspendedLanes = 0,
        h.pingedLanes = 0,
        h.expiredLanes &= g,
        h.mutableReadLanes &= g,
        h.entangledLanes &= g,
        g = h.entanglements;
        var E = h.eventTimes;
        for (h = h.expirationTimes; 0 < S; ) {
            var F = 31 - Hn(S)
              , W = 1 << F;
            g[F] = 0,
            E[F] = -1,
            h[F] = -1,
            S &= ~W
        }
    }
    function ic(h, g) {
        var S = h.entangledLanes |= g;
        for (h = h.entanglements; S; ) {
            var E = 31 - Hn(S)
              , F = 1 << E;
            F & g | h[E] & g && (h[E] |= g),
            S &= ~F
        }
    }
    var dn = 0;
    function ws(h) {
        return h &= -h,
        1 < h ? 4 < h ? (h & 268435455) !== 0 ? 16 : 536870912 : 4 : 1
    }
    var Xr, Ss, Ns, Da, ch, au = !1, po = [], Qi = null, Br = null, cs = null, La = new Map, wl = new Map, ei = [], mi = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Ui(h, g) {
        switch (h) {
        case "focusin":
        case "focusout":
            Qi = null;
            break;
        case "dragenter":
        case "dragleave":
            Br = null;
            break;
        case "mouseover":
        case "mouseout":
            cs = null;
            break;
        case "pointerover":
        case "pointerout":
            La.delete(g.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            wl.delete(g.pointerId)
        }
    }
    function ii(h, g, S, E, F, W) {
        return h === null || h.nativeEvent !== W ? (h = {
            blockedOn: g,
            domEventName: S,
            eventSystemFlags: E,
            nativeEvent: W,
            targetContainers: [F]
        },
        g !== null && (g = Dl(g),
        g !== null && Ss(g)),
        h) : (h.eventSystemFlags |= E,
        g = h.targetContainers,
        F !== null && g.indexOf(F) === -1 && g.push(F),
        h)
    }
    function Qn(h, g, S, E, F) {
        switch (g) {
        case "focusin":
            return Qi = ii(Qi, h, g, S, E, F),
            !0;
        case "dragenter":
            return Br = ii(Br, h, g, S, E, F),
            !0;
        case "mouseover":
            return cs = ii(cs, h, g, S, E, F),
            !0;
        case "pointerover":
            var W = F.pointerId;
            return La.set(W, ii(La.get(W) || null, h, g, S, E, F)),
            !0;
        case "gotpointercapture":
            return W = F.pointerId,
            wl.set(W, ii(wl.get(W) || null, h, g, S, E, F)),
            !0
        }
        return !1
    }
    function lu(h) {
        var g = fs(h.target);
        if (g !== null) {
            var S = it(g);
            if (S !== null) {
                if (g = S.tag,
                g === 13) {
                    if (g = Xe(S),
                    g !== null) {
                        h.blockedOn = g,
                        ch(h.priority, function() {
                            Ns(S)
                        });
                        return
                    }
                } else if (g === 3 && S.stateNode.current.memoizedState.isDehydrated) {
                    h.blockedOn = S.tag === 3 ? S.stateNode.containerInfo : null;
                    return
                }
            }
        }
        h.blockedOn = null
    }
    function Yr(h) {
        if (h.blockedOn !== null)
            return !1;
        for (var g = h.targetContainers; 0 < g.length; ) {
            var S = us(h.domEventName, h.eventSystemFlags, g[0], h.nativeEvent);
            if (S === null) {
                S = h.nativeEvent;
                var E = new S.constructor(S.type,S);
                et = E,
                S.target.dispatchEvent(E),
                et = null
            } else
                return g = Dl(S),
                g !== null && Ss(g),
                h.blockedOn = S,
                !1;
            g.shift()
        }
        return !0
    }
    function mo(h, g, S) {
        Yr(h) && S.delete(g)
    }
    function jr() {
        au = !1,
        Qi !== null && Yr(Qi) && (Qi = null),
        Br !== null && Yr(Br) && (Br = null),
        cs !== null && Yr(cs) && (cs = null),
        La.forEach(mo),
        wl.forEach(mo)
    }
    function Fr(h, g) {
        h.blockedOn === g && (h.blockedOn = null,
        au || (au = !0,
        t.unstable_scheduleCallback(t.unstable_NormalPriority, jr)))
    }
    function Cs(h) {
        function g(F) {
            return Fr(F, h)
        }
        if (0 < po.length) {
            Fr(po[0], h);
            for (var S = 1; S < po.length; S++) {
                var E = po[S];
                E.blockedOn === h && (E.blockedOn = null)
            }
        }
        for (Qi !== null && Fr(Qi, h),
        Br !== null && Fr(Br, h),
        cs !== null && Fr(cs, h),
        La.forEach(g),
        wl.forEach(g),
        S = 0; S < ei.length; S++)
            E = ei[S],
            E.blockedOn === h && (E.blockedOn = null);
        for (; 0 < ei.length && (S = ei[0],
        S.blockedOn === null); )
            lu(S),
            S.blockedOn === null && ei.shift()
    }
    var Sr = ce.ReactCurrentBatchConfig
      , $s = !0;
    function go(h, g, S, E) {
        var F = dn
          , W = Sr.transition;
        Sr.transition = null;
        try {
            dn = 1,
            Ji(h, g, S, E)
        } finally {
            dn = F,
            Sr.transition = W
        }
    }
    function oc(h, g, S, E) {
        var F = dn
          , W = Sr.transition;
        Sr.transition = null;
        try {
            dn = 4,
            Ji(h, g, S, E)
        } finally {
            dn = F,
            Sr.transition = W
        }
    }
    function Ji(h, g, S, E) {
        if ($s) {
            var F = us(h, g, S, E);
            if (F === null)
                gc(h, g, E, sc, S),
                Ui(h, E);
            else if (Qn(F, h, g, S, E))
                E.stopPropagation();
            else if (Ui(h, E),
            g & 4 && -1 < mi.indexOf(h)) {
                for (; F !== null; ) {
                    var W = Dl(F);
                    if (W !== null && Xr(W),
                    W = us(h, g, S, E),
                    W === null && gc(h, g, E, sc, S),
                    W === F)
                        break;
                    F = W
                }
                F !== null && E.stopPropagation()
            } else
                gc(h, g, E, null, S)
        }
    }
    var sc = null;
    function us(h, g, S, E) {
        if (sc = null,
        h = at(E),
        h = fs(h),
        h !== null)
            if (g = it(h),
            g === null)
                h = null;
            else if (S = g.tag,
            S === 13) {
                if (h = Xe(g),
                h !== null)
                    return h;
                h = null
            } else if (S === 3) {
                if (g.stateNode.current.memoizedState.isDehydrated)
                    return g.tag === 3 ? g.stateNode.containerInfo : null;
                h = null
            } else
                g !== h && (h = null);
        return sc = h,
        null
    }
    function od(h) {
        switch (h) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (ci()) {
            case Si:
                return 1;
            case $i:
                return 4;
            case Ro:
            case Ln:
                return 16;
            case an:
                return 536870912;
            default:
                return 16
            }
        default:
            return 16
        }
    }
    var sa = null
      , Sl = null
      , Oa = null;
    function hs() {
        if (Oa)
            return Oa;
        var h, g = Sl, S = g.length, E, F = "value"in sa ? sa.value : sa.textContent, W = F.length;
        for (h = 0; h < S && g[h] === F[h]; h++)
            ;
        var pe = S - h;
        for (E = 1; E <= pe && g[S - E] === F[W - E]; E++)
            ;
        return Oa = F.slice(h, 1 < E ? 1 - E : void 0)
    }
    function ui(h) {
        var g = h.keyCode;
        return "charCode"in h ? (h = h.charCode,
        h === 0 && g === 13 && (h = 13)) : h = g,
        h === 10 && (h = 13),
        32 <= h || h === 13 ? h : 0
    }
    function aa() {
        return !0
    }
    function ac() {
        return !1
    }
    function Ii(h) {
        function g(S, E, F, W, pe) {
            this._reactName = S,
            this._targetInst = F,
            this.type = E,
            this.nativeEvent = W,
            this.target = pe,
            this.currentTarget = null;
            for (var Fe in h)
                h.hasOwnProperty(Fe) && (S = h[Fe],
                this[Fe] = S ? S(W) : W[Fe]);
            return this.isDefaultPrevented = (W.defaultPrevented != null ? W.defaultPrevented : W.returnValue === !1) ? aa : ac,
            this.isPropagationStopped = ac,
            this
        }
        return Pt(g.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var S = this.nativeEvent;
                S && (S.preventDefault ? S.preventDefault() : typeof S.returnValue != "unknown" && (S.returnValue = !1),
                this.isDefaultPrevented = aa)
            },
            stopPropagation: function() {
                var S = this.nativeEvent;
                S && (S.stopPropagation ? S.stopPropagation() : typeof S.cancelBubble != "unknown" && (S.cancelBubble = !0),
                this.isPropagationStopped = aa)
            },
            persist: function() {},
            isPersistent: aa
        }),
        g
    }
    var Zn = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(h) {
            return h.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, Cl = Ii(Zn), Vs = Pt({}, Zn, {
        view: 0,
        detail: 0
    }), lc = Ii(Vs), sd, Us, la, cc = Pt({}, Vs, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: dc,
        button: 0,
        buttons: 0,
        relatedTarget: function(h) {
            return h.relatedTarget === void 0 ? h.fromElement === h.srcElement ? h.toElement : h.fromElement : h.relatedTarget
        },
        movementX: function(h) {
            return "movementX"in h ? h.movementX : (h !== la && (la && h.type === "mousemove" ? (sd = h.screenX - la.screenX,
            Us = h.screenY - la.screenY) : Us = sd = 0,
            la = h),
            sd)
        },
        movementY: function(h) {
            return "movementY"in h ? h.movementY : Us
        }
    }), Sf = Ii(cc), yo = Pt({}, cc, {
        dataTransfer: 0
    }), uc = Ii(yo), Xo = Pt({}, Vs, {
        relatedTarget: 0
    }), eo = Ii(Xo), ad = Pt({}, Zn, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), cu = Ii(ad), hc = Pt({}, Zn, {
        clipboardData: function(h) {
            return "clipboardData"in h ? h.clipboardData : window.clipboardData
        }
    }), ld = Ii(hc), nm = Pt({}, Zn, {
        data: 0
    }), Cf = Ii(nm), im = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, om = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, uh = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function hh(h) {
        var g = this.nativeEvent;
        return g.getModifierState ? g.getModifierState(h) : (h = uh[h]) ? !!g[h] : !1
    }
    function dc() {
        return hh
    }
    var uu = Pt({}, Vs, {
        key: function(h) {
            if (h.key) {
                var g = im[h.key] || h.key;
                if (g !== "Unidentified")
                    return g
            }
            return h.type === "keypress" ? (h = ui(h),
            h === 13 ? "Enter" : String.fromCharCode(h)) : h.type === "keydown" || h.type === "keyup" ? om[h.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: dc,
        charCode: function(h) {
            return h.type === "keypress" ? ui(h) : 0
        },
        keyCode: function(h) {
            return h.type === "keydown" || h.type === "keyup" ? h.keyCode : 0
        },
        which: function(h) {
            return h.type === "keypress" ? ui(h) : h.type === "keydown" || h.type === "keyup" ? h.keyCode : 0
        }
    })
      , cd = Ii(uu)
      , dh = Pt({}, cc, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
      , Ts = Ii(dh)
      , sm = Pt({}, Vs, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: dc
    })
      , ud = Ii(sm)
      , hu = Pt({}, Zn, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
      , du = Ii(hu)
      , Tf = Pt({}, cc, {
        deltaX: function(h) {
            return "deltaX"in h ? h.deltaX : "wheelDeltaX"in h ? -h.wheelDeltaX : 0
        },
        deltaY: function(h) {
            return "deltaY"in h ? h.deltaY : "wheelDeltaY"in h ? -h.wheelDeltaY : "wheelDelta"in h ? -h.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
      , fu = Ii(Tf)
      , Pf = [9, 13, 27, 32]
      , Fa = o && "CompositionEvent"in window
      , pu = null;
    o && "documentMode"in document && (pu = document.documentMode);
    var Mf = o && "TextEvent"in window && !pu
      , kf = o && (!Fa || pu && 8 < pu && 11 >= pu)
      , mu = " "
      , fh = !1;
    function hd(h, g) {
        switch (h) {
        case "keyup":
            return Pf.indexOf(g.keyCode) !== -1;
        case "keydown":
            return g.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function dd(h) {
        return h = h.detail,
        typeof h == "object" && "data"in h ? h.data : null
    }
    var Ba = !1;
    function fd(h, g) {
        switch (h) {
        case "compositionend":
            return dd(g);
        case "keypress":
            return g.which !== 32 ? null : (fh = !0,
            mu);
        case "textInput":
            return h = g.data,
            h === mu && fh ? null : h;
        default:
            return null
        }
    }
    function Tl(h, g) {
        if (Ba)
            return h === "compositionend" || !Fa && hd(h, g) ? (h = hs(),
            Oa = Sl = sa = null,
            Ba = !1,
            h) : null;
        switch (h) {
        case "paste":
            return null;
        case "keypress":
            if (!(g.ctrlKey || g.altKey || g.metaKey) || g.ctrlKey && g.altKey) {
                if (g.char && 1 < g.char.length)
                    return g.char;
                if (g.which)
                    return String.fromCharCode(g.which)
            }
            return null;
        case "compositionend":
            return kf && g.locale !== "ko" ? null : g.data;
        default:
            return null
        }
    }
    var Ef = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function ph(h) {
        var g = h && h.nodeName && h.nodeName.toLowerCase();
        return g === "input" ? !!Ef[h.type] : g === "textarea"
    }
    function Pl(h, g, S, E) {
        St(E),
        g = Il(g, "onChange"),
        0 < g.length && (S = new Cl("onChange","change",null,S,E),
        h.push({
            event: S,
            listeners: g
        }))
    }
    var gu = null
      , ja = null;
    function am(h) {
        Sd(h, 0)
    }
    function yu(h) {
        var g = Hs(h);
        if (Nr(g))
            return h
    }
    function If(h, g) {
        if (h === "change")
            return g
    }
    var pd = !1;
    if (o) {
        var mh;
        if (o) {
            var _u = "oninput"in document;
            if (!_u) {
                var ln = document.createElement("div");
                ln.setAttribute("oninput", "return;"),
                _u = typeof ln.oninput == "function"
            }
            mh = _u
        } else
            mh = !1;
        pd = mh && (!document.documentMode || 9 < document.documentMode)
    }
    function vu() {
        gu && (gu.detachEvent("onpropertychange", Gs),
        ja = gu = null)
    }
    function Gs(h) {
        if (h.propertyName === "value" && yu(ja)) {
            var g = [];
            Pl(g, ja, h, at(h)),
            sr(am, g)
        }
    }
    function md(h, g, S) {
        h === "focusin" ? (vu(),
        gu = g,
        ja = S,
        gu.attachEvent("onpropertychange", Gs)) : h === "focusout" && vu()
    }
    function gd(h) {
        if (h === "selectionchange" || h === "keyup" || h === "keydown")
            return yu(ja)
    }
    function yd(h, g) {
        if (h === "click")
            return yu(g)
    }
    function Rf(h, g) {
        if (h === "input" || h === "change")
            return yu(g)
    }
    function _d(h, g) {
        return h === g && (h !== 0 || 1 / h === 1 / g) || h !== h && g !== g
    }
    var Gi = typeof Object.is == "function" ? Object.is : _d;
    function Ml(h, g) {
        if (Gi(h, g))
            return !0;
        if (typeof h != "object" || h === null || typeof g != "object" || g === null)
            return !1;
        var S = Object.keys(h)
          , E = Object.keys(g);
        if (S.length !== E.length)
            return !1;
        for (E = 0; E < S.length; E++) {
            var F = S[E];
            if (!w.call(g, F) || !Gi(h[F], g[F]))
                return !1
        }
        return !0
    }
    function Af(h) {
        for (; h && h.firstChild; )
            h = h.firstChild;
        return h
    }
    function zf(h, g) {
        var S = Af(h);
        h = 0;
        for (var E; S; ) {
            if (S.nodeType === 3) {
                if (E = h + S.textContent.length,
                h <= g && E >= g)
                    return {
                        node: S,
                        offset: g - h
                    };
                h = E
            }
            e: {
                for (; S; ) {
                    if (S.nextSibling) {
                        S = S.nextSibling;
                        break e
                    }
                    S = S.parentNode
                }
                S = void 0
            }
            S = Af(S)
        }
    }
    function Df(h, g) {
        return h && g ? h === g ? !0 : h && h.nodeType === 3 ? !1 : g && g.nodeType === 3 ? Df(h, g.parentNode) : "contains"in h ? h.contains(g) : h.compareDocumentPosition ? !!(h.compareDocumentPosition(g) & 16) : !1 : !1
    }
    function Lf() {
        for (var h = window, g = ur(); g instanceof h.HTMLIFrameElement; ) {
            try {
                var S = typeof g.contentWindow.location.href == "string"
            } catch {
                S = !1
            }
            if (S)
                h = g.contentWindow;
            else
                break;
            g = ur(h.document)
        }
        return g
    }
    function gh(h) {
        var g = h && h.nodeName && h.nodeName.toLowerCase();
        return g && (g === "input" && (h.type === "text" || h.type === "search" || h.type === "tel" || h.type === "url" || h.type === "password") || g === "textarea" || h.contentEditable === "true")
    }
    function lm(h) {
        var g = Lf()
          , S = h.focusedElem
          , E = h.selectionRange;
        if (g !== S && S && S.ownerDocument && Df(S.ownerDocument.documentElement, S)) {
            if (E !== null && gh(S)) {
                if (g = E.start,
                h = E.end,
                h === void 0 && (h = g),
                "selectionStart"in S)
                    S.selectionStart = g,
                    S.selectionEnd = Math.min(h, S.value.length);
                else if (h = (g = S.ownerDocument || document) && g.defaultView || window,
                h.getSelection) {
                    h = h.getSelection();
                    var F = S.textContent.length
                      , W = Math.min(E.start, F);
                    E = E.end === void 0 ? W : Math.min(E.end, F),
                    !h.extend && W > E && (F = E,
                    E = W,
                    W = F),
                    F = zf(S, W);
                    var pe = zf(S, E);
                    F && pe && (h.rangeCount !== 1 || h.anchorNode !== F.node || h.anchorOffset !== F.offset || h.focusNode !== pe.node || h.focusOffset !== pe.offset) && (g = g.createRange(),
                    g.setStart(F.node, F.offset),
                    h.removeAllRanges(),
                    W > E ? (h.addRange(g),
                    h.extend(pe.node, pe.offset)) : (g.setEnd(pe.node, pe.offset),
                    h.addRange(g)))
                }
            }
            for (g = [],
            h = S; h = h.parentNode; )
                h.nodeType === 1 && g.push({
                    element: h,
                    left: h.scrollLeft,
                    top: h.scrollTop
                });
            for (typeof S.focus == "function" && S.focus(),
            S = 0; S < g.length; S++)
                h = g[S],
                h.element.scrollLeft = h.left,
                h.element.scrollTop = h.top
        }
    }
    var Of = o && "documentMode"in document && 11 >= document.documentMode
      , ca = null
      , fc = null
      , Na = null
      , xu = !1;
    function $a(h, g, S) {
        var E = S.window === S ? S.document : S.nodeType === 9 ? S : S.ownerDocument;
        xu || ca == null || ca !== ur(E) || (E = ca,
        "selectionStart"in E && gh(E) ? E = {
            start: E.selectionStart,
            end: E.selectionEnd
        } : (E = (E.ownerDocument && E.ownerDocument.defaultView || window).getSelection(),
        E = {
            anchorNode: E.anchorNode,
            anchorOffset: E.anchorOffset,
            focusNode: E.focusNode,
            focusOffset: E.focusOffset
        }),
        Na && Ml(Na, E) || (Na = E,
        E = Il(fc, "onSelect"),
        0 < E.length && (g = new Cl("onSelect","select",null,g,S),
        h.push({
            event: g,
            listeners: E
        }),
        g.target = ca)))
    }
    function Va(h, g) {
        var S = {};
        return S[h.toLowerCase()] = g.toLowerCase(),
        S["Webkit" + h] = "webkit" + g,
        S["Moz" + h] = "moz" + g,
        S
    }
    var Ps = {
        animationend: Va("Animation", "AnimationEnd"),
        animationiteration: Va("Animation", "AnimationIteration"),
        animationstart: Va("Animation", "AnimationStart"),
        transitionend: Va("Transition", "TransitionEnd")
    }
      , zo = {}
      , vd = {};
    o && (vd = document.createElement("div").style,
    "AnimationEvent"in window || (delete Ps.animationend.animation,
    delete Ps.animationiteration.animation,
    delete Ps.animationstart.animation),
    "TransitionEvent"in window || delete Ps.transitionend.transition);
    function bu(h) {
        if (zo[h])
            return zo[h];
        if (!Ps[h])
            return h;
        var g = Ps[h], S;
        for (S in g)
            if (g.hasOwnProperty(S) && S in vd)
                return zo[h] = g[S];
        return h
    }
    var yh = bu("animationend")
      , Ua = bu("animationiteration")
      , wu = bu("animationstart")
      , Su = bu("transitionend")
      , pc = new Map
      , kl = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ua(h, g) {
        pc.set(h, g),
        d(g, [h])
    }
    for (var Ga = 0; Ga < kl.length; Ga++) {
        var Wa = kl[Ga]
          , xd = Wa.toLowerCase()
          , bd = Wa[0].toUpperCase() + Wa.slice(1);
        ua(xd, "on" + bd)
    }
    ua(yh, "onAnimationEnd"),
    ua(Ua, "onAnimationIteration"),
    ua(wu, "onAnimationStart"),
    ua("dblclick", "onDoubleClick"),
    ua("focusin", "onFocus"),
    ua("focusout", "onBlur"),
    ua(Su, "onTransitionEnd"),
    f("onMouseEnter", ["mouseout", "mouseover"]),
    f("onMouseLeave", ["mouseout", "mouseover"]),
    f("onPointerEnter", ["pointerout", "pointerover"]),
    f("onPointerLeave", ["pointerout", "pointerover"]),
    d("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    d("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    d("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    d("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    d("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    d("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var Ur = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , El = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ur));
    function wd(h, g, S) {
        var E = h.type || "unknown-event";
        h.currentTarget = S,
        vt(E, g, void 0, h),
        h.currentTarget = null
    }
    function Sd(h, g) {
        g = (g & 4) !== 0;
        for (var S = 0; S < h.length; S++) {
            var E = h[S]
              , F = E.event;
            E = E.listeners;
            e: {
                var W = void 0;
                if (g)
                    for (var pe = E.length - 1; 0 <= pe; pe--) {
                        var Fe = E[pe]
                          , Je = Fe.instance
                          , xt = Fe.currentTarget;
                        if (Fe = Fe.listener,
                        Je !== W && F.isPropagationStopped())
                            break e;
                        wd(F, Fe, xt),
                        W = Je
                    }
                else
                    for (pe = 0; pe < E.length; pe++) {
                        if (Fe = E[pe],
                        Je = Fe.instance,
                        xt = Fe.currentTarget,
                        Fe = Fe.listener,
                        Je !== W && F.isPropagationStopped())
                            break e;
                        wd(F, Fe, xt),
                        W = Je
                    }
            }
        }
        if (le)
            throw h = ee,
            le = !1,
            ee = null,
            h
    }
    function Pn(h, g) {
        var S = g[yc];
        S === void 0 && (S = g[yc] = new Set);
        var E = h + "__bubble";
        S.has(E) || (Td(g, h, 2, !1),
        S.add(E))
    }
    function Cd(h, g, S) {
        var E = 0;
        g && (E |= 4),
        Td(S, h, E, g)
    }
    var _h = "_reactListening" + Math.random().toString(36).slice(2);
    function mc(h) {
        if (!h[_h]) {
            h[_h] = !0,
            s.forEach(function(S) {
                S !== "selectionchange" && (El.has(S) || Cd(S, !1, h),
                Cd(S, !0, h))
            });
            var g = h.nodeType === 9 ? h : h.ownerDocument;
            g === null || g[_h] || (g[_h] = !0,
            Cd("selectionchange", !1, g))
        }
    }
    function Td(h, g, S, E) {
        switch (od(g)) {
        case 1:
            var F = go;
            break;
        case 4:
            F = oc;
            break;
        default:
            F = Ji
        }
        S = F.bind(null, g, S, h),
        F = void 0,
        !en || g !== "touchstart" && g !== "touchmove" && g !== "wheel" || (F = !0),
        E ? F !== void 0 ? h.addEventListener(g, S, {
            capture: !0,
            passive: F
        }) : h.addEventListener(g, S, !0) : F !== void 0 ? h.addEventListener(g, S, {
            passive: F
        }) : h.addEventListener(g, S, !1)
    }
    function gc(h, g, S, E, F) {
        var W = E;
        if ((g & 1) === 0 && (g & 2) === 0 && E !== null)
            e: for (; ; ) {
                if (E === null)
                    return;
                var pe = E.tag;
                if (pe === 3 || pe === 4) {
                    var Fe = E.stateNode.containerInfo;
                    if (Fe === F || Fe.nodeType === 8 && Fe.parentNode === F)
                        break;
                    if (pe === 4)
                        for (pe = E.return; pe !== null; ) {
                            var Je = pe.tag;
                            if ((Je === 3 || Je === 4) && (Je = pe.stateNode.containerInfo,
                            Je === F || Je.nodeType === 8 && Je.parentNode === F))
                                return;
                            pe = pe.return
                        }
                    for (; Fe !== null; ) {
                        if (pe = fs(Fe),
                        pe === null)
                            return;
                        if (Je = pe.tag,
                        Je === 5 || Je === 6) {
                            E = W = pe;
                            continue e
                        }
                        Fe = Fe.parentNode
                    }
                }
                E = E.return
            }
        sr(function() {
            var xt = W
              , Bt = at(S)
              , Vt = [];
            e: {
                var Lt = pc.get(h);
                if (Lt !== void 0) {
                    var rr = Cl
                      , hr = h;
                    switch (h) {
                    case "keypress":
                        if (ui(S) === 0)
                            break e;
                    case "keydown":
                    case "keyup":
                        rr = cd;
                        break;
                    case "focusin":
                        hr = "focus",
                        rr = eo;
                        break;
                    case "focusout":
                        hr = "blur",
                        rr = eo;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        rr = eo;
                        break;
                    case "click":
                        if (S.button === 2)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        rr = Sf;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        rr = uc;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        rr = ud;
                        break;
                    case yh:
                    case Ua:
                    case wu:
                        rr = cu;
                        break;
                    case Su:
                        rr = du;
                        break;
                    case "scroll":
                        rr = lc;
                        break;
                    case "wheel":
                        rr = fu;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        rr = ld;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        rr = Ts
                    }
                    var wr = (g & 4) !== 0
                      , fi = !wr && h === "scroll"
                      , pt = wr ? Lt !== null ? Lt + "Capture" : null : Lt;
                    wr = [];
                    for (var rt = xt, gt; rt !== null; ) {
                        gt = rt;
                        var Zt = gt.stateNode;
                        if (gt.tag === 5 && Zt !== null && (gt = Zt,
                        pt !== null && (Zt = br(rt, pt),
                        Zt != null && wr.push(qa(rt, Zt, gt)))),
                        fi)
                            break;
                        rt = rt.return
                    }
                    0 < wr.length && (Lt = new rr(Lt,hr,null,S,Bt),
                    Vt.push({
                        event: Lt,
                        listeners: wr
                    }))
                }
            }
            if ((g & 7) === 0) {
                e: {
                    if (Lt = h === "mouseover" || h === "pointerover",
                    rr = h === "mouseout" || h === "pointerout",
                    Lt && S !== et && (hr = S.relatedTarget || S.fromElement) && (fs(hr) || hr[gi]))
                        break e;
                    if ((rr || Lt) && (Lt = Bt.window === Bt ? Bt : (Lt = Bt.ownerDocument) ? Lt.defaultView || Lt.parentWindow : window,
                    rr ? (hr = S.relatedTarget || S.toElement,
                    rr = xt,
                    hr = hr ? fs(hr) : null,
                    hr !== null && (fi = it(hr),
                    hr !== fi || hr.tag !== 5 && hr.tag !== 6) && (hr = null)) : (rr = null,
                    hr = xt),
                    rr !== hr)) {
                        if (wr = Sf,
                        Zt = "onMouseLeave",
                        pt = "onMouseEnter",
                        rt = "mouse",
                        (h === "pointerout" || h === "pointerover") && (wr = Ts,
                        Zt = "onPointerLeave",
                        pt = "onPointerEnter",
                        rt = "pointer"),
                        fi = rr == null ? Lt : Hs(rr),
                        gt = hr == null ? Lt : Hs(hr),
                        Lt = new wr(Zt,rt + "leave",rr,S,Bt),
                        Lt.target = fi,
                        Lt.relatedTarget = gt,
                        Zt = null,
                        fs(Bt) === xt && (wr = new wr(pt,rt + "enter",hr,S,Bt),
                        wr.target = gt,
                        wr.relatedTarget = fi,
                        Zt = wr),
                        fi = Zt,
                        rr && hr)
                            t: {
                                for (wr = rr,
                                pt = hr,
                                rt = 0,
                                gt = wr; gt; gt = Ws(gt))
                                    rt++;
                                for (gt = 0,
                                Zt = pt; Zt; Zt = Ws(Zt))
                                    gt++;
                                for (; 0 < rt - gt; )
                                    wr = Ws(wr),
                                    rt--;
                                for (; 0 < gt - rt; )
                                    pt = Ws(pt),
                                    gt--;
                                for (; rt--; ) {
                                    if (wr === pt || pt !== null && wr === pt.alternate)
                                        break t;
                                    wr = Ws(wr),
                                    pt = Ws(pt)
                                }
                                wr = null
                            }
                        else
                            wr = null;
                        rr !== null && Cu(Vt, Lt, rr, wr, !1),
                        hr !== null && fi !== null && Cu(Vt, fi, hr, wr, !0)
                    }
                }
                e: {
                    if (Lt = xt ? Hs(xt) : window,
                    rr = Lt.nodeName && Lt.nodeName.toLowerCase(),
                    rr === "select" || rr === "input" && Lt.type === "file")
                        var Pr = If;
                    else if (ph(Lt))
                        if (pd)
                            Pr = Rf;
                        else {
                            Pr = gd;
                            var Rr = md
                        }
                    else
                        (rr = Lt.nodeName) && rr.toLowerCase() === "input" && (Lt.type === "checkbox" || Lt.type === "radio") && (Pr = yd);
                    if (Pr && (Pr = Pr(h, xt))) {
                        Pl(Vt, Pr, S, Bt);
                        break e
                    }
                    Rr && Rr(h, Lt, xt),
                    h === "focusout" && (Rr = Lt._wrapperState) && Rr.controlled && Lt.type === "number" && gn(Lt, "number", Lt.value)
                }
                switch (Rr = xt ? Hs(xt) : window,
                h) {
                case "focusin":
                    (ph(Rr) || Rr.contentEditable === "true") && (ca = Rr,
                    fc = xt,
                    Na = null);
                    break;
                case "focusout":
                    Na = fc = ca = null;
                    break;
                case "mousedown":
                    xu = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    xu = !1,
                    $a(Vt, S, Bt);
                    break;
                case "selectionchange":
                    if (Of)
                        break;
                case "keydown":
                case "keyup":
                    $a(Vt, S, Bt)
                }
                var Ar;
                if (Fa)
                    e: {
                        switch (h) {
                        case "compositionstart":
                            var Lr = "onCompositionStart";
                            break e;
                        case "compositionend":
                            Lr = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            Lr = "onCompositionUpdate";
                            break e
                        }
                        Lr = void 0
                    }
                else
                    Ba ? hd(h, S) && (Lr = "onCompositionEnd") : h === "keydown" && S.keyCode === 229 && (Lr = "onCompositionStart");
                Lr && (kf && S.locale !== "ko" && (Ba || Lr !== "onCompositionStart" ? Lr === "onCompositionEnd" && Ba && (Ar = hs()) : (sa = Bt,
                Sl = "value"in sa ? sa.value : sa.textContent,
                Ba = !0)),
                Rr = Il(xt, Lr),
                0 < Rr.length && (Lr = new Cf(Lr,h,null,S,Bt),
                Vt.push({
                    event: Lr,
                    listeners: Rr
                }),
                Ar ? Lr.data = Ar : (Ar = dd(S),
                Ar !== null && (Lr.data = Ar)))),
                (Ar = Mf ? fd(h, S) : Tl(h, S)) && (xt = Il(xt, "onBeforeInput"),
                0 < xt.length && (Bt = new Cf("onBeforeInput","beforeinput",null,S,Bt),
                Vt.push({
                    event: Bt,
                    listeners: xt
                }),
                Bt.data = Ar))
            }
            Sd(Vt, g)
        })
    }
    function qa(h, g, S) {
        return {
            instance: h,
            listener: g,
            currentTarget: S
        }
    }
    function Il(h, g) {
        for (var S = g + "Capture", E = []; h !== null; ) {
            var F = h
              , W = F.stateNode;
            F.tag === 5 && W !== null && (F = W,
            W = br(h, S),
            W != null && E.unshift(qa(h, W, F)),
            W = br(h, g),
            W != null && E.push(qa(h, W, F))),
            h = h.return
        }
        return E
    }
    function Ws(h) {
        if (h === null)
            return null;
        do
            h = h.return;
        while (h && h.tag !== 5);
        return h || null
    }
    function Cu(h, g, S, E, F) {
        for (var W = g._reactName, pe = []; S !== null && S !== E; ) {
            var Fe = S
              , Je = Fe.alternate
              , xt = Fe.stateNode;
            if (Je !== null && Je === E)
                break;
            Fe.tag === 5 && xt !== null && (Fe = xt,
            F ? (Je = br(S, W),
            Je != null && pe.unshift(qa(S, Je, Fe))) : F || (Je = br(S, W),
            Je != null && pe.push(qa(S, Je, Fe)))),
            S = S.return
        }
        pe.length !== 0 && h.push({
            event: g,
            listeners: pe
        })
    }
    var Pd = /\r\n?/g
      , Tu = /\u0000|\uFFFD/g;
    function Rl(h) {
        return (typeof h == "string" ? h : "" + h).replace(Pd, `
`).replace(Tu, "")
    }
    function ha(h, g, S) {
        if (g = Rl(g),
        Rl(h) !== g && S)
            throw Error(i(425))
    }
    function Ha() {}
    var Pu = null
      , qs = null;
    function Md(h, g) {
        return h === "textarea" || h === "noscript" || typeof g.children == "string" || typeof g.children == "number" || typeof g.dangerouslySetInnerHTML == "object" && g.dangerouslySetInnerHTML !== null && g.dangerouslySetInnerHTML.__html != null
    }
    var vh = typeof setTimeout == "function" ? setTimeout : void 0
      , xh = typeof clearTimeout == "function" ? clearTimeout : void 0
      , bh = typeof Promise == "function" ? Promise : void 0
      , Ff = typeof queueMicrotask == "function" ? queueMicrotask : typeof bh < "u" ? function(h) {
        return bh.resolve(null).then(h).catch(Bf)
    }
    : vh;
    function Bf(h) {
        setTimeout(function() {
            throw h
        })
    }
    function Al(h, g) {
        var S = g
          , E = 0;
        do {
            var F = S.nextSibling;
            if (h.removeChild(S),
            F && F.nodeType === 8)
                if (S = F.data,
                S === "/$") {
                    if (E === 0) {
                        h.removeChild(F),
                        Cs(g);
                        return
                    }
                    E--
                } else
                    S !== "$" && S !== "$?" && S !== "$!" || E++;
            S = F
        } while (S);
        Cs(g)
    }
    function Ms(h) {
        for (; h != null; h = h.nextSibling) {
            var g = h.nodeType;
            if (g === 1 || g === 3)
                break;
            if (g === 8) {
                if (g = h.data,
                g === "$" || g === "$!" || g === "$?")
                    break;
                if (g === "/$")
                    return null
            }
        }
        return h
    }
    function Mu(h) {
        h = h.previousSibling;
        for (var g = 0; h; ) {
            if (h.nodeType === 8) {
                var S = h.data;
                if (S === "$" || S === "$!" || S === "$?") {
                    if (g === 0)
                        return h;
                    g--
                } else
                    S === "/$" && g++
            }
            h = h.previousSibling
        }
        return null
    }
    var zl = Math.random().toString(36).slice(2)
      , fn = "__reactFiber$" + zl
      , ds = "__reactProps$" + zl
      , gi = "__reactContainer$" + zl
      , yc = "__reactEvents$" + zl
      , ku = "__reactListeners$" + zl
      , _c = "__reactHandles$" + zl;
    function fs(h) {
        var g = h[fn];
        if (g)
            return g;
        for (var S = h.parentNode; S; ) {
            if (g = S[gi] || S[fn]) {
                if (S = g.alternate,
                g.child !== null || S !== null && S.child !== null)
                    for (h = Mu(h); h !== null; ) {
                        if (S = h[fn])
                            return S;
                        h = Mu(h)
                    }
                return g
            }
            h = S,
            S = h.parentNode
        }
        return null
    }
    function Dl(h) {
        return h = h[fn] || h[gi],
        !h || h.tag !== 5 && h.tag !== 6 && h.tag !== 13 && h.tag !== 3 ? null : h
    }
    function Hs(h) {
        if (h.tag === 5 || h.tag === 6)
            return h.stateNode;
        throw Error(i(33))
    }
    function vc(h) {
        return h[ds] || null
    }
    var wh = []
      , Ll = -1;
    function Yo(h) {
        return {
            current: h
        }
    }
    function wn(h) {
        0 > Ll || (h.current = wh[Ll],
        wh[Ll] = null,
        Ll--)
    }
    function tn(h, g) {
        Ll++,
        wh[Ll] = h.current,
        h.current = g
    }
    var Ri = {}
      , Ai = Yo(Ri)
      , _o = Yo(!1)
      , Za = Ri;
    function ks(h, g) {
        var S = h.type.contextTypes;
        if (!S)
            return Ri;
        var E = h.stateNode;
        if (E && E.__reactInternalMemoizedUnmaskedChildContext === g)
            return E.__reactInternalMemoizedMaskedChildContext;
        var F = {}, W;
        for (W in S)
            F[W] = g[W];
        return E && (h = h.stateNode,
        h.__reactInternalMemoizedUnmaskedChildContext = g,
        h.__reactInternalMemoizedMaskedChildContext = F),
        F
    }
    function to(h) {
        return h = h.childContextTypes,
        h != null
    }
    function Ol() {
        wn(_o),
        wn(Ai)
    }
    function kd(h, g, S) {
        if (Ai.current !== Ri)
            throw Error(i(168));
        tn(Ai, g),
        tn(_o, S)
    }
    function Eu(h, g, S) {
        var E = h.stateNode;
        if (g = g.childContextTypes,
        typeof E.getChildContext != "function")
            return S;
        E = E.getChildContext();
        for (var F in E)
            if (!(F in g))
                throw Error(i(108, tr(h) || "Unknown", F));
        return Pt({}, S, E)
    }
    function Fl(h) {
        return h = (h = h.stateNode) && h.__reactInternalMemoizedMergedChildContext || Ri,
        Za = Ai.current,
        tn(Ai, h),
        tn(_o, _o.current),
        !0
    }
    function Bl(h, g, S) {
        var E = h.stateNode;
        if (!E)
            throw Error(i(169));
        S ? (h = Eu(h, g, Za),
        E.__reactInternalMemoizedMergedChildContext = h,
        wn(_o),
        wn(Ai),
        tn(Ai, h)) : wn(_o),
        tn(_o, S)
    }
    var yi = null
      , Do = !1
      , Sh = !1;
    function ro(h) {
        yi === null ? yi = [h] : yi.push(h)
    }
    function xc(h) {
        Do = !0,
        ro(h)
    }
    function Xa() {
        if (!Sh && yi !== null) {
            Sh = !0;
            var h = 0
              , g = dn;
            try {
                var S = yi;
                for (dn = 1; h < S.length; h++) {
                    var E = S[h];
                    do
                        E = E(!0);
                    while (E !== null)
                }
                yi = null,
                Do = !1
            } catch (F) {
                throw yi !== null && (yi = yi.slice(h + 1)),
                lr(Si, Xa),
                F
            } finally {
                dn = g,
                Sh = !1
            }
        }
        return null
    }
    var da = []
      , bc = 0
      , wc = null
      , Ya = 0
      , Wi = []
      , hi = 0
      , Kt = null
      , Es = 1
      , Ko = "";
    function fa(h, g) {
        da[bc++] = Ya,
        da[bc++] = wc,
        wc = h,
        Ya = g
    }
    function Sc(h, g, S) {
        Wi[hi++] = Es,
        Wi[hi++] = Ko,
        Wi[hi++] = Kt,
        Kt = h;
        var E = Es;
        h = Ko;
        var F = 32 - Hn(E) - 1;
        E &= ~(1 << F),
        S += 1;
        var W = 32 - Hn(g) + F;
        if (30 < W) {
            var pe = F - F % 5;
            W = (E & (1 << pe) - 1).toString(32),
            E >>= pe,
            F -= pe,
            Es = 1 << 32 - Hn(g) + F | S << F | E,
            Ko = W + h
        } else
            Es = 1 << W | S << F | E,
            Ko = h
    }
    function Ka(h) {
        h.return !== null && (fa(h, 1),
        Sc(h, 1, 0))
    }
    function Iu(h) {
        for (; h === wc; )
            wc = da[--bc],
            da[bc] = null,
            Ya = da[--bc],
            da[bc] = null;
        for (; h === Kt; )
            Kt = Wi[--hi],
            Wi[hi] = null,
            Ko = Wi[--hi],
            Wi[hi] = null,
            Es = Wi[--hi],
            Wi[hi] = null
    }
    var Ir = null
      , vo = null
      , Xn = !1
      , Lo = null;
    function jf(h, g) {
        var S = Js(5, null, null, 0);
        S.elementType = "DELETED",
        S.stateNode = g,
        S.return = h,
        g = h.deletions,
        g === null ? (h.deletions = [S],
        h.flags |= 16) : g.push(S)
    }
    function Nf(h, g) {
        switch (h.tag) {
        case 5:
            var S = h.type;
            return g = g.nodeType !== 1 || S.toLowerCase() !== g.nodeName.toLowerCase() ? null : g,
            g !== null ? (h.stateNode = g,
            Ir = h,
            vo = Ms(g.firstChild),
            !0) : !1;
        case 6:
            return g = h.pendingProps === "" || g.nodeType !== 3 ? null : g,
            g !== null ? (h.stateNode = g,
            Ir = h,
            vo = null,
            !0) : !1;
        case 13:
            return g = g.nodeType !== 8 ? null : g,
            g !== null ? (S = Kt !== null ? {
                id: Es,
                overflow: Ko
            } : null,
            h.memoizedState = {
                dehydrated: g,
                treeContext: S,
                retryLane: 1073741824
            },
            S = Js(18, null, null, 0),
            S.stateNode = g,
            S.return = h,
            h.child = S,
            Ir = h,
            vo = null,
            !0) : !1;
        default:
            return !1
        }
    }
    function Ru(h) {
        return (h.mode & 1) !== 0 && (h.flags & 128) === 0
    }
    function Cc(h) {
        if (Xn) {
            var g = vo;
            if (g) {
                var S = g;
                if (!Nf(h, g)) {
                    if (Ru(h))
                        throw Error(i(418));
                    g = Ms(S.nextSibling);
                    var E = Ir;
                    g && Nf(h, g) ? jf(E, S) : (h.flags = h.flags & -4097 | 2,
                    Xn = !1,
                    Ir = h)
                }
            } else {
                if (Ru(h))
                    throw Error(i(418));
                h.flags = h.flags & -4097 | 2,
                Xn = !1,
                Ir = h
            }
        }
    }
    function Ch(h) {
        for (h = h.return; h !== null && h.tag !== 5 && h.tag !== 3 && h.tag !== 13; )
            h = h.return;
        Ir = h
    }
    function Au(h) {
        if (h !== Ir)
            return !1;
        if (!Xn)
            return Ch(h),
            Xn = !0,
            !1;
        var g;
        if ((g = h.tag !== 3) && !(g = h.tag !== 5) && (g = h.type,
        g = g !== "head" && g !== "body" && !Md(h.type, h.memoizedProps)),
        g && (g = vo)) {
            if (Ru(h))
                throw Tc(),
                Error(i(418));
            for (; g; )
                jf(h, g),
                g = Ms(g.nextSibling)
        }
        if (Ch(h),
        h.tag === 13) {
            if (h = h.memoizedState,
            h = h !== null ? h.dehydrated : null,
            !h)
                throw Error(i(317));
            e: {
                for (h = h.nextSibling,
                g = 0; h; ) {
                    if (h.nodeType === 8) {
                        var S = h.data;
                        if (S === "/$") {
                            if (g === 0) {
                                vo = Ms(h.nextSibling);
                                break e
                            }
                            g--
                        } else
                            S !== "$" && S !== "$!" && S !== "$?" || g++
                    }
                    h = h.nextSibling
                }
                vo = null
            }
        } else
            vo = Ir ? Ms(h.stateNode.nextSibling) : null;
        return !0
    }
    function Tc() {
        for (var h = vo; h; )
            h = Ms(h.nextSibling)
    }
    function Pc() {
        vo = Ir = null,
        Xn = !1
    }
    function zu(h) {
        Lo === null ? Lo = [h] : Lo.push(h)
    }
    var Qa = ce.ReactCurrentBatchConfig;
    function Mn(h, g, S) {
        if (h = S.ref,
        h !== null && typeof h != "function" && typeof h != "object") {
            if (S._owner) {
                if (S = S._owner,
                S) {
                    if (S.tag !== 1)
                        throw Error(i(309));
                    var E = S.stateNode
                }
                if (!E)
                    throw Error(i(147, h));
                var F = E
                  , W = "" + h;
                return g !== null && g.ref !== null && typeof g.ref == "function" && g.ref._stringRef === W ? g.ref : (g = function(pe) {
                    var Fe = F.refs;
                    pe === null ? delete Fe[W] : Fe[W] = pe
                }
                ,
                g._stringRef = W,
                g)
            }
            if (typeof h != "string")
                throw Error(i(284));
            if (!S._owner)
                throw Error(i(290, h))
        }
        return h
    }
    function Ja(h, g) {
        throw h = Object.prototype.toString.call(g),
        Error(i(31, h === "[object Object]" ? "object with keys {" + Object.keys(g).join(", ") + "}" : h))
    }
    function Du(h) {
        var g = h._init;
        return g(h._payload)
    }
    function Th(h) {
        function g(pt, rt) {
            if (h) {
                var gt = pt.deletions;
                gt === null ? (pt.deletions = [rt],
                pt.flags |= 16) : gt.push(rt)
            }
        }
        function S(pt, rt) {
            if (!h)
                return null;
            for (; rt !== null; )
                g(pt, rt),
                rt = rt.sibling;
            return null
        }
        function E(pt, rt) {
            for (pt = new Map; rt !== null; )
                rt.key !== null ? pt.set(rt.key, rt) : pt.set(rt.index, rt),
                rt = rt.sibling;
            return pt
        }
        function F(pt, rt) {
            return pt = Gl(pt, rt),
            pt.index = 0,
            pt.sibling = null,
            pt
        }
        function W(pt, rt, gt) {
            return pt.index = gt,
            h ? (gt = pt.alternate,
            gt !== null ? (gt = gt.index,
            gt < rt ? (pt.flags |= 2,
            rt) : gt) : (pt.flags |= 2,
            rt)) : (pt.flags |= 1048576,
            rt)
        }
        function pe(pt) {
            return h && pt.alternate === null && (pt.flags |= 2),
            pt
        }
        function Fe(pt, rt, gt, Zt) {
            return rt === null || rt.tag !== 6 ? (rt = np(gt, pt.mode, Zt),
            rt.return = pt,
            rt) : (rt = F(rt, gt),
            rt.return = pt,
            rt)
        }
        function Je(pt, rt, gt, Zt) {
            var Pr = gt.type;
            return Pr === K ? Bt(pt, rt, gt.props.children, Zt, gt.key) : rt !== null && (rt.elementType === Pr || typeof Pr == "object" && Pr !== null && Pr.$$typeof === ve && Du(Pr) === rt.type) ? (Zt = F(rt, gt.props),
            Zt.ref = Mn(pt, rt, gt),
            Zt.return = pt,
            Zt) : (Zt = rp(gt.type, gt.key, gt.props, null, pt.mode, Zt),
            Zt.ref = Mn(pt, rt, gt),
            Zt.return = pt,
            Zt)
        }
        function xt(pt, rt, gt, Zt) {
            return rt === null || rt.tag !== 4 || rt.stateNode.containerInfo !== gt.containerInfo || rt.stateNode.implementation !== gt.implementation ? (rt = $d(gt, pt.mode, Zt),
            rt.return = pt,
            rt) : (rt = F(rt, gt.children || []),
            rt.return = pt,
            rt)
        }
        function Bt(pt, rt, gt, Zt, Pr) {
            return rt === null || rt.tag !== 7 ? (rt = Ku(gt, pt.mode, Zt, Pr),
            rt.return = pt,
            rt) : (rt = F(rt, gt),
            rt.return = pt,
            rt)
        }
        function Vt(pt, rt, gt) {
            if (typeof rt == "string" && rt !== "" || typeof rt == "number")
                return rt = np("" + rt, pt.mode, gt),
                rt.return = pt,
                rt;
            if (typeof rt == "object" && rt !== null) {
                switch (rt.$$typeof) {
                case X:
                    return gt = rp(rt.type, rt.key, rt.props, null, pt.mode, gt),
                    gt.ref = Mn(pt, null, rt),
                    gt.return = pt,
                    gt;
                case me:
                    return rt = $d(rt, pt.mode, gt),
                    rt.return = pt,
                    rt;
                case ve:
                    var Zt = rt._init;
                    return Vt(pt, Zt(rt._payload), gt)
                }
                if (zr(rt) || lt(rt))
                    return rt = Ku(rt, pt.mode, gt, null),
                    rt.return = pt,
                    rt;
                Ja(pt, rt)
            }
            return null
        }
        function Lt(pt, rt, gt, Zt) {
            var Pr = rt !== null ? rt.key : null;
            if (typeof gt == "string" && gt !== "" || typeof gt == "number")
                return Pr !== null ? null : Fe(pt, rt, "" + gt, Zt);
            if (typeof gt == "object" && gt !== null) {
                switch (gt.$$typeof) {
                case X:
                    return gt.key === Pr ? Je(pt, rt, gt, Zt) : null;
                case me:
                    return gt.key === Pr ? xt(pt, rt, gt, Zt) : null;
                case ve:
                    return Pr = gt._init,
                    Lt(pt, rt, Pr(gt._payload), Zt)
                }
                if (zr(gt) || lt(gt))
                    return Pr !== null ? null : Bt(pt, rt, gt, Zt, null);
                Ja(pt, gt)
            }
            return null
        }
        function rr(pt, rt, gt, Zt, Pr) {
            if (typeof Zt == "string" && Zt !== "" || typeof Zt == "number")
                return pt = pt.get(gt) || null,
                Fe(rt, pt, "" + Zt, Pr);
            if (typeof Zt == "object" && Zt !== null) {
                switch (Zt.$$typeof) {
                case X:
                    return pt = pt.get(Zt.key === null ? gt : Zt.key) || null,
                    Je(rt, pt, Zt, Pr);
                case me:
                    return pt = pt.get(Zt.key === null ? gt : Zt.key) || null,
                    xt(rt, pt, Zt, Pr);
                case ve:
                    var Rr = Zt._init;
                    return rr(pt, rt, gt, Rr(Zt._payload), Pr)
                }
                if (zr(Zt) || lt(Zt))
                    return pt = pt.get(gt) || null,
                    Bt(rt, pt, Zt, Pr, null);
                Ja(rt, Zt)
            }
            return null
        }
        function hr(pt, rt, gt, Zt) {
            for (var Pr = null, Rr = null, Ar = rt, Lr = rt = 0, qi = null; Ar !== null && Lr < gt.length; Lr++) {
                Ar.index > Lr ? (qi = Ar,
                Ar = null) : qi = Ar.sibling;
                var xn = Lt(pt, Ar, gt[Lr], Zt);
                if (xn === null) {
                    Ar === null && (Ar = qi);
                    break
                }
                h && Ar && xn.alternate === null && g(pt, Ar),
                rt = W(xn, rt, Lr),
                Rr === null ? Pr = xn : Rr.sibling = xn,
                Rr = xn,
                Ar = qi
            }
            if (Lr === gt.length)
                return S(pt, Ar),
                Xn && fa(pt, Lr),
                Pr;
            if (Ar === null) {
                for (; Lr < gt.length; Lr++)
                    Ar = Vt(pt, gt[Lr], Zt),
                    Ar !== null && (rt = W(Ar, rt, Lr),
                    Rr === null ? Pr = Ar : Rr.sibling = Ar,
                    Rr = Ar);
                return Xn && fa(pt, Lr),
                Pr
            }
            for (Ar = E(pt, Ar); Lr < gt.length; Lr++)
                qi = rr(Ar, pt, Lr, gt[Lr], Zt),
                qi !== null && (h && qi.alternate !== null && Ar.delete(qi.key === null ? Lr : qi.key),
                rt = W(qi, rt, Lr),
                Rr === null ? Pr = qi : Rr.sibling = qi,
                Rr = qi);
            return h && Ar.forEach(function(sl) {
                return g(pt, sl)
            }),
            Xn && fa(pt, Lr),
            Pr
        }
        function wr(pt, rt, gt, Zt) {
            var Pr = lt(gt);
            if (typeof Pr != "function")
                throw Error(i(150));
            if (gt = Pr.call(gt),
            gt == null)
                throw Error(i(151));
            for (var Rr = Pr = null, Ar = rt, Lr = rt = 0, qi = null, xn = gt.next(); Ar !== null && !xn.done; Lr++,
            xn = gt.next()) {
                Ar.index > Lr ? (qi = Ar,
                Ar = null) : qi = Ar.sibling;
                var sl = Lt(pt, Ar, xn.value, Zt);
                if (sl === null) {
                    Ar === null && (Ar = qi);
                    break
                }
                h && Ar && sl.alternate === null && g(pt, Ar),
                rt = W(sl, rt, Lr),
                Rr === null ? Pr = sl : Rr.sibling = sl,
                Rr = sl,
                Ar = qi
            }
            if (xn.done)
                return S(pt, Ar),
                Xn && fa(pt, Lr),
                Pr;
            if (Ar === null) {
                for (; !xn.done; Lr++,
                xn = gt.next())
                    xn = Vt(pt, xn.value, Zt),
                    xn !== null && (rt = W(xn, rt, Lr),
                    Rr === null ? Pr = xn : Rr.sibling = xn,
                    Rr = xn);
                return Xn && fa(pt, Lr),
                Pr
            }
            for (Ar = E(pt, Ar); !xn.done; Lr++,
            xn = gt.next())
                xn = rr(Ar, pt, Lr, xn.value, Zt),
                xn !== null && (h && xn.alternate !== null && Ar.delete(xn.key === null ? Lr : xn.key),
                rt = W(xn, rt, Lr),
                Rr === null ? Pr = xn : Rr.sibling = xn,
                Rr = xn);
            return h && Ar.forEach(function($y) {
                return g(pt, $y)
            }),
            Xn && fa(pt, Lr),
            Pr
        }
        function fi(pt, rt, gt, Zt) {
            if (typeof gt == "object" && gt !== null && gt.type === K && gt.key === null && (gt = gt.props.children),
            typeof gt == "object" && gt !== null) {
                switch (gt.$$typeof) {
                case X:
                    e: {
                        for (var Pr = gt.key, Rr = rt; Rr !== null; ) {
                            if (Rr.key === Pr) {
                                if (Pr = gt.type,
                                Pr === K) {
                                    if (Rr.tag === 7) {
                                        S(pt, Rr.sibling),
                                        rt = F(Rr, gt.props.children),
                                        rt.return = pt,
                                        pt = rt;
                                        break e
                                    }
                                } else if (Rr.elementType === Pr || typeof Pr == "object" && Pr !== null && Pr.$$typeof === ve && Du(Pr) === Rr.type) {
                                    S(pt, Rr.sibling),
                                    rt = F(Rr, gt.props),
                                    rt.ref = Mn(pt, Rr, gt),
                                    rt.return = pt,
                                    pt = rt;
                                    break e
                                }
                                S(pt, Rr);
                                break
                            } else
                                g(pt, Rr);
                            Rr = Rr.sibling
                        }
                        gt.type === K ? (rt = Ku(gt.props.children, pt.mode, Zt, gt.key),
                        rt.return = pt,
                        pt = rt) : (Zt = rp(gt.type, gt.key, gt.props, null, pt.mode, Zt),
                        Zt.ref = Mn(pt, rt, gt),
                        Zt.return = pt,
                        pt = Zt)
                    }
                    return pe(pt);
                case me:
                    e: {
                        for (Rr = gt.key; rt !== null; ) {
                            if (rt.key === Rr)
                                if (rt.tag === 4 && rt.stateNode.containerInfo === gt.containerInfo && rt.stateNode.implementation === gt.implementation) {
                                    S(pt, rt.sibling),
                                    rt = F(rt, gt.children || []),
                                    rt.return = pt,
                                    pt = rt;
                                    break e
                                } else {
                                    S(pt, rt);
                                    break
                                }
                            else
                                g(pt, rt);
                            rt = rt.sibling
                        }
                        rt = $d(gt, pt.mode, Zt),
                        rt.return = pt,
                        pt = rt
                    }
                    return pe(pt);
                case ve:
                    return Rr = gt._init,
                    fi(pt, rt, Rr(gt._payload), Zt)
                }
                if (zr(gt))
                    return hr(pt, rt, gt, Zt);
                if (lt(gt))
                    return wr(pt, rt, gt, Zt);
                Ja(pt, gt)
            }
            return typeof gt == "string" && gt !== "" || typeof gt == "number" ? (gt = "" + gt,
            rt !== null && rt.tag === 6 ? (S(pt, rt.sibling),
            rt = F(rt, gt),
            rt.return = pt,
            pt = rt) : (S(pt, rt),
            rt = np(gt, pt.mode, Zt),
            rt.return = pt,
            pt = rt),
            pe(pt)) : S(pt, rt)
        }
        return fi
    }
    var jl = Th(!0)
      , Ed = Th(!1)
      , Ph = Yo(null)
      , Qo = null
      , pa = null
      , ir = null;
    function Cr() {
        ir = pa = Qo = null
    }
    function Mc(h) {
        var g = Ph.current;
        wn(Ph),
        h._currentValue = g
    }
    function Lu(h, g, S) {
        for (; h !== null; ) {
            var E = h.alternate;
            if ((h.childLanes & g) !== g ? (h.childLanes |= g,
            E !== null && (E.childLanes |= g)) : E !== null && (E.childLanes & g) !== g && (E.childLanes |= g),
            h === S)
                break;
            h = h.return
        }
    }
    function Zs(h, g) {
        Qo = h,
        ir = pa = null,
        h = h.dependencies,
        h !== null && h.firstContext !== null && ((h.lanes & g) !== 0 && (rs = !0),
        h.firstContext = null)
    }
    function Vn(h) {
        var g = h._currentValue;
        if (ir !== h)
            if (h = {
                context: h,
                memoizedValue: g,
                next: null
            },
            pa === null) {
                if (Qo === null)
                    throw Error(i(308));
                pa = h,
                Qo.dependencies = {
                    lanes: 0,
                    firstContext: h
                }
            } else
                pa = pa.next = h;
        return g
    }
    var el = null;
    function Ci(h) {
        el === null ? el = [h] : el.push(h)
    }
    function Id(h, g, S, E) {
        var F = g.interleaved;
        return F === null ? (S.next = S,
        Ci(g)) : (S.next = F.next,
        F.next = S),
        g.interleaved = S,
        xo(h, E)
    }
    function xo(h, g) {
        h.lanes |= g;
        var S = h.alternate;
        for (S !== null && (S.lanes |= g),
        S = h,
        h = h.return; h !== null; )
            h.childLanes |= g,
            S = h.alternate,
            S !== null && (S.childLanes |= g),
            S = h,
            h = h.return;
        return S.tag === 3 ? S.stateNode : null
    }
    var _n = !1;
    function Yn(h) {
        h.updateQueue = {
            baseState: h.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }
    function Rd(h, g) {
        h = h.updateQueue,
        g.updateQueue === h && (g.updateQueue = {
            baseState: h.baseState,
            firstBaseUpdate: h.firstBaseUpdate,
            lastBaseUpdate: h.lastBaseUpdate,
            shared: h.shared,
            effects: h.effects
        })
    }
    function no(h, g) {
        return {
            eventTime: h,
            lane: g,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function bo(h, g, S) {
        var E = h.updateQueue;
        if (E === null)
            return null;
        if (E = E.shared,
        (mn & 2) !== 0) {
            var F = E.pending;
            return F === null ? g.next = g : (g.next = F.next,
            F.next = g),
            E.pending = g,
            xo(h, S)
        }
        return F = E.interleaved,
        F === null ? (g.next = g,
        Ci(E)) : (g.next = F.next,
        F.next = g),
        E.interleaved = g,
        xo(h, S)
    }
    function kc(h, g, S) {
        if (g = g.updateQueue,
        g !== null && (g = g.shared,
        (S & 4194240) !== 0)) {
            var E = g.lanes;
            E &= h.pendingLanes,
            S |= E,
            g.lanes = S,
            ic(h, S)
        }
    }
    function Ou(h, g) {
        var S = h.updateQueue
          , E = h.alternate;
        if (E !== null && (E = E.updateQueue,
        S === E)) {
            var F = null
              , W = null;
            if (S = S.firstBaseUpdate,
            S !== null) {
                do {
                    var pe = {
                        eventTime: S.eventTime,
                        lane: S.lane,
                        tag: S.tag,
                        payload: S.payload,
                        callback: S.callback,
                        next: null
                    };
                    W === null ? F = W = pe : W = W.next = pe,
                    S = S.next
                } while (S !== null);
                W === null ? F = W = g : W = W.next = g
            } else
                F = W = g;
            S = {
                baseState: E.baseState,
                firstBaseUpdate: F,
                lastBaseUpdate: W,
                shared: E.shared,
                effects: E.effects
            },
            h.updateQueue = S;
            return
        }
        h = S.lastBaseUpdate,
        h === null ? S.firstBaseUpdate = g : h.next = g,
        S.lastBaseUpdate = g
    }
    function Xs(h, g, S, E) {
        var F = h.updateQueue;
        _n = !1;
        var W = F.firstBaseUpdate
          , pe = F.lastBaseUpdate
          , Fe = F.shared.pending;
        if (Fe !== null) {
            F.shared.pending = null;
            var Je = Fe
              , xt = Je.next;
            Je.next = null,
            pe === null ? W = xt : pe.next = xt,
            pe = Je;
            var Bt = h.alternate;
            Bt !== null && (Bt = Bt.updateQueue,
            Fe = Bt.lastBaseUpdate,
            Fe !== pe && (Fe === null ? Bt.firstBaseUpdate = xt : Fe.next = xt,
            Bt.lastBaseUpdate = Je))
        }
        if (W !== null) {
            var Vt = F.baseState;
            pe = 0,
            Bt = xt = Je = null,
            Fe = W;
            do {
                var Lt = Fe.lane
                  , rr = Fe.eventTime;
                if ((E & Lt) === Lt) {
                    Bt !== null && (Bt = Bt.next = {
                        eventTime: rr,
                        lane: 0,
                        tag: Fe.tag,
                        payload: Fe.payload,
                        callback: Fe.callback,
                        next: null
                    });
                    e: {
                        var hr = h
                          , wr = Fe;
                        switch (Lt = g,
                        rr = S,
                        wr.tag) {
                        case 1:
                            if (hr = wr.payload,
                            typeof hr == "function") {
                                Vt = hr.call(rr, Vt, Lt);
                                break e
                            }
                            Vt = hr;
                            break e;
                        case 3:
                            hr.flags = hr.flags & -65537 | 128;
                        case 0:
                            if (hr = wr.payload,
                            Lt = typeof hr == "function" ? hr.call(rr, Vt, Lt) : hr,
                            Lt == null)
                                break e;
                            Vt = Pt({}, Vt, Lt);
                            break e;
                        case 2:
                            _n = !0
                        }
                    }
                    Fe.callback !== null && Fe.lane !== 0 && (h.flags |= 64,
                    Lt = F.effects,
                    Lt === null ? F.effects = [Fe] : Lt.push(Fe))
                } else
                    rr = {
                        eventTime: rr,
                        lane: Lt,
                        tag: Fe.tag,
                        payload: Fe.payload,
                        callback: Fe.callback,
                        next: null
                    },
                    Bt === null ? (xt = Bt = rr,
                    Je = Vt) : Bt = Bt.next = rr,
                    pe |= Lt;
                if (Fe = Fe.next,
                Fe === null) {
                    if (Fe = F.shared.pending,
                    Fe === null)
                        break;
                    Lt = Fe,
                    Fe = Lt.next,
                    Lt.next = null,
                    F.lastBaseUpdate = Lt,
                    F.shared.pending = null
                }
            } while (!0);
            if (Bt === null && (Je = Vt),
            F.baseState = Je,
            F.firstBaseUpdate = xt,
            F.lastBaseUpdate = Bt,
            g = F.shared.interleaved,
            g !== null) {
                F = g;
                do
                    pe |= F.lane,
                    F = F.next;
                while (F !== g)
            } else
                W === null && (F.shared.lanes = 0);
            Bc |= pe,
            h.lanes = pe,
            h.memoizedState = Vt
        }
    }
    function Ec(h, g, S) {
        if (h = g.effects,
        g.effects = null,
        h !== null)
            for (g = 0; g < h.length; g++) {
                var E = h[g]
                  , F = E.callback;
                if (F !== null) {
                    if (E.callback = null,
                    E = S,
                    typeof F != "function")
                        throw Error(i(191, F));
                    F.call(E)
                }
            }
    }
    var Nl = {}
      , Jo = Yo(Nl)
      , $l = Yo(Nl)
      , v = Yo(Nl);
    function r(h) {
        if (h === Nl)
            throw Error(i(174));
        return h
    }
    function a(h, g) {
        switch (tn(v, g),
        tn($l, h),
        tn(Jo, Nl),
        h = g.nodeType,
        h) {
        case 9:
        case 11:
            g = (g = g.documentElement) ? g.namespaceURI : sn(null, "");
            break;
        default:
            h = h === 8 ? g.parentNode : g,
            g = h.namespaceURI || null,
            h = h.tagName,
            g = sn(g, h)
        }
        wn(Jo),
        tn(Jo, g)
    }
    function m() {
        wn(Jo),
        wn($l),
        wn(v)
    }
    function y(h) {
        r(v.current);
        var g = r(Jo.current)
          , S = sn(g, h.type);
        g !== S && (tn($l, h),
        tn(Jo, S))
    }
    function x(h) {
        $l.current === h && (wn(Jo),
        wn($l))
    }
    var P = Yo(0);
    function I(h) {
        for (var g = h; g !== null; ) {
            if (g.tag === 13) {
                var S = g.memoizedState;
                if (S !== null && (S = S.dehydrated,
                S === null || S.data === "$?" || S.data === "$!"))
                    return g
            } else if (g.tag === 19 && g.memoizedProps.revealOrder !== void 0) {
                if ((g.flags & 128) !== 0)
                    return g
            } else if (g.child !== null) {
                g.child.return = g,
                g = g.child;
                continue
            }
            if (g === h)
                break;
            for (; g.sibling === null; ) {
                if (g.return === null || g.return === h)
                    return null;
                g = g.return
            }
            g.sibling.return = g.return,
            g = g.sibling
        }
        return null
    }
    var A = [];
    function B() {
        for (var h = 0; h < A.length; h++)
            A[h]._workInProgressVersionPrimary = null;
        A.length = 0
    }
    var $ = ce.ReactCurrentDispatcher
      , Z = ce.ReactCurrentBatchConfig
      , H = 0
      , Y = null
      , ae = null
      , ye = null
      , Se = !1
      , Te = !1
      , Re = 0
      , De = 0;
    function Ae() {
        throw Error(i(321))
    }
    function Be(h, g) {
        if (g === null)
            return !1;
        for (var S = 0; S < g.length && S < h.length; S++)
            if (!Gi(h[S], g[S]))
                return !1;
        return !0
    }
    function qe(h, g, S, E, F, W) {
        if (H = W,
        Y = g,
        g.memoizedState = null,
        g.updateQueue = null,
        g.lanes = 0,
        $.current = h === null || h.memoizedState === null ? Pi : $f,
        h = S(E, F),
        Te) {
            W = 0;
            do {
                if (Te = !1,
                Re = 0,
                25 <= W)
                    throw Error(i(301));
                W += 1,
                ye = ae = null,
                g.updateQueue = null,
                $.current = cm,
                h = S(E, F)
            } while (Te)
        }
        if ($.current = Li,
        g = ae !== null && ae.next !== null,
        H = 0,
        ye = ae = Y = null,
        Se = !1,
        g)
            throw Error(i(300));
        return h
    }
    function ze() {
        var h = Re !== 0;
        return Re = 0,
        h
    }
    function Ke() {
        var h = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return ye === null ? Y.memoizedState = ye = h : ye = ye.next = h,
        ye
    }
    function ht() {
        if (ae === null) {
            var h = Y.alternate;
            h = h !== null ? h.memoizedState : null
        } else
            h = ae.next;
        var g = ye === null ? Y.memoizedState : ye.next;
        if (g !== null)
            ye = g,
            ae = h;
        else {
            if (h === null)
                throw Error(i(310));
            ae = h,
            h = {
                memoizedState: ae.memoizedState,
                baseState: ae.baseState,
                baseQueue: ae.baseQueue,
                queue: ae.queue,
                next: null
            },
            ye === null ? Y.memoizedState = ye = h : ye = ye.next = h
        }
        return ye
    }
    function ot(h, g) {
        return typeof g == "function" ? g(h) : g
    }
    function ut(h) {
        var g = ht()
          , S = g.queue;
        if (S === null)
            throw Error(i(311));
        S.lastRenderedReducer = h;
        var E = ae
          , F = E.baseQueue
          , W = S.pending;
        if (W !== null) {
            if (F !== null) {
                var pe = F.next;
                F.next = W.next,
                W.next = pe
            }
            E.baseQueue = F = W,
            S.pending = null
        }
        if (F !== null) {
            W = F.next,
            E = E.baseState;
            var Fe = pe = null
              , Je = null
              , xt = W;
            do {
                var Bt = xt.lane;
                if ((H & Bt) === Bt)
                    Je !== null && (Je = Je.next = {
                        lane: 0,
                        action: xt.action,
                        hasEagerState: xt.hasEagerState,
                        eagerState: xt.eagerState,
                        next: null
                    }),
                    E = xt.hasEagerState ? xt.eagerState : h(E, xt.action);
                else {
                    var Vt = {
                        lane: Bt,
                        action: xt.action,
                        hasEagerState: xt.hasEagerState,
                        eagerState: xt.eagerState,
                        next: null
                    };
                    Je === null ? (Fe = Je = Vt,
                    pe = E) : Je = Je.next = Vt,
                    Y.lanes |= Bt,
                    Bc |= Bt
                }
                xt = xt.next
            } while (xt !== null && xt !== W);
            Je === null ? pe = E : Je.next = Fe,
            Gi(E, g.memoizedState) || (rs = !0),
            g.memoizedState = E,
            g.baseState = pe,
            g.baseQueue = Je,
            S.lastRenderedState = E
        }
        if (h = S.interleaved,
        h !== null) {
            F = h;
            do
                W = F.lane,
                Y.lanes |= W,
                Bc |= W,
                F = F.next;
            while (F !== h)
        } else
            F === null && (S.lanes = 0);
        return [g.memoizedState, S.dispatch]
    }
    function mt(h) {
        var g = ht()
          , S = g.queue;
        if (S === null)
            throw Error(i(311));
        S.lastRenderedReducer = h;
        var E = S.dispatch
          , F = S.pending
          , W = g.memoizedState;
        if (F !== null) {
            S.pending = null;
            var pe = F = F.next;
            do
                W = h(W, pe.action),
                pe = pe.next;
            while (pe !== F);
            Gi(W, g.memoizedState) || (rs = !0),
            g.memoizedState = W,
            g.baseQueue === null && (g.baseState = W),
            S.lastRenderedState = W
        }
        return [W, E]
    }
    function $t() {}
    function jt(h, g) {
        var S = Y
          , E = ht()
          , F = g()
          , W = !Gi(E.memoizedState, F);
        if (W && (E.memoizedState = F,
        rs = !0),
        E = E.queue,
        rn(Vr.bind(null, S, E, h), [h]),
        E.getSnapshot !== g || W || ye !== null && ye.memoizedState.tag & 1) {
            if (S.flags |= 2048,
            On(9, or.bind(null, S, E, F, g), void 0, null),
            _i === null)
                throw Error(i(349));
            (H & 30) !== 0 || It(S, g, F)
        }
        return F
    }
    function It(h, g, S) {
        h.flags |= 16384,
        h = {
            getSnapshot: g,
            value: S
        },
        g = Y.updateQueue,
        g === null ? (g = {
            lastEffect: null,
            stores: null
        },
        Y.updateQueue = g,
        g.stores = [h]) : (S = g.stores,
        S === null ? g.stores = [h] : S.push(h))
    }
    function or(h, g, S, E) {
        g.value = S,
        g.getSnapshot = E,
        cn(g) && Kn(h)
    }
    function Vr(h, g, S) {
        return S(function() {
            cn(g) && Kn(h)
        })
    }
    function cn(h) {
        var g = h.getSnapshot;
        h = h.value;
        try {
            var S = g();
            return !Gi(h, S)
        } catch {
            return !0
        }
    }
    function Kn(h) {
        var g = xo(h, 1);
        g !== null && ps(g, h, 1, -1)
    }
    function Sn(h) {
        var g = Ke();
        return typeof h == "function" && (h = h()),
        g.memoizedState = g.baseState = h,
        h = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: ot,
            lastRenderedState: h
        },
        g.queue = h,
        h = h.dispatch = tl.bind(null, Y, h),
        [g.memoizedState, h]
    }
    function On(h, g, S, E) {
        return h = {
            tag: h,
            create: g,
            destroy: S,
            deps: E,
            next: null
        },
        g = Y.updateQueue,
        g === null ? (g = {
            lastEffect: null,
            stores: null
        },
        Y.updateQueue = g,
        g.lastEffect = h.next = h) : (S = g.lastEffect,
        S === null ? g.lastEffect = h.next = h : (E = S.next,
        S.next = h,
        h.next = E,
        g.lastEffect = h)),
        h
    }
    function kn() {
        return ht().memoizedState
    }
    function pn(h, g, S, E) {
        var F = Ke();
        Y.flags |= h,
        F.memoizedState = On(1 | g, S, void 0, E === void 0 ? null : E)
    }
    function vn(h, g, S, E) {
        var F = ht();
        E = E === void 0 ? null : E;
        var W = void 0;
        if (ae !== null) {
            var pe = ae.memoizedState;
            if (W = pe.destroy,
            E !== null && Be(E, pe.deps)) {
                F.memoizedState = On(g, S, W, E);
                return
            }
        }
        Y.flags |= h,
        F.memoizedState = On(1 | g, S, W, E)
    }
    function zi(h, g) {
        return pn(8390656, 8, h, g)
    }
    function rn(h, g) {
        return vn(2048, 8, h, g)
    }
    function Ti(h, g) {
        return vn(4, 2, h, g)
    }
    function Di(h, g) {
        return vn(4, 4, h, g)
    }
    function ma(h, g) {
        if (typeof g == "function")
            return h = h(),
            g(h),
            function() {
                g(null)
            }
            ;
        if (g != null)
            return h = h(),
            g.current = h,
            function() {
                g.current = null
            }
    }
    function ga(h, g, S) {
        return S = S != null ? S.concat([h]) : null,
        vn(4, 4, ma.bind(null, g, h), S)
    }
    function Ys() {}
    function Is(h, g) {
        var S = ht();
        g = g === void 0 ? null : g;
        var E = S.memoizedState;
        return E !== null && g !== null && Be(g, E[1]) ? E[0] : (S.memoizedState = [h, g],
        h)
    }
    function Ic(h, g) {
        var S = ht();
        g = g === void 0 ? null : g;
        var E = S.memoizedState;
        return E !== null && g !== null && Be(g, E[1]) ? E[0] : (h = h(),
        S.memoizedState = [h, g],
        h)
    }
    function Rc(h, g, S) {
        return (H & 21) === 0 ? (h.baseState && (h.baseState = !1,
        rs = !0),
        h.memoizedState = S) : (Gi(S, g) || (S = Ki(),
        Y.lanes |= S,
        Bc |= S,
        h.baseState = !0),
        g)
    }
    function Ac(h, g) {
        var S = dn;
        dn = S !== 0 && 4 > S ? S : 4,
        h(!0);
        var E = Z.transition;
        Z.transition = {};
        try {
            h(!1),
            g()
        } finally {
            dn = S,
            Z.transition = E
        }
    }
    function wo() {
        return ht().memoizedState
    }
    function Rs(h, g, S) {
        var E = Ul(h);
        if (S = {
            lane: E,
            action: S,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        rl(h))
            ti(g, S);
        else if (S = Id(h, g, S, E),
        S !== null) {
            var F = jo();
            ps(S, h, E, F),
            Bn(S, g, E)
        }
    }
    function tl(h, g, S) {
        var E = Ul(h)
          , F = {
            lane: E,
            action: S,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (rl(h))
            ti(g, F);
        else {
            var W = h.alternate;
            if (h.lanes === 0 && (W === null || W.lanes === 0) && (W = g.lastRenderedReducer,
            W !== null))
                try {
                    var pe = g.lastRenderedState
                      , Fe = W(pe, S);
                    if (F.hasEagerState = !0,
                    F.eagerState = Fe,
                    Gi(Fe, pe)) {
                        var Je = g.interleaved;
                        Je === null ? (F.next = F,
                        Ci(g)) : (F.next = Je.next,
                        Je.next = F),
                        g.interleaved = F;
                        return
                    }
                } catch {} finally {}
            S = Id(h, g, F, E),
            S !== null && (F = jo(),
            ps(S, h, E, F),
            Bn(S, g, E))
        }
    }
    function rl(h) {
        var g = h.alternate;
        return h === Y || g !== null && g === Y
    }
    function ti(h, g) {
        Te = Se = !0;
        var S = h.pending;
        S === null ? g.next = g : (g.next = S.next,
        S.next = g),
        h.pending = g
    }
    function Bn(h, g, S) {
        if ((S & 4194240) !== 0) {
            var E = g.lanes;
            E &= h.pendingLanes,
            S |= E,
            g.lanes = S,
            ic(h, S)
        }
    }
    var Li = {
        readContext: Vn,
        useCallback: Ae,
        useContext: Ae,
        useEffect: Ae,
        useImperativeHandle: Ae,
        useInsertionEffect: Ae,
        useLayoutEffect: Ae,
        useMemo: Ae,
        useReducer: Ae,
        useRef: Ae,
        useState: Ae,
        useDebugValue: Ae,
        useDeferredValue: Ae,
        useTransition: Ae,
        useMutableSource: Ae,
        useSyncExternalStore: Ae,
        useId: Ae,
        unstable_isNewReconciler: !1
    }
      , Pi = {
        readContext: Vn,
        useCallback: function(h, g) {
            return Ke().memoizedState = [h, g === void 0 ? null : g],
            h
        },
        useContext: Vn,
        useEffect: zi,
        useImperativeHandle: function(h, g, S) {
            return S = S != null ? S.concat([h]) : null,
            pn(4194308, 4, ma.bind(null, g, h), S)
        },
        useLayoutEffect: function(h, g) {
            return pn(4194308, 4, h, g)
        },
        useInsertionEffect: function(h, g) {
            return pn(4, 2, h, g)
        },
        useMemo: function(h, g) {
            var S = Ke();
            return g = g === void 0 ? null : g,
            h = h(),
            S.memoizedState = [h, g],
            h
        },
        useReducer: function(h, g, S) {
            var E = Ke();
            return g = S !== void 0 ? S(g) : g,
            E.memoizedState = E.baseState = g,
            h = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: h,
                lastRenderedState: g
            },
            E.queue = h,
            h = h.dispatch = Rs.bind(null, Y, h),
            [E.memoizedState, h]
        },
        useRef: function(h) {
            var g = Ke();
            return h = {
                current: h
            },
            g.memoizedState = h
        },
        useState: Sn,
        useDebugValue: Ys,
        useDeferredValue: function(h) {
            return Ke().memoizedState = h
        },
        useTransition: function() {
            var h = Sn(!1)
              , g = h[0];
            return h = Ac.bind(null, h[1]),
            Ke().memoizedState = h,
            [g, h]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(h, g, S) {
            var E = Y
              , F = Ke();
            if (Xn) {
                if (S === void 0)
                    throw Error(i(407));
                S = S()
            } else {
                if (S = g(),
                _i === null)
                    throw Error(i(349));
                (H & 30) !== 0 || It(E, g, S)
            }
            F.memoizedState = S;
            var W = {
                value: S,
                getSnapshot: g
            };
            return F.queue = W,
            zi(Vr.bind(null, E, W, h), [h]),
            E.flags |= 2048,
            On(9, or.bind(null, E, W, S, g), void 0, null),
            S
        },
        useId: function() {
            var h = Ke()
              , g = _i.identifierPrefix;
            if (Xn) {
                var S = Ko
                  , E = Es;
                S = (E & ~(1 << 32 - Hn(E) - 1)).toString(32) + S,
                g = ":" + g + "R" + S,
                S = Re++,
                0 < S && (g += "H" + S.toString(32)),
                g += ":"
            } else
                S = De++,
                g = ":" + g + "r" + S.toString(32) + ":";
            return h.memoizedState = g
        },
        unstable_isNewReconciler: !1
    }
      , $f = {
        readContext: Vn,
        useCallback: Is,
        useContext: Vn,
        useEffect: rn,
        useImperativeHandle: ga,
        useInsertionEffect: Ti,
        useLayoutEffect: Di,
        useMemo: Ic,
        useReducer: ut,
        useRef: kn,
        useState: function() {
            return ut(ot)
        },
        useDebugValue: Ys,
        useDeferredValue: function(h) {
            var g = ht();
            return Rc(g, ae.memoizedState, h)
        },
        useTransition: function() {
            var h = ut(ot)[0]
              , g = ht().memoizedState;
            return [h, g]
        },
        useMutableSource: $t,
        useSyncExternalStore: jt,
        useId: wo,
        unstable_isNewReconciler: !1
    }
      , cm = {
        readContext: Vn,
        useCallback: Is,
        useContext: Vn,
        useEffect: rn,
        useImperativeHandle: ga,
        useInsertionEffect: Ti,
        useLayoutEffect: Di,
        useMemo: Ic,
        useReducer: mt,
        useRef: kn,
        useState: function() {
            return mt(ot)
        },
        useDebugValue: Ys,
        useDeferredValue: function(h) {
            var g = ht();
            return ae === null ? g.memoizedState = h : Rc(g, ae.memoizedState, h)
        },
        useTransition: function() {
            var h = mt(ot)[0]
              , g = ht().memoizedState;
            return [h, g]
        },
        useMutableSource: $t,
        useSyncExternalStore: jt,
        useId: wo,
        unstable_isNewReconciler: !1
    };
    function es(h, g) {
        if (h && h.defaultProps) {
            g = Pt({}, g),
            h = h.defaultProps;
            for (var S in h)
                g[S] === void 0 && (g[S] = h[S]);
            return g
        }
        return g
    }
    function Vl(h, g, S, E) {
        g = h.memoizedState,
        S = S(E, g),
        S = S == null ? g : Pt({}, g, S),
        h.memoizedState = S,
        h.lanes === 0 && (h.updateQueue.baseState = S)
    }
    var ya = {
        isMounted: function(h) {
            return (h = h._reactInternals) ? it(h) === h : !1
        },
        enqueueSetState: function(h, g, S) {
            h = h._reactInternals;
            var E = jo()
              , F = Ul(h)
              , W = no(E, F);
            W.payload = g,
            S != null && (W.callback = S),
            g = bo(h, W, F),
            g !== null && (ps(g, h, F, E),
            kc(g, h, F))
        },
        enqueueReplaceState: function(h, g, S) {
            h = h._reactInternals;
            var E = jo()
              , F = Ul(h)
              , W = no(E, F);
            W.tag = 1,
            W.payload = g,
            S != null && (W.callback = S),
            g = bo(h, W, F),
            g !== null && (ps(g, h, F, E),
            kc(g, h, F))
        },
        enqueueForceUpdate: function(h, g) {
            h = h._reactInternals;
            var S = jo()
              , E = Ul(h)
              , F = no(S, E);
            F.tag = 2,
            g != null && (F.callback = g),
            g = bo(h, F, E),
            g !== null && (ps(g, h, E, S),
            kc(g, h, E))
        }
    };
    function Ks(h, g, S, E, F, W, pe) {
        return h = h.stateNode,
        typeof h.shouldComponentUpdate == "function" ? h.shouldComponentUpdate(E, W, pe) : g.prototype && g.prototype.isPureReactComponent ? !Ml(S, E) || !Ml(F, W) : !0
    }
    function Oi(h, g, S) {
        var E = !1
          , F = Ri
          , W = g.contextType;
        return typeof W == "object" && W !== null ? W = Vn(W) : (F = to(g) ? Za : Ai.current,
        E = g.contextTypes,
        W = (E = E != null) ? ks(h, F) : Ri),
        g = new g(S,W),
        h.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null,
        g.updater = ya,
        h.stateNode = g,
        g._reactInternals = h,
        E && (h = h.stateNode,
        h.__reactInternalMemoizedUnmaskedChildContext = F,
        h.__reactInternalMemoizedMaskedChildContext = W),
        g
    }
    function Qs(h, g, S, E) {
        h = g.state,
        typeof g.componentWillReceiveProps == "function" && g.componentWillReceiveProps(S, E),
        typeof g.UNSAFE_componentWillReceiveProps == "function" && g.UNSAFE_componentWillReceiveProps(S, E),
        g.state !== h && ya.enqueueReplaceState(g, g.state, null)
    }
    function Fu(h, g, S, E) {
        var F = h.stateNode;
        F.props = S,
        F.state = h.memoizedState,
        F.refs = {},
        Yn(h);
        var W = g.contextType;
        typeof W == "object" && W !== null ? F.context = Vn(W) : (W = to(g) ? Za : Ai.current,
        F.context = ks(h, W)),
        F.state = h.memoizedState,
        W = g.getDerivedStateFromProps,
        typeof W == "function" && (Vl(h, g, W, S),
        F.state = h.memoizedState),
        typeof g.getDerivedStateFromProps == "function" || typeof F.getSnapshotBeforeUpdate == "function" || typeof F.UNSAFE_componentWillMount != "function" && typeof F.componentWillMount != "function" || (g = F.state,
        typeof F.componentWillMount == "function" && F.componentWillMount(),
        typeof F.UNSAFE_componentWillMount == "function" && F.UNSAFE_componentWillMount(),
        g !== F.state && ya.enqueueReplaceState(F, F.state, null),
        Xs(h, S, F, E),
        F.state = h.memoizedState),
        typeof F.componentDidMount == "function" && (h.flags |= 4194308)
    }
    function ts(h, g) {
        try {
            var S = ""
              , E = g;
            do
                S += Qt(E),
                E = E.return;
            while (E);
            var F = S
        } catch (W) {
            F = `
Error generating stack: ` + W.message + `
` + W.stack
        }
        return {
            value: h,
            source: g,
            stack: F,
            digest: null
        }
    }
    function Bu(h, g, S) {
        return {
            value: h,
            source: null,
            stack: S ?? null,
            digest: g ?? null
        }
    }
    function ju(h, g) {
        try {
            console.error(g.value)
        } catch (S) {
            setTimeout(function() {
                throw S
            })
        }
    }
    var Nu = typeof WeakMap == "function" ? WeakMap : Map;
    function um(h, g, S) {
        S = no(-1, S),
        S.tag = 3,
        S.payload = {
            element: null
        };
        var E = g.value;
        return S.callback = function() {
            Jf || (Jf = !0,
            Cm = E),
            ju(h, g)
        }
        ,
        S
    }
    function zc(h, g, S) {
        S = no(-1, S),
        S.tag = 3;
        var E = h.type.getDerivedStateFromError;
        if (typeof E == "function") {
            var F = g.value;
            S.payload = function() {
                return E(F)
            }
            ,
            S.callback = function() {
                ju(h, g)
            }
        }
        var W = h.stateNode;
        return W !== null && typeof W.componentDidCatch == "function" && (S.callback = function() {
            ju(h, g),
            typeof E != "function" && (jc === null ? jc = new Set([this]) : jc.add(this));
            var pe = g.stack;
            this.componentDidCatch(g.value, {
                componentStack: pe !== null ? pe : ""
            })
        }
        ),
        S
    }
    function Dc(h, g, S) {
        var E = h.pingCache;
        if (E === null) {
            E = h.pingCache = new Nu;
            var F = new Set;
            E.set(g, F)
        } else
            F = E.get(g),
            F === void 0 && (F = new Set,
            E.set(g, F));
        F.has(S) || (F.add(S),
        h = zy.bind(null, h, g, S),
        g.then(h, h))
    }
    function hm(h) {
        do {
            var g;
            if ((g = h.tag === 13) && (g = h.memoizedState,
            g = g !== null ? g.dehydrated !== null : !0),
            g)
                return h;
            h = h.return
        } while (h !== null);
        return null
    }
    function _y(h, g, S, E, F) {
        return (h.mode & 1) === 0 ? (h === g ? h.flags |= 65536 : (h.flags |= 128,
        S.flags |= 131072,
        S.flags &= -52805,
        S.tag === 1 && (S.alternate === null ? S.tag = 17 : (g = no(-1, 1),
        g.tag = 2,
        bo(S, g, 1))),
        S.lanes |= 1),
        h) : (h.flags |= 65536,
        h.lanes = F,
        h)
    }
    var dm = ce.ReactCurrentOwner
      , rs = !1;
    function ns(h, g, S, E) {
        g.child = h === null ? Ed(g, null, S, E) : jl(g, h.child, S, E)
    }
    function fm(h, g, S, E, F) {
        S = S.render;
        var W = g.ref;
        return Zs(g, F),
        E = qe(h, g, S, E, W, F),
        S = ze(),
        h !== null && !rs ? (g.updateQueue = h.updateQueue,
        g.flags &= -2053,
        h.lanes &= ~F,
        _a(h, g, F)) : (Xn && S && Ka(g),
        g.flags |= 1,
        ns(h, g, E, F),
        g.child)
    }
    function vy(h, g, S, E, F) {
        if (h === null) {
            var W = S.type;
            return typeof W == "function" && !Rm(W) && W.defaultProps === void 0 && S.compare === null && S.defaultProps === void 0 ? (g.tag = 15,
            g.type = W,
            Vf(h, g, W, E, F)) : (h = rp(S.type, null, E, g, g.mode, F),
            h.ref = g.ref,
            h.return = g,
            g.child = h)
        }
        if (W = h.child,
        (h.lanes & F) === 0) {
            var pe = W.memoizedProps;
            if (S = S.compare,
            S = S !== null ? S : Ml,
            S(pe, E) && h.ref === g.ref)
                return _a(h, g, F)
        }
        return g.flags |= 1,
        h = Gl(W, E),
        h.ref = g.ref,
        h.return = g,
        g.child = h
    }
    function Vf(h, g, S, E, F) {
        if (h !== null) {
            var W = h.memoizedProps;
            if (Ml(W, E) && h.ref === g.ref)
                if (rs = !1,
                g.pendingProps = E = W,
                (h.lanes & F) !== 0)
                    (h.flags & 131072) !== 0 && (rs = !0);
                else
                    return g.lanes = h.lanes,
                    _a(h, g, F)
        }
        return Gf(h, g, S, E, F)
    }
    function xy(h, g, S) {
        var E = g.pendingProps
          , F = E.children
          , W = h !== null ? h.memoizedState : null;
        if (E.mode === "hidden")
            if ((g.mode & 1) === 0)
                g.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                },
                tn(ba, Bo),
                Bo |= S;
            else {
                if ((S & 1073741824) === 0)
                    return h = W !== null ? W.baseLanes | S : S,
                    g.lanes = g.childLanes = 1073741824,
                    g.memoizedState = {
                        baseLanes: h,
                        cachePool: null,
                        transitions: null
                    },
                    g.updateQueue = null,
                    tn(ba, Bo),
                    Bo |= h,
                    null;
                g.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                },
                E = W !== null ? W.baseLanes : S,
                tn(ba, Bo),
                Bo |= E
            }
        else
            W !== null ? (E = W.baseLanes | S,
            g.memoizedState = null) : E = S,
            tn(ba, Bo),
            Bo |= E;
        return ns(h, g, F, S),
        g.child
    }
    function Uf(h, g) {
        var S = g.ref;
        (h === null && S !== null || h !== null && h.ref !== S) && (g.flags |= 512,
        g.flags |= 2097152)
    }
    function Gf(h, g, S, E, F) {
        var W = to(S) ? Za : Ai.current;
        return W = ks(g, W),
        Zs(g, F),
        S = qe(h, g, S, E, W, F),
        E = ze(),
        h !== null && !rs ? (g.updateQueue = h.updateQueue,
        g.flags &= -2053,
        h.lanes &= ~F,
        _a(h, g, F)) : (Xn && E && Ka(g),
        g.flags |= 1,
        ns(h, g, S, F),
        g.child)
    }
    function pm(h, g, S, E, F) {
        if (to(S)) {
            var W = !0;
            Fl(g)
        } else
            W = !1;
        if (Zs(g, F),
        g.stateNode === null)
            Zf(h, g),
            Oi(g, S, E),
            Fu(g, S, E, F),
            E = !0;
        else if (h === null) {
            var pe = g.stateNode
              , Fe = g.memoizedProps;
            pe.props = Fe;
            var Je = pe.context
              , xt = S.contextType;
            typeof xt == "object" && xt !== null ? xt = Vn(xt) : (xt = to(S) ? Za : Ai.current,
            xt = ks(g, xt));
            var Bt = S.getDerivedStateFromProps
              , Vt = typeof Bt == "function" || typeof pe.getSnapshotBeforeUpdate == "function";
            Vt || typeof pe.UNSAFE_componentWillReceiveProps != "function" && typeof pe.componentWillReceiveProps != "function" || (Fe !== E || Je !== xt) && Qs(g, pe, E, xt),
            _n = !1;
            var Lt = g.memoizedState;
            pe.state = Lt,
            Xs(g, E, pe, F),
            Je = g.memoizedState,
            Fe !== E || Lt !== Je || _o.current || _n ? (typeof Bt == "function" && (Vl(g, S, Bt, E),
            Je = g.memoizedState),
            (Fe = _n || Ks(g, S, Fe, E, Lt, Je, xt)) ? (Vt || typeof pe.UNSAFE_componentWillMount != "function" && typeof pe.componentWillMount != "function" || (typeof pe.componentWillMount == "function" && pe.componentWillMount(),
            typeof pe.UNSAFE_componentWillMount == "function" && pe.UNSAFE_componentWillMount()),
            typeof pe.componentDidMount == "function" && (g.flags |= 4194308)) : (typeof pe.componentDidMount == "function" && (g.flags |= 4194308),
            g.memoizedProps = E,
            g.memoizedState = Je),
            pe.props = E,
            pe.state = Je,
            pe.context = xt,
            E = Fe) : (typeof pe.componentDidMount == "function" && (g.flags |= 4194308),
            E = !1)
        } else {
            pe = g.stateNode,
            Rd(h, g),
            Fe = g.memoizedProps,
            xt = g.type === g.elementType ? Fe : es(g.type, Fe),
            pe.props = xt,
            Vt = g.pendingProps,
            Lt = pe.context,
            Je = S.contextType,
            typeof Je == "object" && Je !== null ? Je = Vn(Je) : (Je = to(S) ? Za : Ai.current,
            Je = ks(g, Je));
            var rr = S.getDerivedStateFromProps;
            (Bt = typeof rr == "function" || typeof pe.getSnapshotBeforeUpdate == "function") || typeof pe.UNSAFE_componentWillReceiveProps != "function" && typeof pe.componentWillReceiveProps != "function" || (Fe !== Vt || Lt !== Je) && Qs(g, pe, E, Je),
            _n = !1,
            Lt = g.memoizedState,
            pe.state = Lt,
            Xs(g, E, pe, F);
            var hr = g.memoizedState;
            Fe !== Vt || Lt !== hr || _o.current || _n ? (typeof rr == "function" && (Vl(g, S, rr, E),
            hr = g.memoizedState),
            (xt = _n || Ks(g, S, xt, E, Lt, hr, Je) || !1) ? (Bt || typeof pe.UNSAFE_componentWillUpdate != "function" && typeof pe.componentWillUpdate != "function" || (typeof pe.componentWillUpdate == "function" && pe.componentWillUpdate(E, hr, Je),
            typeof pe.UNSAFE_componentWillUpdate == "function" && pe.UNSAFE_componentWillUpdate(E, hr, Je)),
            typeof pe.componentDidUpdate == "function" && (g.flags |= 4),
            typeof pe.getSnapshotBeforeUpdate == "function" && (g.flags |= 1024)) : (typeof pe.componentDidUpdate != "function" || Fe === h.memoizedProps && Lt === h.memoizedState || (g.flags |= 4),
            typeof pe.getSnapshotBeforeUpdate != "function" || Fe === h.memoizedProps && Lt === h.memoizedState || (g.flags |= 1024),
            g.memoizedProps = E,
            g.memoizedState = hr),
            pe.props = E,
            pe.state = hr,
            pe.context = Je,
            E = xt) : (typeof pe.componentDidUpdate != "function" || Fe === h.memoizedProps && Lt === h.memoizedState || (g.flags |= 4),
            typeof pe.getSnapshotBeforeUpdate != "function" || Fe === h.memoizedProps && Lt === h.memoizedState || (g.flags |= 1024),
            E = !1)
        }
        return Lc(h, g, S, E, W, F)
    }
    function Lc(h, g, S, E, F, W) {
        Uf(h, g);
        var pe = (g.flags & 128) !== 0;
        if (!E && !pe)
            return F && Bl(g, S, !1),
            _a(h, g, W);
        E = g.stateNode,
        dm.current = g;
        var Fe = pe && typeof S.getDerivedStateFromError != "function" ? null : E.render();
        return g.flags |= 1,
        h !== null && pe ? (g.child = jl(g, h.child, null, W),
        g.child = jl(g, null, Fe, W)) : ns(h, g, Fe, W),
        g.memoizedState = E.state,
        F && Bl(g, S, !0),
        g.child
    }
    function by(h) {
        var g = h.stateNode;
        g.pendingContext ? kd(h, g.pendingContext, g.pendingContext !== g.context) : g.context && kd(h, g.context, !1),
        a(h, g.containerInfo)
    }
    function Mh(h, g, S, E, F) {
        return Pc(),
        zu(F),
        g.flags |= 256,
        ns(h, g, S, E),
        g.child
    }
    var kh = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };
    function Eh(h) {
        return {
            baseLanes: h,
            cachePool: null,
            transitions: null
        }
    }
    function mm(h, g, S) {
        var E = g.pendingProps, F = P.current, W = !1, pe = (g.flags & 128) !== 0, Fe;
        if ((Fe = pe) || (Fe = h !== null && h.memoizedState === null ? !1 : (F & 2) !== 0),
        Fe ? (W = !0,
        g.flags &= -129) : (h === null || h.memoizedState !== null) && (F |= 1),
        tn(P, F & 1),
        h === null)
            return Cc(g),
            h = g.memoizedState,
            h !== null && (h = h.dehydrated,
            h !== null) ? ((g.mode & 1) === 0 ? g.lanes = 1 : h.data === "$!" ? g.lanes = 8 : g.lanes = 1073741824,
            null) : (pe = E.children,
            h = E.fallback,
            W ? (E = g.mode,
            W = g.child,
            pe = {
                mode: "hidden",
                children: pe
            },
            (E & 1) === 0 && W !== null ? (W.childLanes = 0,
            W.pendingProps = pe) : W = Uc(pe, E, 0, null),
            h = Ku(h, E, S, null),
            W.return = g,
            h.return = g,
            W.sibling = h,
            g.child = W,
            g.child.memoizedState = Eh(S),
            g.memoizedState = kh,
            h) : Wf(g, pe));
        if (F = h.memoizedState,
        F !== null && (Fe = F.dehydrated,
        Fe !== null))
            return Dv(h, g, pe, E, Fe, F, S);
        if (W) {
            W = E.fallback,
            pe = g.mode,
            F = h.child,
            Fe = F.sibling;
            var Je = {
                mode: "hidden",
                children: E.children
            };
            return (pe & 1) === 0 && g.child !== F ? (E = g.child,
            E.childLanes = 0,
            E.pendingProps = Je,
            g.deletions = null) : (E = Gl(F, Je),
            E.subtreeFlags = F.subtreeFlags & 14680064),
            Fe !== null ? W = Gl(Fe, W) : (W = Ku(W, pe, S, null),
            W.flags |= 2),
            W.return = g,
            E.return = g,
            E.sibling = W,
            g.child = E,
            E = W,
            W = g.child,
            pe = h.child.memoizedState,
            pe = pe === null ? Eh(S) : {
                baseLanes: pe.baseLanes | S,
                cachePool: null,
                transitions: pe.transitions
            },
            W.memoizedState = pe,
            W.childLanes = h.childLanes & ~S,
            g.memoizedState = kh,
            E
        }
        return W = h.child,
        h = W.sibling,
        E = Gl(W, {
            mode: "visible",
            children: E.children
        }),
        (g.mode & 1) === 0 && (E.lanes = S),
        E.return = g,
        E.sibling = null,
        h !== null && (S = g.deletions,
        S === null ? (g.deletions = [h],
        g.flags |= 16) : S.push(h)),
        g.child = E,
        g.memoizedState = null,
        E
    }
    function Wf(h, g) {
        return g = Uc({
            mode: "visible",
            children: g
        }, h.mode, 0, null),
        g.return = h,
        h.child = g
    }
    function qf(h, g, S, E) {
        return E !== null && zu(E),
        jl(g, h.child, null, S),
        h = Wf(g, g.pendingProps.children),
        h.flags |= 2,
        g.memoizedState = null,
        h
    }
    function Dv(h, g, S, E, F, W, pe) {
        if (S)
            return g.flags & 256 ? (g.flags &= -257,
            E = Bu(Error(i(422))),
            qf(h, g, pe, E)) : g.memoizedState !== null ? (g.child = h.child,
            g.flags |= 128,
            null) : (W = E.fallback,
            F = g.mode,
            E = Uc({
                mode: "visible",
                children: E.children
            }, F, 0, null),
            W = Ku(W, F, pe, null),
            W.flags |= 2,
            E.return = g,
            W.return = g,
            E.sibling = W,
            g.child = E,
            (g.mode & 1) !== 0 && jl(g, h.child, null, pe),
            g.child.memoizedState = Eh(pe),
            g.memoizedState = kh,
            W);
        if ((g.mode & 1) === 0)
            return qf(h, g, pe, null);
        if (F.data === "$!") {
            if (E = F.nextSibling && F.nextSibling.dataset,
            E)
                var Fe = E.dgst;
            return E = Fe,
            W = Error(i(419)),
            E = Bu(W, E, void 0),
            qf(h, g, pe, E)
        }
        if (Fe = (pe & h.childLanes) !== 0,
        rs || Fe) {
            if (E = _i,
            E !== null) {
                switch (pe & -pe) {
                case 4:
                    F = 2;
                    break;
                case 16:
                    F = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    F = 32;
                    break;
                case 536870912:
                    F = 268435456;
                    break;
                default:
                    F = 0
                }
                F = (F & (E.suspendedLanes | pe)) !== 0 ? 0 : F,
                F !== 0 && F !== W.retryLane && (W.retryLane = F,
                xo(h, F),
                ps(E, h, F, -1))
            }
            return km(),
            E = Bu(Error(i(421))),
            qf(h, g, pe, E)
        }
        return F.data === "$?" ? (g.flags |= 128,
        g.child = h.child,
        g = Dy.bind(null, h),
        F._reactRetry = g,
        null) : (h = W.treeContext,
        vo = Ms(F.nextSibling),
        Ir = g,
        Xn = !0,
        Lo = null,
        h !== null && (Wi[hi++] = Es,
        Wi[hi++] = Ko,
        Wi[hi++] = Kt,
        Es = h.id,
        Ko = h.overflow,
        Kt = g),
        g = Wf(g, E.children),
        g.flags |= 4096,
        g)
    }
    function gm(h, g, S) {
        h.lanes |= g;
        var E = h.alternate;
        E !== null && (E.lanes |= g),
        Lu(h.return, g, S)
    }
    function Hf(h, g, S, E, F) {
        var W = h.memoizedState;
        W === null ? h.memoizedState = {
            isBackwards: g,
            rendering: null,
            renderingStartTime: 0,
            last: E,
            tail: S,
            tailMode: F
        } : (W.isBackwards = g,
        W.rendering = null,
        W.renderingStartTime = 0,
        W.last = E,
        W.tail = S,
        W.tailMode = F)
    }
    function ym(h, g, S) {
        var E = g.pendingProps
          , F = E.revealOrder
          , W = E.tail;
        if (ns(h, g, E.children, S),
        E = P.current,
        (E & 2) !== 0)
            E = E & 1 | 2,
            g.flags |= 128;
        else {
            if (h !== null && (h.flags & 128) !== 0)
                e: for (h = g.child; h !== null; ) {
                    if (h.tag === 13)
                        h.memoizedState !== null && gm(h, S, g);
                    else if (h.tag === 19)
                        gm(h, S, g);
                    else if (h.child !== null) {
                        h.child.return = h,
                        h = h.child;
                        continue
                    }
                    if (h === g)
                        break e;
                    for (; h.sibling === null; ) {
                        if (h.return === null || h.return === g)
                            break e;
                        h = h.return
                    }
                    h.sibling.return = h.return,
                    h = h.sibling
                }
            E &= 1
        }
        if (tn(P, E),
        (g.mode & 1) === 0)
            g.memoizedState = null;
        else
            switch (F) {
            case "forwards":
                for (S = g.child,
                F = null; S !== null; )
                    h = S.alternate,
                    h !== null && I(h) === null && (F = S),
                    S = S.sibling;
                S = F,
                S === null ? (F = g.child,
                g.child = null) : (F = S.sibling,
                S.sibling = null),
                Hf(g, !1, F, S, W);
                break;
            case "backwards":
                for (S = null,
                F = g.child,
                g.child = null; F !== null; ) {
                    if (h = F.alternate,
                    h !== null && I(h) === null) {
                        g.child = F;
                        break
                    }
                    h = F.sibling,
                    F.sibling = S,
                    S = F,
                    F = h
                }
                Hf(g, !0, S, null, W);
                break;
            case "together":
                Hf(g, !1, null, null, void 0);
                break;
            default:
                g.memoizedState = null
            }
        return g.child
    }
    function Zf(h, g) {
        (g.mode & 1) === 0 && h !== null && (h.alternate = null,
        g.alternate = null,
        g.flags |= 2)
    }
    function _a(h, g, S) {
        if (h !== null && (g.dependencies = h.dependencies),
        Bc |= g.lanes,
        (S & g.childLanes) === 0)
            return null;
        if (h !== null && g.child !== h.child)
            throw Error(i(153));
        if (g.child !== null) {
            for (h = g.child,
            S = Gl(h, h.pendingProps),
            g.child = S,
            S.return = g; h.sibling !== null; )
                h = h.sibling,
                S = S.sibling = Gl(h, h.pendingProps),
                S.return = g;
            S.sibling = null
        }
        return g.child
    }
    function wy(h, g, S) {
        switch (g.tag) {
        case 3:
            by(g),
            Pc();
            break;
        case 5:
            y(g);
            break;
        case 1:
            to(g.type) && Fl(g);
            break;
        case 4:
            a(g, g.stateNode.containerInfo);
            break;
        case 10:
            var E = g.type._context
              , F = g.memoizedProps.value;
            tn(Ph, E._currentValue),
            E._currentValue = F;
            break;
        case 13:
            if (E = g.memoizedState,
            E !== null)
                return E.dehydrated !== null ? (tn(P, P.current & 1),
                g.flags |= 128,
                null) : (S & g.child.childLanes) !== 0 ? mm(h, g, S) : (tn(P, P.current & 1),
                h = _a(h, g, S),
                h !== null ? h.sibling : null);
            tn(P, P.current & 1);
            break;
        case 19:
            if (E = (S & g.childLanes) !== 0,
            (h.flags & 128) !== 0) {
                if (E)
                    return ym(h, g, S);
                g.flags |= 128
            }
            if (F = g.memoizedState,
            F !== null && (F.rendering = null,
            F.tail = null,
            F.lastEffect = null),
            tn(P, P.current),
            E)
                break;
            return null;
        case 22:
        case 23:
            return g.lanes = 0,
            xy(h, g, S)
        }
        return _a(h, g, S)
    }
    var Xf, $u, Oo, _m;
    Xf = function(h, g) {
        for (var S = g.child; S !== null; ) {
            if (S.tag === 5 || S.tag === 6)
                h.appendChild(S.stateNode);
            else if (S.tag !== 4 && S.child !== null) {
                S.child.return = S,
                S = S.child;
                continue
            }
            if (S === g)
                break;
            for (; S.sibling === null; ) {
                if (S.return === null || S.return === g)
                    return;
                S = S.return
            }
            S.sibling.return = S.return,
            S = S.sibling
        }
    }
    ,
    $u = function() {}
    ,
    Oo = function(h, g, S, E) {
        var F = h.memoizedProps;
        if (F !== E) {
            h = g.stateNode,
            r(Jo.current);
            var W = null;
            switch (S) {
            case "input":
                F = vr(h, F),
                E = vr(h, E),
                W = [];
                break;
            case "select":
                F = Pt({}, F, {
                    value: void 0
                }),
                E = Pt({}, E, {
                    value: void 0
                }),
                W = [];
                break;
            case "textarea":
                F = $n(h, F),
                E = $n(h, E),
                W = [];
                break;
            default:
                typeof F.onClick != "function" && typeof E.onClick == "function" && (h.onclick = Ha)
            }
            Me(S, E);
            var pe;
            S = null;
            for (xt in F)
                if (!E.hasOwnProperty(xt) && F.hasOwnProperty(xt) && F[xt] != null)
                    if (xt === "style") {
                        var Fe = F[xt];
                        for (pe in Fe)
                            Fe.hasOwnProperty(pe) && (S || (S = {}),
                            S[pe] = "")
                    } else
                        xt !== "dangerouslySetInnerHTML" && xt !== "children" && xt !== "suppressContentEditableWarning" && xt !== "suppressHydrationWarning" && xt !== "autoFocus" && (u.hasOwnProperty(xt) ? W || (W = []) : (W = W || []).push(xt, null));
            for (xt in E) {
                var Je = E[xt];
                if (Fe = F?.[xt],
                E.hasOwnProperty(xt) && Je !== Fe && (Je != null || Fe != null))
                    if (xt === "style")
                        if (Fe) {
                            for (pe in Fe)
                                !Fe.hasOwnProperty(pe) || Je && Je.hasOwnProperty(pe) || (S || (S = {}),
                                S[pe] = "");
                            for (pe in Je)
                                Je.hasOwnProperty(pe) && Fe[pe] !== Je[pe] && (S || (S = {}),
                                S[pe] = Je[pe])
                        } else
                            S || (W || (W = []),
                            W.push(xt, S)),
                            S = Je;
                    else
                        xt === "dangerouslySetInnerHTML" ? (Je = Je ? Je.__html : void 0,
                        Fe = Fe ? Fe.__html : void 0,
                        Je != null && Fe !== Je && (W = W || []).push(xt, Je)) : xt === "children" ? typeof Je != "string" && typeof Je != "number" || (W = W || []).push(xt, "" + Je) : xt !== "suppressContentEditableWarning" && xt !== "suppressHydrationWarning" && (u.hasOwnProperty(xt) ? (Je != null && xt === "onScroll" && Pn("scroll", h),
                        W || Fe === Je || (W = [])) : (W = W || []).push(xt, Je))
            }
            S && (W = W || []).push("style", S);
            var xt = W;
            (g.updateQueue = xt) && (g.flags |= 4)
        }
    }
    ,
    _m = function(h, g, S, E) {
        S !== E && (g.flags |= 4)
    }
    ;
    function Vu(h, g) {
        if (!Xn)
            switch (h.tailMode) {
            case "hidden":
                g = h.tail;
                for (var S = null; g !== null; )
                    g.alternate !== null && (S = g),
                    g = g.sibling;
                S === null ? h.tail = null : S.sibling = null;
                break;
            case "collapsed":
                S = h.tail;
                for (var E = null; S !== null; )
                    S.alternate !== null && (E = S),
                    S = S.sibling;
                E === null ? g || h.tail === null ? h.tail = null : h.tail.sibling = null : E.sibling = null
            }
    }
    function Fo(h) {
        var g = h.alternate !== null && h.alternate.child === h.child
          , S = 0
          , E = 0;
        if (g)
            for (var F = h.child; F !== null; )
                S |= F.lanes | F.childLanes,
                E |= F.subtreeFlags & 14680064,
                E |= F.flags & 14680064,
                F.return = h,
                F = F.sibling;
        else
            for (F = h.child; F !== null; )
                S |= F.lanes | F.childLanes,
                E |= F.subtreeFlags,
                E |= F.flags,
                F.return = h,
                F = F.sibling;
        return h.subtreeFlags |= E,
        h.childLanes = S,
        g
    }
    function Sy(h, g, S) {
        var E = g.pendingProps;
        switch (Iu(g),
        g.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Fo(g),
            null;
        case 1:
            return to(g.type) && Ol(),
            Fo(g),
            null;
        case 3:
            return E = g.stateNode,
            m(),
            wn(_o),
            wn(Ai),
            B(),
            E.pendingContext && (E.context = E.pendingContext,
            E.pendingContext = null),
            (h === null || h.child === null) && (Au(g) ? g.flags |= 4 : h === null || h.memoizedState.isDehydrated && (g.flags & 256) === 0 || (g.flags |= 1024,
            Lo !== null && (Zu(Lo),
            Lo = null))),
            $u(h, g),
            Fo(g),
            null;
        case 5:
            x(g);
            var F = r(v.current);
            if (S = g.type,
            h !== null && g.stateNode != null)
                Oo(h, g, S, E, F),
                h.ref !== g.ref && (g.flags |= 512,
                g.flags |= 2097152);
            else {
                if (!E) {
                    if (g.stateNode === null)
                        throw Error(i(166));
                    return Fo(g),
                    null
                }
                if (h = r(Jo.current),
                Au(g)) {
                    E = g.stateNode,
                    S = g.type;
                    var W = g.memoizedProps;
                    switch (E[fn] = g,
                    E[ds] = W,
                    h = (g.mode & 1) !== 0,
                    S) {
                    case "dialog":
                        Pn("cancel", E),
                        Pn("close", E);
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        Pn("load", E);
                        break;
                    case "video":
                    case "audio":
                        for (F = 0; F < Ur.length; F++)
                            Pn(Ur[F], E);
                        break;
                    case "source":
                        Pn("error", E);
                        break;
                    case "img":
                    case "image":
                    case "link":
                        Pn("error", E),
                        Pn("load", E);
                        break;
                    case "details":
                        Pn("toggle", E);
                        break;
                    case "input":
                        gr(E, W),
                        Pn("invalid", E);
                        break;
                    case "select":
                        E._wrapperState = {
                            wasMultiple: !!W.multiple
                        },
                        Pn("invalid", E);
                        break;
                    case "textarea":
                        Dn(E, W),
                        Pn("invalid", E)
                    }
                    Me(S, W),
                    F = null;
                    for (var pe in W)
                        if (W.hasOwnProperty(pe)) {
                            var Fe = W[pe];
                            pe === "children" ? typeof Fe == "string" ? E.textContent !== Fe && (W.suppressHydrationWarning !== !0 && ha(E.textContent, Fe, h),
                            F = ["children", Fe]) : typeof Fe == "number" && E.textContent !== "" + Fe && (W.suppressHydrationWarning !== !0 && ha(E.textContent, Fe, h),
                            F = ["children", "" + Fe]) : u.hasOwnProperty(pe) && Fe != null && pe === "onScroll" && Pn("scroll", E)
                        }
                    switch (S) {
                    case "input":
                        xr(E),
                        $r(E, W, !0);
                        break;
                    case "textarea":
                        xr(E),
                        Tn(E);
                        break;
                    case "select":
                    case "option":
                        break;
                    default:
                        typeof W.onClick == "function" && (E.onclick = Ha)
                    }
                    E = F,
                    g.updateQueue = E,
                    E !== null && (g.flags |= 4)
                } else {
                    pe = F.nodeType === 9 ? F : F.ownerDocument,
                    h === "http://www.w3.org/1999/xhtml" && (h = bn(S)),
                    h === "http://www.w3.org/1999/xhtml" ? S === "script" ? (h = pe.createElement("div"),
                    h.innerHTML = "<script><\/script>",
                    h = h.removeChild(h.firstChild)) : typeof E.is == "string" ? h = pe.createElement(S, {
                        is: E.is
                    }) : (h = pe.createElement(S),
                    S === "select" && (pe = h,
                    E.multiple ? pe.multiple = !0 : E.size && (pe.size = E.size))) : h = pe.createElementNS(h, S),
                    h[fn] = g,
                    h[ds] = E,
                    Xf(h, g, !1, !1),
                    g.stateNode = h;
                    e: {
                        switch (pe = $e(S, E),
                        S) {
                        case "dialog":
                            Pn("cancel", h),
                            Pn("close", h),
                            F = E;
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            Pn("load", h),
                            F = E;
                            break;
                        case "video":
                        case "audio":
                            for (F = 0; F < Ur.length; F++)
                                Pn(Ur[F], h);
                            F = E;
                            break;
                        case "source":
                            Pn("error", h),
                            F = E;
                            break;
                        case "img":
                        case "image":
                        case "link":
                            Pn("error", h),
                            Pn("load", h),
                            F = E;
                            break;
                        case "details":
                            Pn("toggle", h),
                            F = E;
                            break;
                        case "input":
                            gr(h, E),
                            F = vr(h, E),
                            Pn("invalid", h);
                            break;
                        case "option":
                            F = E;
                            break;
                        case "select":
                            h._wrapperState = {
                                wasMultiple: !!E.multiple
                            },
                            F = Pt({}, E, {
                                value: void 0
                            }),
                            Pn("invalid", h);
                            break;
                        case "textarea":
                            Dn(h, E),
                            F = $n(h, E),
                            Pn("invalid", h);
                            break;
                        default:
                            F = E
                        }
                        Me(S, F),
                        Fe = F;
                        for (W in Fe)
                            if (Fe.hasOwnProperty(W)) {
                                var Je = Fe[W];
                                W === "style" ? fe(h, Je) : W === "dangerouslySetInnerHTML" ? (Je = Je ? Je.__html : void 0,
                                Je != null && kt(h, Je)) : W === "children" ? typeof Je == "string" ? (S !== "textarea" || Je !== "") && er(h, Je) : typeof Je == "number" && er(h, "" + Je) : W !== "suppressContentEditableWarning" && W !== "suppressHydrationWarning" && W !== "autoFocus" && (u.hasOwnProperty(W) ? Je != null && W === "onScroll" && Pn("scroll", h) : Je != null && ue(h, W, Je, pe))
                            }
                        switch (S) {
                        case "input":
                            xr(h),
                            $r(h, E, !1);
                            break;
                        case "textarea":
                            xr(h),
                            Tn(h);
                            break;
                        case "option":
                            E.value != null && h.setAttribute("value", "" + cr(E.value));
                            break;
                        case "select":
                            h.multiple = !!E.multiple,
                            W = E.value,
                            W != null ? Wr(h, !!E.multiple, W, !1) : E.defaultValue != null && Wr(h, !!E.multiple, E.defaultValue, !0);
                            break;
                        default:
                            typeof F.onClick == "function" && (h.onclick = Ha)
                        }
                        switch (S) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                            E = !!E.autoFocus;
                            break e;
                        case "img":
                            E = !0;
                            break e;
                        default:
                            E = !1
                        }
                    }
                    E && (g.flags |= 4)
                }
                g.ref !== null && (g.flags |= 512,
                g.flags |= 2097152)
            }
            return Fo(g),
            null;
        case 6:
            if (h && g.stateNode != null)
                _m(h, g, h.memoizedProps, E);
            else {
                if (typeof E != "string" && g.stateNode === null)
                    throw Error(i(166));
                if (S = r(v.current),
                r(Jo.current),
                Au(g)) {
                    if (E = g.stateNode,
                    S = g.memoizedProps,
                    E[fn] = g,
                    (W = E.nodeValue !== S) && (h = Ir,
                    h !== null))
                        switch (h.tag) {
                        case 3:
                            ha(E.nodeValue, S, (h.mode & 1) !== 0);
                            break;
                        case 5:
                            h.memoizedProps.suppressHydrationWarning !== !0 && ha(E.nodeValue, S, (h.mode & 1) !== 0)
                        }
                    W && (g.flags |= 4)
                } else
                    E = (S.nodeType === 9 ? S : S.ownerDocument).createTextNode(E),
                    E[fn] = g,
                    g.stateNode = E
            }
            return Fo(g),
            null;
        case 13:
            if (wn(P),
            E = g.memoizedState,
            h === null || h.memoizedState !== null && h.memoizedState.dehydrated !== null) {
                if (Xn && vo !== null && (g.mode & 1) !== 0 && (g.flags & 128) === 0)
                    Tc(),
                    Pc(),
                    g.flags |= 98560,
                    W = !1;
                else if (W = Au(g),
                E !== null && E.dehydrated !== null) {
                    if (h === null) {
                        if (!W)
                            throw Error(i(318));
                        if (W = g.memoizedState,
                        W = W !== null ? W.dehydrated : null,
                        !W)
                            throw Error(i(317));
                        W[fn] = g
                    } else
                        Pc(),
                        (g.flags & 128) === 0 && (g.memoizedState = null),
                        g.flags |= 4;
                    Fo(g),
                    W = !1
                } else
                    Lo !== null && (Zu(Lo),
                    Lo = null),
                    W = !0;
                if (!W)
                    return g.flags & 65536 ? g : null
            }
            return (g.flags & 128) !== 0 ? (g.lanes = S,
            g) : (E = E !== null,
            E !== (h !== null && h.memoizedState !== null) && E && (g.child.flags |= 8192,
            (g.mode & 1) !== 0 && (h === null || (P.current & 1) !== 0 ? di === 0 && (di = 3) : km())),
            g.updateQueue !== null && (g.flags |= 4),
            Fo(g),
            null);
        case 4:
            return m(),
            $u(h, g),
            h === null && mc(g.stateNode.containerInfo),
            Fo(g),
            null;
        case 10:
            return Mc(g.type._context),
            Fo(g),
            null;
        case 17:
            return to(g.type) && Ol(),
            Fo(g),
            null;
        case 19:
            if (wn(P),
            W = g.memoizedState,
            W === null)
                return Fo(g),
                null;
            if (E = (g.flags & 128) !== 0,
            pe = W.rendering,
            pe === null)
                if (E)
                    Vu(W, !1);
                else {
                    if (di !== 0 || h !== null && (h.flags & 128) !== 0)
                        for (h = g.child; h !== null; ) {
                            if (pe = I(h),
                            pe !== null) {
                                for (g.flags |= 128,
                                Vu(W, !1),
                                E = pe.updateQueue,
                                E !== null && (g.updateQueue = E,
                                g.flags |= 4),
                                g.subtreeFlags = 0,
                                E = S,
                                S = g.child; S !== null; )
                                    W = S,
                                    h = E,
                                    W.flags &= 14680066,
                                    pe = W.alternate,
                                    pe === null ? (W.childLanes = 0,
                                    W.lanes = h,
                                    W.child = null,
                                    W.subtreeFlags = 0,
                                    W.memoizedProps = null,
                                    W.memoizedState = null,
                                    W.updateQueue = null,
                                    W.dependencies = null,
                                    W.stateNode = null) : (W.childLanes = pe.childLanes,
                                    W.lanes = pe.lanes,
                                    W.child = pe.child,
                                    W.subtreeFlags = 0,
                                    W.deletions = null,
                                    W.memoizedProps = pe.memoizedProps,
                                    W.memoizedState = pe.memoizedState,
                                    W.updateQueue = pe.updateQueue,
                                    W.type = pe.type,
                                    h = pe.dependencies,
                                    W.dependencies = h === null ? null : {
                                        lanes: h.lanes,
                                        firstContext: h.firstContext
                                    }),
                                    S = S.sibling;
                                return tn(P, P.current & 1 | 2),
                                g.child
                            }
                            h = h.sibling
                        }
                    W.tail !== null && kr() > Hu && (g.flags |= 128,
                    E = !0,
                    Vu(W, !1),
                    g.lanes = 4194304)
                }
            else {
                if (!E)
                    if (h = I(pe),
                    h !== null) {
                        if (g.flags |= 128,
                        E = !0,
                        S = h.updateQueue,
                        S !== null && (g.updateQueue = S,
                        g.flags |= 4),
                        Vu(W, !0),
                        W.tail === null && W.tailMode === "hidden" && !pe.alternate && !Xn)
                            return Fo(g),
                            null
                    } else
                        2 * kr() - W.renderingStartTime > Hu && S !== 1073741824 && (g.flags |= 128,
                        E = !0,
                        Vu(W, !1),
                        g.lanes = 4194304);
                W.isBackwards ? (pe.sibling = g.child,
                g.child = pe) : (S = W.last,
                S !== null ? S.sibling = pe : g.child = pe,
                W.last = pe)
            }
            return W.tail !== null ? (g = W.tail,
            W.rendering = g,
            W.tail = g.sibling,
            W.renderingStartTime = kr(),
            g.sibling = null,
            S = P.current,
            tn(P, E ? S & 1 | 2 : S & 1),
            g) : (Fo(g),
            null);
        case 22:
        case 23:
            return Pm(),
            E = g.memoizedState !== null,
            h !== null && h.memoizedState !== null !== E && (g.flags |= 8192),
            E && (g.mode & 1) !== 0 ? (Bo & 1073741824) !== 0 && (Fo(g),
            g.subtreeFlags & 6 && (g.flags |= 8192)) : Fo(g),
            null;
        case 24:
            return null;
        case 25:
            return null
        }
        throw Error(i(156, g.tag))
    }
    function Lv(h, g) {
        switch (Iu(g),
        g.tag) {
        case 1:
            return to(g.type) && Ol(),
            h = g.flags,
            h & 65536 ? (g.flags = h & -65537 | 128,
            g) : null;
        case 3:
            return m(),
            wn(_o),
            wn(Ai),
            B(),
            h = g.flags,
            (h & 65536) !== 0 && (h & 128) === 0 ? (g.flags = h & -65537 | 128,
            g) : null;
        case 5:
            return x(g),
            null;
        case 13:
            if (wn(P),
            h = g.memoizedState,
            h !== null && h.dehydrated !== null) {
                if (g.alternate === null)
                    throw Error(i(340));
                Pc()
            }
            return h = g.flags,
            h & 65536 ? (g.flags = h & -65537 | 128,
            g) : null;
        case 19:
            return wn(P),
            null;
        case 4:
            return m(),
            null;
        case 10:
            return Mc(g.type._context),
            null;
        case 22:
        case 23:
            return Pm(),
            null;
        case 24:
            return null;
        default:
            return null
        }
    }
    var Yf = !1
      , So = !1
      , Ov = typeof WeakSet == "function" ? WeakSet : Set
      , mr = null;
    function Uu(h, g) {
        var S = h.ref;
        if (S !== null)
            if (typeof S == "function")
                try {
                    S(null)
                } catch (E) {
                    si(h, g, E)
                }
            else
                S.current = null
    }
    function Kf(h, g, S) {
        try {
            S()
        } catch (E) {
            si(h, g, E)
        }
    }
    var Cy = !1;
    function Fv(h, g) {
        if (Pu = $s,
        h = Lf(),
        gh(h)) {
            if ("selectionStart"in h)
                var S = {
                    start: h.selectionStart,
                    end: h.selectionEnd
                };
            else
                e: {
                    S = (S = h.ownerDocument) && S.defaultView || window;
                    var E = S.getSelection && S.getSelection();
                    if (E && E.rangeCount !== 0) {
                        S = E.anchorNode;
                        var F = E.anchorOffset
                          , W = E.focusNode;
                        E = E.focusOffset;
                        try {
                            S.nodeType,
                            W.nodeType
                        } catch {
                            S = null;
                            break e
                        }
                        var pe = 0
                          , Fe = -1
                          , Je = -1
                          , xt = 0
                          , Bt = 0
                          , Vt = h
                          , Lt = null;
                        t: for (; ; ) {
                            for (var rr; Vt !== S || F !== 0 && Vt.nodeType !== 3 || (Fe = pe + F),
                            Vt !== W || E !== 0 && Vt.nodeType !== 3 || (Je = pe + E),
                            Vt.nodeType === 3 && (pe += Vt.nodeValue.length),
                            (rr = Vt.firstChild) !== null; )
                                Lt = Vt,
                                Vt = rr;
                            for (; ; ) {
                                if (Vt === h)
                                    break t;
                                if (Lt === S && ++xt === F && (Fe = pe),
                                Lt === W && ++Bt === E && (Je = pe),
                                (rr = Vt.nextSibling) !== null)
                                    break;
                                Vt = Lt,
                                Lt = Vt.parentNode
                            }
                            Vt = rr
                        }
                        S = Fe === -1 || Je === -1 ? null : {
                            start: Fe,
                            end: Je
                        }
                    } else
                        S = null
                }
            S = S || {
                start: 0,
                end: 0
            }
        } else
            S = null;
        for (qs = {
            focusedElem: h,
            selectionRange: S
        },
        $s = !1,
        mr = g; mr !== null; )
            if (g = mr,
            h = g.child,
            (g.subtreeFlags & 1028) !== 0 && h !== null)
                h.return = g,
                mr = h;
            else
                for (; mr !== null; ) {
                    g = mr;
                    try {
                        var hr = g.alternate;
                        if ((g.flags & 1024) !== 0)
                            switch (g.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (hr !== null) {
                                    var wr = hr.memoizedProps
                                      , fi = hr.memoizedState
                                      , pt = g.stateNode
                                      , rt = pt.getSnapshotBeforeUpdate(g.elementType === g.type ? wr : es(g.type, wr), fi);
                                    pt.__reactInternalSnapshotBeforeUpdate = rt
                                }
                                break;
                            case 3:
                                var gt = g.stateNode.containerInfo;
                                gt.nodeType === 1 ? gt.textContent = "" : gt.nodeType === 9 && gt.documentElement && gt.removeChild(gt.documentElement);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(i(163))
                            }
                    } catch (Zt) {
                        si(g, g.return, Zt)
                    }
                    if (h = g.sibling,
                    h !== null) {
                        h.return = g.return,
                        mr = h;
                        break
                    }
                    mr = g.return
                }
        return hr = Cy,
        Cy = !1,
        hr
    }
    function Ad(h, g, S) {
        var E = g.updateQueue;
        if (E = E !== null ? E.lastEffect : null,
        E !== null) {
            var F = E = E.next;
            do {
                if ((F.tag & h) === h) {
                    var W = F.destroy;
                    F.destroy = void 0,
                    W !== void 0 && Kf(g, S, W)
                }
                F = F.next
            } while (F !== E)
        }
    }
    function Ih(h, g) {
        if (g = g.updateQueue,
        g = g !== null ? g.lastEffect : null,
        g !== null) {
            var S = g = g.next;
            do {
                if ((S.tag & h) === h) {
                    var E = S.create;
                    S.destroy = E()
                }
                S = S.next
            } while (S !== g)
        }
    }
    function zd(h) {
        var g = h.ref;
        if (g !== null) {
            var S = h.stateNode;
            switch (h.tag) {
            case 5:
                h = S;
                break;
            default:
                h = S
            }
            typeof g == "function" ? g(h) : g.current = h
        }
    }
    function vm(h) {
        var g = h.alternate;
        g !== null && (h.alternate = null,
        vm(g)),
        h.child = null,
        h.deletions = null,
        h.sibling = null,
        h.tag === 5 && (g = h.stateNode,
        g !== null && (delete g[fn],
        delete g[ds],
        delete g[yc],
        delete g[ku],
        delete g[_c])),
        h.stateNode = null,
        h.return = null,
        h.dependencies = null,
        h.memoizedProps = null,
        h.memoizedState = null,
        h.pendingProps = null,
        h.stateNode = null,
        h.updateQueue = null
    }
    function Oc(h) {
        return h.tag === 5 || h.tag === 3 || h.tag === 4
    }
    function Rh(h) {
        e: for (; ; ) {
            for (; h.sibling === null; ) {
                if (h.return === null || Oc(h.return))
                    return null;
                h = h.return
            }
            for (h.sibling.return = h.return,
            h = h.sibling; h.tag !== 5 && h.tag !== 6 && h.tag !== 18; ) {
                if (h.flags & 2 || h.child === null || h.tag === 4)
                    continue e;
                h.child.return = h,
                h = h.child
            }
            if (!(h.flags & 2))
                return h.stateNode
        }
    }
    function xm(h, g, S) {
        var E = h.tag;
        if (E === 5 || E === 6)
            h = h.stateNode,
            g ? S.nodeType === 8 ? S.parentNode.insertBefore(h, g) : S.insertBefore(h, g) : (S.nodeType === 8 ? (g = S.parentNode,
            g.insertBefore(h, S)) : (g = S,
            g.appendChild(h)),
            S = S._reactRootContainer,
            S != null || g.onclick !== null || (g.onclick = Ha));
        else if (E !== 4 && (h = h.child,
        h !== null))
            for (xm(h, g, S),
            h = h.sibling; h !== null; )
                xm(h, g, S),
                h = h.sibling
    }
    function bm(h, g, S) {
        var E = h.tag;
        if (E === 5 || E === 6)
            h = h.stateNode,
            g ? S.insertBefore(h, g) : S.appendChild(h);
        else if (E !== 4 && (h = h.child,
        h !== null))
            for (bm(h, g, S),
            h = h.sibling; h !== null; )
                bm(h, g, S),
                h = h.sibling
    }
    var Co = null
      , va = !1;
    function Fc(h, g, S) {
        for (S = S.child; S !== null; )
            Ty(h, g, S),
            S = S.sibling
    }
    function Ty(h, g, S) {
        if (Ei && typeof Ei.onCommitFiberUnmount == "function")
            try {
                Ei.onCommitFiberUnmount(qn, S)
            } catch {}
        switch (S.tag) {
        case 5:
            So || Uu(S, g);
        case 6:
            var E = Co
              , F = va;
            Co = null,
            Fc(h, g, S),
            Co = E,
            va = F,
            Co !== null && (va ? (h = Co,
            S = S.stateNode,
            h.nodeType === 8 ? h.parentNode.removeChild(S) : h.removeChild(S)) : Co.removeChild(S.stateNode));
            break;
        case 18:
            Co !== null && (va ? (h = Co,
            S = S.stateNode,
            h.nodeType === 8 ? Al(h.parentNode, S) : h.nodeType === 1 && Al(h, S),
            Cs(h)) : Al(Co, S.stateNode));
            break;
        case 4:
            E = Co,
            F = va,
            Co = S.stateNode.containerInfo,
            va = !0,
            Fc(h, g, S),
            Co = E,
            va = F;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!So && (E = S.updateQueue,
            E !== null && (E = E.lastEffect,
            E !== null))) {
                F = E = E.next;
                do {
                    var W = F
                      , pe = W.destroy;
                    W = W.tag,
                    pe !== void 0 && ((W & 2) !== 0 || (W & 4) !== 0) && Kf(S, g, pe),
                    F = F.next
                } while (F !== E)
            }
            Fc(h, g, S);
            break;
        case 1:
            if (!So && (Uu(S, g),
            E = S.stateNode,
            typeof E.componentWillUnmount == "function"))
                try {
                    E.props = S.memoizedProps,
                    E.state = S.memoizedState,
                    E.componentWillUnmount()
                } catch (Fe) {
                    si(S, g, Fe)
                }
            Fc(h, g, S);
            break;
        case 21:
            Fc(h, g, S);
            break;
        case 22:
            S.mode & 1 ? (So = (E = So) || S.memoizedState !== null,
            Fc(h, g, S),
            So = E) : Fc(h, g, S);
            break;
        default:
            Fc(h, g, S)
        }
    }
    function Py(h) {
        var g = h.updateQueue;
        if (g !== null) {
            h.updateQueue = null;
            var S = h.stateNode;
            S === null && (S = h.stateNode = new Ov),
            g.forEach(function(E) {
                var F = $v.bind(null, h, E);
                S.has(E) || (S.add(E),
                E.then(F, F))
            })
        }
    }
    function As(h, g) {
        var S = g.deletions;
        if (S !== null)
            for (var E = 0; E < S.length; E++) {
                var F = S[E];
                try {
                    var W = h
                      , pe = g
                      , Fe = pe;
                    e: for (; Fe !== null; ) {
                        switch (Fe.tag) {
                        case 5:
                            Co = Fe.stateNode,
                            va = !1;
                            break e;
                        case 3:
                            Co = Fe.stateNode.containerInfo,
                            va = !0;
                            break e;
                        case 4:
                            Co = Fe.stateNode.containerInfo,
                            va = !0;
                            break e
                        }
                        Fe = Fe.return
                    }
                    if (Co === null)
                        throw Error(i(160));
                    Ty(W, pe, F),
                    Co = null,
                    va = !1;
                    var Je = F.alternate;
                    Je !== null && (Je.return = null),
                    F.return = null
                } catch (xt) {
                    si(F, g, xt)
                }
            }
        if (g.subtreeFlags & 12854)
            for (g = g.child; g !== null; )
                My(g, h),
                g = g.sibling
    }
    function My(h, g) {
        var S = h.alternate
          , E = h.flags;
        switch (h.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (As(g, h),
            xa(h),
            E & 4) {
                try {
                    Ad(3, h, h.return),
                    Ih(3, h)
                } catch (wr) {
                    si(h, h.return, wr)
                }
                try {
                    Ad(5, h, h.return)
                } catch (wr) {
                    si(h, h.return, wr)
                }
            }
            break;
        case 1:
            As(g, h),
            xa(h),
            E & 512 && S !== null && Uu(S, S.return);
            break;
        case 5:
            if (As(g, h),
            xa(h),
            E & 512 && S !== null && Uu(S, S.return),
            h.flags & 32) {
                var F = h.stateNode;
                try {
                    er(F, "")
                } catch (wr) {
                    si(h, h.return, wr)
                }
            }
            if (E & 4 && (F = h.stateNode,
            F != null)) {
                var W = h.memoizedProps
                  , pe = S !== null ? S.memoizedProps : W
                  , Fe = h.type
                  , Je = h.updateQueue;
                if (h.updateQueue = null,
                Je !== null)
                    try {
                        Fe === "input" && W.type === "radio" && W.name != null && hn(F, W),
                        $e(Fe, pe);
                        var xt = $e(Fe, W);
                        for (pe = 0; pe < Je.length; pe += 2) {
                            var Bt = Je[pe]
                              , Vt = Je[pe + 1];
                            Bt === "style" ? fe(F, Vt) : Bt === "dangerouslySetInnerHTML" ? kt(F, Vt) : Bt === "children" ? er(F, Vt) : ue(F, Bt, Vt, xt)
                        }
                        switch (Fe) {
                        case "input":
                            Zr(F, W);
                            break;
                        case "textarea":
                            yn(F, W);
                            break;
                        case "select":
                            var Lt = F._wrapperState.wasMultiple;
                            F._wrapperState.wasMultiple = !!W.multiple;
                            var rr = W.value;
                            rr != null ? Wr(F, !!W.multiple, rr, !1) : Lt !== !!W.multiple && (W.defaultValue != null ? Wr(F, !!W.multiple, W.defaultValue, !0) : Wr(F, !!W.multiple, W.multiple ? [] : "", !1))
                        }
                        F[ds] = W
                    } catch (wr) {
                        si(h, h.return, wr)
                    }
            }
            break;
        case 6:
            if (As(g, h),
            xa(h),
            E & 4) {
                if (h.stateNode === null)
                    throw Error(i(162));
                F = h.stateNode,
                W = h.memoizedProps;
                try {
                    F.nodeValue = W
                } catch (wr) {
                    si(h, h.return, wr)
                }
            }
            break;
        case 3:
            if (As(g, h),
            xa(h),
            E & 4 && S !== null && S.memoizedState.isDehydrated)
                try {
                    Cs(g.containerInfo)
                } catch (wr) {
                    si(h, h.return, wr)
                }
            break;
        case 4:
            As(g, h),
            xa(h);
            break;
        case 13:
            As(g, h),
            xa(h),
            F = h.child,
            F.flags & 8192 && (W = F.memoizedState !== null,
            F.stateNode.isHidden = W,
            !W || F.alternate !== null && F.alternate.memoizedState !== null || (Od = kr())),
            E & 4 && Py(h);
            break;
        case 22:
            if (Bt = S !== null && S.memoizedState !== null,
            h.mode & 1 ? (So = (xt = So) || Bt,
            As(g, h),
            So = xt) : As(g, h),
            xa(h),
            E & 8192) {
                if (xt = h.memoizedState !== null,
                (h.stateNode.isHidden = xt) && !Bt && (h.mode & 1) !== 0)
                    for (mr = h,
                    Bt = h.child; Bt !== null; ) {
                        for (Vt = mr = Bt; mr !== null; ) {
                            switch (Lt = mr,
                            rr = Lt.child,
                            Lt.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                Ad(4, Lt, Lt.return);
                                break;
                            case 1:
                                Uu(Lt, Lt.return);
                                var hr = Lt.stateNode;
                                if (typeof hr.componentWillUnmount == "function") {
                                    E = Lt,
                                    S = Lt.return;
                                    try {
                                        g = E,
                                        hr.props = g.memoizedProps,
                                        hr.state = g.memoizedState,
                                        hr.componentWillUnmount()
                                    } catch (wr) {
                                        si(E, S, wr)
                                    }
                                }
                                break;
                            case 5:
                                Uu(Lt, Lt.return);
                                break;
                            case 22:
                                if (Lt.memoizedState !== null) {
                                    Gu(Vt);
                                    continue
                                }
                            }
                            rr !== null ? (rr.return = Lt,
                            mr = rr) : Gu(Vt)
                        }
                        Bt = Bt.sibling
                    }
                e: for (Bt = null,
                Vt = h; ; ) {
                    if (Vt.tag === 5) {
                        if (Bt === null) {
                            Bt = Vt;
                            try {
                                F = Vt.stateNode,
                                xt ? (W = F.style,
                                typeof W.setProperty == "function" ? W.setProperty("display", "none", "important") : W.display = "none") : (Fe = Vt.stateNode,
                                Je = Vt.memoizedProps.style,
                                pe = Je != null && Je.hasOwnProperty("display") ? Je.display : null,
                                Fe.style.display = se("display", pe))
                            } catch (wr) {
                                si(h, h.return, wr)
                            }
                        }
                    } else if (Vt.tag === 6) {
                        if (Bt === null)
                            try {
                                Vt.stateNode.nodeValue = xt ? "" : Vt.memoizedProps
                            } catch (wr) {
                                si(h, h.return, wr)
                            }
                    } else if ((Vt.tag !== 22 && Vt.tag !== 23 || Vt.memoizedState === null || Vt === h) && Vt.child !== null) {
                        Vt.child.return = Vt,
                        Vt = Vt.child;
                        continue
                    }
                    if (Vt === h)
                        break e;
                    for (; Vt.sibling === null; ) {
                        if (Vt.return === null || Vt.return === h)
                            break e;
                        Bt === Vt && (Bt = null),
                        Vt = Vt.return
                    }
                    Bt === Vt && (Bt = null),
                    Vt.sibling.return = Vt.return,
                    Vt = Vt.sibling
                }
            }
            break;
        case 19:
            As(g, h),
            xa(h),
            E & 4 && Py(h);
            break;
        case 21:
            break;
        default:
            As(g, h),
            xa(h)
        }
    }
    function xa(h) {
        var g = h.flags;
        if (g & 2) {
            try {
                e: {
                    for (var S = h.return; S !== null; ) {
                        if (Oc(S)) {
                            var E = S;
                            break e
                        }
                        S = S.return
                    }
                    throw Error(i(160))
                }
                switch (E.tag) {
                case 5:
                    var F = E.stateNode;
                    E.flags & 32 && (er(F, ""),
                    E.flags &= -33);
                    var W = Rh(h);
                    bm(h, W, F);
                    break;
                case 3:
                case 4:
                    var pe = E.stateNode.containerInfo
                      , Fe = Rh(h);
                    xm(h, Fe, pe);
                    break;
                default:
                    throw Error(i(161))
                }
            } catch (Je) {
                si(h, h.return, Je)
            }
            h.flags &= -3
        }
        g & 4096 && (h.flags &= -4097)
    }
    function Dd(h, g, S) {
        mr = h,
        ky(h)
    }
    function ky(h, g, S) {
        for (var E = (h.mode & 1) !== 0; mr !== null; ) {
            var F = mr
              , W = F.child;
            if (F.tag === 22 && E) {
                var pe = F.memoizedState !== null || Yf;
                if (!pe) {
                    var Fe = F.alternate
                      , Je = Fe !== null && Fe.memoizedState !== null || So;
                    Fe = Yf;
                    var xt = So;
                    if (Yf = pe,
                    (So = Je) && !xt)
                        for (mr = F; mr !== null; )
                            pe = mr,
                            Je = pe.child,
                            pe.tag === 22 && pe.memoizedState !== null ? wm(F) : Je !== null ? (Je.return = pe,
                            mr = Je) : wm(F);
                    for (; W !== null; )
                        mr = W,
                        ky(W),
                        W = W.sibling;
                    mr = F,
                    Yf = Fe,
                    So = xt
                }
                oi(h)
            } else
                (F.subtreeFlags & 8772) !== 0 && W !== null ? (W.return = F,
                mr = W) : oi(h)
        }
    }
    function oi(h) {
        for (; mr !== null; ) {
            var g = mr;
            if ((g.flags & 8772) !== 0) {
                var S = g.alternate;
                try {
                    if ((g.flags & 8772) !== 0)
                        switch (g.tag) {
                        case 0:
                        case 11:
                        case 15:
                            So || Ih(5, g);
                            break;
                        case 1:
                            var E = g.stateNode;
                            if (g.flags & 4 && !So)
                                if (S === null)
                                    E.componentDidMount();
                                else {
                                    var F = g.elementType === g.type ? S.memoizedProps : es(g.type, S.memoizedProps);
                                    E.componentDidUpdate(F, S.memoizedState, E.__reactInternalSnapshotBeforeUpdate)
                                }
                            var W = g.updateQueue;
                            W !== null && Ec(g, W, E);
                            break;
                        case 3:
                            var pe = g.updateQueue;
                            if (pe !== null) {
                                if (S = null,
                                g.child !== null)
                                    switch (g.child.tag) {
                                    case 5:
                                        S = g.child.stateNode;
                                        break;
                                    case 1:
                                        S = g.child.stateNode
                                    }
                                Ec(g, pe, S)
                            }
                            break;
                        case 5:
                            var Fe = g.stateNode;
                            if (S === null && g.flags & 4) {
                                S = Fe;
                                var Je = g.memoizedProps;
                                switch (g.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    Je.autoFocus && S.focus();
                                    break;
                                case "img":
                                    Je.src && (S.src = Je.src)
                                }
                            }
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (g.memoizedState === null) {
                                var xt = g.alternate;
                                if (xt !== null) {
                                    var Bt = xt.memoizedState;
                                    if (Bt !== null) {
                                        var Vt = Bt.dehydrated;
                                        Vt !== null && Cs(Vt)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                        case 25:
                            break;
                        default:
                            throw Error(i(163))
                        }
                    So || g.flags & 512 && zd(g)
                } catch (Lt) {
                    si(g, g.return, Lt)
                }
            }
            if (g === h) {
                mr = null;
                break
            }
            if (S = g.sibling,
            S !== null) {
                S.return = g.return,
                mr = S;
                break
            }
            mr = g.return
        }
    }
    function Gu(h) {
        for (; mr !== null; ) {
            var g = mr;
            if (g === h) {
                mr = null;
                break
            }
            var S = g.sibling;
            if (S !== null) {
                S.return = g.return,
                mr = S;
                break
            }
            mr = g.return
        }
    }
    function wm(h) {
        for (; mr !== null; ) {
            var g = mr;
            try {
                switch (g.tag) {
                case 0:
                case 11:
                case 15:
                    var S = g.return;
                    try {
                        Ih(4, g)
                    } catch (Je) {
                        si(g, S, Je)
                    }
                    break;
                case 1:
                    var E = g.stateNode;
                    if (typeof E.componentDidMount == "function") {
                        var F = g.return;
                        try {
                            E.componentDidMount()
                        } catch (Je) {
                            si(g, F, Je)
                        }
                    }
                    var W = g.return;
                    try {
                        zd(g)
                    } catch (Je) {
                        si(g, W, Je)
                    }
                    break;
                case 5:
                    var pe = g.return;
                    try {
                        zd(g)
                    } catch (Je) {
                        si(g, pe, Je)
                    }
                }
            } catch (Je) {
                si(g, g.return, Je)
            }
            if (g === h) {
                mr = null;
                break
            }
            var Fe = g.sibling;
            if (Fe !== null) {
                Fe.return = g.return,
                mr = Fe;
                break
            }
            mr = g.return
        }
    }
    var Qf = Math.ceil
      , Wu = ce.ReactCurrentDispatcher
      , qu = ce.ReactCurrentOwner
      , zs = ce.ReactCurrentBatchConfig
      , mn = 0
      , _i = null
      , vi = null
      , xi = 0
      , Bo = 0
      , ba = Yo(0)
      , di = 0
      , Ld = null
      , Bc = 0
      , nl = 0
      , Sm = 0
      , Ah = null
      , io = null
      , Od = 0
      , Hu = 1 / 0
      , il = null
      , Jf = !1
      , Cm = null
      , jc = null
      , ep = !1
      , Nc = null
      , zh = 0
      , Dh = 0
      , Fd = null
      , Bd = -1
      , Lh = 0;
    function jo() {
        return (mn & 6) !== 0 ? kr() : Bd !== -1 ? Bd : Bd = kr()
    }
    function Ul(h) {
        return (h.mode & 1) === 0 ? 1 : (mn & 2) !== 0 && xi !== 0 ? xi & -xi : Qa.transition !== null ? (Lh === 0 && (Lh = Ki()),
        Lh) : (h = dn,
        h !== 0 || (h = window.event,
        h = h === void 0 ? 16 : od(h.type)),
        h)
    }
    function ps(h, g, S, E) {
        if (50 < Dh)
            throw Dh = 0,
            Fd = null,
            Error(i(185));
        bl(h, S, E),
        ((mn & 2) === 0 || h !== _i) && (h === _i && ((mn & 2) === 0 && (nl |= S),
        di === 4 && ol(h, xi)),
        is(h, E),
        S === 1 && mn === 0 && (g.mode & 1) === 0 && (Hu = kr() + 500,
        Do && Xa()))
    }
    function is(h, g) {
        var S = h.callbackNode;
        Vi(h, g);
        var E = bs(h, h === _i ? xi : 0);
        if (E === 0)
            S !== null && _r(S),
            h.callbackNode = null,
            h.callbackPriority = 0;
        else if (g = E & -E,
        h.callbackPriority !== g) {
            if (S != null && _r(S),
            g === 1)
                h.tag === 0 ? xc(Oh.bind(null, h)) : ro(Oh.bind(null, h)),
                Ff(function() {
                    (mn & 6) === 0 && Xa()
                }),
                S = null;
            else {
                switch (ws(E)) {
                case 1:
                    S = Si;
                    break;
                case 4:
                    S = $i;
                    break;
                case 16:
                    S = Ro;
                    break;
                case 536870912:
                    S = an;
                    break;
                default:
                    S = Ro
                }
                S = Ly(S, Tm.bind(null, h))
            }
            h.callbackPriority = g,
            h.callbackNode = S
        }
    }
    function Tm(h, g) {
        if (Bd = -1,
        Lh = 0,
        (mn & 6) !== 0)
            throw Error(i(327));
        var S = h.callbackNode;
        if (Fh() && h.callbackNode !== S)
            return null;
        var E = bs(h, h === _i ? xi : 0);
        if (E === 0)
            return null;
        if ((E & 30) !== 0 || (E & h.expiredLanes) !== 0 || g)
            g = Vc(h, E);
        else {
            g = E;
            var F = mn;
            mn |= 2;
            var W = Ey();
            (_i !== h || xi !== g) && (il = null,
            Hu = kr() + 500,
            $c(h, g));
            do
                try {
                    jv();
                    break
                } catch (Fe) {
                    Mm(h, Fe)
                }
            while (!0);
            Cr(),
            Wu.current = W,
            mn = F,
            vi !== null ? g = 0 : (_i = null,
            xi = 0,
            g = di)
        }
        if (g !== 0) {
            if (g === 2 && (F = oa(h),
            F !== 0 && (E = F,
            g = tp(h, F))),
            g === 1)
                throw S = Ld,
                $c(h, 0),
                ol(h, E),
                is(h, kr()),
                S;
            if (g === 6)
                ol(h, E);
            else {
                if (F = h.current.alternate,
                (E & 30) === 0 && !Bv(F) && (g = Vc(h, E),
                g === 2 && (W = oa(h),
                W !== 0 && (E = W,
                g = tp(h, W))),
                g === 1))
                    throw S = Ld,
                    $c(h, 0),
                    ol(h, E),
                    is(h, kr()),
                    S;
                switch (h.finishedWork = F,
                h.finishedLanes = E,
                g) {
                case 0:
                case 1:
                    throw Error(i(345));
                case 2:
                    Yu(h, io, il);
                    break;
                case 3:
                    if (ol(h, E),
                    (E & 130023424) === E && (g = Od + 500 - kr(),
                    10 < g)) {
                        if (bs(h, 0) !== 0)
                            break;
                        if (F = h.suspendedLanes,
                        (F & E) !== E) {
                            jo(),
                            h.pingedLanes |= h.suspendedLanes & F;
                            break
                        }
                        h.timeoutHandle = vh(Yu.bind(null, h, io, il), g);
                        break
                    }
                    Yu(h, io, il);
                    break;
                case 4:
                    if (ol(h, E),
                    (E & 4194240) === E)
                        break;
                    for (g = h.eventTimes,
                    F = -1; 0 < E; ) {
                        var pe = 31 - Hn(E);
                        W = 1 << pe,
                        pe = g[pe],
                        pe > F && (F = pe),
                        E &= ~W
                    }
                    if (E = F,
                    E = kr() - E,
                    E = (120 > E ? 120 : 480 > E ? 480 : 1080 > E ? 1080 : 1920 > E ? 1920 : 3e3 > E ? 3e3 : 4320 > E ? 4320 : 1960 * Qf(E / 1960)) - E,
                    10 < E) {
                        h.timeoutHandle = vh(Yu.bind(null, h, io, il), E);
                        break
                    }
                    Yu(h, io, il);
                    break;
                case 5:
                    Yu(h, io, il);
                    break;
                default:
                    throw Error(i(329))
                }
            }
        }
        return is(h, kr()),
        h.callbackNode === S ? Tm.bind(null, h) : null
    }
    function tp(h, g) {
        var S = Ah;
        return h.current.memoizedState.isDehydrated && ($c(h, g).flags |= 256),
        h = Vc(h, g),
        h !== 2 && (g = io,
        io = S,
        g !== null && Zu(g)),
        h
    }
    function Zu(h) {
        io === null ? io = h : io.push.apply(io, h)
    }
    function Bv(h) {
        for (var g = h; ; ) {
            if (g.flags & 16384) {
                var S = g.updateQueue;
                if (S !== null && (S = S.stores,
                S !== null))
                    for (var E = 0; E < S.length; E++) {
                        var F = S[E]
                          , W = F.getSnapshot;
                        F = F.value;
                        try {
                            if (!Gi(W(), F))
                                return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (S = g.child,
            g.subtreeFlags & 16384 && S !== null)
                S.return = g,
                g = S;
            else {
                if (g === h)
                    break;
                for (; g.sibling === null; ) {
                    if (g.return === null || g.return === h)
                        return !0;
                    g = g.return
                }
                g.sibling.return = g.return,
                g = g.sibling
            }
        }
        return !0
    }
    function ol(h, g) {
        for (g &= ~Sm,
        g &= ~nl,
        h.suspendedLanes |= g,
        h.pingedLanes &= ~g,
        h = h.expirationTimes; 0 < g; ) {
            var S = 31 - Hn(g)
              , E = 1 << S;
            h[S] = -1,
            g &= ~E
        }
    }
    function Oh(h) {
        if ((mn & 6) !== 0)
            throw Error(i(327));
        Fh();
        var g = bs(h, 0);
        if ((g & 1) === 0)
            return is(h, kr()),
            null;
        var S = Vc(h, g);
        if (h.tag !== 0 && S === 2) {
            var E = oa(h);
            E !== 0 && (g = E,
            S = tp(h, E))
        }
        if (S === 1)
            throw S = Ld,
            $c(h, 0),
            ol(h, g),
            is(h, kr()),
            S;
        if (S === 6)
            throw Error(i(345));
        return h.finishedWork = h.current.alternate,
        h.finishedLanes = g,
        Yu(h, io, il),
        is(h, kr()),
        null
    }
    function jd(h, g) {
        var S = mn;
        mn |= 1;
        try {
            return h(g)
        } finally {
            mn = S,
            mn === 0 && (Hu = kr() + 500,
            Do && Xa())
        }
    }
    function Xu(h) {
        Nc !== null && Nc.tag === 0 && (mn & 6) === 0 && Fh();
        var g = mn;
        mn |= 1;
        var S = zs.transition
          , E = dn;
        try {
            if (zs.transition = null,
            dn = 1,
            h)
                return h()
        } finally {
            dn = E,
            zs.transition = S,
            mn = g,
            (mn & 6) === 0 && Xa()
        }
    }
    function Pm() {
        Bo = ba.current,
        wn(ba)
    }
    function $c(h, g) {
        h.finishedWork = null,
        h.finishedLanes = 0;
        var S = h.timeoutHandle;
        if (S !== -1 && (h.timeoutHandle = -1,
        xh(S)),
        vi !== null)
            for (S = vi.return; S !== null; ) {
                var E = S;
                switch (Iu(E),
                E.tag) {
                case 1:
                    E = E.type.childContextTypes,
                    E != null && Ol();
                    break;
                case 3:
                    m(),
                    wn(_o),
                    wn(Ai),
                    B();
                    break;
                case 5:
                    x(E);
                    break;
                case 4:
                    m();
                    break;
                case 13:
                    wn(P);
                    break;
                case 19:
                    wn(P);
                    break;
                case 10:
                    Mc(E.type._context);
                    break;
                case 22:
                case 23:
                    Pm()
                }
                S = S.return
            }
        if (_i = h,
        vi = h = Gl(h.current, null),
        xi = Bo = g,
        di = 0,
        Ld = null,
        Sm = nl = Bc = 0,
        io = Ah = null,
        el !== null) {
            for (g = 0; g < el.length; g++)
                if (S = el[g],
                E = S.interleaved,
                E !== null) {
                    S.interleaved = null;
                    var F = E.next
                      , W = S.pending;
                    if (W !== null) {
                        var pe = W.next;
                        W.next = F,
                        E.next = pe
                    }
                    S.pending = E
                }
            el = null
        }
        return h
    }
    function Mm(h, g) {
        do {
            var S = vi;
            try {
                if (Cr(),
                $.current = Li,
                Se) {
                    for (var E = Y.memoizedState; E !== null; ) {
                        var F = E.queue;
                        F !== null && (F.pending = null),
                        E = E.next
                    }
                    Se = !1
                }
                if (H = 0,
                ye = ae = Y = null,
                Te = !1,
                Re = 0,
                qu.current = null,
                S === null || S.return === null) {
                    di = 1,
                    Ld = g,
                    vi = null;
                    break
                }
                e: {
                    var W = h
                      , pe = S.return
                      , Fe = S
                      , Je = g;
                    if (g = xi,
                    Fe.flags |= 32768,
                    Je !== null && typeof Je == "object" && typeof Je.then == "function") {
                        var xt = Je
                          , Bt = Fe
                          , Vt = Bt.tag;
                        if ((Bt.mode & 1) === 0 && (Vt === 0 || Vt === 11 || Vt === 15)) {
                            var Lt = Bt.alternate;
                            Lt ? (Bt.updateQueue = Lt.updateQueue,
                            Bt.memoizedState = Lt.memoizedState,
                            Bt.lanes = Lt.lanes) : (Bt.updateQueue = null,
                            Bt.memoizedState = null)
                        }
                        var rr = hm(pe);
                        if (rr !== null) {
                            rr.flags &= -257,
                            _y(rr, pe, Fe, W, g),
                            rr.mode & 1 && Dc(W, xt, g),
                            g = rr,
                            Je = xt;
                            var hr = g.updateQueue;
                            if (hr === null) {
                                var wr = new Set;
                                wr.add(Je),
                                g.updateQueue = wr
                            } else
                                hr.add(Je);
                            break e
                        } else {
                            if ((g & 1) === 0) {
                                Dc(W, xt, g),
                                km();
                                break e
                            }
                            Je = Error(i(426))
                        }
                    } else if (Xn && Fe.mode & 1) {
                        var fi = hm(pe);
                        if (fi !== null) {
                            (fi.flags & 65536) === 0 && (fi.flags |= 256),
                            _y(fi, pe, Fe, W, g),
                            zu(ts(Je, Fe));
                            break e
                        }
                    }
                    W = Je = ts(Je, Fe),
                    di !== 4 && (di = 2),
                    Ah === null ? Ah = [W] : Ah.push(W),
                    W = pe;
                    do {
                        switch (W.tag) {
                        case 3:
                            W.flags |= 65536,
                            g &= -g,
                            W.lanes |= g;
                            var pt = um(W, Je, g);
                            Ou(W, pt);
                            break e;
                        case 1:
                            Fe = Je;
                            var rt = W.type
                              , gt = W.stateNode;
                            if ((W.flags & 128) === 0 && (typeof rt.getDerivedStateFromError == "function" || gt !== null && typeof gt.componentDidCatch == "function" && (jc === null || !jc.has(gt)))) {
                                W.flags |= 65536,
                                g &= -g,
                                W.lanes |= g;
                                var Zt = zc(W, Fe, g);
                                Ou(W, Zt);
                                break e
                            }
                        }
                        W = W.return
                    } while (W !== null)
                }
                Ay(S)
            } catch (Pr) {
                g = Pr,
                vi === S && S !== null && (vi = S = S.return);
                continue
            }
            break
        } while (!0)
    }
    function Ey() {
        var h = Wu.current;
        return Wu.current = Li,
        h === null ? Li : h
    }
    function km() {
        (di === 0 || di === 3 || di === 2) && (di = 4),
        _i === null || (Bc & 268435455) === 0 && (nl & 268435455) === 0 || ol(_i, xi)
    }
    function Vc(h, g) {
        var S = mn;
        mn |= 2;
        var E = Ey();
        (_i !== h || xi !== g) && (il = null,
        $c(h, g));
        do
            try {
                Iy();
                break
            } catch (F) {
                Mm(h, F)
            }
        while (!0);
        if (Cr(),
        mn = S,
        Wu.current = E,
        vi !== null)
            throw Error(i(261));
        return _i = null,
        xi = 0,
        di
    }
    function Iy() {
        for (; vi !== null; )
            Ry(vi)
    }
    function jv() {
        for (; vi !== null && !ri(); )
            Ry(vi)
    }
    function Ry(h) {
        var g = Nd(h.alternate, h, Bo);
        h.memoizedProps = h.pendingProps,
        g === null ? Ay(h) : vi = g,
        qu.current = null
    }
    function Ay(h) {
        var g = h;
        do {
            var S = g.alternate;
            if (h = g.return,
            (g.flags & 32768) === 0) {
                if (S = Sy(S, g, Bo),
                S !== null) {
                    vi = S;
                    return
                }
            } else {
                if (S = Lv(S, g),
                S !== null) {
                    S.flags &= 32767,
                    vi = S;
                    return
                }
                if (h !== null)
                    h.flags |= 32768,
                    h.subtreeFlags = 0,
                    h.deletions = null;
                else {
                    di = 6,
                    vi = null;
                    return
                }
            }
            if (g = g.sibling,
            g !== null) {
                vi = g;
                return
            }
            vi = g = h
        } while (g !== null);
        di === 0 && (di = 5)
    }
    function Yu(h, g, S) {
        var E = dn
          , F = zs.transition;
        try {
            zs.transition = null,
            dn = 1,
            Nv(h, g, S, E)
        } finally {
            zs.transition = F,
            dn = E
        }
        return null
    }
    function Nv(h, g, S, E) {
        do
            Fh();
        while (Nc !== null);
        if ((mn & 6) !== 0)
            throw Error(i(327));
        S = h.finishedWork;
        var F = h.finishedLanes;
        if (S === null)
            return null;
        if (h.finishedWork = null,
        h.finishedLanes = 0,
        S === h.current)
            throw Error(i(177));
        h.callbackNode = null,
        h.callbackPriority = 0;
        var W = S.lanes | S.childLanes;
        if (wf(h, W),
        h === _i && (vi = _i = null,
        xi = 0),
        (S.subtreeFlags & 2064) === 0 && (S.flags & 2064) === 0 || ep || (ep = !0,
        Ly(Ro, function() {
            return Fh(),
            null
        })),
        W = (S.flags & 15990) !== 0,
        (S.subtreeFlags & 15990) !== 0 || W) {
            W = zs.transition,
            zs.transition = null;
            var pe = dn;
            dn = 1;
            var Fe = mn;
            mn |= 4,
            qu.current = null,
            Fv(h, S),
            My(S, h),
            lm(qs),
            $s = !!Pu,
            qs = Pu = null,
            h.current = S,
            Dd(S),
            ni(),
            mn = Fe,
            dn = pe,
            zs.transition = W
        } else
            h.current = S;
        if (ep && (ep = !1,
        Nc = h,
        zh = F),
        W = h.pendingLanes,
        W === 0 && (jc = null),
        Ao(S.stateNode),
        is(h, kr()),
        g !== null)
            for (E = h.onRecoverableError,
            S = 0; S < g.length; S++)
                F = g[S],
                E(F.value, {
                    componentStack: F.stack,
                    digest: F.digest
                });
        if (Jf)
            throw Jf = !1,
            h = Cm,
            Cm = null,
            h;
        return (zh & 1) !== 0 && h.tag !== 0 && Fh(),
        W = h.pendingLanes,
        (W & 1) !== 0 ? h === Fd ? Dh++ : (Dh = 0,
        Fd = h) : Dh = 0,
        Xa(),
        null
    }
    function Fh() {
        if (Nc !== null) {
            var h = ws(zh)
              , g = zs.transition
              , S = dn;
            try {
                if (zs.transition = null,
                dn = 16 > h ? 16 : h,
                Nc === null)
                    var E = !1;
                else {
                    if (h = Nc,
                    Nc = null,
                    zh = 0,
                    (mn & 6) !== 0)
                        throw Error(i(331));
                    var F = mn;
                    for (mn |= 4,
                    mr = h.current; mr !== null; ) {
                        var W = mr
                          , pe = W.child;
                        if ((mr.flags & 16) !== 0) {
                            var Fe = W.deletions;
                            if (Fe !== null) {
                                for (var Je = 0; Je < Fe.length; Je++) {
                                    var xt = Fe[Je];
                                    for (mr = xt; mr !== null; ) {
                                        var Bt = mr;
                                        switch (Bt.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Ad(8, Bt, W)
                                        }
                                        var Vt = Bt.child;
                                        if (Vt !== null)
                                            Vt.return = Bt,
                                            mr = Vt;
                                        else
                                            for (; mr !== null; ) {
                                                Bt = mr;
                                                var Lt = Bt.sibling
                                                  , rr = Bt.return;
                                                if (vm(Bt),
                                                Bt === xt) {
                                                    mr = null;
                                                    break
                                                }
                                                if (Lt !== null) {
                                                    Lt.return = rr,
                                                    mr = Lt;
                                                    break
                                                }
                                                mr = rr
                                            }
                                    }
                                }
                                var hr = W.alternate;
                                if (hr !== null) {
                                    var wr = hr.child;
                                    if (wr !== null) {
                                        hr.child = null;
                                        do {
                                            var fi = wr.sibling;
                                            wr.sibling = null,
                                            wr = fi
                                        } while (wr !== null)
                                    }
                                }
                                mr = W
                            }
                        }
                        if ((W.subtreeFlags & 2064) !== 0 && pe !== null)
                            pe.return = W,
                            mr = pe;
                        else
                            e: for (; mr !== null; ) {
                                if (W = mr,
                                (W.flags & 2048) !== 0)
                                    switch (W.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Ad(9, W, W.return)
                                    }
                                var pt = W.sibling;
                                if (pt !== null) {
                                    pt.return = W.return,
                                    mr = pt;
                                    break e
                                }
                                mr = W.return
                            }
                    }
                    var rt = h.current;
                    for (mr = rt; mr !== null; ) {
                        pe = mr;
                        var gt = pe.child;
                        if ((pe.subtreeFlags & 2064) !== 0 && gt !== null)
                            gt.return = pe,
                            mr = gt;
                        else
                            e: for (pe = rt; mr !== null; ) {
                                if (Fe = mr,
                                (Fe.flags & 2048) !== 0)
                                    try {
                                        switch (Fe.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Ih(9, Fe)
                                        }
                                    } catch (Pr) {
                                        si(Fe, Fe.return, Pr)
                                    }
                                if (Fe === pe) {
                                    mr = null;
                                    break e
                                }
                                var Zt = Fe.sibling;
                                if (Zt !== null) {
                                    Zt.return = Fe.return,
                                    mr = Zt;
                                    break e
                                }
                                mr = Fe.return
                            }
                    }
                    if (mn = F,
                    Xa(),
                    Ei && typeof Ei.onPostCommitFiberRoot == "function")
                        try {
                            Ei.onPostCommitFiberRoot(qn, h)
                        } catch {}
                    E = !0
                }
                return E
            } finally {
                dn = S,
                zs.transition = g
            }
        }
        return !1
    }
    function Em(h, g, S) {
        g = ts(S, g),
        g = um(h, g, 1),
        h = bo(h, g, 1),
        g = jo(),
        h !== null && (bl(h, 1, g),
        is(h, g))
    }
    function si(h, g, S) {
        if (h.tag === 3)
            Em(h, h, S);
        else
            for (; g !== null; ) {
                if (g.tag === 3) {
                    Em(g, h, S);
                    break
                } else if (g.tag === 1) {
                    var E = g.stateNode;
                    if (typeof g.type.getDerivedStateFromError == "function" || typeof E.componentDidCatch == "function" && (jc === null || !jc.has(E))) {
                        h = ts(S, h),
                        h = zc(g, h, 1),
                        g = bo(g, h, 1),
                        h = jo(),
                        g !== null && (bl(g, 1, h),
                        is(g, h));
                        break
                    }
                }
                g = g.return
            }
    }
    function zy(h, g, S) {
        var E = h.pingCache;
        E !== null && E.delete(g),
        g = jo(),
        h.pingedLanes |= h.suspendedLanes & S,
        _i === h && (xi & S) === S && (di === 4 || di === 3 && (xi & 130023424) === xi && 500 > kr() - Od ? $c(h, 0) : Sm |= S),
        is(h, g)
    }
    function Im(h, g) {
        g === 0 && ((h.mode & 1) === 0 ? g = 1 : (g = Ho,
        Ho <<= 1,
        (Ho & 130023424) === 0 && (Ho = 4194304)));
        var S = jo();
        h = xo(h, g),
        h !== null && (bl(h, g, S),
        is(h, S))
    }
    function Dy(h) {
        var g = h.memoizedState
          , S = 0;
        g !== null && (S = g.retryLane),
        Im(h, S)
    }
    function $v(h, g) {
        var S = 0;
        switch (h.tag) {
        case 13:
            var E = h.stateNode
              , F = h.memoizedState;
            F !== null && (S = F.retryLane);
            break;
        case 19:
            E = h.stateNode;
            break;
        default:
            throw Error(i(314))
        }
        E !== null && E.delete(g),
        Im(h, S)
    }
    var Nd;
    Nd = function(h, g, S) {
        if (h !== null)
            if (h.memoizedProps !== g.pendingProps || _o.current)
                rs = !0;
            else {
                if ((h.lanes & S) === 0 && (g.flags & 128) === 0)
                    return rs = !1,
                    wy(h, g, S);
                rs = (h.flags & 131072) !== 0
            }
        else
            rs = !1,
            Xn && (g.flags & 1048576) !== 0 && Sc(g, Ya, g.index);
        switch (g.lanes = 0,
        g.tag) {
        case 2:
            var E = g.type;
            Zf(h, g),
            h = g.pendingProps;
            var F = ks(g, Ai.current);
            Zs(g, S),
            F = qe(null, g, E, h, F, S);
            var W = ze();
            return g.flags |= 1,
            typeof F == "object" && F !== null && typeof F.render == "function" && F.$$typeof === void 0 ? (g.tag = 1,
            g.memoizedState = null,
            g.updateQueue = null,
            to(E) ? (W = !0,
            Fl(g)) : W = !1,
            g.memoizedState = F.state !== null && F.state !== void 0 ? F.state : null,
            Yn(g),
            F.updater = ya,
            g.stateNode = F,
            F._reactInternals = g,
            Fu(g, E, h, S),
            g = Lc(null, g, E, !0, W, S)) : (g.tag = 0,
            Xn && W && Ka(g),
            ns(null, g, F, S),
            g = g.child),
            g;
        case 16:
            E = g.elementType;
            e: {
                switch (Zf(h, g),
                h = g.pendingProps,
                F = E._init,
                E = F(E._payload),
                g.type = E,
                F = g.tag = Vv(E),
                h = es(E, h),
                F) {
                case 0:
                    g = Gf(null, g, E, h, S);
                    break e;
                case 1:
                    g = pm(null, g, E, h, S);
                    break e;
                case 11:
                    g = fm(null, g, E, h, S);
                    break e;
                case 14:
                    g = vy(null, g, E, es(E.type, h), S);
                    break e
                }
                throw Error(i(306, E, ""))
            }
            return g;
        case 0:
            return E = g.type,
            F = g.pendingProps,
            F = g.elementType === E ? F : es(E, F),
            Gf(h, g, E, F, S);
        case 1:
            return E = g.type,
            F = g.pendingProps,
            F = g.elementType === E ? F : es(E, F),
            pm(h, g, E, F, S);
        case 3:
            e: {
                if (by(g),
                h === null)
                    throw Error(i(387));
                E = g.pendingProps,
                W = g.memoizedState,
                F = W.element,
                Rd(h, g),
                Xs(g, E, null, S);
                var pe = g.memoizedState;
                if (E = pe.element,
                W.isDehydrated)
                    if (W = {
                        element: E,
                        isDehydrated: !1,
                        cache: pe.cache,
                        pendingSuspenseBoundaries: pe.pendingSuspenseBoundaries,
                        transitions: pe.transitions
                    },
                    g.updateQueue.baseState = W,
                    g.memoizedState = W,
                    g.flags & 256) {
                        F = ts(Error(i(423)), g),
                        g = Mh(h, g, E, S, F);
                        break e
                    } else if (E !== F) {
                        F = ts(Error(i(424)), g),
                        g = Mh(h, g, E, S, F);
                        break e
                    } else
                        for (vo = Ms(g.stateNode.containerInfo.firstChild),
                        Ir = g,
                        Xn = !0,
                        Lo = null,
                        S = Ed(g, null, E, S),
                        g.child = S; S; )
                            S.flags = S.flags & -3 | 4096,
                            S = S.sibling;
                else {
                    if (Pc(),
                    E === F) {
                        g = _a(h, g, S);
                        break e
                    }
                    ns(h, g, E, S)
                }
                g = g.child
            }
            return g;
        case 5:
            return y(g),
            h === null && Cc(g),
            E = g.type,
            F = g.pendingProps,
            W = h !== null ? h.memoizedProps : null,
            pe = F.children,
            Md(E, F) ? pe = null : W !== null && Md(E, W) && (g.flags |= 32),
            Uf(h, g),
            ns(h, g, pe, S),
            g.child;
        case 6:
            return h === null && Cc(g),
            null;
        case 13:
            return mm(h, g, S);
        case 4:
            return a(g, g.stateNode.containerInfo),
            E = g.pendingProps,
            h === null ? g.child = jl(g, null, E, S) : ns(h, g, E, S),
            g.child;
        case 11:
            return E = g.type,
            F = g.pendingProps,
            F = g.elementType === E ? F : es(E, F),
            fm(h, g, E, F, S);
        case 7:
            return ns(h, g, g.pendingProps, S),
            g.child;
        case 8:
            return ns(h, g, g.pendingProps.children, S),
            g.child;
        case 12:
            return ns(h, g, g.pendingProps.children, S),
            g.child;
        case 10:
            e: {
                if (E = g.type._context,
                F = g.pendingProps,
                W = g.memoizedProps,
                pe = F.value,
                tn(Ph, E._currentValue),
                E._currentValue = pe,
                W !== null)
                    if (Gi(W.value, pe)) {
                        if (W.children === F.children && !_o.current) {
                            g = _a(h, g, S);
                            break e
                        }
                    } else
                        for (W = g.child,
                        W !== null && (W.return = g); W !== null; ) {
                            var Fe = W.dependencies;
                            if (Fe !== null) {
                                pe = W.child;
                                for (var Je = Fe.firstContext; Je !== null; ) {
                                    if (Je.context === E) {
                                        if (W.tag === 1) {
                                            Je = no(-1, S & -S),
                                            Je.tag = 2;
                                            var xt = W.updateQueue;
                                            if (xt !== null) {
                                                xt = xt.shared;
                                                var Bt = xt.pending;
                                                Bt === null ? Je.next = Je : (Je.next = Bt.next,
                                                Bt.next = Je),
                                                xt.pending = Je
                                            }
                                        }
                                        W.lanes |= S,
                                        Je = W.alternate,
                                        Je !== null && (Je.lanes |= S),
                                        Lu(W.return, S, g),
                                        Fe.lanes |= S;
                                        break
                                    }
                                    Je = Je.next
                                }
                            } else if (W.tag === 10)
                                pe = W.type === g.type ? null : W.child;
                            else if (W.tag === 18) {
                                if (pe = W.return,
                                pe === null)
                                    throw Error(i(341));
                                pe.lanes |= S,
                                Fe = pe.alternate,
                                Fe !== null && (Fe.lanes |= S),
                                Lu(pe, S, g),
                                pe = W.sibling
                            } else
                                pe = W.child;
                            if (pe !== null)
                                pe.return = W;
                            else
                                for (pe = W; pe !== null; ) {
                                    if (pe === g) {
                                        pe = null;
                                        break
                                    }
                                    if (W = pe.sibling,
                                    W !== null) {
                                        W.return = pe.return,
                                        pe = W;
                                        break
                                    }
                                    pe = pe.return
                                }
                            W = pe
                        }
                ns(h, g, F.children, S),
                g = g.child
            }
            return g;
        case 9:
            return F = g.type,
            E = g.pendingProps.children,
            Zs(g, S),
            F = Vn(F),
            E = E(F),
            g.flags |= 1,
            ns(h, g, E, S),
            g.child;
        case 14:
            return E = g.type,
            F = es(E, g.pendingProps),
            F = es(E.type, F),
            vy(h, g, E, F, S);
        case 15:
            return Vf(h, g, g.type, g.pendingProps, S);
        case 17:
            return E = g.type,
            F = g.pendingProps,
            F = g.elementType === E ? F : es(E, F),
            Zf(h, g),
            g.tag = 1,
            to(E) ? (h = !0,
            Fl(g)) : h = !1,
            Zs(g, S),
            Oi(g, E, F),
            Fu(g, E, F, S),
            Lc(null, g, E, !0, h, S);
        case 19:
            return ym(h, g, S);
        case 22:
            return xy(h, g, S)
        }
        throw Error(i(156, g.tag))
    }
    ;
    function Ly(h, g) {
        return lr(h, g)
    }
    function Oy(h, g, S, E) {
        this.tag = h,
        this.key = S,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = g,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = E,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function Js(h, g, S, E) {
        return new Oy(h,g,S,E)
    }
    function Rm(h) {
        return h = h.prototype,
        !(!h || !h.isReactComponent)
    }
    function Vv(h) {
        if (typeof h == "function")
            return Rm(h) ? 1 : 0;
        if (h != null) {
            if (h = h.$$typeof,
            h === ct)
                return 11;
            if (h === he)
                return 14
        }
        return 2
    }
    function Gl(h, g) {
        var S = h.alternate;
        return S === null ? (S = Js(h.tag, g, h.key, h.mode),
        S.elementType = h.elementType,
        S.type = h.type,
        S.stateNode = h.stateNode,
        S.alternate = h,
        h.alternate = S) : (S.pendingProps = g,
        S.type = h.type,
        S.flags = 0,
        S.subtreeFlags = 0,
        S.deletions = null),
        S.flags = h.flags & 14680064,
        S.childLanes = h.childLanes,
        S.lanes = h.lanes,
        S.child = h.child,
        S.memoizedProps = h.memoizedProps,
        S.memoizedState = h.memoizedState,
        S.updateQueue = h.updateQueue,
        g = h.dependencies,
        S.dependencies = g === null ? null : {
            lanes: g.lanes,
            firstContext: g.firstContext
        },
        S.sibling = h.sibling,
        S.index = h.index,
        S.ref = h.ref,
        S
    }
    function rp(h, g, S, E, F, W) {
        var pe = 2;
        if (E = h,
        typeof h == "function")
            Rm(h) && (pe = 1);
        else if (typeof h == "string")
            pe = 5;
        else
            e: switch (h) {
            case K:
                return Ku(S.children, F, W, g);
            case be:
                pe = 8,
                F |= 8;
                break;
            case Ee:
                return h = Js(12, S, g, F | 2),
                h.elementType = Ee,
                h.lanes = W,
                h;
            case nt:
                return h = Js(13, S, g, F),
                h.elementType = nt,
                h.lanes = W,
                h;
            case J:
                return h = Js(19, S, g, F),
                h.elementType = J,
                h.lanes = W,
                h;
            case Ne:
                return Uc(S, F, W, g);
            default:
                if (typeof h == "object" && h !== null)
                    switch (h.$$typeof) {
                    case Ce:
                        pe = 10;
                        break e;
                    case He:
                        pe = 9;
                        break e;
                    case ct:
                        pe = 11;
                        break e;
                    case he:
                        pe = 14;
                        break e;
                    case ve:
                        pe = 16,
                        E = null;
                        break e
                    }
                throw Error(i(130, h == null ? h : typeof h, ""))
            }
        return g = Js(pe, S, g, F),
        g.elementType = h,
        g.type = E,
        g.lanes = W,
        g
    }
    function Ku(h, g, S, E) {
        return h = Js(7, h, E, g),
        h.lanes = S,
        h
    }
    function Uc(h, g, S, E) {
        return h = Js(22, h, E, g),
        h.elementType = Ne,
        h.lanes = S,
        h.stateNode = {
            isHidden: !1
        },
        h
    }
    function np(h, g, S) {
        return h = Js(6, h, null, g),
        h.lanes = S,
        h
    }
    function $d(h, g, S) {
        return g = Js(4, h.children !== null ? h.children : [], h.key, g),
        g.lanes = S,
        g.stateNode = {
            containerInfo: h.containerInfo,
            pendingChildren: null,
            implementation: h.implementation
        },
        g
    }
    function Fy(h, g, S, E, F) {
        this.tag = g,
        this.containerInfo = h,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = su(0),
        this.expirationTimes = su(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = su(0),
        this.identifierPrefix = E,
        this.onRecoverableError = F,
        this.mutableSourceEagerHydrationData = null
    }
    function bi(h, g, S, E, F, W, pe, Fe, Je) {
        return h = new Fy(h,g,S,Fe,Je),
        g === 1 ? (g = 1,
        W === !0 && (g |= 8)) : g = 0,
        W = Js(3, null, null, g),
        h.current = W,
        W.stateNode = h,
        W.memoizedState = {
            element: E,
            isDehydrated: S,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null
        },
        Yn(W),
        h
    }
    function Am(h, g, S) {
        var E = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: me,
            key: E == null ? null : "" + E,
            children: h,
            containerInfo: g,
            implementation: S
        }
    }
    function By(h) {
        if (!h)
            return Ri;
        h = h._reactInternals;
        e: {
            if (it(h) !== h || h.tag !== 1)
                throw Error(i(170));
            var g = h;
            do {
                switch (g.tag) {
                case 3:
                    g = g.stateNode.context;
                    break e;
                case 1:
                    if (to(g.type)) {
                        g = g.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
                }
                g = g.return
            } while (g !== null);
            throw Error(i(171))
        }
        if (h.tag === 1) {
            var S = h.type;
            if (to(S))
                return Eu(h, S, g)
        }
        return g
    }
    function zm(h, g, S, E, F, W, pe, Fe, Je) {
        return h = bi(S, E, !0, h, F, W, pe, Fe, Je),
        h.context = By(null),
        S = h.current,
        E = jo(),
        F = Ul(S),
        W = no(E, F),
        W.callback = g ?? null,
        bo(S, W, F),
        h.current.lanes = F,
        bl(h, F, E),
        is(h, E),
        h
    }
    function wa(h, g, S, E) {
        var F = g.current
          , W = jo()
          , pe = Ul(F);
        return S = By(S),
        g.context === null ? g.context = S : g.pendingContext = S,
        g = no(W, pe),
        g.payload = {
            element: h
        },
        E = E === void 0 ? null : E,
        E !== null && (g.callback = E),
        h = bo(F, g, pe),
        h !== null && (ps(h, F, pe, W),
        kc(h, F, pe)),
        pe
    }
    function Bh(h) {
        if (h = h.current,
        !h.child)
            return null;
        switch (h.child.tag) {
        case 5:
            return h.child.stateNode;
        default:
            return h.child.stateNode
        }
    }
    function jy(h, g) {
        if (h = h.memoizedState,
        h !== null && h.dehydrated !== null) {
            var S = h.retryLane;
            h.retryLane = S !== 0 && S < g ? S : g
        }
    }
    function Dm(h, g) {
        jy(h, g),
        (h = h.alternate) && jy(h, g)
    }
    function Uv() {
        return null
    }
    var Lm = typeof reportError == "function" ? reportError : function(h) {
        console.error(h)
    }
    ;
    function Vd(h) {
        this._internalRoot = h
    }
    Ud.prototype.render = Vd.prototype.render = function(h) {
        var g = this._internalRoot;
        if (g === null)
            throw Error(i(409));
        wa(h, g, null, null)
    }
    ,
    Ud.prototype.unmount = Vd.prototype.unmount = function() {
        var h = this._internalRoot;
        if (h !== null) {
            this._internalRoot = null;
            var g = h.containerInfo;
            Xu(function() {
                wa(null, h, null, null)
            }),
            g[gi] = null
        }
    }
    ;
    function Ud(h) {
        this._internalRoot = h
    }
    Ud.prototype.unstable_scheduleHydration = function(h) {
        if (h) {
            var g = Da();
            h = {
                blockedOn: null,
                target: h,
                priority: g
            };
            for (var S = 0; S < ei.length && g !== 0 && g < ei[S].priority; S++)
                ;
            ei.splice(S, 0, h),
            S === 0 && lu(h)
        }
    }
    ;
    function Qu(h) {
        return !(!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11)
    }
    function Wl(h) {
        return !(!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11 && (h.nodeType !== 8 || h.nodeValue !== " react-mount-point-unstable "))
    }
    function Gd() {}
    function ip(h, g, S, E, F) {
        if (F) {
            if (typeof E == "function") {
                var W = E;
                E = function() {
                    var xt = Bh(pe);
                    W.call(xt)
                }
            }
            var pe = zm(g, E, h, 0, null, !1, !1, "", Gd);
            return h._reactRootContainer = pe,
            h[gi] = pe.current,
            mc(h.nodeType === 8 ? h.parentNode : h),
            Xu(),
            pe
        }
        for (; F = h.lastChild; )
            h.removeChild(F);
        if (typeof E == "function") {
            var Fe = E;
            E = function() {
                var xt = Bh(Je);
                Fe.call(xt)
            }
        }
        var Je = bi(h, 0, !1, null, null, !1, !1, "", Gd);
        return h._reactRootContainer = Je,
        h[gi] = Je.current,
        mc(h.nodeType === 8 ? h.parentNode : h),
        Xu(function() {
            wa(g, Je, S, E)
        }),
        Je
    }
    function op(h, g, S, E, F) {
        var W = S._reactRootContainer;
        if (W) {
            var pe = W;
            if (typeof F == "function") {
                var Fe = F;
                F = function() {
                    var Je = Bh(pe);
                    Fe.call(Je)
                }
            }
            wa(g, pe, h, F)
        } else
            pe = ip(S, g, h, F, E);
        return Bh(pe)
    }
    Xr = function(h) {
        switch (h.tag) {
        case 3:
            var g = h.stateNode;
            if (g.current.memoizedState.isDehydrated) {
                var S = xs(g.pendingLanes);
                S !== 0 && (ic(g, S | 1),
                is(g, kr()),
                (mn & 6) === 0 && (Hu = kr() + 500,
                Xa()))
            }
            break;
        case 13:
            Xu(function() {
                var E = xo(h, 1);
                if (E !== null) {
                    var F = jo();
                    ps(E, h, 1, F)
                }
            }),
            Dm(h, 1)
        }
    }
    ,
    Ss = function(h) {
        if (h.tag === 13) {
            var g = xo(h, 134217728);
            if (g !== null) {
                var S = jo();
                ps(g, h, 134217728, S)
            }
            Dm(h, 134217728)
        }
    }
    ,
    Ns = function(h) {
        if (h.tag === 13) {
            var g = Ul(h)
              , S = xo(h, g);
            if (S !== null) {
                var E = jo();
                ps(S, h, g, E)
            }
            Dm(h, g)
        }
    }
    ,
    Da = function() {
        return dn
    }
    ,
    ch = function(h, g) {
        var S = dn;
        try {
            return dn = h,
            g()
        } finally {
            dn = S
        }
    }
    ,
    Qe = function(h, g, S) {
        switch (g) {
        case "input":
            if (Zr(h, S),
            g = S.name,
            S.type === "radio" && g != null) {
                for (S = h; S.parentNode; )
                    S = S.parentNode;
                for (S = S.querySelectorAll("input[name=" + JSON.stringify("" + g) + '][type="radio"]'),
                g = 0; g < S.length; g++) {
                    var E = S[g];
                    if (E !== h && E.form === h.form) {
                        var F = vc(E);
                        if (!F)
                            throw Error(i(90));
                        Nr(E),
                        Zr(E, F)
                    }
                }
            }
            break;
        case "textarea":
            yn(h, S);
            break;
        case "select":
            g = S.value,
            g != null && Wr(h, !!S.multiple, g, !1)
        }
    }
    ,
    Ut = jd,
    yr = Xu;
    var Gv = {
        usingClientEntryPoint: !1,
        Events: [Dl, Hs, vc, St, Ve, jd]
    }
      , jh = {
        findFiberByHostInstance: fs,
        bundleType: 0,
        version: "18.3.1",
        rendererPackageName: "react-dom"
    }
      , Ny = {
        bundleType: jh.bundleType,
        version: jh.version,
        rendererPackageName: jh.rendererPackageName,
        rendererConfig: jh.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: ce.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(h) {
            return h = Gt(h),
            h === null ? null : h.stateNode
        },
        findFiberByHostInstance: jh.findFiberByHostInstance || Uv,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var sp = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!sp.isDisabled && sp.supportsFiber)
            try {
                qn = sp.inject(Ny),
                Ei = sp
            } catch {}
    }
    return ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Gv,
    ea.createPortal = function(h, g) {
        var S = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!Qu(g))
            throw Error(i(200));
        return Am(h, g, null, S)
    }
    ,
    ea.createRoot = function(h, g) {
        if (!Qu(h))
            throw Error(i(299));
        var S = !1
          , E = ""
          , F = Lm;
        return g != null && (g.unstable_strictMode === !0 && (S = !0),
        g.identifierPrefix !== void 0 && (E = g.identifierPrefix),
        g.onRecoverableError !== void 0 && (F = g.onRecoverableError)),
        g = bi(h, 1, !1, null, null, S, !1, E, F),
        h[gi] = g.current,
        mc(h.nodeType === 8 ? h.parentNode : h),
        new Vd(g)
    }
    ,
    ea.findDOMNode = function(h) {
        if (h == null)
            return null;
        if (h.nodeType === 1)
            return h;
        var g = h._reactInternals;
        if (g === void 0)
            throw typeof h.render == "function" ? Error(i(188)) : (h = Object.keys(h).join(","),
            Error(i(268, h)));
        return h = Gt(g),
        h = h === null ? null : h.stateNode,
        h
    }
    ,
    ea.flushSync = function(h) {
        return Xu(h)
    }
    ,
    ea.hydrate = function(h, g, S) {
        if (!Wl(g))
            throw Error(i(200));
        return op(null, h, g, !0, S)
    }
    ,
    ea.hydrateRoot = function(h, g, S) {
        if (!Qu(h))
            throw Error(i(405));
        var E = S != null && S.hydratedSources || null
          , F = !1
          , W = ""
          , pe = Lm;
        if (S != null && (S.unstable_strictMode === !0 && (F = !0),
        S.identifierPrefix !== void 0 && (W = S.identifierPrefix),
        S.onRecoverableError !== void 0 && (pe = S.onRecoverableError)),
        g = zm(g, null, h, 1, S ?? null, F, !1, W, pe),
        h[gi] = g.current,
        mc(h),
        E)
            for (h = 0; h < E.length; h++)
                S = E[h],
                F = S._getVersion,
                F = F(S._source),
                g.mutableSourceEagerHydrationData == null ? g.mutableSourceEagerHydrationData = [S, F] : g.mutableSourceEagerHydrationData.push(S, F);
        return new Ud(g)
    }
    ,
    ea.render = function(h, g, S) {
        if (!Wl(g))
            throw Error(i(200));
        return op(null, h, g, !1, S)
    }
    ,
    ea.unmountComponentAtNode = function(h) {
        if (!Wl(h))
            throw Error(i(40));
        return h._reactRootContainer ? (Xu(function() {
            op(null, null, h, !1, function() {
                h._reactRootContainer = null,
                h[gi] = null
            })
        }),
        !0) : !1
    }
    ,
    ea.unstable_batchedUpdates = jd,
    ea.unstable_renderSubtreeIntoContainer = function(h, g, S, E) {
        if (!Wl(S))
            throw Error(i(200));
        if (h == null || h._reactInternals === void 0)
            throw Error(i(38));
        return op(h, g, S, !1, E)
    }
    ,
    ea.version = "18.3.1-next-f1338f8080-20240426",
    ea
}
var x1;
function mC() {
    if (x1)
        return a0.exports;
    x1 = 1;
    function e() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
            } catch (t) {
                console.error(t)
            }
    }
    return e(),
    a0.exports = pk(),
    a0.exports
}
var b1;
function mk() {
    if (b1)
        return Xy;
    b1 = 1;
    var e = mC();
    return Xy.createRoot = e.createRoot,
    Xy.hydrateRoot = e.hydrateRoot,
    Xy
}
var Wh = mk();
const Ug = {
    black: "#000",
    white: "#fff"
}
  , pp = {
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    700: "#d32f2f",
    800: "#c62828"
}
  , mp = {
    50: "#f3e5f5",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    700: "#7b1fa2"
}
  , gp = {
    50: "#e3f2fd",
    200: "#90caf9",
    400: "#42a5f5",
    700: "#1976d2",
    800: "#1565c0"
}
  , yp = {
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    700: "#0288d1",
    900: "#01579b"
}
  , _p = {
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20"
}
  , Nm = {
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    700: "#f57c00",
    900: "#e65100"
}
  , gk = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
};
function zp(e) {
    let t = "https://mui.com/production-error/?code=" + e;
    for (let i = 1; i < arguments.length; i += 1)
        t += "&args[]=" + encodeURIComponent(arguments[i]);
    return "Minified MUI error #" + e + "; visit " + t + " for the full message."
}
const yk = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: zp
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Gg = "$$material";
function xe() {
    return xe = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var i = arguments[t];
            for (var s in i)
                ({}).hasOwnProperty.call(i, s) && (e[s] = i[s])
        }
        return e
    }
    ,
    xe.apply(null, arguments)
}
function dr(e, t) {
    if (e == null)
        return {};
    var i = {};
    for (var s in e)
        if ({}.hasOwnProperty.call(e, s)) {
            if (t.indexOf(s) !== -1)
                continue;
            i[s] = e[s]
        }
    return i
}
var Pe = iy();
const Ra = Ni(Pe)
  , H0 = fC({
    __proto__: null,
    default: Ra
}, [Pe]);
function gC(e) {
    var t = Object.create(null);
    return function(i) {
        return t[i] === void 0 && (t[i] = e(i)),
        t[i]
    }
}
var _k = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/
  , vk = gC(function(e) {
    return _k.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91
});
function xk(e) {
    if (e.sheet)
        return e.sheet;
    for (var t = 0; t < document.styleSheets.length; t++)
        if (document.styleSheets[t].ownerNode === e)
            return document.styleSheets[t]
}
function bk(e) {
    var t = document.createElement("style");
    return t.setAttribute("data-emotion", e.key),
    e.nonce !== void 0 && t.setAttribute("nonce", e.nonce),
    t.appendChild(document.createTextNode("")),
    t.setAttribute("data-s", ""),
    t
}
var wk = function() {
    function e(i) {
        var s = this;
        this._insertTag = function(u) {
            var d;
            s.tags.length === 0 ? s.insertionPoint ? d = s.insertionPoint.nextSibling : s.prepend ? d = s.container.firstChild : d = s.before : d = s.tags[s.tags.length - 1].nextSibling,
            s.container.insertBefore(u, d),
            s.tags.push(u)
        }
        ,
        this.isSpeedy = i.speedy === void 0 ? !0 : i.speedy,
        this.tags = [],
        this.ctr = 0,
        this.nonce = i.nonce,
        this.key = i.key,
        this.container = i.container,
        this.prepend = i.prepend,
        this.insertionPoint = i.insertionPoint,
        this.before = null
    }
    var t = e.prototype;
    return t.hydrate = function(s) {
        s.forEach(this._insertTag)
    }
    ,
    t.insert = function(s) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(bk(this));
        var u = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
            var d = xk(u);
            try {
                d.insertRule(s, d.cssRules.length)
            } catch {}
        } else
            u.appendChild(document.createTextNode(s));
        this.ctr++
    }
    ,
    t.flush = function() {
        this.tags.forEach(function(s) {
            var u;
            return (u = s.parentNode) == null ? void 0 : u.removeChild(s)
        }),
        this.tags = [],
        this.ctr = 0
    }
    ,
    e
}()
  , gs = "-ms-"
  , V_ = "-moz-"
  , jn = "-webkit-"
  , yC = "comm"
  , Px = "rule"
  , Mx = "decl"
  , Sk = "@import"
  , _C = "@keyframes"
  , Ck = "@layer"
  , Tk = Math.abs
  , sv = String.fromCharCode
  , Pk = Object.assign;
function Mk(e, t) {
    return ss(e, 0) ^ 45 ? (((t << 2 ^ ss(e, 0)) << 2 ^ ss(e, 1)) << 2 ^ ss(e, 2)) << 2 ^ ss(e, 3) : 0
}
function vC(e) {
    return e.trim()
}
function kk(e, t) {
    return (e = t.exec(e)) ? e[0] : e
}
function Nn(e, t, i) {
    return e.replace(t, i)
}
function Z0(e, t) {
    return e.indexOf(t)
}
function ss(e, t) {
    return e.charCodeAt(t) | 0
}
function Wg(e, t, i) {
    return e.slice(t, i)
}
function Zc(e) {
    return e.length
}
function kx(e) {
    return e.length
}
function Yy(e, t) {
    return t.push(e),
    e
}
function Ek(e, t) {
    return e.map(t).join("")
}
var av = 1
  , Dp = 1
  , xC = 0
  , ia = 0
  , ho = 0
  , Xp = "";
function lv(e, t, i, s, u, d, f) {
    return {
        value: e,
        root: t,
        parent: i,
        type: s,
        props: u,
        children: d,
        line: av,
        column: Dp,
        length: f,
        return: ""
    }
}
function $m(e, t) {
    return Pk(lv("", null, null, "", null, null, 0), e, {
        length: -e.length
    }, t)
}
function Ik() {
    return ho
}
function Rk() {
    return ho = ia > 0 ? ss(Xp, --ia) : 0,
    Dp--,
    ho === 10 && (Dp = 1,
    av--),
    ho
}
function Aa() {
    return ho = ia < xC ? ss(Xp, ia++) : 0,
    Dp++,
    ho === 10 && (Dp = 1,
    av++),
    ho
}
function eu() {
    return ss(Xp, ia)
}
function A_() {
    return ia
}
function oy(e, t) {
    return Wg(Xp, e, t)
}
function qg(e) {
    switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
        return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
        return 4;
    case 58:
        return 3;
    case 34:
    case 39:
    case 40:
    case 91:
        return 2;
    case 41:
    case 93:
        return 1
    }
    return 0
}
function bC(e) {
    return av = Dp = 1,
    xC = Zc(Xp = e),
    ia = 0,
    []
}
function wC(e) {
    return Xp = "",
    e
}
function z_(e) {
    return vC(oy(ia - 1, X0(e === 91 ? e + 2 : e === 40 ? e + 1 : e)))
}
function Ak(e) {
    for (; (ho = eu()) && ho < 33; )
        Aa();
    return qg(e) > 2 || qg(ho) > 3 ? "" : " "
}
function zk(e, t) {
    for (; --t && Aa() && !(ho < 48 || ho > 102 || ho > 57 && ho < 65 || ho > 70 && ho < 97); )
        ;
    return oy(e, A_() + (t < 6 && eu() == 32 && Aa() == 32))
}
function X0(e) {
    for (; Aa(); )
        switch (ho) {
        case e:
            return ia;
        case 34:
        case 39:
            e !== 34 && e !== 39 && X0(ho);
            break;
        case 40:
            e === 41 && X0(e);
            break;
        case 92:
            Aa();
            break
        }
    return ia
}
function Dk(e, t) {
    for (; Aa() && e + ho !== 57; )
        if (e + ho === 84 && eu() === 47)
            break;
    return "/*" + oy(t, ia - 1) + "*" + sv(e === 47 ? e : Aa())
}
function Lk(e) {
    for (; !qg(eu()); )
        Aa();
    return oy(e, ia)
}
function Ok(e) {
    return wC(D_("", null, null, null, [""], e = bC(e), 0, [0], e))
}
function D_(e, t, i, s, u, d, f, o, w) {
    for (var T = 0, k = 0, L = f, z = 0, D = 0, N = 0, U = 1, V = 1, re = 1, ie = 0, ue = "", ce = u, X = d, me = s, K = ue; V; )
        switch (N = ie,
        ie = Aa()) {
        case 40:
            if (N != 108 && ss(K, L - 1) == 58) {
                Z0(K += Nn(z_(ie), "&", "&\f"), "&\f") != -1 && (re = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            K += z_(ie);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            K += Ak(N);
            break;
        case 92:
            K += zk(A_() - 1, 7);
            continue;
        case 47:
            switch (eu()) {
            case 42:
            case 47:
                Yy(Fk(Dk(Aa(), A_()), t, i), w);
                break;
            default:
                K += "/"
            }
            break;
        case 123 * U:
            o[T++] = Zc(K) * re;
        case 125 * U:
        case 59:
        case 0:
            switch (ie) {
            case 0:
            case 125:
                V = 0;
            case 59 + k:
                re == -1 && (K = Nn(K, /\f/g, "")),
                D > 0 && Zc(K) - L && Yy(D > 32 ? S1(K + ";", s, i, L - 1) : S1(Nn(K, " ", "") + ";", s, i, L - 2), w);
                break;
            case 59:
                K += ";";
            default:
                if (Yy(me = w1(K, t, i, T, k, u, o, ue, ce = [], X = [], L), d),
                ie === 123)
                    if (k === 0)
                        D_(K, t, me, me, ce, d, L, o, X);
                    else
                        switch (z === 99 && ss(K, 3) === 110 ? 100 : z) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                            D_(e, me, me, s && Yy(w1(e, me, me, 0, 0, u, o, ue, u, ce = [], L), X), u, X, L, o, s ? ce : X);
                            break;
                        default:
                            D_(K, me, me, me, [""], X, 0, o, X)
                        }
            }
            T = k = D = 0,
            U = re = 1,
            ue = K = "",
            L = f;
            break;
        case 58:
            L = 1 + Zc(K),
            D = N;
        default:
            if (U < 1) {
                if (ie == 123)
                    --U;
                else if (ie == 125 && U++ == 0 && Rk() == 125)
                    continue
            }
            switch (K += sv(ie),
            ie * U) {
            case 38:
                re = k > 0 ? 1 : (K += "\f",
                -1);
                break;
            case 44:
                o[T++] = (Zc(K) - 1) * re,
                re = 1;
                break;
            case 64:
                eu() === 45 && (K += z_(Aa())),
                z = eu(),
                k = L = Zc(ue = K += Lk(A_())),
                ie++;
                break;
            case 45:
                N === 45 && Zc(K) == 2 && (U = 0)
            }
        }
    return d
}
function w1(e, t, i, s, u, d, f, o, w, T, k) {
    for (var L = u - 1, z = u === 0 ? d : [""], D = kx(z), N = 0, U = 0, V = 0; N < s; ++N)
        for (var re = 0, ie = Wg(e, L + 1, L = Tk(U = f[N])), ue = e; re < D; ++re)
            (ue = vC(U > 0 ? z[re] + " " + ie : Nn(ie, /&\f/g, z[re]))) && (w[V++] = ue);
    return lv(e, t, i, u === 0 ? Px : o, w, T, k)
}
function Fk(e, t, i) {
    return lv(e, t, i, yC, sv(Ik()), Wg(e, 2, -2), 0)
}
function S1(e, t, i, s) {
    return lv(e, t, i, Mx, Wg(e, 0, s), Wg(e, s + 1, -1), s)
}
function Ip(e, t) {
    for (var i = "", s = kx(e), u = 0; u < s; u++)
        i += t(e[u], u, e, t) || "";
    return i
}
function Bk(e, t, i, s) {
    switch (e.type) {
    case Ck:
        if (e.children.length)
            break;
    case Sk:
    case Mx:
        return e.return = e.return || e.value;
    case yC:
        return "";
    case _C:
        return e.return = e.value + "{" + Ip(e.children, s) + "}";
    case Px:
        e.value = e.props.join(",")
    }
    return Zc(i = Ip(e.children, s)) ? e.return = e.value + "{" + i + "}" : ""
}
function jk(e) {
    var t = kx(e);
    return function(i, s, u, d) {
        for (var f = "", o = 0; o < t; o++)
            f += e[o](i, s, u, d) || "";
        return f
    }
}
function Nk(e) {
    return function(t) {
        t.root || (t = t.return) && e(t)
    }
}
var $k = function(t, i, s) {
    for (var u = 0, d = 0; u = d,
    d = eu(),
    u === 38 && d === 12 && (i[s] = 1),
    !qg(d); )
        Aa();
    return oy(t, ia)
}
  , Vk = function(t, i) {
    var s = -1
      , u = 44;
    do
        switch (qg(u)) {
        case 0:
            u === 38 && eu() === 12 && (i[s] = 1),
            t[s] += $k(ia - 1, i, s);
            break;
        case 2:
            t[s] += z_(u);
            break;
        case 4:
            if (u === 44) {
                t[++s] = eu() === 58 ? "&\f" : "",
                i[s] = t[s].length;
                break
            }
        default:
            t[s] += sv(u)
        }
    while (u = Aa());
    return t
}
  , Uk = function(t, i) {
    return wC(Vk(bC(t), i))
}
  , C1 = new WeakMap
  , Gk = function(t) {
    if (!(t.type !== "rule" || !t.parent || t.length < 1)) {
        for (var i = t.value, s = t.parent, u = t.column === s.column && t.line === s.line; s.type !== "rule"; )
            if (s = s.parent,
            !s)
                return;
        if (!(t.props.length === 1 && i.charCodeAt(0) !== 58 && !C1.get(s)) && !u) {
            C1.set(t, !0);
            for (var d = [], f = Uk(i, d), o = s.props, w = 0, T = 0; w < f.length; w++)
                for (var k = 0; k < o.length; k++,
                T++)
                    t.props[T] = d[w] ? f[w].replace(/&\f/g, o[k]) : o[k] + " " + f[w]
        }
    }
}
  , Wk = function(t) {
    if (t.type === "decl") {
        var i = t.value;
        i.charCodeAt(0) === 108 && i.charCodeAt(2) === 98 && (t.return = "",
        t.value = "")
    }
};
function SC(e, t) {
    switch (Mk(e, t)) {
    case 5103:
        return jn + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
        return jn + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
        return jn + e + V_ + e + gs + e + e;
    case 6828:
    case 4268:
        return jn + e + gs + e + e;
    case 6165:
        return jn + e + gs + "flex-" + e + e;
    case 5187:
        return jn + e + Nn(e, /(\w+).+(:[^]+)/, jn + "box-$1$2" + gs + "flex-$1$2") + e;
    case 5443:
        return jn + e + gs + "flex-item-" + Nn(e, /flex-|-self/, "") + e;
    case 4675:
        return jn + e + gs + "flex-line-pack" + Nn(e, /align-content|flex-|-self/, "") + e;
    case 5548:
        return jn + e + gs + Nn(e, "shrink", "negative") + e;
    case 5292:
        return jn + e + gs + Nn(e, "basis", "preferred-size") + e;
    case 6060:
        return jn + "box-" + Nn(e, "-grow", "") + jn + e + gs + Nn(e, "grow", "positive") + e;
    case 4554:
        return jn + Nn(e, /([^-])(transform)/g, "$1" + jn + "$2") + e;
    case 6187:
        return Nn(Nn(Nn(e, /(zoom-|grab)/, jn + "$1"), /(image-set)/, jn + "$1"), e, "") + e;
    case 5495:
    case 3959:
        return Nn(e, /(image-set\([^]*)/, jn + "$1$`$1");
    case 4968:
        return Nn(Nn(e, /(.+:)(flex-)?(.*)/, jn + "box-pack:$3" + gs + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + jn + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
        return Nn(e, /(.+)-inline(.+)/, jn + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
        if (Zc(e) - 1 - t > 6)
            switch (ss(e, t + 1)) {
            case 109:
                if (ss(e, t + 4) !== 45)
                    break;
            case 102:
                return Nn(e, /(.+:)(.+)-([^]+)/, "$1" + jn + "$2-$3$1" + V_ + (ss(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
            case 115:
                return ~Z0(e, "stretch") ? SC(Nn(e, "stretch", "fill-available"), t) + e : e
            }
        break;
    case 4949:
        if (ss(e, t + 1) !== 115)
            break;
    case 6444:
        switch (ss(e, Zc(e) - 3 - (~Z0(e, "!important") && 10))) {
        case 107:
            return Nn(e, ":", ":" + jn) + e;
        case 101:
            return Nn(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + jn + (ss(e, 14) === 45 ? "inline-" : "") + "box$3$1" + jn + "$2$3$1" + gs + "$2box$3") + e
        }
        break;
    case 5936:
        switch (ss(e, t + 11)) {
        case 114:
            return jn + e + gs + Nn(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
            return jn + e + gs + Nn(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
            return jn + e + gs + Nn(e, /[svh]\w+-[tblr]{2}/, "lr") + e
        }
        return jn + e + gs + e + e
    }
    return e
}
var qk = function(t, i, s, u) {
    if (t.length > -1 && !t.return)
        switch (t.type) {
        case Mx:
            t.return = SC(t.value, t.length);
            break;
        case _C:
            return Ip([$m(t, {
                value: Nn(t.value, "@", "@" + jn)
            })], u);
        case Px:
            if (t.length)
                return Ek(t.props, function(d) {
                    switch (kk(d, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                        return Ip([$m(t, {
                            props: [Nn(d, /:(read-\w+)/, ":" + V_ + "$1")]
                        })], u);
                    case "::placeholder":
                        return Ip([$m(t, {
                            props: [Nn(d, /:(plac\w+)/, ":" + jn + "input-$1")]
                        }), $m(t, {
                            props: [Nn(d, /:(plac\w+)/, ":" + V_ + "$1")]
                        }), $m(t, {
                            props: [Nn(d, /:(plac\w+)/, gs + "input-$1")]
                        })], u)
                    }
                    return ""
                })
        }
}
  , Hk = [qk]
  , CC = function(t) {
    var i = t.key;
    if (i === "css") {
        var s = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(s, function(U) {
            var V = U.getAttribute("data-emotion");
            V.indexOf(" ") !== -1 && (document.head.appendChild(U),
            U.setAttribute("data-s", ""))
        })
    }
    var u = t.stylisPlugins || Hk, d = {}, f, o = [];
    f = t.container || document.head,
    Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + i + ' "]'), function(U) {
        for (var V = U.getAttribute("data-emotion").split(" "), re = 1; re < V.length; re++)
            d[V[re]] = !0;
        o.push(U)
    });
    var w, T = [Gk, Wk];
    {
        var k, L = [Bk, Nk(function(U) {
            k.insert(U)
        })], z = jk(T.concat(u, L)), D = function(V) {
            return Ip(Ok(V), z)
        };
        w = function(V, re, ie, ue) {
            k = ie,
            D(V ? V + "{" + re.styles + "}" : re.styles),
            ue && (N.inserted[re.name] = !0)
        }
    }
    var N = {
        key: i,
        sheet: new wk({
            key: i,
            container: f,
            nonce: t.nonce,
            speedy: t.speedy,
            prepend: t.prepend,
            insertionPoint: t.insertionPoint
        }),
        nonce: t.nonce,
        inserted: d,
        registered: {},
        insert: w
    };
    return N.sheet.hydrate(o),
    N
}
  , u0 = {
    exports: {}
}
  , Un = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var T1;
function Zk() {
    if (T1)
        return Un;
    T1 = 1;
    var e = typeof Symbol == "function" && Symbol.for
      , t = e ? Symbol.for("react.element") : 60103
      , i = e ? Symbol.for("react.portal") : 60106
      , s = e ? Symbol.for("react.fragment") : 60107
      , u = e ? Symbol.for("react.strict_mode") : 60108
      , d = e ? Symbol.for("react.profiler") : 60114
      , f = e ? Symbol.for("react.provider") : 60109
      , o = e ? Symbol.for("react.context") : 60110
      , w = e ? Symbol.for("react.async_mode") : 60111
      , T = e ? Symbol.for("react.concurrent_mode") : 60111
      , k = e ? Symbol.for("react.forward_ref") : 60112
      , L = e ? Symbol.for("react.suspense") : 60113
      , z = e ? Symbol.for("react.suspense_list") : 60120
      , D = e ? Symbol.for("react.memo") : 60115
      , N = e ? Symbol.for("react.lazy") : 60116
      , U = e ? Symbol.for("react.block") : 60121
      , V = e ? Symbol.for("react.fundamental") : 60117
      , re = e ? Symbol.for("react.responder") : 60118
      , ie = e ? Symbol.for("react.scope") : 60119;
    function ue(X) {
        if (typeof X == "object" && X !== null) {
            var me = X.$$typeof;
            switch (me) {
            case t:
                switch (X = X.type,
                X) {
                case w:
                case T:
                case s:
                case d:
                case u:
                case L:
                    return X;
                default:
                    switch (X = X && X.$$typeof,
                    X) {
                    case o:
                    case k:
                    case N:
                    case D:
                    case f:
                        return X;
                    default:
                        return me
                    }
                }
            case i:
                return me
            }
        }
    }
    function ce(X) {
        return ue(X) === T
    }
    return Un.AsyncMode = w,
    Un.ConcurrentMode = T,
    Un.ContextConsumer = o,
    Un.ContextProvider = f,
    Un.Element = t,
    Un.ForwardRef = k,
    Un.Fragment = s,
    Un.Lazy = N,
    Un.Memo = D,
    Un.Portal = i,
    Un.Profiler = d,
    Un.StrictMode = u,
    Un.Suspense = L,
    Un.isAsyncMode = function(X) {
        return ce(X) || ue(X) === w
    }
    ,
    Un.isConcurrentMode = ce,
    Un.isContextConsumer = function(X) {
        return ue(X) === o
    }
    ,
    Un.isContextProvider = function(X) {
        return ue(X) === f
    }
    ,
    Un.isElement = function(X) {
        return typeof X == "object" && X !== null && X.$$typeof === t
    }
    ,
    Un.isForwardRef = function(X) {
        return ue(X) === k
    }
    ,
    Un.isFragment = function(X) {
        return ue(X) === s
    }
    ,
    Un.isLazy = function(X) {
        return ue(X) === N
    }
    ,
    Un.isMemo = function(X) {
        return ue(X) === D
    }
    ,
    Un.isPortal = function(X) {
        return ue(X) === i
    }
    ,
    Un.isProfiler = function(X) {
        return ue(X) === d
    }
    ,
    Un.isStrictMode = function(X) {
        return ue(X) === u
    }
    ,
    Un.isSuspense = function(X) {
        return ue(X) === L
    }
    ,
    Un.isValidElementType = function(X) {
        return typeof X == "string" || typeof X == "function" || X === s || X === T || X === d || X === u || X === L || X === z || typeof X == "object" && X !== null && (X.$$typeof === N || X.$$typeof === D || X.$$typeof === f || X.$$typeof === o || X.$$typeof === k || X.$$typeof === V || X.$$typeof === re || X.$$typeof === ie || X.$$typeof === U)
    }
    ,
    Un.typeOf = ue,
    Un
}
var P1;
function Xk() {
    return P1 || (P1 = 1,
    u0.exports = Zk()),
    u0.exports
}
var h0, M1;
function Yk() {
    if (M1)
        return h0;
    M1 = 1;
    var e = Xk()
      , t = {
        childContextTypes: !0,
        contextType: !0,
        contextTypes: !0,
        defaultProps: !0,
        displayName: !0,
        getDefaultProps: !0,
        getDerivedStateFromError: !0,
        getDerivedStateFromProps: !0,
        mixins: !0,
        propTypes: !0,
        type: !0
    }
      , i = {
        name: !0,
        length: !0,
        prototype: !0,
        caller: !0,
        callee: !0,
        arguments: !0,
        arity: !0
    }
      , s = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0
    }
      , u = {
        $$typeof: !0,
        compare: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
        type: !0
    }
      , d = {};
    d[e.ForwardRef] = s,
    d[e.Memo] = u;
    function f(N) {
        return e.isMemo(N) ? u : d[N.$$typeof] || t
    }
    var o = Object.defineProperty
      , w = Object.getOwnPropertyNames
      , T = Object.getOwnPropertySymbols
      , k = Object.getOwnPropertyDescriptor
      , L = Object.getPrototypeOf
      , z = Object.prototype;
    function D(N, U, V) {
        if (typeof U != "string") {
            if (z) {
                var re = L(U);
                re && re !== z && D(N, re, V)
            }
            var ie = w(U);
            T && (ie = ie.concat(T(U)));
            for (var ue = f(N), ce = f(U), X = 0; X < ie.length; ++X) {
                var me = ie[X];
                if (!i[me] && !(V && V[me]) && !(ce && ce[me]) && !(ue && ue[me])) {
                    var K = k(U, me);
                    try {
                        o(N, me, K)
                    } catch {}
                }
            }
        }
        return N
    }
    return h0 = D,
    h0
}
Yk();
var Kk = !0;
function Qk(e, t, i) {
    var s = "";
    return i.split(" ").forEach(function(u) {
        e[u] !== void 0 ? t.push(e[u] + ";") : u && (s += u + " ")
    }),
    s
}
var TC = function(t, i, s) {
    var u = t.key + "-" + i.name;
    (s === !1 || Kk === !1) && t.registered[u] === void 0 && (t.registered[u] = i.styles)
}
  , PC = function(t, i, s) {
    TC(t, i, s);
    var u = t.key + "-" + i.name;
    if (t.inserted[i.name] === void 0) {
        var d = i;
        do
            t.insert(i === d ? "." + u : "", d, t.sheet, !0),
            d = d.next;
        while (d !== void 0)
    }
};
function Jk(e) {
    for (var t = 0, i, s = 0, u = e.length; u >= 4; ++s,
    u -= 4)
        i = e.charCodeAt(s) & 255 | (e.charCodeAt(++s) & 255) << 8 | (e.charCodeAt(++s) & 255) << 16 | (e.charCodeAt(++s) & 255) << 24,
        i = (i & 65535) * 1540483477 + ((i >>> 16) * 59797 << 16),
        i ^= i >>> 24,
        t = (i & 65535) * 1540483477 + ((i >>> 16) * 59797 << 16) ^ (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    switch (u) {
    case 3:
        t ^= (e.charCodeAt(s + 2) & 255) << 16;
    case 2:
        t ^= (e.charCodeAt(s + 1) & 255) << 8;
    case 1:
        t ^= e.charCodeAt(s) & 255,
        t = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16)
    }
    return t ^= t >>> 13,
    t = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16),
    ((t ^ t >>> 15) >>> 0).toString(36)
}
var eE = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
}
  , tE = /[A-Z]|^ms/g
  , rE = /_EMO_([^_]+?)_([^]*?)_EMO_/g
  , MC = function(t) {
    return t.charCodeAt(1) === 45
}
  , k1 = function(t) {
    return t != null && typeof t != "boolean"
}
  , d0 = gC(function(e) {
    return MC(e) ? e : e.replace(tE, "-$&").toLowerCase()
})
  , E1 = function(t, i) {
    switch (t) {
    case "animation":
    case "animationName":
        if (typeof i == "string")
            return i.replace(rE, function(s, u, d) {
                return Xc = {
                    name: u,
                    styles: d,
                    next: Xc
                },
                u
            })
    }
    return eE[t] !== 1 && !MC(t) && typeof i == "number" && i !== 0 ? i + "px" : i
};
function Hg(e, t, i) {
    if (i == null)
        return "";
    var s = i;
    if (s.__emotion_styles !== void 0)
        return s;
    switch (typeof i) {
    case "boolean":
        return "";
    case "object":
        {
            var u = i;
            if (u.anim === 1)
                return Xc = {
                    name: u.name,
                    styles: u.styles,
                    next: Xc
                },
                u.name;
            var d = i;
            if (d.styles !== void 0) {
                var f = d.next;
                if (f !== void 0)
                    for (; f !== void 0; )
                        Xc = {
                            name: f.name,
                            styles: f.styles,
                            next: Xc
                        },
                        f = f.next;
                var o = d.styles + ";";
                return o
            }
            return nE(e, t, i)
        }
    case "function":
        {
            if (e !== void 0) {
                var w = Xc
                  , T = i(e);
                return Xc = w,
                Hg(e, t, T)
            }
            break
        }
    }
    var k = i;
    if (t == null)
        return k;
    var L = t[k];
    return L !== void 0 ? L : k
}
function nE(e, t, i) {
    var s = "";
    if (Array.isArray(i))
        for (var u = 0; u < i.length; u++)
            s += Hg(e, t, i[u]) + ";";
    else
        for (var d in i) {
            var f = i[d];
            if (typeof f != "object") {
                var o = f;
                t != null && t[o] !== void 0 ? s += d + "{" + t[o] + "}" : k1(o) && (s += d0(d) + ":" + E1(d, o) + ";")
            } else if (Array.isArray(f) && typeof f[0] == "string" && (t == null || t[f[0]] === void 0))
                for (var w = 0; w < f.length; w++)
                    k1(f[w]) && (s += d0(d) + ":" + E1(d, f[w]) + ";");
            else {
                var T = Hg(e, t, f);
                switch (d) {
                case "animation":
                case "animationName":
                    {
                        s += d0(d) + ":" + T + ";";
                        break
                    }
                default:
                    s += d + "{" + T + "}"
                }
            }
        }
    return s
}
var I1 = /label:\s*([^\s;{]+)\s*(;|$)/g, Xc;
function Ex(e, t, i) {
    if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
        return e[0];
    var s = !0
      , u = "";
    Xc = void 0;
    var d = e[0];
    if (d == null || d.raw === void 0)
        s = !1,
        u += Hg(i, t, d);
    else {
        var f = d;
        u += f[0]
    }
    for (var o = 1; o < e.length; o++)
        if (u += Hg(i, t, e[o]),
        s) {
            var w = d;
            u += w[o]
        }
    I1.lastIndex = 0;
    for (var T = "", k; (k = I1.exec(u)) !== null; )
        T += "-" + k[1];
    var L = Jk(u) + T;
    return {
        name: L,
        styles: u,
        next: Xc
    }
}
var iE = function(t) {
    return t()
}
  , kC = H0.useInsertionEffect ? H0.useInsertionEffect : !1
  , oE = kC || iE
  , R1 = kC || Pe.useLayoutEffect
  , EC = Pe.createContext(typeof HTMLElement < "u" ? CC({
    key: "css"
}) : null)
  , sE = EC.Provider
  , IC = function(t) {
    return Pe.forwardRef(function(i, s) {
        var u = Pe.useContext(EC);
        return t(i, u, s)
    })
}
  , sy = Pe.createContext({})
  , aE = IC(function(e, t) {
    var i = e.styles
      , s = Ex([i], void 0, Pe.useContext(sy))
      , u = Pe.useRef();
    return R1(function() {
        var d = t.key + "-global"
          , f = new t.sheet.constructor({
            key: d,
            nonce: t.sheet.nonce,
            container: t.sheet.container,
            speedy: t.sheet.isSpeedy
        })
          , o = !1
          , w = document.querySelector('style[data-emotion="' + d + " " + s.name + '"]');
        return t.sheet.tags.length && (f.before = t.sheet.tags[0]),
        w !== null && (o = !0,
        w.setAttribute("data-emotion", d),
        f.hydrate([w])),
        u.current = [f, o],
        function() {
            f.flush()
        }
    }, [t]),
    R1(function() {
        var d = u.current
          , f = d[0]
          , o = d[1];
        if (o) {
            d[1] = !1;
            return
        }
        if (s.next !== void 0 && PC(t, s.next, !0),
        f.tags.length) {
            var w = f.tags[f.tags.length - 1].nextElementSibling;
            f.before = w,
            f.flush()
        }
        t.insert("", s, f, !1)
    }, [t, s.name]),
    null
});
function RC() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
    return Ex(t)
}
var cv = function() {
    var t = RC.apply(void 0, arguments)
      , i = "animation-" + t.name;
    return {
        name: i,
        styles: "@keyframes " + i + "{" + t.styles + "}",
        anim: 1,
        toString: function() {
            return "_EMO_" + this.name + "_" + this.styles + "_EMO_"
        }
    }
}
  , lE = vk
  , cE = function(t) {
    return t !== "theme"
}
  , A1 = function(t) {
    return typeof t == "string" && t.charCodeAt(0) > 96 ? lE : cE
}
  , z1 = function(t, i, s) {
    var u;
    if (i) {
        var d = i.shouldForwardProp;
        u = t.__emotion_forwardProp && d ? function(f) {
            return t.__emotion_forwardProp(f) && d(f)
        }
        : d
    }
    return typeof u != "function" && s && (u = t.__emotion_forwardProp),
    u
}
  , uE = function(t) {
    var i = t.cache
      , s = t.serialized
      , u = t.isStringTag;
    return TC(i, s, u),
    oE(function() {
        return PC(i, s, u)
    }),
    null
}
  , hE = function e(t, i) {
    var s = t.__emotion_real === t, u = s && t.__emotion_base || t, d, f;
    i !== void 0 && (d = i.label,
    f = i.target);
    var o = z1(t, i, s)
      , w = o || A1(u)
      , T = !w("as");
    return function() {
        var k = arguments
          , L = s && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
        if (d !== void 0 && L.push("label:" + d + ";"),
        k[0] == null || k[0].raw === void 0)
            L.push.apply(L, k);
        else {
            L.push(k[0][0]);
            for (var z = k.length, D = 1; D < z; D++)
                L.push(k[D], k[0][D])
        }
        var N = IC(function(U, V, re) {
            var ie = T && U.as || u
              , ue = ""
              , ce = []
              , X = U;
            if (U.theme == null) {
                X = {};
                for (var me in U)
                    X[me] = U[me];
                X.theme = Pe.useContext(sy)
            }
            typeof U.className == "string" ? ue = Qk(V.registered, ce, U.className) : U.className != null && (ue = U.className + " ");
            var K = Ex(L.concat(ce), V.registered, X);
            ue += V.key + "-" + K.name,
            f !== void 0 && (ue += " " + f);
            var be = T && o === void 0 ? A1(ie) : w
              , Ee = {};
            for (var Ce in U)
                T && Ce === "as" || be(Ce) && (Ee[Ce] = U[Ce]);
            return Ee.className = ue,
            re && (Ee.ref = re),
            Pe.createElement(Pe.Fragment, null, Pe.createElement(uE, {
                cache: V,
                serialized: K,
                isStringTag: typeof ie == "string"
            }), Pe.createElement(ie, Ee))
        });
        return N.displayName = d !== void 0 ? d : "Styled(" + (typeof u == "string" ? u : u.displayName || u.name || "Component") + ")",
        N.defaultProps = t.defaultProps,
        N.__emotion_real = N,
        N.__emotion_base = u,
        N.__emotion_styles = L,
        N.__emotion_forwardProp = o,
        Object.defineProperty(N, "toString", {
            value: function() {
                return "." + f
            }
        }),
        N.withComponent = function(U, V) {
            return e(U, xe({}, i, V, {
                shouldForwardProp: z1(N, V, !0)
            })).apply(void 0, L)
        }
        ,
        N
    }
}
  , dE = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]
  , Y0 = hE.bind();
dE.forEach(function(e) {
    Y0[e] = Y0(e)
});
let K0;
typeof document == "object" && (K0 = CC({
    key: "css",
    prepend: !0
}));
function AC(e) {
    const {injectFirst: t, children: i} = e;
    return t && K0 ? G.jsx(sE, {
        value: K0,
        children: i
    }) : i
}
function fE(e) {
    return e == null || Object.keys(e).length === 0
}
function zC(e) {
    const {styles: t, defaultTheme: i={}} = e
      , s = typeof t == "function" ? u => t(fE(u) ? i : u) : t;
    return G.jsx(aE, {
        styles: s
    })
}
function Ix(e, t) {
    return Y0(e, t)
}
const DC = (e, t) => {
    Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles))
}
  , pE = Object.freeze(Object.defineProperty({
    __proto__: null,
    GlobalStyles: zC,
    StyledEngineProvider: AC,
    ThemeContext: sy,
    css: RC,
    default: Ix,
    internal_processStyles: DC,
    keyframes: cv
}, Symbol.toStringTag, {
    value: "Module"
}));
function ih(e) {
    if (typeof e != "object" || e === null)
        return !1;
    const t = Object.getPrototypeOf(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
}
function LC(e) {
    if (!ih(e))
        return e;
    const t = {};
    return Object.keys(e).forEach(i => {
        t[i] = LC(e[i])
    }
    ),
    t
}
function pl(e, t, i={
    clone: !0
}) {
    const s = i.clone ? xe({}, e) : e;
    return ih(e) && ih(t) && Object.keys(t).forEach(u => {
        ih(t[u]) && Object.prototype.hasOwnProperty.call(e, u) && ih(e[u]) ? s[u] = pl(e[u], t[u], i) : i.clone ? s[u] = ih(t[u]) ? LC(t[u]) : t[u] : s[u] = t[u]
    }
    ),
    s
}
const mE = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: pl,
    isPlainObject: ih
}, Symbol.toStringTag, {
    value: "Module"
}))
  , gE = ["values", "unit", "step"]
  , yE = e => {
    const t = Object.keys(e).map(i => ({
        key: i,
        val: e[i]
    })) || [];
    return t.sort( (i, s) => i.val - s.val),
    t.reduce( (i, s) => xe({}, i, {
        [s.key]: s.val
    }), {})
}
;
function OC(e) {
    const {values: t={
        xs: 0,
        sm: 600,
        md: 900,
        lg: 1200,
        xl: 1536
    }, unit: i="px", step: s=5} = e
      , u = dr(e, gE)
      , d = yE(t)
      , f = Object.keys(d);
    function o(z) {
        return `@media (min-width:${typeof t[z] == "number" ? t[z] : z}${i})`
    }
    function w(z) {
        return `@media (max-width:${(typeof t[z] == "number" ? t[z] : z) - s / 100}${i})`
    }
    function T(z, D) {
        const N = f.indexOf(D);
        return `@media (min-width:${typeof t[z] == "number" ? t[z] : z}${i}) and (max-width:${(N !== -1 && typeof t[f[N]] == "number" ? t[f[N]] : D) - s / 100}${i})`
    }
    function k(z) {
        return f.indexOf(z) + 1 < f.length ? T(z, f[f.indexOf(z) + 1]) : o(z)
    }
    function L(z) {
        const D = f.indexOf(z);
        return D === 0 ? o(f[1]) : D === f.length - 1 ? w(f[D]) : T(z, f[f.indexOf(z) + 1]).replace("@media", "@media not all and")
    }
    return xe({
        keys: f,
        values: d,
        up: o,
        down: w,
        between: T,
        only: k,
        not: L,
        unit: i
    }, u)
}
const _E = {
    borderRadius: 4
};
function Ag(e, t) {
    return t ? pl(e, t, {
        clone: !1
    }) : e
}
const Rx = {
    xs: 0,
    sm: 600,
    md: 900,
    lg: 1200,
    xl: 1536
}
  , D1 = {
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: e => `@media (min-width:${Rx[e]}px)`
};
function tc(e, t, i) {
    const s = e.theme || {};
    if (Array.isArray(t)) {
        const d = s.breakpoints || D1;
        return t.reduce( (f, o, w) => (f[d.up(d.keys[w])] = i(t[w]),
        f), {})
    }
    if (typeof t == "object") {
        const d = s.breakpoints || D1;
        return Object.keys(t).reduce( (f, o) => {
            if (Object.keys(d.values || Rx).indexOf(o) !== -1) {
                const w = d.up(o);
                f[w] = i(t[o], o)
            } else {
                const w = o;
                f[w] = t[w]
            }
            return f
        }
        , {})
    }
    return i(t)
}
function FC(e={}) {
    var t;
    return ((t = e.keys) == null ? void 0 : t.reduce( (s, u) => {
        const d = e.up(u);
        return s[d] = {},
        s
    }
    , {})) || {}
}
function BC(e, t) {
    return e.reduce( (i, s) => {
        const u = i[s];
        return (!u || Object.keys(u).length === 0) && delete i[s],
        i
    }
    , t)
}
function vE(e, ...t) {
    const i = FC(e)
      , s = [i, ...t].reduce( (u, d) => pl(u, d), {});
    return BC(Object.keys(i), s)
}
function xE(e, t) {
    if (typeof e != "object")
        return {};
    const i = {}
      , s = Object.keys(t);
    return Array.isArray(e) ? s.forEach( (u, d) => {
        d < e.length && (i[u] = !0)
    }
    ) : s.forEach(u => {
        e[u] != null && (i[u] = !0)
    }
    ),
    i
}
function f0({values: e, breakpoints: t, base: i}) {
    const s = i || xE(e, t)
      , u = Object.keys(s);
    if (u.length === 0)
        return e;
    let d;
    return u.reduce( (f, o, w) => (Array.isArray(e) ? (f[o] = e[w] != null ? e[w] : e[d],
    d = w) : typeof e == "object" ? (f[o] = e[o] != null ? e[o] : e[d],
    d = o) : f[o] = e,
    f), {})
}
function Ot(e) {
    if (typeof e != "string")
        throw new Error(zp(7));
    return e.charAt(0).toUpperCase() + e.slice(1)
}
const bE = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Ot
}, Symbol.toStringTag, {
    value: "Module"
}));
function Lp(e, t, i=!0) {
    if (!t || typeof t != "string")
        return null;
    if (e && e.vars && i) {
        const s = `vars.${t}`.split(".").reduce( (u, d) => u && u[d] ? u[d] : null, e);
        if (s != null)
            return s
    }
    return t.split(".").reduce( (s, u) => s && s[u] != null ? s[u] : null, e)
}
function U_(e, t, i, s=i) {
    let u;
    return typeof e == "function" ? u = e(i) : Array.isArray(e) ? u = e[i] || s : u = Lp(e, i) || s,
    t && (u = t(u, s, e)),
    u
}
function Yi(e) {
    const {prop: t, cssProperty: i=e.prop, themeKey: s, transform: u} = e
      , d = f => {
        if (f[t] == null)
            return null;
        const o = f[t]
          , w = f.theme
          , T = Lp(w, s) || {};
        return tc(f, o, L => {
            let z = U_(T, u, L);
            return L === z && typeof L == "string" && (z = U_(T, u, `${t}${L === "default" ? "" : Ot(L)}`, L)),
            i === !1 ? z : {
                [i]: z
            }
        }
        )
    }
    ;
    return d.propTypes = {},
    d.filterProps = [t],
    d
}
function wE(e) {
    const t = {};
    return i => (t[i] === void 0 && (t[i] = e(i)),
    t[i])
}
const SE = {
    m: "margin",
    p: "padding"
}
  , CE = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
}
  , L1 = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
}
  , TE = wE(e => {
    if (e.length > 2)
        if (L1[e])
            e = L1[e];
        else
            return [e];
    const [t,i] = e.split("")
      , s = SE[t]
      , u = CE[i] || "";
    return Array.isArray(u) ? u.map(d => s + d) : [s + u]
}
)
  , Ax = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"]
  , zx = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...Ax, ...zx];
function ay(e, t, i, s) {
    var u;
    const d = (u = Lp(e, t, !1)) != null ? u : i;
    return typeof d == "number" ? f => typeof f == "string" ? f : d * f : Array.isArray(d) ? f => typeof f == "string" ? f : d[f] : typeof d == "function" ? d : () => {}
}
function Dx(e) {
    return ay(e, "spacing", 8)
}
function yf(e, t) {
    if (typeof t == "string" || t == null)
        return t;
    const i = Math.abs(t)
      , s = e(i);
    return t >= 0 ? s : typeof s == "number" ? -s : `-${s}`
}
function PE(e, t) {
    return i => e.reduce( (s, u) => (s[u] = yf(t, i),
    s), {})
}
function ME(e, t, i, s) {
    if (t.indexOf(i) === -1)
        return null;
    const u = TE(i)
      , d = PE(u, s)
      , f = e[i];
    return tc(e, f, d)
}
function jC(e, t) {
    const i = Dx(e.theme);
    return Object.keys(e).map(s => ME(e, t, s, i)).reduce(Ag, {})
}
function Bi(e) {
    return jC(e, Ax)
}
Bi.propTypes = {};
Bi.filterProps = Ax;
function ji(e) {
    return jC(e, zx)
}
ji.propTypes = {};
ji.filterProps = zx;
function kE(e=8) {
    if (e.mui)
        return e;
    const t = Dx({
        spacing: e
    })
      , i = (...s) => (s.length === 0 ? [1] : s).map(d => {
        const f = t(d);
        return typeof f == "number" ? `${f}px` : f
    }
    ).join(" ");
    return i.mui = !0,
    i
}
function uv(...e) {
    const t = e.reduce( (s, u) => (u.filterProps.forEach(d => {
        s[d] = u
    }
    ),
    s), {})
      , i = s => Object.keys(s).reduce( (u, d) => t[d] ? Ag(u, t[d](s)) : u, {});
    return i.propTypes = {},
    i.filterProps = e.reduce( (s, u) => s.concat(u.filterProps), []),
    i
}
function hl(e) {
    return typeof e != "number" ? e : `${e}px solid`
}
function vl(e, t) {
    return Yi({
        prop: e,
        themeKey: "borders",
        transform: t
    })
}
const EE = vl("border", hl)
  , IE = vl("borderTop", hl)
  , RE = vl("borderRight", hl)
  , AE = vl("borderBottom", hl)
  , zE = vl("borderLeft", hl)
  , DE = vl("borderColor")
  , LE = vl("borderTopColor")
  , OE = vl("borderRightColor")
  , FE = vl("borderBottomColor")
  , BE = vl("borderLeftColor")
  , jE = vl("outline", hl)
  , NE = vl("outlineColor")
  , hv = e => {
    if (e.borderRadius !== void 0 && e.borderRadius !== null) {
        const t = ay(e.theme, "shape.borderRadius", 4)
          , i = s => ({
            borderRadius: yf(t, s)
        });
        return tc(e, e.borderRadius, i)
    }
    return null
}
;
hv.propTypes = {};
hv.filterProps = ["borderRadius"];
uv(EE, IE, RE, AE, zE, DE, LE, OE, FE, BE, hv, jE, NE);
const dv = e => {
    if (e.gap !== void 0 && e.gap !== null) {
        const t = ay(e.theme, "spacing", 8)
          , i = s => ({
            gap: yf(t, s)
        });
        return tc(e, e.gap, i)
    }
    return null
}
;
dv.propTypes = {};
dv.filterProps = ["gap"];
const fv = e => {
    if (e.columnGap !== void 0 && e.columnGap !== null) {
        const t = ay(e.theme, "spacing", 8)
          , i = s => ({
            columnGap: yf(t, s)
        });
        return tc(e, e.columnGap, i)
    }
    return null
}
;
fv.propTypes = {};
fv.filterProps = ["columnGap"];
const pv = e => {
    if (e.rowGap !== void 0 && e.rowGap !== null) {
        const t = ay(e.theme, "spacing", 8)
          , i = s => ({
            rowGap: yf(t, s)
        });
        return tc(e, e.rowGap, i)
    }
    return null
}
;
pv.propTypes = {};
pv.filterProps = ["rowGap"];
const $E = Yi({
    prop: "gridColumn"
})
  , VE = Yi({
    prop: "gridRow"
})
  , UE = Yi({
    prop: "gridAutoFlow"
})
  , GE = Yi({
    prop: "gridAutoColumns"
})
  , WE = Yi({
    prop: "gridAutoRows"
})
  , qE = Yi({
    prop: "gridTemplateColumns"
})
  , HE = Yi({
    prop: "gridTemplateRows"
})
  , ZE = Yi({
    prop: "gridTemplateAreas"
})
  , XE = Yi({
    prop: "gridArea"
});
uv(dv, fv, pv, $E, VE, UE, GE, WE, qE, HE, ZE, XE);
function Rp(e, t) {
    return t === "grey" ? t : e
}
const YE = Yi({
    prop: "color",
    themeKey: "palette",
    transform: Rp
})
  , KE = Yi({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: Rp
})
  , QE = Yi({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: Rp
});
uv(YE, KE, QE);
function Ia(e) {
    return e <= 1 && e !== 0 ? `${e * 100}%` : e
}
const JE = Yi({
    prop: "width",
    transform: Ia
})
  , Lx = e => {
    if (e.maxWidth !== void 0 && e.maxWidth !== null) {
        const t = i => {
            var s, u;
            const d = ((s = e.theme) == null || (s = s.breakpoints) == null || (s = s.values) == null ? void 0 : s[i]) || Rx[i];
            return d ? ((u = e.theme) == null || (u = u.breakpoints) == null ? void 0 : u.unit) !== "px" ? {
                maxWidth: `${d}${e.theme.breakpoints.unit}`
            } : {
                maxWidth: d
            } : {
                maxWidth: Ia(i)
            }
        }
        ;
        return tc(e, e.maxWidth, t)
    }
    return null
}
;
Lx.filterProps = ["maxWidth"];
const eI = Yi({
    prop: "minWidth",
    transform: Ia
})
  , tI = Yi({
    prop: "height",
    transform: Ia
})
  , rI = Yi({
    prop: "maxHeight",
    transform: Ia
})
  , nI = Yi({
    prop: "minHeight",
    transform: Ia
});
Yi({
    prop: "size",
    cssProperty: "width",
    transform: Ia
});
Yi({
    prop: "size",
    cssProperty: "height",
    transform: Ia
});
const iI = Yi({
    prop: "boxSizing"
});
uv(JE, Lx, eI, tI, rI, nI, iI);
const ly = {
    border: {
        themeKey: "borders",
        transform: hl
    },
    borderTop: {
        themeKey: "borders",
        transform: hl
    },
    borderRight: {
        themeKey: "borders",
        transform: hl
    },
    borderBottom: {
        themeKey: "borders",
        transform: hl
    },
    borderLeft: {
        themeKey: "borders",
        transform: hl
    },
    borderColor: {
        themeKey: "palette"
    },
    borderTopColor: {
        themeKey: "palette"
    },
    borderRightColor: {
        themeKey: "palette"
    },
    borderBottomColor: {
        themeKey: "palette"
    },
    borderLeftColor: {
        themeKey: "palette"
    },
    outline: {
        themeKey: "borders",
        transform: hl
    },
    outlineColor: {
        themeKey: "palette"
    },
    borderRadius: {
        themeKey: "shape.borderRadius",
        style: hv
    },
    color: {
        themeKey: "palette",
        transform: Rp
    },
    bgcolor: {
        themeKey: "palette",
        cssProperty: "backgroundColor",
        transform: Rp
    },
    backgroundColor: {
        themeKey: "palette",
        transform: Rp
    },
    p: {
        style: ji
    },
    pt: {
        style: ji
    },
    pr: {
        style: ji
    },
    pb: {
        style: ji
    },
    pl: {
        style: ji
    },
    px: {
        style: ji
    },
    py: {
        style: ji
    },
    padding: {
        style: ji
    },
    paddingTop: {
        style: ji
    },
    paddingRight: {
        style: ji
    },
    paddingBottom: {
        style: ji
    },
    paddingLeft: {
        style: ji
    },
    paddingX: {
        style: ji
    },
    paddingY: {
        style: ji
    },
    paddingInline: {
        style: ji
    },
    paddingInlineStart: {
        style: ji
    },
    paddingInlineEnd: {
        style: ji
    },
    paddingBlock: {
        style: ji
    },
    paddingBlockStart: {
        style: ji
    },
    paddingBlockEnd: {
        style: ji
    },
    m: {
        style: Bi
    },
    mt: {
        style: Bi
    },
    mr: {
        style: Bi
    },
    mb: {
        style: Bi
    },
    ml: {
        style: Bi
    },
    mx: {
        style: Bi
    },
    my: {
        style: Bi
    },
    margin: {
        style: Bi
    },
    marginTop: {
        style: Bi
    },
    marginRight: {
        style: Bi
    },
    marginBottom: {
        style: Bi
    },
    marginLeft: {
        style: Bi
    },
    marginX: {
        style: Bi
    },
    marginY: {
        style: Bi
    },
    marginInline: {
        style: Bi
    },
    marginInlineStart: {
        style: Bi
    },
    marginInlineEnd: {
        style: Bi
    },
    marginBlock: {
        style: Bi
    },
    marginBlockStart: {
        style: Bi
    },
    marginBlockEnd: {
        style: Bi
    },
    displayPrint: {
        cssProperty: !1,
        transform: e => ({
            "@media print": {
                display: e
            }
        })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    gap: {
        style: dv
    },
    rowGap: {
        style: pv
    },
    columnGap: {
        style: fv
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    position: {},
    zIndex: {
        themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    boxShadow: {
        themeKey: "shadows"
    },
    width: {
        transform: Ia
    },
    maxWidth: {
        style: Lx
    },
    minWidth: {
        transform: Ia
    },
    height: {
        transform: Ia
    },
    maxHeight: {
        transform: Ia
    },
    minHeight: {
        transform: Ia
    },
    boxSizing: {},
    fontFamily: {
        themeKey: "typography"
    },
    fontSize: {
        themeKey: "typography"
    },
    fontStyle: {
        themeKey: "typography"
    },
    fontWeight: {
        themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
        cssProperty: !1,
        themeKey: "typography"
    }
};
function oI(...e) {
    const t = e.reduce( (s, u) => s.concat(Object.keys(u)), [])
      , i = new Set(t);
    return e.every(s => i.size === Object.keys(s).length)
}
function sI(e, t) {
    return typeof e == "function" ? e(t) : e
}
function NC() {
    function e(i, s, u, d) {
        const f = {
            [i]: s,
            theme: u
        }
          , o = d[i];
        if (!o)
            return {
                [i]: s
            };
        const {cssProperty: w=i, themeKey: T, transform: k, style: L} = o;
        if (s == null)
            return null;
        if (T === "typography" && s === "inherit")
            return {
                [i]: s
            };
        const z = Lp(u, T) || {};
        return L ? L(f) : tc(f, s, N => {
            let U = U_(z, k, N);
            return N === U && typeof N == "string" && (U = U_(z, k, `${i}${N === "default" ? "" : Ot(N)}`, N)),
            w === !1 ? U : {
                [w]: U
            }
        }
        )
    }
    function t(i) {
        var s;
        const {sx: u, theme: d={}} = i || {};
        if (!u)
            return null;
        const f = (s = d.unstable_sxConfig) != null ? s : ly;
        function o(w) {
            let T = w;
            if (typeof w == "function")
                T = w(d);
            else if (typeof w != "object")
                return w;
            if (!T)
                return null;
            const k = FC(d.breakpoints)
              , L = Object.keys(k);
            let z = k;
            return Object.keys(T).forEach(D => {
                const N = sI(T[D], d);
                if (N != null)
                    if (typeof N == "object")
                        if (f[D])
                            z = Ag(z, e(D, N, d, f));
                        else {
                            const U = tc({
                                theme: d
                            }, N, V => ({
                                [D]: V
                            }));
                            oI(U, N) ? z[D] = t({
                                sx: N,
                                theme: d
                            }) : z = Ag(z, U)
                        }
                    else
                        z = Ag(z, e(D, N, d, f))
            }
            ),
            BC(L, z)
        }
        return Array.isArray(u) ? u.map(o) : o(u)
    }
    return t
}
const Yp = NC();
Yp.filterProps = ["sx"];
function $C(e, t) {
    const i = this;
    return i.vars && typeof i.getColorSchemeSelector == "function" ? {
        [i.getColorSchemeSelector(e).replace(/(\[[^\]]+\])/, "*:where($1)")]: t
    } : i.palette.mode === e ? t : {}
}
const aI = ["breakpoints", "palette", "spacing", "shape"];
function cy(e={}, ...t) {
    const {breakpoints: i={}, palette: s={}, spacing: u, shape: d={}} = e
      , f = dr(e, aI)
      , o = OC(i)
      , w = kE(u);
    let T = pl({
        breakpoints: o,
        direction: "ltr",
        components: {},
        palette: xe({
            mode: "light"
        }, s),
        spacing: w,
        shape: xe({}, _E, d)
    }, f);
    return T.applyStyles = $C,
    T = t.reduce( (k, L) => pl(k, L), T),
    T.unstable_sxConfig = xe({}, ly, f?.unstable_sxConfig),
    T.unstable_sx = function(L) {
        return Yp({
            sx: L,
            theme: this
        })
    }
    ,
    T
}
const lI = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: cy,
    private_createBreakpoints: OC,
    unstable_applyStyles: $C
}, Symbol.toStringTag, {
    value: "Module"
}));
function cI(e) {
    return Object.keys(e).length === 0
}
function VC(e=null) {
    const t = Pe.useContext(sy);
    return !t || cI(t) ? e : t
}
const uI = cy();
function mv(e=uI) {
    return VC(e)
}
function hI({styles: e, themeId: t, defaultTheme: i={}}) {
    const s = mv(i)
      , u = typeof e == "function" ? e(t && s[t] || s) : e;
    return G.jsx(zC, {
        styles: u
    })
}
const dI = ["sx"]
  , fI = e => {
    var t, i;
    const s = {
        systemProps: {},
        otherProps: {}
    }
      , u = (t = e == null || (i = e.theme) == null ? void 0 : i.unstable_sxConfig) != null ? t : ly;
    return Object.keys(e).forEach(d => {
        u[d] ? s.systemProps[d] = e[d] : s.otherProps[d] = e[d]
    }
    ),
    s
}
;
function gv(e) {
    const {sx: t} = e
      , i = dr(e, dI)
      , {systemProps: s, otherProps: u} = fI(i);
    let d;
    return Array.isArray(t) ? d = [s, ...t] : typeof t == "function" ? d = (...f) => {
        const o = t(...f);
        return ih(o) ? xe({}, s, o) : s
    }
    : d = xe({}, s, t),
    xe({}, u, {
        sx: d
    })
}
const pI = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Yp,
    extendSxProp: gv,
    unstable_createStyleFunctionSx: NC,
    unstable_defaultSxConfig: ly
}, Symbol.toStringTag, {
    value: "Module"
}))
  , O1 = e => e
  , mI = () => {
    let e = O1;
    return {
        configure(t) {
            e = t
        },
        generate(t) {
            return e(t)
        },
        reset() {
            e = O1
        }
    }
}
  , Ox = mI();
function UC(e) {
    var t, i, s = "";
    if (typeof e == "string" || typeof e == "number")
        s += e;
    else if (typeof e == "object")
        if (Array.isArray(e)) {
            var u = e.length;
            for (t = 0; t < u; t++)
                e[t] && (i = UC(e[t])) && (s && (s += " "),
                s += i)
        } else
            for (i in e)
                e[i] && (s && (s += " "),
                s += i);
    return s
}
function nr() {
    for (var e, t, i = 0, s = "", u = arguments.length; i < u; i++)
        (e = arguments[i]) && (t = UC(e)) && (s && (s += " "),
        s += t);
    return s
}
const gI = ["className", "component"];
function yI(e={}) {
    const {themeId: t, defaultTheme: i, defaultClassName: s="MuiBox-root", generateClassName: u} = e
      , d = Ix("div", {
        shouldForwardProp: o => o !== "theme" && o !== "sx" && o !== "as"
    })(Yp);
    return Pe.forwardRef(function(w, T) {
        const k = mv(i)
          , L = gv(w)
          , {className: z, component: D="div"} = L
          , N = dr(L, gI);
        return G.jsx(d, xe({
            as: D,
            ref: T,
            className: nr(z, u ? u(s) : s),
            theme: t && k[t] || k
        }, N))
    })
}
const _I = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
};
function Kr(e, t, i="Mui") {
    const s = _I[t];
    return s ? `${i}-${s}` : `${Ox.generate(e)}-${t}`
}
function Qr(e, t, i="Mui") {
    const s = {};
    return t.forEach(u => {
        s[u] = Kr(e, u, i)
    }
    ),
    s
}
const vI = Qr("MuiBox", ["root"])
  , ka = yI({
    defaultClassName: vI.root,
    generateClassName: Ox.generate
});
var p0 = {
    exports: {}
}
  , Gn = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var F1;
function xI() {
    if (F1)
        return Gn;
    F1 = 1;
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), u = Symbol.for("react.profiler"), d = Symbol.for("react.provider"), f = Symbol.for("react.context"), o = Symbol.for("react.server_context"), w = Symbol.for("react.forward_ref"), T = Symbol.for("react.suspense"), k = Symbol.for("react.suspense_list"), L = Symbol.for("react.memo"), z = Symbol.for("react.lazy"), D = Symbol.for("react.offscreen"), N;
    N = Symbol.for("react.module.reference");
    function U(V) {
        if (typeof V == "object" && V !== null) {
            var re = V.$$typeof;
            switch (re) {
            case e:
                switch (V = V.type,
                V) {
                case i:
                case u:
                case s:
                case T:
                case k:
                    return V;
                default:
                    switch (V = V && V.$$typeof,
                    V) {
                    case o:
                    case f:
                    case w:
                    case z:
                    case L:
                    case d:
                        return V;
                    default:
                        return re
                    }
                }
            case t:
                return re
            }
        }
    }
    return Gn.ContextConsumer = f,
    Gn.ContextProvider = d,
    Gn.Element = e,
    Gn.ForwardRef = w,
    Gn.Fragment = i,
    Gn.Lazy = z,
    Gn.Memo = L,
    Gn.Portal = t,
    Gn.Profiler = u,
    Gn.StrictMode = s,
    Gn.Suspense = T,
    Gn.SuspenseList = k,
    Gn.isAsyncMode = function() {
        return !1
    }
    ,
    Gn.isConcurrentMode = function() {
        return !1
    }
    ,
    Gn.isContextConsumer = function(V) {
        return U(V) === f
    }
    ,
    Gn.isContextProvider = function(V) {
        return U(V) === d
    }
    ,
    Gn.isElement = function(V) {
        return typeof V == "object" && V !== null && V.$$typeof === e
    }
    ,
    Gn.isForwardRef = function(V) {
        return U(V) === w
    }
    ,
    Gn.isFragment = function(V) {
        return U(V) === i
    }
    ,
    Gn.isLazy = function(V) {
        return U(V) === z
    }
    ,
    Gn.isMemo = function(V) {
        return U(V) === L
    }
    ,
    Gn.isPortal = function(V) {
        return U(V) === t
    }
    ,
    Gn.isProfiler = function(V) {
        return U(V) === u
    }
    ,
    Gn.isStrictMode = function(V) {
        return U(V) === s
    }
    ,
    Gn.isSuspense = function(V) {
        return U(V) === T
    }
    ,
    Gn.isSuspenseList = function(V) {
        return U(V) === k
    }
    ,
    Gn.isValidElementType = function(V) {
        return typeof V == "string" || typeof V == "function" || V === i || V === u || V === s || V === T || V === k || V === D || typeof V == "object" && V !== null && (V.$$typeof === z || V.$$typeof === L || V.$$typeof === d || V.$$typeof === f || V.$$typeof === w || V.$$typeof === N || V.getModuleId !== void 0)
    }
    ,
    Gn.typeOf = U,
    Gn
}
var B1;
function bI() {
    return B1 || (B1 = 1,
    p0.exports = xI()),
    p0.exports
}
var j1 = bI();
const wI = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function GC(e) {
    const t = `${e}`.match(wI);
    return t && t[1] || ""
}
function WC(e, t="") {
    return e.displayName || e.name || GC(e) || t
}
function N1(e, t, i) {
    const s = WC(t);
    return e.displayName || (s !== "" ? `${i}(${s})` : i)
}
function SI(e) {
    if (e != null) {
        if (typeof e == "string")
            return e;
        if (typeof e == "function")
            return WC(e, "Component");
        if (typeof e == "object")
            switch (e.$$typeof) {
            case j1.ForwardRef:
                return N1(e, e.render, "ForwardRef");
            case j1.Memo:
                return N1(e, e.type, "memo");
            default:
                return
            }
    }
}
const CI = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: SI,
    getFunctionName: GC
}, Symbol.toStringTag, {
    value: "Module"
}))
  , TI = ["ownerState"]
  , PI = ["variants"]
  , MI = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function kI(e) {
    return Object.keys(e).length === 0
}
function EI(e) {
    return typeof e == "string" && e.charCodeAt(0) > 96
}
function m0(e) {
    return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as"
}
const II = cy()
  , RI = e => e && e.charAt(0).toLowerCase() + e.slice(1);
function Ky({defaultTheme: e, theme: t, themeId: i}) {
    return kI(t) ? e : t[i] || t
}
function AI(e) {
    return e ? (t, i) => i[e] : null
}
function L_(e, t) {
    let {ownerState: i} = t
      , s = dr(t, TI);
    const u = typeof e == "function" ? e(xe({
        ownerState: i
    }, s)) : e;
    if (Array.isArray(u))
        return u.flatMap(d => L_(d, xe({
            ownerState: i
        }, s)));
    if (u && typeof u == "object" && Array.isArray(u.variants)) {
        const {variants: d=[]} = u;
        let o = dr(u, PI);
        return d.forEach(w => {
            let T = !0;
            typeof w.props == "function" ? T = w.props(xe({
                ownerState: i
            }, s, i)) : Object.keys(w.props).forEach(k => {
                i?.[k] !== w.props[k] && s[k] !== w.props[k] && (T = !1)
            }
            ),
            T && (Array.isArray(o) || (o = [o]),
            o.push(typeof w.style == "function" ? w.style(xe({
                ownerState: i
            }, s, i)) : w.style))
        }
        ),
        o
    }
    return u
}
function zI(e={}) {
    const {themeId: t, defaultTheme: i=II, rootShouldForwardProp: s=m0, slotShouldForwardProp: u=m0} = e
      , d = f => Yp(xe({}, f, {
        theme: Ky(xe({}, f, {
            defaultTheme: i,
            themeId: t
        }))
    }));
    return d.__mui_systemSx = !0,
    (f, o={}) => {
        DC(f, X => X.filter(me => !(me != null && me.__mui_systemSx)));
        const {name: w, slot: T, skipVariantsResolver: k, skipSx: L, overridesResolver: z=AI(RI(T))} = o
          , D = dr(o, MI)
          , N = k !== void 0 ? k : T && T !== "Root" && T !== "root" || !1
          , U = L || !1;
        let V, re = m0;
        T === "Root" || T === "root" ? re = s : T ? re = u : EI(f) && (re = void 0);
        const ie = Ix(f, xe({
            shouldForwardProp: re,
            label: V
        }, D))
          , ue = X => typeof X == "function" && X.__emotion_real !== X || ih(X) ? me => L_(X, xe({}, me, {
            theme: Ky({
                theme: me.theme,
                defaultTheme: i,
                themeId: t
            })
        })) : X
          , ce = (X, ...me) => {
            let K = ue(X);
            const be = me ? me.map(ue) : [];
            w && z && be.push(He => {
                const ct = Ky(xe({}, He, {
                    defaultTheme: i,
                    themeId: t
                }));
                if (!ct.components || !ct.components[w] || !ct.components[w].styleOverrides)
                    return null;
                const nt = ct.components[w].styleOverrides
                  , J = {};
                return Object.entries(nt).forEach( ([he,ve]) => {
                    J[he] = L_(ve, xe({}, He, {
                        theme: ct
                    }))
                }
                ),
                z(He, J)
            }
            ),
            w && !N && be.push(He => {
                var ct;
                const nt = Ky(xe({}, He, {
                    defaultTheme: i,
                    themeId: t
                }))
                  , J = nt == null || (ct = nt.components) == null || (ct = ct[w]) == null ? void 0 : ct.variants;
                return L_({
                    variants: J
                }, xe({}, He, {
                    theme: nt
                }))
            }
            ),
            U || be.push(d);
            const Ee = be.length - me.length;
            if (Array.isArray(X) && Ee > 0) {
                const He = new Array(Ee).fill("");
                K = [...X, ...He],
                K.raw = [...X.raw, ...He]
            }
            const Ce = ie(K, ...be);
            return f.muiName && (Ce.muiName = f.muiName),
            Ce
        }
        ;
        return ie.withConfig && (ce.withConfig = ie.withConfig),
        ce
    }
}
const qC = zI();
function Zg(e, t) {
    const i = xe({}, t);
    return Object.keys(e).forEach(s => {
        if (s.toString().match(/^(components|slots)$/))
            i[s] = xe({}, e[s], i[s]);
        else if (s.toString().match(/^(componentsProps|slotProps)$/)) {
            const u = e[s] || {}
              , d = t[s];
            i[s] = {},
            !d || !Object.keys(d) ? i[s] = u : !u || !Object.keys(u) ? i[s] = d : (i[s] = xe({}, d),
            Object.keys(u).forEach(f => {
                i[s][f] = Zg(u[f], d[f])
            }
            ))
        } else
            i[s] === void 0 && (i[s] = e[s])
    }
    ),
    i
}
function DI(e) {
    const {theme: t, name: i, props: s} = e;
    return !t || !t.components || !t.components[i] || !t.components[i].defaultProps ? s : Zg(t.components[i].defaultProps, s)
}
function LI({props: e, name: t, defaultTheme: i, themeId: s}) {
    let u = mv(i);
    return s && (u = u[s] || u),
    DI({
        theme: u,
        name: t,
        props: e
    })
}
const gl = typeof window < "u" ? Pe.useLayoutEffect : Pe.useEffect;
function wp(e, t=Number.MIN_SAFE_INTEGER, i=Number.MAX_SAFE_INTEGER) {
    return Math.max(t, Math.min(e, i))
}
const OI = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: wp
}, Symbol.toStringTag, {
    value: "Module"
}));
function G_(...e) {
    return e.reduce( (t, i) => i == null ? t : function(...u) {
        t.apply(this, u),
        i.apply(this, u)
    }
    , () => {}
    )
}
function Fx(e, t=166) {
    let i;
    function s(...u) {
        const d = () => {
            e.apply(this, u)
        }
        ;
        clearTimeout(i),
        i = setTimeout(d, t)
    }
    return s.clear = () => {
        clearTimeout(i)
    }
    ,
    s
}
function FI(e, t) {
    return () => null
}
function zg(e, t) {
    var i, s;
    return Pe.isValidElement(e) && t.indexOf((i = e.type.muiName) != null ? i : (s = e.type) == null || (s = s._payload) == null || (s = s.value) == null ? void 0 : s.muiName) !== -1
}
function js(e) {
    return e && e.ownerDocument || document
}
function Yh(e) {
    return js(e).defaultView || window
}
function BI(e, t) {
    return () => null
}
function W_(e, t) {
    typeof e == "function" ? e(t) : e && (e.current = t)
}
let $1 = 0;
function jI(e) {
    const [t,i] = Pe.useState(e)
      , s = e || t;
    return Pe.useEffect( () => {
        t == null && ($1 += 1,
        i(`mui-${$1}`))
    }
    , [t]),
    s
}
const V1 = H0.useId;
function yv(e) {
    if (V1 !== void 0) {
        const t = V1();
        return e ?? t
    }
    return jI(e)
}
function NI(e, t, i, s, u) {
    return null
}
function uy({controlled: e, default: t, name: i, state: s="value"}) {
    const {current: u} = Pe.useRef(e !== void 0)
      , [d,f] = Pe.useState(t)
      , o = u ? e : d
      , w = Pe.useCallback(T => {
        u || f(T)
    }
    , []);
    return [o, w]
}
function dl(e) {
    const t = Pe.useRef(e);
    return gl( () => {
        t.current = e
    }
    ),
    Pe.useRef( (...i) => (0,
    t.current)(...i)).current
}
function ki(...e) {
    return Pe.useMemo( () => e.every(t => t == null) ? null : t => {
        e.forEach(i => {
            W_(i, t)
        }
        )
    }
    , e)
}
const U1 = {};
function $I(e, t) {
    const i = Pe.useRef(U1);
    return i.current === U1 && (i.current = e(t)),
    i
}
const VI = [];
function UI(e) {
    Pe.useEffect(e, VI)
}
class hy {
    constructor() {
        this.currentId = null,
        this.clear = () => {
            this.currentId !== null && (clearTimeout(this.currentId),
            this.currentId = null)
        }
        ,
        this.disposeEffect = () => this.clear
    }
    static create() {
        return new hy
    }
    start(t, i) {
        this.clear(),
        this.currentId = setTimeout( () => {
            this.currentId = null,
            i()
        }
        , t)
    }
}
function Pp() {
    const e = $I(hy.create).current;
    return UI(e.disposeEffect),
    e
}
let _v = !0
  , Q0 = !1;
const GI = new hy
  , WI = {
    text: !0,
    search: !0,
    url: !0,
    tel: !0,
    email: !0,
    password: !0,
    number: !0,
    date: !0,
    month: !0,
    week: !0,
    time: !0,
    datetime: !0,
    "datetime-local": !0
};
function qI(e) {
    const {type: t, tagName: i} = e;
    return !!(i === "INPUT" && WI[t] && !e.readOnly || i === "TEXTAREA" && !e.readOnly || e.isContentEditable)
}
function HI(e) {
    e.metaKey || e.altKey || e.ctrlKey || (_v = !0)
}
function g0() {
    _v = !1
}
function ZI() {
    this.visibilityState === "hidden" && Q0 && (_v = !0)
}
function XI(e) {
    e.addEventListener("keydown", HI, !0),
    e.addEventListener("mousedown", g0, !0),
    e.addEventListener("pointerdown", g0, !0),
    e.addEventListener("touchstart", g0, !0),
    e.addEventListener("visibilitychange", ZI, !0)
}
function YI(e) {
    const {target: t} = e;
    try {
        return t.matches(":focus-visible")
    } catch {}
    return _v || qI(t)
}
function dy() {
    const e = Pe.useCallback(u => {
        u != null && XI(u.ownerDocument)
    }
    , [])
      , t = Pe.useRef(!1);
    function i() {
        return t.current ? (Q0 = !0,
        GI.start(100, () => {
            Q0 = !1
        }
        ),
        t.current = !1,
        !0) : !1
    }
    function s(u) {
        return YI(u) ? (t.current = !0,
        !0) : !1
    }
    return {
        isFocusVisibleRef: t,
        onFocus: s,
        onBlur: i,
        ref: e
    }
}
function KI(e) {
    const t = e.documentElement.clientWidth;
    return Math.abs(window.innerWidth - t)
}
const QI = {
    border: 0,
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
};
function Jr(e, t, i=void 0) {
    const s = {};
    return Object.keys(e).forEach(u => {
        s[u] = e[u].reduce( (d, f) => {
            if (f) {
                const o = t(f);
                o !== "" && d.push(o),
                i && i[f] && d.push(i[f])
            }
            return d
        }
        , []).join(" ")
    }
    ),
    s
}
function oh(e) {
    return typeof e == "string"
}
function Mp(e, t, i) {
    return e === void 0 || oh(e) ? t : xe({}, t, {
        ownerState: xe({}, t.ownerState, i)
    })
}
function Dg(e, t=[]) {
    if (e === void 0)
        return {};
    const i = {};
    return Object.keys(e).filter(s => s.match(/^on[A-Z]/) && typeof e[s] == "function" && !t.includes(s)).forEach(s => {
        i[s] = e[s]
    }
    ),
    i
}
function G1(e) {
    if (e === void 0)
        return {};
    const t = {};
    return Object.keys(e).filter(i => !(i.match(/^on[A-Z]/) && typeof e[i] == "function")).forEach(i => {
        t[i] = e[i]
    }
    ),
    t
}
function HC(e) {
    const {getSlotProps: t, additionalProps: i, externalSlotProps: s, externalForwardedProps: u, className: d} = e;
    if (!t) {
        const D = nr(i?.className, d, u?.className, s?.className)
          , N = xe({}, i?.style, u?.style, s?.style)
          , U = xe({}, i, u, s);
        return D.length > 0 && (U.className = D),
        Object.keys(N).length > 0 && (U.style = N),
        {
            props: U,
            internalRef: void 0
        }
    }
    const f = Dg(xe({}, u, s))
      , o = G1(s)
      , w = G1(u)
      , T = t(f)
      , k = nr(T?.className, i?.className, d, u?.className, s?.className)
      , L = xe({}, T?.style, i?.style, u?.style, s?.style)
      , z = xe({}, T, i, w, o);
    return k.length > 0 && (z.className = k),
    Object.keys(L).length > 0 && (z.style = L),
    {
        props: z,
        internalRef: T.ref
    }
}
function ZC(e, t, i) {
    return typeof e == "function" ? e(t, i) : e
}
const JI = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
function cl(e) {
    var t;
    const {elementType: i, externalSlotProps: s, ownerState: u, skipResolvingSlotProps: d=!1} = e
      , f = dr(e, JI)
      , o = d ? {} : ZC(s, u)
      , {props: w, internalRef: T} = HC(xe({}, f, {
        externalSlotProps: o
    }))
      , k = ki(T, o?.ref, (t = e.additionalProps) == null ? void 0 : t.ref);
    return Mp(i, xe({}, w, {
        ref: k
    }), u)
}
const XC = Pe.createContext(null);
function YC() {
    return Pe.useContext(XC)
}
const eR = typeof Symbol == "function" && Symbol.for
  , tR = eR ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function rR(e, t) {
    return typeof t == "function" ? t(e) : xe({}, e, t)
}
function nR(e) {
    const {children: t, theme: i} = e
      , s = YC()
      , u = Pe.useMemo( () => {
        const d = s === null ? i : rR(s, i);
        return d != null && (d[tR] = s !== null),
        d
    }
    , [i, s]);
    return G.jsx(XC.Provider, {
        value: u,
        children: t
    })
}
const iR = ["value"]
  , KC = Pe.createContext();
function oR(e) {
    let {value: t} = e
      , i = dr(e, iR);
    return G.jsx(KC.Provider, xe({
        value: t ?? !0
    }, i))
}
const Bx = () => {
    const e = Pe.useContext(KC);
    return e ?? !1
}
  , QC = Pe.createContext(void 0);
function sR({value: e, children: t}) {
    return G.jsx(QC.Provider, {
        value: e,
        children: t
    })
}
function aR(e) {
    const {theme: t, name: i, props: s} = e;
    if (!t || !t.components || !t.components[i])
        return s;
    const u = t.components[i];
    return u.defaultProps ? Zg(u.defaultProps, s) : !u.styleOverrides && !u.variants ? Zg(u, s) : s
}
function lR({props: e, name: t}) {
    const i = Pe.useContext(QC);
    return aR({
        props: e,
        name: t,
        theme: {
            components: i
        }
    })
}
const W1 = {};
function q1(e, t, i, s=!1) {
    return Pe.useMemo( () => {
        const u = e && t[e] || t;
        if (typeof i == "function") {
            const d = i(u)
              , f = e ? xe({}, t, {
                [e]: d
            }) : d;
            return s ? () => f : f
        }
        return e ? xe({}, t, {
            [e]: i
        }) : xe({}, t, i)
    }
    , [e, t, i, s])
}
function cR(e) {
    const {children: t, theme: i, themeId: s} = e
      , u = VC(W1)
      , d = YC() || W1
      , f = q1(s, u, i)
      , o = q1(s, d, i, !0)
      , w = f.direction === "rtl";
    return G.jsx(nR, {
        theme: o,
        children: G.jsx(sy.Provider, {
            value: f,
            children: G.jsx(oR, {
                value: w,
                children: G.jsx(sR, {
                    value: f?.components,
                    children: t
                })
            })
        })
    })
}
const uR = ["component", "direction", "spacing", "divider", "children", "className", "useFlexGap"]
  , hR = cy()
  , dR = qC("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (e, t) => t.root
});
function fR(e) {
    return LI({
        props: e,
        name: "MuiStack",
        defaultTheme: hR
    })
}
function pR(e, t) {
    const i = Pe.Children.toArray(e).filter(Boolean);
    return i.reduce( (s, u, d) => (s.push(u),
    d < i.length - 1 && s.push(Pe.cloneElement(t, {
        key: `separator-${d}`
    })),
    s), [])
}
const mR = e => ({
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
})[e]
  , gR = ({ownerState: e, theme: t}) => {
    let i = xe({
        display: "flex",
        flexDirection: "column"
    }, tc({
        theme: t
    }, f0({
        values: e.direction,
        breakpoints: t.breakpoints.values
    }), s => ({
        flexDirection: s
    })));
    if (e.spacing) {
        const s = Dx(t)
          , u = Object.keys(t.breakpoints.values).reduce( (w, T) => ((typeof e.spacing == "object" && e.spacing[T] != null || typeof e.direction == "object" && e.direction[T] != null) && (w[T] = !0),
        w), {})
          , d = f0({
            values: e.direction,
            base: u
        })
          , f = f0({
            values: e.spacing,
            base: u
        });
        typeof d == "object" && Object.keys(d).forEach( (w, T, k) => {
            if (!d[w]) {
                const z = T > 0 ? d[k[T - 1]] : "column";
                d[w] = z
            }
        }
        ),
        i = pl(i, tc({
            theme: t
        }, f, (w, T) => e.useFlexGap ? {
            gap: yf(s, w)
        } : {
            "& > :not(style):not(style)": {
                margin: 0
            },
            "& > :not(style) ~ :not(style)": {
                [`margin${mR(T ? d[T] : e.direction)}`]: yf(s, w)
            }
        }))
    }
    return i = vE(t.breakpoints, i),
    i
}
;
function yR(e={}) {
    const {createStyledComponent: t=dR, useThemeProps: i=fR, componentName: s="MuiStack"} = e
      , u = () => Jr({
        root: ["root"]
    }, w => Kr(s, w), {})
      , d = t(gR);
    return Pe.forwardRef(function(w, T) {
        const k = i(w)
          , L = gv(k)
          , {component: z="div", direction: D="column", spacing: N=0, divider: U, children: V, className: re, useFlexGap: ie=!1} = L
          , ue = dr(L, uR)
          , ce = {
            direction: D,
            spacing: N,
            useFlexGap: ie
        }
          , X = u();
        return G.jsx(d, xe({
            as: z,
            ownerState: ce,
            ref: T,
            className: nr(X.root, re)
        }, ue, {
            children: U ? pR(V, U) : V
        }))
    })
}
function _R(e, t) {
    return xe({
        toolbar: {
            minHeight: 56,
            [e.up("xs")]: {
                "@media (orientation: landscape)": {
                    minHeight: 48
                }
            },
            [e.up("sm")]: {
                minHeight: 64
            }
        }
    }, t)
}
var Mi = {}, y0 = {
    exports: {}
}, H1;
function Io() {
    return H1 || (H1 = 1,
    function(e) {
        function t(i) {
            return i && i.__esModule ? i : {
                default: i
            }
        }
        e.exports = t,
        e.exports.__esModule = !0,
        e.exports.default = e.exports
    }(y0)),
    y0.exports
}
const vR = ou(yk)
  , xR = ou(OI);
var Z1;
function bR() {
    if (Z1)
        return Mi;
    Z1 = 1;
    var e = Io();
    Object.defineProperty(Mi, "__esModule", {
        value: !0
    }),
    Mi.alpha = N,
    Mi.blend = me,
    Mi.colorChannel = void 0,
    Mi.darken = V,
    Mi.decomposeColor = f,
    Mi.emphasize = ce,
    Mi.getContrastRatio = D,
    Mi.getLuminance = z,
    Mi.hexToRgb = u,
    Mi.hslToRgb = L,
    Mi.lighten = ie,
    Mi.private_safeAlpha = U,
    Mi.private_safeColorChannel = void 0,
    Mi.private_safeDarken = re,
    Mi.private_safeEmphasize = X,
    Mi.private_safeLighten = ue,
    Mi.recomposeColor = T,
    Mi.rgbToHex = k;
    var t = e(vR)
      , i = e(xR);
    function s(K, be=0, Ee=1) {
        return (0,
        i.default)(K, be, Ee)
    }
    function u(K) {
        K = K.slice(1);
        const be = new RegExp(`.{1,${K.length >= 6 ? 2 : 1}}`,"g");
        let Ee = K.match(be);
        return Ee && Ee[0].length === 1 && (Ee = Ee.map(Ce => Ce + Ce)),
        Ee ? `rgb${Ee.length === 4 ? "a" : ""}(${Ee.map( (Ce, He) => He < 3 ? parseInt(Ce, 16) : Math.round(parseInt(Ce, 16) / 255 * 1e3) / 1e3).join(", ")})` : ""
    }
    function d(K) {
        const be = K.toString(16);
        return be.length === 1 ? `0${be}` : be
    }
    function f(K) {
        if (K.type)
            return K;
        if (K.charAt(0) === "#")
            return f(u(K));
        const be = K.indexOf("(")
          , Ee = K.substring(0, be);
        if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(Ee) === -1)
            throw new Error((0,
            t.default)(9, K));
        let Ce = K.substring(be + 1, K.length - 1), He;
        if (Ee === "color") {
            if (Ce = Ce.split(" "),
            He = Ce.shift(),
            Ce.length === 4 && Ce[3].charAt(0) === "/" && (Ce[3] = Ce[3].slice(1)),
            ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(He) === -1)
                throw new Error((0,
                t.default)(10, He))
        } else
            Ce = Ce.split(",");
        return Ce = Ce.map(ct => parseFloat(ct)),
        {
            type: Ee,
            values: Ce,
            colorSpace: He
        }
    }
    const o = K => {
        const be = f(K);
        return be.values.slice(0, 3).map( (Ee, Ce) => be.type.indexOf("hsl") !== -1 && Ce !== 0 ? `${Ee}%` : Ee).join(" ")
    }
    ;
    Mi.colorChannel = o;
    const w = (K, be) => {
        try {
            return o(K)
        } catch {
            return K
        }
    }
    ;
    Mi.private_safeColorChannel = w;
    function T(K) {
        const {type: be, colorSpace: Ee} = K;
        let {values: Ce} = K;
        return be.indexOf("rgb") !== -1 ? Ce = Ce.map( (He, ct) => ct < 3 ? parseInt(He, 10) : He) : be.indexOf("hsl") !== -1 && (Ce[1] = `${Ce[1]}%`,
        Ce[2] = `${Ce[2]}%`),
        be.indexOf("color") !== -1 ? Ce = `${Ee} ${Ce.join(" ")}` : Ce = `${Ce.join(", ")}`,
        `${be}(${Ce})`
    }
    function k(K) {
        if (K.indexOf("#") === 0)
            return K;
        const {values: be} = f(K);
        return `#${be.map( (Ee, Ce) => d(Ce === 3 ? Math.round(255 * Ee) : Ee)).join("")}`
    }
    function L(K) {
        K = f(K);
        const {values: be} = K
          , Ee = be[0]
          , Ce = be[1] / 100
          , He = be[2] / 100
          , ct = Ce * Math.min(He, 1 - He)
          , nt = (ve, Ne=(ve + Ee / 30) % 12) => He - ct * Math.max(Math.min(Ne - 3, 9 - Ne, 1), -1);
        let J = "rgb";
        const he = [Math.round(nt(0) * 255), Math.round(nt(8) * 255), Math.round(nt(4) * 255)];
        return K.type === "hsla" && (J += "a",
        he.push(be[3])),
        T({
            type: J,
            values: he
        })
    }
    function z(K) {
        K = f(K);
        let be = K.type === "hsl" || K.type === "hsla" ? f(L(K)).values : K.values;
        return be = be.map(Ee => (K.type !== "color" && (Ee /= 255),
        Ee <= .03928 ? Ee / 12.92 : ((Ee + .055) / 1.055) ** 2.4)),
        Number((.2126 * be[0] + .7152 * be[1] + .0722 * be[2]).toFixed(3))
    }
    function D(K, be) {
        const Ee = z(K)
          , Ce = z(be);
        return (Math.max(Ee, Ce) + .05) / (Math.min(Ee, Ce) + .05)
    }
    function N(K, be) {
        return K = f(K),
        be = s(be),
        (K.type === "rgb" || K.type === "hsl") && (K.type += "a"),
        K.type === "color" ? K.values[3] = `/${be}` : K.values[3] = be,
        T(K)
    }
    function U(K, be, Ee) {
        try {
            return N(K, be)
        } catch {
            return K
        }
    }
    function V(K, be) {
        if (K = f(K),
        be = s(be),
        K.type.indexOf("hsl") !== -1)
            K.values[2] *= 1 - be;
        else if (K.type.indexOf("rgb") !== -1 || K.type.indexOf("color") !== -1)
            for (let Ee = 0; Ee < 3; Ee += 1)
                K.values[Ee] *= 1 - be;
        return T(K)
    }
    function re(K, be, Ee) {
        try {
            return V(K, be)
        } catch {
            return K
        }
    }
    function ie(K, be) {
        if (K = f(K),
        be = s(be),
        K.type.indexOf("hsl") !== -1)
            K.values[2] += (100 - K.values[2]) * be;
        else if (K.type.indexOf("rgb") !== -1)
            for (let Ee = 0; Ee < 3; Ee += 1)
                K.values[Ee] += (255 - K.values[Ee]) * be;
        else if (K.type.indexOf("color") !== -1)
            for (let Ee = 0; Ee < 3; Ee += 1)
                K.values[Ee] += (1 - K.values[Ee]) * be;
        return T(K)
    }
    function ue(K, be, Ee) {
        try {
            return ie(K, be)
        } catch {
            return K
        }
    }
    function ce(K, be=.15) {
        return z(K) > .5 ? V(K, be) : ie(K, be)
    }
    function X(K, be, Ee) {
        try {
            return ce(K, be)
        } catch {
            return K
        }
    }
    function me(K, be, Ee, Ce=1) {
        const He = (he, ve) => Math.round((he ** (1 / Ce) * (1 - Ee) + ve ** (1 / Ce) * Ee) ** Ce)
          , ct = f(K)
          , nt = f(be)
          , J = [He(ct.values[0], nt.values[0]), He(ct.values[1], nt.values[1]), He(ct.values[2], nt.values[2])];
        return T({
            type: "rgb",
            values: J
        })
    }
    return Mi
}
var Or = bR();
const wR = ["mode", "contrastThreshold", "tonalOffset"]
  , X1 = {
    text: {
        primary: "rgba(0, 0, 0, 0.87)",
        secondary: "rgba(0, 0, 0, 0.6)",
        disabled: "rgba(0, 0, 0, 0.38)"
    },
    divider: "rgba(0, 0, 0, 0.12)",
    background: {
        paper: Ug.white,
        default: Ug.white
    },
    action: {
        active: "rgba(0, 0, 0, 0.54)",
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: .04,
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: .08,
        disabled: "rgba(0, 0, 0, 0.26)",
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: .38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: .12,
        activatedOpacity: .12
    }
}
  , _0 = {
    text: {
        primary: Ug.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
        paper: "#121212",
        default: "#121212"
    },
    action: {
        active: Ug.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: .08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: .16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: .38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: .12,
        activatedOpacity: .24
    }
};
function Y1(e, t, i, s) {
    const u = s.light || s
      , d = s.dark || s * 1.5;
    e[t] || (e.hasOwnProperty(i) ? e[t] = e[i] : t === "light" ? e.light = Or.lighten(e.main, u) : t === "dark" && (e.dark = Or.darken(e.main, d)))
}
function SR(e="light") {
    return e === "dark" ? {
        main: gp[200],
        light: gp[50],
        dark: gp[400]
    } : {
        main: gp[700],
        light: gp[400],
        dark: gp[800]
    }
}
function CR(e="light") {
    return e === "dark" ? {
        main: mp[200],
        light: mp[50],
        dark: mp[400]
    } : {
        main: mp[500],
        light: mp[300],
        dark: mp[700]
    }
}
function TR(e="light") {
    return e === "dark" ? {
        main: pp[500],
        light: pp[300],
        dark: pp[700]
    } : {
        main: pp[700],
        light: pp[400],
        dark: pp[800]
    }
}
function PR(e="light") {
    return e === "dark" ? {
        main: yp[400],
        light: yp[300],
        dark: yp[700]
    } : {
        main: yp[700],
        light: yp[500],
        dark: yp[900]
    }
}
function MR(e="light") {
    return e === "dark" ? {
        main: _p[400],
        light: _p[300],
        dark: _p[700]
    } : {
        main: _p[800],
        light: _p[500],
        dark: _p[900]
    }
}
function kR(e="light") {
    return e === "dark" ? {
        main: Nm[400],
        light: Nm[300],
        dark: Nm[700]
    } : {
        main: "#ed6c02",
        light: Nm[500],
        dark: Nm[900]
    }
}
function ER(e) {
    const {mode: t="light", contrastThreshold: i=3, tonalOffset: s=.2} = e
      , u = dr(e, wR)
      , d = e.primary || SR(t)
      , f = e.secondary || CR(t)
      , o = e.error || TR(t)
      , w = e.info || PR(t)
      , T = e.success || MR(t)
      , k = e.warning || kR(t);
    function L(U) {
        return Or.getContrastRatio(U, _0.text.primary) >= i ? _0.text.primary : X1.text.primary
    }
    const z = ({color: U, name: V, mainShade: re=500, lightShade: ie=300, darkShade: ue=700}) => {
        if (U = xe({}, U),
        !U.main && U[re] && (U.main = U[re]),
        !U.hasOwnProperty("main"))
            throw new Error(zp(11, V ? ` (${V})` : "", re));
        if (typeof U.main != "string")
            throw new Error(zp(12, V ? ` (${V})` : "", JSON.stringify(U.main)));
        return Y1(U, "light", ie, s),
        Y1(U, "dark", ue, s),
        U.contrastText || (U.contrastText = L(U.main)),
        U
    }
      , D = {
        dark: _0,
        light: X1
    };
    return pl(xe({
        common: xe({}, Ug),
        mode: t,
        primary: z({
            color: d,
            name: "primary"
        }),
        secondary: z({
            color: f,
            name: "secondary",
            mainShade: "A400",
            lightShade: "A200",
            darkShade: "A700"
        }),
        error: z({
            color: o,
            name: "error"
        }),
        warning: z({
            color: k,
            name: "warning"
        }),
        info: z({
            color: w,
            name: "info"
        }),
        success: z({
            color: T,
            name: "success"
        }),
        grey: gk,
        contrastThreshold: i,
        getContrastText: L,
        augmentColor: z,
        tonalOffset: s
    }, D[t]), u)
}
const IR = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function RR(e) {
    return Math.round(e * 1e5) / 1e5
}
const K1 = {
    textTransform: "uppercase"
}
  , Q1 = '"Roboto", "Helvetica", "Arial", sans-serif';
function AR(e, t) {
    const i = typeof t == "function" ? t(e) : t
      , {fontFamily: s=Q1, fontSize: u=14, fontWeightLight: d=300, fontWeightRegular: f=400, fontWeightMedium: o=500, fontWeightBold: w=700, htmlFontSize: T=16, allVariants: k, pxToRem: L} = i
      , z = dr(i, IR)
      , D = u / 14
      , N = L || (re => `${re / T * D}rem`)
      , U = (re, ie, ue, ce, X) => xe({
        fontFamily: s,
        fontWeight: re,
        fontSize: N(ie),
        lineHeight: ue
    }, s === Q1 ? {
        letterSpacing: `${RR(ce / ie)}em`
    } : {}, X, k)
      , V = {
        h1: U(d, 96, 1.167, -1.5),
        h2: U(d, 60, 1.2, -.5),
        h3: U(f, 48, 1.167, 0),
        h4: U(f, 34, 1.235, .25),
        h5: U(f, 24, 1.334, 0),
        h6: U(o, 20, 1.6, .15),
        subtitle1: U(f, 16, 1.75, .15),
        subtitle2: U(o, 14, 1.57, .1),
        body1: U(f, 16, 1.5, .15),
        body2: U(f, 14, 1.43, .15),
        button: U(o, 14, 1.75, .4, K1),
        caption: U(f, 12, 1.66, .4),
        overline: U(f, 12, 2.66, 1, K1),
        inherit: {
            fontFamily: "inherit",
            fontWeight: "inherit",
            fontSize: "inherit",
            lineHeight: "inherit",
            letterSpacing: "inherit"
        }
    };
    return pl(xe({
        htmlFontSize: T,
        pxToRem: N,
        fontFamily: s,
        fontSize: u,
        fontWeightLight: d,
        fontWeightRegular: f,
        fontWeightMedium: o,
        fontWeightBold: w
    }, V), z, {
        clone: !1
    })
}
const zR = .2
  , DR = .14
  , LR = .12;
function wi(...e) {
    return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${zR})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${DR})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${LR})`].join(",")
}
const OR = ["none", wi(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), wi(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), wi(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), wi(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), wi(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), wi(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), wi(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), wi(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), wi(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), wi(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), wi(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), wi(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), wi(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), wi(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), wi(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), wi(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), wi(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), wi(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), wi(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), wi(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), wi(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), wi(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), wi(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), wi(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)]
  , FR = ["duration", "easing", "delay"]
  , BR = {
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}
  , jR = {
    shortest: 150,
    shorter: 200,
    short: 250,
    standard: 300,
    complex: 375,
    enteringScreen: 225,
    leavingScreen: 195
};
function J1(e) {
    return `${Math.round(e)}ms`
}
function NR(e) {
    if (!e)
        return 0;
    const t = e / 36;
    return Math.round((4 + 15 * t ** .25 + t / 5) * 10)
}
function $R(e) {
    const t = xe({}, BR, e.easing)
      , i = xe({}, jR, e.duration);
    return xe({
        getAutoHeightDuration: NR,
        create: (u=["all"], d={}) => {
            const {duration: f=i.standard, easing: o=t.easeInOut, delay: w=0} = d;
            return dr(d, FR),
            (Array.isArray(u) ? u : [u]).map(T => `${T} ${typeof f == "string" ? f : J1(f)} ${o} ${typeof w == "string" ? w : J1(w)}`).join(",")
        }
    }, e, {
        easing: t,
        duration: i
    })
}
const VR = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
}
  , UR = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function JC(e={}, ...t) {
    const {mixins: i={}, palette: s={}, transitions: u={}, typography: d={}} = e
      , f = dr(e, UR);
    if (e.vars)
        throw new Error(zp(18));
    const o = ER(s)
      , w = cy(e);
    let T = pl(w, {
        mixins: _R(w.breakpoints, i),
        palette: o,
        shadows: OR.slice(),
        typography: AR(o, d),
        transitions: $R(u),
        zIndex: xe({}, VR)
    });
    return T = pl(T, f),
    T = t.reduce( (k, L) => pl(k, L), T),
    T.unstable_sxConfig = xe({}, ly, f?.unstable_sxConfig),
    T.unstable_sx = function(L) {
        return Yp({
            sx: L,
            theme: this
        })
    }
    ,
    T
}
const jx = JC();
function Kp() {
    const e = mv(jx);
    return e[Gg] || e
}
var Xd = {}, v0 = {
    exports: {}
}, ew;
function GR() {
    return ew || (ew = 1,
    function(e) {
        function t() {
            return e.exports = t = Object.assign ? Object.assign.bind() : function(i) {
                for (var s = 1; s < arguments.length; s++) {
                    var u = arguments[s];
                    for (var d in u)
                        ({}).hasOwnProperty.call(u, d) && (i[d] = u[d])
                }
                return i
            }
            ,
            e.exports.__esModule = !0,
            e.exports.default = e.exports,
            t.apply(null, arguments)
        }
        e.exports = t,
        e.exports.__esModule = !0,
        e.exports.default = e.exports
    }(v0)),
    v0.exports
}
var x0 = {
    exports: {}
}, tw;
function WR() {
    return tw || (tw = 1,
    function(e) {
        function t(i, s) {
            if (i == null)
                return {};
            var u = {};
            for (var d in i)
                if ({}.hasOwnProperty.call(i, d)) {
                    if (s.indexOf(d) !== -1)
                        continue;
                    u[d] = i[d]
                }
            return u
        }
        e.exports = t,
        e.exports.__esModule = !0,
        e.exports.default = e.exports
    }(x0)),
    x0.exports
}
const eT = ou(pE)
  , qR = ou(mE)
  , HR = ou(bE)
  , ZR = ou(CI)
  , XR = ou(lI)
  , YR = ou(pI);
var rw;
function KR() {
    if (rw)
        return Xd;
    rw = 1;
    var e = Io();
    Object.defineProperty(Xd, "__esModule", {
        value: !0
    }),
    Xd.default = ce,
    Xd.shouldForwardProp = N,
    Xd.systemDefaultTheme = void 0;
    var t = e(GR())
      , i = e(WR())
      , s = L(eT)
      , u = qR;
    e(HR),
    e(ZR);
    var d = e(XR)
      , f = e(YR);
    const o = ["ownerState"]
      , w = ["variants"]
      , T = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
    function k(X) {
        if (typeof WeakMap != "function")
            return null;
        var me = new WeakMap
          , K = new WeakMap;
        return (k = function(be) {
            return be ? K : me
        }
        )(X)
    }
    function L(X, me) {
        if (X && X.__esModule)
            return X;
        if (X === null || typeof X != "object" && typeof X != "function")
            return {
                default: X
            };
        var K = k(me);
        if (K && K.has(X))
            return K.get(X);
        var be = {
            __proto__: null
        }
          , Ee = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var Ce in X)
            if (Ce !== "default" && Object.prototype.hasOwnProperty.call(X, Ce)) {
                var He = Ee ? Object.getOwnPropertyDescriptor(X, Ce) : null;
                He && (He.get || He.set) ? Object.defineProperty(be, Ce, He) : be[Ce] = X[Ce]
            }
        return be.default = X,
        K && K.set(X, be),
        be
    }
    function z(X) {
        return Object.keys(X).length === 0
    }
    function D(X) {
        return typeof X == "string" && X.charCodeAt(0) > 96
    }
    function N(X) {
        return X !== "ownerState" && X !== "theme" && X !== "sx" && X !== "as"
    }
    const U = Xd.systemDefaultTheme = (0,
    d.default)()
      , V = X => X && X.charAt(0).toLowerCase() + X.slice(1);
    function re({defaultTheme: X, theme: me, themeId: K}) {
        return z(me) ? X : me[K] || me
    }
    function ie(X) {
        return X ? (me, K) => K[X] : null
    }
    function ue(X, me) {
        let {ownerState: K} = me
          , be = (0,
        i.default)(me, o);
        const Ee = typeof X == "function" ? X((0,
        t.default)({
            ownerState: K
        }, be)) : X;
        if (Array.isArray(Ee))
            return Ee.flatMap(Ce => ue(Ce, (0,
            t.default)({
                ownerState: K
            }, be)));
        if (Ee && typeof Ee == "object" && Array.isArray(Ee.variants)) {
            const {variants: Ce=[]} = Ee;
            let ct = (0,
            i.default)(Ee, w);
            return Ce.forEach(nt => {
                let J = !0;
                typeof nt.props == "function" ? J = nt.props((0,
                t.default)({
                    ownerState: K
                }, be, K)) : Object.keys(nt.props).forEach(he => {
                    K?.[he] !== nt.props[he] && be[he] !== nt.props[he] && (J = !1)
                }
                ),
                J && (Array.isArray(ct) || (ct = [ct]),
                ct.push(typeof nt.style == "function" ? nt.style((0,
                t.default)({
                    ownerState: K
                }, be, K)) : nt.style))
            }
            ),
            ct
        }
        return Ee
    }
    function ce(X={}) {
        const {themeId: me, defaultTheme: K=U, rootShouldForwardProp: be=N, slotShouldForwardProp: Ee=N} = X
          , Ce = He => (0,
        f.default)((0,
        t.default)({}, He, {
            theme: re((0,
            t.default)({}, He, {
                defaultTheme: K,
                themeId: me
            }))
        }));
        return Ce.__mui_systemSx = !0,
        (He, ct={}) => {
            (0,
            s.internal_processStyles)(He, Wt => Wt.filter(tr => !(tr != null && tr.__mui_systemSx)));
            const {name: nt, slot: J, skipVariantsResolver: he, skipSx: ve, overridesResolver: Ne=ie(V(J))} = ct
              , je = (0,
            i.default)(ct, T)
              , lt = he !== void 0 ? he : J && J !== "Root" && J !== "root" || !1
              , Pt = ve || !1;
            let We, st = N;
            J === "Root" || J === "root" ? st = be : J ? st = Ee : D(He) && (st = void 0);
            const Nt = (0,
            s.default)(He, (0,
            t.default)({
                shouldForwardProp: st,
                label: We
            }, je))
              , zt = Wt => typeof Wt == "function" && Wt.__emotion_real !== Wt || (0,
            u.isPlainObject)(Wt) ? tr => ue(Wt, (0,
            t.default)({}, tr, {
                theme: re({
                    theme: tr.theme,
                    defaultTheme: K,
                    themeId: me
                })
            })) : Wt
              , Qt = (Wt, ...tr) => {
                let cr = zt(Wt);
                const Yt = tr ? tr.map(zt) : [];
                nt && Ne && Yt.push(Nr => {
                    const ur = re((0,
                    t.default)({}, Nr, {
                        defaultTheme: K,
                        themeId: me
                    }));
                    if (!ur.components || !ur.components[nt] || !ur.components[nt].styleOverrides)
                        return null;
                    const vr = ur.components[nt].styleOverrides
                      , gr = {};
                    return Object.entries(vr).forEach( ([hn,Zr]) => {
                        gr[hn] = ue(Zr, (0,
                        t.default)({}, Nr, {
                            theme: ur
                        }))
                    }
                    ),
                    Ne(Nr, gr)
                }
                ),
                nt && !lt && Yt.push(Nr => {
                    var ur;
                    const vr = re((0,
                    t.default)({}, Nr, {
                        defaultTheme: K,
                        themeId: me
                    }))
                      , gr = vr == null || (ur = vr.components) == null || (ur = ur[nt]) == null ? void 0 : ur.variants;
                    return ue({
                        variants: gr
                    }, (0,
                    t.default)({}, Nr, {
                        theme: vr
                    }))
                }
                ),
                Pt || Yt.push(Ce);
                const Gr = Yt.length - tr.length;
                if (Array.isArray(Wt) && Gr > 0) {
                    const Nr = new Array(Gr).fill("");
                    cr = [...Wt, ...Nr],
                    cr.raw = [...Wt.raw, ...Nr]
                }
                const xr = Nt(cr, ...Yt);
                return He.muiName && (xr.muiName = He.muiName),
                xr
            }
            ;
            return Nt.withConfig && (Qt.withConfig = Nt.withConfig),
            Qt
        }
    }
    return Xd
}
var QR = KR();
const JR = Ni(QR);
function Nx(e) {
    return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as"
}
const ed = e => Nx(e) && e !== "classes"
  , Jt = JR({
    themeId: Gg,
    defaultTheme: jx,
    rootShouldForwardProp: ed
})
  , eA = ["theme"];
function tA(e) {
    let {theme: t} = e
      , i = dr(e, eA);
    const s = t[Gg];
    return G.jsx(cR, xe({}, i, {
        themeId: s ? Gg : void 0,
        theme: s || t
    }))
}
const nw = e => {
    let t;
    return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2,
    (t / 100).toFixed(2)
}
;
function nn(e) {
    return lR(e)
}
function rA(e) {
    return Kr("MuiSvgIcon", e)
}
Qr("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const nA = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"]
  , iA = e => {
    const {color: t, fontSize: i, classes: s} = e
      , u = {
        root: ["root", t !== "inherit" && `color${Ot(t)}`, `fontSize${Ot(i)}`]
    };
    return Jr(u, rA, s)
}
  , oA = Jt("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, i.color !== "inherit" && t[`color${Ot(i.color)}`], t[`fontSize${Ot(i.fontSize)}`]]
    }
})( ({theme: e, ownerState: t}) => {
    var i, s, u, d, f, o, w, T, k, L, z, D, N;
    return {
        userSelect: "none",
        width: "1em",
        height: "1em",
        display: "inline-block",
        fill: t.hasSvgAsChild ? void 0 : "currentColor",
        flexShrink: 0,
        transition: (i = e.transitions) == null || (s = i.create) == null ? void 0 : s.call(i, "fill", {
            duration: (u = e.transitions) == null || (u = u.duration) == null ? void 0 : u.shorter
        }),
        fontSize: {
            inherit: "inherit",
            small: ((d = e.typography) == null || (f = d.pxToRem) == null ? void 0 : f.call(d, 20)) || "1.25rem",
            medium: ((o = e.typography) == null || (w = o.pxToRem) == null ? void 0 : w.call(o, 24)) || "1.5rem",
            large: ((T = e.typography) == null || (k = T.pxToRem) == null ? void 0 : k.call(T, 35)) || "2.1875rem"
        }[t.fontSize],
        color: (L = (z = (e.vars || e).palette) == null || (z = z[t.color]) == null ? void 0 : z.main) != null ? L : {
            action: (D = (e.vars || e).palette) == null || (D = D.action) == null ? void 0 : D.active,
            disabled: (N = (e.vars || e).palette) == null || (N = N.action) == null ? void 0 : N.disabled,
            inherit: void 0
        }[t.color]
    }
}
)
  , J0 = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiSvgIcon"
    })
      , {children: u, className: d, color: f="inherit", component: o="svg", fontSize: w="medium", htmlColor: T, inheritViewBox: k=!1, titleAccess: L, viewBox: z="0 0 24 24"} = s
      , D = dr(s, nA)
      , N = Pe.isValidElement(u) && u.type === "svg"
      , U = xe({}, s, {
        color: f,
        component: o,
        fontSize: w,
        instanceFontSize: t.fontSize,
        inheritViewBox: k,
        viewBox: z,
        hasSvgAsChild: N
    })
      , V = {};
    k || (V.viewBox = z);
    const re = iA(U);
    return G.jsxs(oA, xe({
        as: o,
        className: nr(re.root, d),
        focusable: "false",
        color: T,
        "aria-hidden": L ? void 0 : !0,
        role: L ? "img" : void 0,
        ref: i
    }, V, D, N && u.props, {
        ownerState: U,
        children: [N ? u.props.children : u, L ? G.jsx("title", {
            children: L
        }) : null]
    }))
});
J0.muiName = "SvgIcon";
function rc(e, t) {
    function i(s, u) {
        return G.jsx(J0, xe({
            "data-testid": `${t}Icon`,
            ref: u
        }, s, {
            children: e
        }))
    }
    return i.muiName = J0.muiName,
    Pe.memo(Pe.forwardRef(i))
}
const sA = {
    configure: e => {
        Ox.configure(e)
    }
}
  , aA = Object.freeze(Object.defineProperty({
    __proto__: null,
    capitalize: Ot,
    createChainedFunction: G_,
    createSvgIcon: rc,
    debounce: Fx,
    deprecatedPropType: FI,
    isMuiElement: zg,
    ownerDocument: js,
    ownerWindow: Yh,
    requirePropFactory: BI,
    setRef: W_,
    unstable_ClassNameGenerator: sA,
    unstable_useEnhancedEffect: gl,
    unstable_useId: yv,
    unsupportedProp: NI,
    useControlled: uy,
    useEventCallback: dl,
    useForkRef: ki,
    useIsFocusVisible: dy
}, Symbol.toStringTag, {
    value: "Module"
}));
var b0 = {
    exports: {}
}
  , Wn = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iw;
function lA() {
    if (iw)
        return Wn;
    iw = 1;
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), u = Symbol.for("react.profiler"), d = Symbol.for("react.provider"), f = Symbol.for("react.context"), o = Symbol.for("react.server_context"), w = Symbol.for("react.forward_ref"), T = Symbol.for("react.suspense"), k = Symbol.for("react.suspense_list"), L = Symbol.for("react.memo"), z = Symbol.for("react.lazy"), D = Symbol.for("react.offscreen"), N;
    N = Symbol.for("react.module.reference");
    function U(V) {
        if (typeof V == "object" && V !== null) {
            var re = V.$$typeof;
            switch (re) {
            case e:
                switch (V = V.type,
                V) {
                case i:
                case u:
                case s:
                case T:
                case k:
                    return V;
                default:
                    switch (V = V && V.$$typeof,
                    V) {
                    case o:
                    case f:
                    case w:
                    case z:
                    case L:
                    case d:
                        return V;
                    default:
                        return re
                    }
                }
            case t:
                return re
            }
        }
    }
    return Wn.ContextConsumer = f,
    Wn.ContextProvider = d,
    Wn.Element = e,
    Wn.ForwardRef = w,
    Wn.Fragment = i,
    Wn.Lazy = z,
    Wn.Memo = L,
    Wn.Portal = t,
    Wn.Profiler = u,
    Wn.StrictMode = s,
    Wn.Suspense = T,
    Wn.SuspenseList = k,
    Wn.isAsyncMode = function() {
        return !1
    }
    ,
    Wn.isConcurrentMode = function() {
        return !1
    }
    ,
    Wn.isContextConsumer = function(V) {
        return U(V) === f
    }
    ,
    Wn.isContextProvider = function(V) {
        return U(V) === d
    }
    ,
    Wn.isElement = function(V) {
        return typeof V == "object" && V !== null && V.$$typeof === e
    }
    ,
    Wn.isForwardRef = function(V) {
        return U(V) === w
    }
    ,
    Wn.isFragment = function(V) {
        return U(V) === i
    }
    ,
    Wn.isLazy = function(V) {
        return U(V) === z
    }
    ,
    Wn.isMemo = function(V) {
        return U(V) === L
    }
    ,
    Wn.isPortal = function(V) {
        return U(V) === t
    }
    ,
    Wn.isProfiler = function(V) {
        return U(V) === u
    }
    ,
    Wn.isStrictMode = function(V) {
        return U(V) === s
    }
    ,
    Wn.isSuspense = function(V) {
        return U(V) === T
    }
    ,
    Wn.isSuspenseList = function(V) {
        return U(V) === k
    }
    ,
    Wn.isValidElementType = function(V) {
        return typeof V == "string" || typeof V == "function" || V === i || V === u || V === s || V === T || V === k || V === D || typeof V == "object" && V !== null && (V.$$typeof === z || V.$$typeof === L || V.$$typeof === d || V.$$typeof === f || V.$$typeof === w || V.$$typeof === N || V.getModuleId !== void 0)
    }
    ,
    Wn.typeOf = U,
    Wn
}
var ow;
function cA() {
    return ow || (ow = 1,
    b0.exports = lA()),
    b0.exports
}
cA();
function ex(e, t) {
    return ex = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, s) {
        return i.__proto__ = s,
        i
    }
    ,
    ex(e, t)
}
function tT(e, t) {
    e.prototype = Object.create(t.prototype),
    e.prototype.constructor = e,
    ex(e, t)
}
var rT = mC();
const Qy = Ni(rT)
  , sw = {
    disabled: !1
}
  , q_ = Ra.createContext(null);
var uA = function(t) {
    return t.scrollTop
}
  , Tg = "unmounted"
  , nf = "exited"
  , of = "entering"
  , Sp = "entered"
  , tx = "exiting"
  , nc = function(e) {
    tT(t, e);
    function t(s, u) {
        var d;
        d = e.call(this, s, u) || this;
        var f = u, o = f && !f.isMounting ? s.enter : s.appear, w;
        return d.appearStatus = null,
        s.in ? o ? (w = nf,
        d.appearStatus = of) : w = Sp : s.unmountOnExit || s.mountOnEnter ? w = Tg : w = nf,
        d.state = {
            status: w
        },
        d.nextCallback = null,
        d
    }
    t.getDerivedStateFromProps = function(u, d) {
        var f = u.in;
        return f && d.status === Tg ? {
            status: nf
        } : null
    }
    ;
    var i = t.prototype;
    return i.componentDidMount = function() {
        this.updateStatus(!0, this.appearStatus)
    }
    ,
    i.componentDidUpdate = function(u) {
        var d = null;
        if (u !== this.props) {
            var f = this.state.status;
            this.props.in ? f !== of && f !== Sp && (d = of) : (f === of || f === Sp) && (d = tx)
        }
        this.updateStatus(!1, d)
    }
    ,
    i.componentWillUnmount = function() {
        this.cancelNextCallback()
    }
    ,
    i.getTimeouts = function() {
        var u = this.props.timeout, d, f, o;
        return d = f = o = u,
        u != null && typeof u != "number" && (d = u.exit,
        f = u.enter,
        o = u.appear !== void 0 ? u.appear : f),
        {
            exit: d,
            enter: f,
            appear: o
        }
    }
    ,
    i.updateStatus = function(u, d) {
        if (u === void 0 && (u = !1),
        d !== null)
            if (this.cancelNextCallback(),
            d === of) {
                if (this.props.unmountOnExit || this.props.mountOnEnter) {
                    var f = this.props.nodeRef ? this.props.nodeRef.current : Qy.findDOMNode(this);
                    f && uA(f)
                }
                this.performEnter(u)
            } else
                this.performExit();
        else
            this.props.unmountOnExit && this.state.status === nf && this.setState({
                status: Tg
            })
    }
    ,
    i.performEnter = function(u) {
        var d = this
          , f = this.props.enter
          , o = this.context ? this.context.isMounting : u
          , w = this.props.nodeRef ? [o] : [Qy.findDOMNode(this), o]
          , T = w[0]
          , k = w[1]
          , L = this.getTimeouts()
          , z = o ? L.appear : L.enter;
        if (!u && !f || sw.disabled) {
            this.safeSetState({
                status: Sp
            }, function() {
                d.props.onEntered(T)
            });
            return
        }
        this.props.onEnter(T, k),
        this.safeSetState({
            status: of
        }, function() {
            d.props.onEntering(T, k),
            d.onTransitionEnd(z, function() {
                d.safeSetState({
                    status: Sp
                }, function() {
                    d.props.onEntered(T, k)
                })
            })
        })
    }
    ,
    i.performExit = function() {
        var u = this
          , d = this.props.exit
          , f = this.getTimeouts()
          , o = this.props.nodeRef ? void 0 : Qy.findDOMNode(this);
        if (!d || sw.disabled) {
            this.safeSetState({
                status: nf
            }, function() {
                u.props.onExited(o)
            });
            return
        }
        this.props.onExit(o),
        this.safeSetState({
            status: tx
        }, function() {
            u.props.onExiting(o),
            u.onTransitionEnd(f.exit, function() {
                u.safeSetState({
                    status: nf
                }, function() {
                    u.props.onExited(o)
                })
            })
        })
    }
    ,
    i.cancelNextCallback = function() {
        this.nextCallback !== null && (this.nextCallback.cancel(),
        this.nextCallback = null)
    }
    ,
    i.safeSetState = function(u, d) {
        d = this.setNextCallback(d),
        this.setState(u, d)
    }
    ,
    i.setNextCallback = function(u) {
        var d = this
          , f = !0;
        return this.nextCallback = function(o) {
            f && (f = !1,
            d.nextCallback = null,
            u(o))
        }
        ,
        this.nextCallback.cancel = function() {
            f = !1
        }
        ,
        this.nextCallback
    }
    ,
    i.onTransitionEnd = function(u, d) {
        this.setNextCallback(d);
        var f = this.props.nodeRef ? this.props.nodeRef.current : Qy.findDOMNode(this)
          , o = u == null && !this.props.addEndListener;
        if (!f || o) {
            setTimeout(this.nextCallback, 0);
            return
        }
        if (this.props.addEndListener) {
            var w = this.props.nodeRef ? [this.nextCallback] : [f, this.nextCallback]
              , T = w[0]
              , k = w[1];
            this.props.addEndListener(T, k)
        }
        u != null && setTimeout(this.nextCallback, u)
    }
    ,
    i.render = function() {
        var u = this.state.status;
        if (u === Tg)
            return null;
        var d = this.props
          , f = d.children;
        d.in,
        d.mountOnEnter,
        d.unmountOnExit,
        d.appear,
        d.enter,
        d.exit,
        d.timeout,
        d.addEndListener,
        d.onEnter,
        d.onEntering,
        d.onEntered,
        d.onExit,
        d.onExiting,
        d.onExited,
        d.nodeRef;
        var o = dr(d, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
        return Ra.createElement(q_.Provider, {
            value: null
        }, typeof f == "function" ? f(u, o) : Ra.cloneElement(Ra.Children.only(f), o))
    }
    ,
    t
}(Ra.Component);
nc.contextType = q_;
nc.propTypes = {};
function vp() {}
nc.defaultProps = {
    in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: vp,
    onEntering: vp,
    onEntered: vp,
    onExit: vp,
    onExiting: vp,
    onExited: vp
};
nc.UNMOUNTED = Tg;
nc.EXITED = nf;
nc.ENTERING = of;
nc.ENTERED = Sp;
nc.EXITING = tx;
function hA(e) {
    if (e === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}
function $x(e, t) {
    var i = function(d) {
        return t && Pe.isValidElement(d) ? t(d) : d
    }
      , s = Object.create(null);
    return e && Pe.Children.map(e, function(u) {
        return u
    }).forEach(function(u) {
        s[u.key] = i(u)
    }),
    s
}
function dA(e, t) {
    e = e || {},
    t = t || {};
    function i(k) {
        return k in t ? t[k] : e[k]
    }
    var s = Object.create(null)
      , u = [];
    for (var d in e)
        d in t ? u.length && (s[d] = u,
        u = []) : u.push(d);
    var f, o = {};
    for (var w in t) {
        if (s[w])
            for (f = 0; f < s[w].length; f++) {
                var T = s[w][f];
                o[s[w][f]] = i(T)
            }
        o[w] = i(w)
    }
    for (f = 0; f < u.length; f++)
        o[u[f]] = i(u[f]);
    return o
}
function df(e, t, i) {
    return i[t] != null ? i[t] : e.props[t]
}
function fA(e, t) {
    return $x(e.children, function(i) {
        return Pe.cloneElement(i, {
            onExited: t.bind(null, i),
            in: !0,
            appear: df(i, "appear", e),
            enter: df(i, "enter", e),
            exit: df(i, "exit", e)
        })
    })
}
function pA(e, t, i) {
    var s = $x(e.children)
      , u = dA(t, s);
    return Object.keys(u).forEach(function(d) {
        var f = u[d];
        if (Pe.isValidElement(f)) {
            var o = d in t
              , w = d in s
              , T = t[d]
              , k = Pe.isValidElement(T) && !T.props.in;
            w && (!o || k) ? u[d] = Pe.cloneElement(f, {
                onExited: i.bind(null, f),
                in: !0,
                exit: df(f, "exit", e),
                enter: df(f, "enter", e)
            }) : !w && o && !k ? u[d] = Pe.cloneElement(f, {
                in: !1
            }) : w && o && Pe.isValidElement(T) && (u[d] = Pe.cloneElement(f, {
                onExited: i.bind(null, f),
                in: T.props.in,
                exit: df(f, "exit", e),
                enter: df(f, "enter", e)
            }))
        }
    }),
    u
}
var mA = Object.values || function(e) {
    return Object.keys(e).map(function(t) {
        return e[t]
    })
}
  , gA = {
    component: "div",
    childFactory: function(t) {
        return t
    }
}
  , Vx = function(e) {
    tT(t, e);
    function t(s, u) {
        var d;
        d = e.call(this, s, u) || this;
        var f = d.handleExited.bind(hA(d));
        return d.state = {
            contextValue: {
                isMounting: !0
            },
            handleExited: f,
            firstRender: !0
        },
        d
    }
    var i = t.prototype;
    return i.componentDidMount = function() {
        this.mounted = !0,
        this.setState({
            contextValue: {
                isMounting: !1
            }
        })
    }
    ,
    i.componentWillUnmount = function() {
        this.mounted = !1
    }
    ,
    t.getDerivedStateFromProps = function(u, d) {
        var f = d.children
          , o = d.handleExited
          , w = d.firstRender;
        return {
            children: w ? fA(u, o) : pA(u, f, o),
            firstRender: !1
        }
    }
    ,
    i.handleExited = function(u, d) {
        var f = $x(this.props.children);
        u.key in f || (u.props.onExited && u.props.onExited(d),
        this.mounted && this.setState(function(o) {
            var w = xe({}, o.children);
            return delete w[u.key],
            {
                children: w
            }
        }))
    }
    ,
    i.render = function() {
        var u = this.props
          , d = u.component
          , f = u.childFactory
          , o = dr(u, ["component", "childFactory"])
          , w = this.state.contextValue
          , T = mA(this.state.children).map(f);
        return delete o.appear,
        delete o.enter,
        delete o.exit,
        d === null ? Ra.createElement(q_.Provider, {
            value: w
        }, T) : Ra.createElement(q_.Provider, {
            value: w
        }, Ra.createElement(d, o, T))
    }
    ,
    t
}(Ra.Component);
Vx.propTypes = {};
Vx.defaultProps = gA;
const Ux = e => e.scrollTop;
function Op(e, t) {
    var i, s;
    const {timeout: u, easing: d, style: f={}} = e;
    return {
        duration: (i = f.transitionDuration) != null ? i : typeof u == "number" ? u : u[t.mode] || 0,
        easing: (s = f.transitionTimingFunction) != null ? s : typeof d == "object" ? d[t.mode] : d,
        delay: f.transitionDelay
    }
}
function yA(e) {
    return Kr("MuiPaper", e)
}
Qr("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const _A = ["className", "component", "elevation", "square", "variant"]
  , vA = e => {
    const {square: t, elevation: i, variant: s, classes: u} = e
      , d = {
        root: ["root", s, !t && "rounded", s === "elevation" && `elevation${i}`]
    };
    return Jr(d, yA, u)
}
  , xA = Jt("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, t[i.variant], !i.square && t.rounded, i.variant === "elevation" && t[`elevation${i.elevation}`]]
    }
})( ({theme: e, ownerState: t}) => {
    var i;
    return xe({
        backgroundColor: (e.vars || e).palette.background.paper,
        color: (e.vars || e).palette.text.primary,
        transition: e.transitions.create("box-shadow")
    }, !t.square && {
        borderRadius: e.shape.borderRadius
    }, t.variant === "outlined" && {
        border: `1px solid ${(e.vars || e).palette.divider}`
    }, t.variant === "elevation" && xe({
        boxShadow: (e.vars || e).shadows[t.elevation]
    }, !e.vars && e.palette.mode === "dark" && {
        backgroundImage: `linear-gradient(${Or.alpha("#fff", nw(t.elevation))}, ${Or.alpha("#fff", nw(t.elevation))})`
    }, e.vars && {
        backgroundImage: (i = e.vars.overlays) == null ? void 0 : i[t.elevation]
    }))
}
)
  , fy = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiPaper"
    })
      , {className: u, component: d="div", elevation: f=1, square: o=!1, variant: w="elevation"} = s
      , T = dr(s, _A)
      , k = xe({}, s, {
        component: d,
        elevation: f,
        square: o,
        variant: w
    })
      , L = vA(k);
    return G.jsx(xA, xe({
        as: d,
        ownerState: k,
        className: nr(L.root, u),
        ref: i
    }, T))
})
  , bA = ["className", "elementType", "ownerState", "externalForwardedProps", "getSlotOwnerState", "internalForwardedProps"]
  , wA = ["component", "slots", "slotProps"]
  , SA = ["component"];
function CA(e, t) {
    const {className: i, elementType: s, ownerState: u, externalForwardedProps: d, getSlotOwnerState: f, internalForwardedProps: o} = t
      , w = dr(t, bA)
      , {component: T, slots: k={
        [e]: void 0
    }, slotProps: L={
        [e]: void 0
    }} = d;
    dr(d, wA);
    const z = k[e] || s
      , D = ZC(L[e], u)
      , N = HC(xe({
        className: i
    }, w, {
        externalForwardedProps: void 0,
        externalSlotProps: D
    }))
      , {props: {component: U}, internalRef: V} = N
      , re = dr(N.props, SA)
      , ie = ki(V, D?.ref, t.ref)
      , ue = f ? f(re) : {}
      , ce = xe({}, u, ue)
      , X = U
      , me = Mp(z, xe({}, e === "root", !k[e] && o, re, X && {
        as: X
    }, {
        ref: ie
    }), ce);
    return Object.keys(ue).forEach(K => {
        delete me[K]
    }
    ),
    [z, me]
}
function TA(e) {
    const {className: t, classes: i, pulsate: s=!1, rippleX: u, rippleY: d, rippleSize: f, in: o, onExited: w, timeout: T} = e
      , [k,L] = Pe.useState(!1)
      , z = nr(t, i.ripple, i.rippleVisible, s && i.ripplePulsate)
      , D = {
        width: f,
        height: f,
        top: -(f / 2) + d,
        left: -(f / 2) + u
    }
      , N = nr(i.child, k && i.childLeaving, s && i.childPulsate);
    return !o && !k && L(!0),
    Pe.useEffect( () => {
        if (!o && w != null) {
            const U = setTimeout(w, T);
            return () => {
                clearTimeout(U)
            }
        }
    }
    , [w, o, T]),
    G.jsx("span", {
        className: z,
        style: D,
        children: G.jsx("span", {
            className: N
        })
    })
}
const ul = Qr("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"])
  , PA = ["center", "classes", "className"];
let vv = e => e, aw, lw, cw, uw;
const rx = 550
  , MA = 80
  , kA = cv(aw || (aw = vv`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`))
  , EA = cv(lw || (lw = vv`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`))
  , IA = cv(cw || (cw = vv`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`))
  , RA = Jt("span", {
    name: "MuiTouchRipple",
    slot: "Root"
})({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit"
})
  , AA = Jt(TA, {
    name: "MuiTouchRipple",
    slot: "Ripple"
})(uw || (uw = vv`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), ul.rippleVisible, kA, rx, ({theme: e}) => e.transitions.easing.easeInOut, ul.ripplePulsate, ({theme: e}) => e.transitions.duration.shorter, ul.child, ul.childLeaving, EA, rx, ({theme: e}) => e.transitions.easing.easeInOut, ul.childPulsate, IA, ({theme: e}) => e.transitions.easing.easeInOut)
  , zA = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiTouchRipple"
    })
      , {center: u=!1, classes: d={}, className: f} = s
      , o = dr(s, PA)
      , [w,T] = Pe.useState([])
      , k = Pe.useRef(0)
      , L = Pe.useRef(null);
    Pe.useEffect( () => {
        L.current && (L.current(),
        L.current = null)
    }
    , [w]);
    const z = Pe.useRef(!1)
      , D = Pp()
      , N = Pe.useRef(null)
      , U = Pe.useRef(null)
      , V = Pe.useCallback(ce => {
        const {pulsate: X, rippleX: me, rippleY: K, rippleSize: be, cb: Ee} = ce;
        T(Ce => [...Ce, G.jsx(AA, {
            classes: {
                ripple: nr(d.ripple, ul.ripple),
                rippleVisible: nr(d.rippleVisible, ul.rippleVisible),
                ripplePulsate: nr(d.ripplePulsate, ul.ripplePulsate),
                child: nr(d.child, ul.child),
                childLeaving: nr(d.childLeaving, ul.childLeaving),
                childPulsate: nr(d.childPulsate, ul.childPulsate)
            },
            timeout: rx,
            pulsate: X,
            rippleX: me,
            rippleY: K,
            rippleSize: be
        }, k.current)]),
        k.current += 1,
        L.current = Ee
    }
    , [d])
      , re = Pe.useCallback( (ce={}, X={}, me= () => {}
    ) => {
        const {pulsate: K=!1, center: be=u || X.pulsate, fakeElement: Ee=!1} = X;
        if (ce?.type === "mousedown" && z.current) {
            z.current = !1;
            return
        }
        ce?.type === "touchstart" && (z.current = !0);
        const Ce = Ee ? null : U.current
          , He = Ce ? Ce.getBoundingClientRect() : {
            width: 0,
            height: 0,
            left: 0,
            top: 0
        };
        let ct, nt, J;
        if (be || ce === void 0 || ce.clientX === 0 && ce.clientY === 0 || !ce.clientX && !ce.touches)
            ct = Math.round(He.width / 2),
            nt = Math.round(He.height / 2);
        else {
            const {clientX: he, clientY: ve} = ce.touches && ce.touches.length > 0 ? ce.touches[0] : ce;
            ct = Math.round(he - He.left),
            nt = Math.round(ve - He.top)
        }
        if (be)
            J = Math.sqrt((2 * He.width ** 2 + He.height ** 2) / 3),
            J % 2 === 0 && (J += 1);
        else {
            const he = Math.max(Math.abs((Ce ? Ce.clientWidth : 0) - ct), ct) * 2 + 2
              , ve = Math.max(Math.abs((Ce ? Ce.clientHeight : 0) - nt), nt) * 2 + 2;
            J = Math.sqrt(he ** 2 + ve ** 2)
        }
        ce != null && ce.touches ? N.current === null && (N.current = () => {
            V({
                pulsate: K,
                rippleX: ct,
                rippleY: nt,
                rippleSize: J,
                cb: me
            })
        }
        ,
        D.start(MA, () => {
            N.current && (N.current(),
            N.current = null)
        }
        )) : V({
            pulsate: K,
            rippleX: ct,
            rippleY: nt,
            rippleSize: J,
            cb: me
        })
    }
    , [u, V, D])
      , ie = Pe.useCallback( () => {
        re({}, {
            pulsate: !0
        })
    }
    , [re])
      , ue = Pe.useCallback( (ce, X) => {
        if (D.clear(),
        ce?.type === "touchend" && N.current) {
            N.current(),
            N.current = null,
            D.start(0, () => {
                ue(ce, X)
            }
            );
            return
        }
        N.current = null,
        T(me => me.length > 0 ? me.slice(1) : me),
        L.current = X
    }
    , [D]);
    return Pe.useImperativeHandle(i, () => ({
        pulsate: ie,
        start: re,
        stop: ue
    }), [ie, re, ue]),
    G.jsx(RA, xe({
        className: nr(ul.root, d.root, f),
        ref: U
    }, o, {
        children: G.jsx(Vx, {
            component: null,
            exit: !0,
            children: w
        })
    }))
});
function DA(e) {
    return Kr("MuiButtonBase", e)
}
const LA = Qr("MuiButtonBase", ["root", "disabled", "focusVisible"])
  , OA = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"]
  , FA = e => {
    const {disabled: t, focusVisible: i, focusVisibleClassName: s, classes: u} = e
      , f = Jr({
        root: ["root", t && "disabled", i && "focusVisible"]
    }, DA, u);
    return i && s && (f.root += ` ${s}`),
    f
}
  , BA = Jt("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    outline: 0,
    border: 0,
    margin: 0,
    borderRadius: 0,
    padding: 0,
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    WebkitAppearance: "none",
    textDecoration: "none",
    color: "inherit",
    "&::-moz-focus-inner": {
        borderStyle: "none"
    },
    [`&.${LA.disabled}`]: {
        pointerEvents: "none",
        cursor: "default"
    },
    "@media print": {
        colorAdjust: "exact"
    }
})
  , Kh = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiButtonBase"
    })
      , {action: u, centerRipple: d=!1, children: f, className: o, component: w="button", disabled: T=!1, disableRipple: k=!1, disableTouchRipple: L=!1, focusRipple: z=!1, LinkComponent: D="a", onBlur: N, onClick: U, onContextMenu: V, onDragLeave: re, onFocus: ie, onFocusVisible: ue, onKeyDown: ce, onKeyUp: X, onMouseDown: me, onMouseLeave: K, onMouseUp: be, onTouchEnd: Ee, onTouchMove: Ce, onTouchStart: He, tabIndex: ct=0, TouchRippleProps: nt, touchRippleRef: J, type: he} = s
      , ve = dr(s, OA)
      , Ne = Pe.useRef(null)
      , je = Pe.useRef(null)
      , lt = ki(je, J)
      , {isFocusVisibleRef: Pt, onFocus: We, onBlur: st, ref: Nt} = dy()
      , [zt,Qt] = Pe.useState(!1);
    T && zt && Qt(!1),
    Pe.useImperativeHandle(u, () => ({
        focusVisible: () => {
            Qt(!0),
            Ne.current.focus()
        }
    }), []);
    const [Wt,tr] = Pe.useState(!1);
    Pe.useEffect( () => {
        tr(!0)
    }
    , []);
    const cr = Wt && !k && !T;
    Pe.useEffect( () => {
        zt && z && !k && Wt && je.current.pulsate()
    }
    , [k, z, zt, Wt]);
    function Yt(kt, er, Er=L) {
        return dl(Ue => (er && er(Ue),
        !Er && je.current && je.current[kt](Ue),
        !0))
    }
    const Gr = Yt("start", me)
      , xr = Yt("stop", V)
      , Nr = Yt("stop", re)
      , ur = Yt("stop", be)
      , vr = Yt("stop", kt => {
        zt && kt.preventDefault(),
        K && K(kt)
    }
    )
      , gr = Yt("start", He)
      , hn = Yt("stop", Ee)
      , Zr = Yt("stop", Ce)
      , $r = Yt("stop", kt => {
        st(kt),
        Pt.current === !1 && Qt(!1),
        N && N(kt)
    }
    , !1)
      , gn = dl(kt => {
        Ne.current || (Ne.current = kt.currentTarget),
        We(kt),
        Pt.current === !0 && (Qt(!0),
        ue && ue(kt)),
        ie && ie(kt)
    }
    )
      , zr = () => {
        const kt = Ne.current;
        return w && w !== "button" && !(kt.tagName === "A" && kt.href)
    }
      , Wr = Pe.useRef(!1)
      , $n = dl(kt => {
        z && !Wr.current && zt && je.current && kt.key === " " && (Wr.current = !0,
        je.current.stop(kt, () => {
            je.current.start(kt)
        }
        )),
        kt.target === kt.currentTarget && zr() && kt.key === " " && kt.preventDefault(),
        ce && ce(kt),
        kt.target === kt.currentTarget && zr() && kt.key === "Enter" && !T && (kt.preventDefault(),
        U && U(kt))
    }
    )
      , Dn = dl(kt => {
        z && kt.key === " " && je.current && zt && !kt.defaultPrevented && (Wr.current = !1,
        je.current.stop(kt, () => {
            je.current.pulsate(kt)
        }
        )),
        X && X(kt),
        U && kt.target === kt.currentTarget && zr() && kt.key === " " && !kt.defaultPrevented && U(kt)
    }
    );
    let yn = w;
    yn === "button" && (ve.href || ve.to) && (yn = D);
    const Tn = {};
    yn === "button" ? (Tn.type = he === void 0 ? "button" : he,
    Tn.disabled = T) : (!ve.href && !ve.to && (Tn.role = "button"),
    T && (Tn["aria-disabled"] = T));
    const bn = ki(i, Nt, Ne)
      , sn = xe({}, s, {
        centerRipple: d,
        component: w,
        disabled: T,
        disableRipple: k,
        disableTouchRipple: L,
        focusRipple: z,
        tabIndex: ct,
        focusVisible: zt
    })
      , Mt = FA(sn);
    return G.jsxs(BA, xe({
        as: yn,
        className: nr(Mt.root, o),
        ownerState: sn,
        onBlur: $r,
        onClick: U,
        onContextMenu: xr,
        onFocus: gn,
        onKeyDown: $n,
        onKeyUp: Dn,
        onMouseDown: Gr,
        onMouseLeave: vr,
        onMouseUp: ur,
        onDragLeave: Nr,
        onTouchEnd: hn,
        onTouchMove: Zr,
        onTouchStart: gr,
        ref: bn,
        tabIndex: T ? -1 : ct,
        type: he
    }, Tn, ve, {
        children: [f, cr ? G.jsx(zA, xe({
            ref: lt,
            center: d
        }, nt)) : null]
    }))
});
function jA(e) {
    return Kr("MuiIconButton", e)
}
const NA = Qr("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"])
  , $A = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"]
  , VA = e => {
    const {classes: t, disabled: i, color: s, edge: u, size: d} = e
      , f = {
        root: ["root", i && "disabled", s !== "default" && `color${Ot(s)}`, u && `edge${Ot(u)}`, `size${Ot(d)}`]
    };
    return Jr(f, jA, t)
}
  , UA = Jt(Kh, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, i.color !== "default" && t[`color${Ot(i.color)}`], i.edge && t[`edge${Ot(i.edge)}`], t[`size${Ot(i.size)}`]]
    }
})( ({theme: e, ownerState: t}) => xe({
    textAlign: "center",
    flex: "0 0 auto",
    fontSize: e.typography.pxToRem(24),
    padding: 8,
    borderRadius: "50%",
    overflow: "visible",
    color: (e.vars || e).palette.action.active,
    transition: e.transitions.create("background-color", {
        duration: e.transitions.duration.shortest
    })
}, !t.disableRipple && {
    "&:hover": {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : Or.alpha(e.palette.action.active, e.palette.action.hoverOpacity),
        "@media (hover: none)": {
            backgroundColor: "transparent"
        }
    }
}, t.edge === "start" && {
    marginLeft: t.size === "small" ? -3 : -12
}, t.edge === "end" && {
    marginRight: t.size === "small" ? -3 : -12
}), ({theme: e, ownerState: t}) => {
    var i;
    const s = (i = (e.vars || e).palette) == null ? void 0 : i[t.color];
    return xe({}, t.color === "inherit" && {
        color: "inherit"
    }, t.color !== "inherit" && t.color !== "default" && xe({
        color: s?.main
    }, !t.disableRipple && {
        "&:hover": xe({}, s && {
            backgroundColor: e.vars ? `rgba(${s.mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Or.alpha(s.main, e.palette.action.hoverOpacity)
        }, {
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        })
    }), t.size === "small" && {
        padding: 5,
        fontSize: e.typography.pxToRem(18)
    }, t.size === "large" && {
        padding: 12,
        fontSize: e.typography.pxToRem(28)
    }, {
        [`&.${NA.disabled}`]: {
            backgroundColor: "transparent",
            color: (e.vars || e).palette.action.disabled
        }
    })
}
)
  , Lg = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiIconButton"
    })
      , {edge: u=!1, children: d, className: f, color: o="default", disabled: w=!1, disableFocusRipple: T=!1, size: k="medium"} = s
      , L = dr(s, $A)
      , z = xe({}, s, {
        edge: u,
        color: o,
        disabled: w,
        disableFocusRipple: T,
        size: k
    })
      , D = VA(z);
    return G.jsx(UA, xe({
        className: nr(D.root, f),
        centerRipple: !0,
        focusRipple: !T,
        disabled: w,
        ref: i
    }, L, {
        ownerState: z,
        children: d
    }))
});
function GA(e) {
    return Kr("MuiTypography", e)
}
Qr("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const WA = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"]
  , qA = e => {
    const {align: t, gutterBottom: i, noWrap: s, paragraph: u, variant: d, classes: f} = e
      , o = {
        root: ["root", d, e.align !== "inherit" && `align${Ot(t)}`, i && "gutterBottom", s && "noWrap", u && "paragraph"]
    };
    return Jr(o, GA, f)
}
  , HA = Jt("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, i.variant && t[i.variant], i.align !== "inherit" && t[`align${Ot(i.align)}`], i.noWrap && t.noWrap, i.gutterBottom && t.gutterBottom, i.paragraph && t.paragraph]
    }
})( ({theme: e, ownerState: t}) => xe({
    margin: 0
}, t.variant === "inherit" && {
    font: "inherit"
}, t.variant !== "inherit" && e.typography[t.variant], t.align !== "inherit" && {
    textAlign: t.align
}, t.noWrap && {
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
}, t.gutterBottom && {
    marginBottom: "0.35em"
}, t.paragraph && {
    marginBottom: 16
}))
  , hw = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p"
}
  , ZA = {
    primary: "primary.main",
    textPrimary: "text.primary",
    secondary: "secondary.main",
    textSecondary: "text.secondary",
    error: "error.main"
}
  , XA = e => ZA[e] || e
  , qt = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiTypography"
    })
      , u = XA(s.color)
      , d = gv(xe({}, s, {
        color: u
    }))
      , {align: f="inherit", className: o, component: w, gutterBottom: T=!1, noWrap: k=!1, paragraph: L=!1, variant: z="body1", variantMapping: D=hw} = d
      , N = dr(d, WA)
      , U = xe({}, d, {
        align: f,
        color: u,
        className: o,
        component: w,
        gutterBottom: T,
        noWrap: k,
        paragraph: L,
        variant: z,
        variantMapping: D
    })
      , V = w || (L ? "p" : D[z] || hw[z]) || "span"
      , re = qA(U);
    return G.jsx(HA, xe({
        as: V,
        ref: i,
        ownerState: U,
        className: nr(re.root, o)
    }, N))
});
var Vm = {}, dw;
function YA() {
    if (dw)
        return Vm;
    dw = 1,
    Object.defineProperty(Vm, "__esModule", {
        value: !0
    }),
    Vm.default = void 0;
    var e = s(iy())
      , t = eT;
    function i(f) {
        if (typeof WeakMap != "function")
            return null;
        var o = new WeakMap
          , w = new WeakMap;
        return (i = function(T) {
            return T ? w : o
        }
        )(f)
    }
    function s(f, o) {
        if (f && f.__esModule)
            return f;
        if (f === null || typeof f != "object" && typeof f != "function")
            return {
                default: f
            };
        var w = i(o);
        if (w && w.has(f))
            return w.get(f);
        var T = {
            __proto__: null
        }
          , k = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var L in f)
            if (L !== "default" && Object.prototype.hasOwnProperty.call(f, L)) {
                var z = k ? Object.getOwnPropertyDescriptor(f, L) : null;
                z && (z.get || z.set) ? Object.defineProperty(T, L, z) : T[L] = f[L]
            }
        return T.default = f,
        w && w.set(f, T),
        T
    }
    function u(f) {
        return Object.keys(f).length === 0
    }
    function d(f=null) {
        const o = e.useContext(t.ThemeContext);
        return !o || u(o) ? f : o
    }
    return Vm.default = d,
    Vm
}
var KA = YA();
const QA = Ni(KA);
var ra = "top"
  , yl = "bottom"
  , _l = "right"
  , na = "left"
  , Gx = "auto"
  , py = [ra, yl, _l, na]
  , Fp = "start"
  , Xg = "end"
  , JA = "clippingParents"
  , nT = "viewport"
  , Um = "popper"
  , ez = "reference"
  , fw = py.reduce(function(e, t) {
    return e.concat([t + "-" + Fp, t + "-" + Xg])
}, [])
  , iT = [].concat(py, [Gx]).reduce(function(e, t) {
    return e.concat([t, t + "-" + Fp, t + "-" + Xg])
}, [])
  , tz = "beforeRead"
  , rz = "read"
  , nz = "afterRead"
  , iz = "beforeMain"
  , oz = "main"
  , sz = "afterMain"
  , az = "beforeWrite"
  , lz = "write"
  , cz = "afterWrite"
  , uz = [tz, rz, nz, iz, oz, sz, az, lz, cz];
function nu(e) {
    return e ? (e.nodeName || "").toLowerCase() : null
}
function za(e) {
    if (e == null)
        return window;
    if (e.toString() !== "[object Window]") {
        var t = e.ownerDocument;
        return t && t.defaultView || window
    }
    return e
}
function _f(e) {
    var t = za(e).Element;
    return e instanceof t || e instanceof Element
}
function ml(e) {
    var t = za(e).HTMLElement;
    return e instanceof t || e instanceof HTMLElement
}
function Wx(e) {
    if (typeof ShadowRoot > "u")
        return !1;
    var t = za(e).ShadowRoot;
    return e instanceof t || e instanceof ShadowRoot
}
function hz(e) {
    var t = e.state;
    Object.keys(t.elements).forEach(function(i) {
        var s = t.styles[i] || {}
          , u = t.attributes[i] || {}
          , d = t.elements[i];
        !ml(d) || !nu(d) || (Object.assign(d.style, s),
        Object.keys(u).forEach(function(f) {
            var o = u[f];
            o === !1 ? d.removeAttribute(f) : d.setAttribute(f, o === !0 ? "" : o)
        }))
    })
}
function dz(e) {
    var t = e.state
      , i = {
        popper: {
            position: t.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
        },
        arrow: {
            position: "absolute"
        },
        reference: {}
    };
    return Object.assign(t.elements.popper.style, i.popper),
    t.styles = i,
    t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow),
    function() {
        Object.keys(t.elements).forEach(function(s) {
            var u = t.elements[s]
              , d = t.attributes[s] || {}
              , f = Object.keys(t.styles.hasOwnProperty(s) ? t.styles[s] : i[s])
              , o = f.reduce(function(w, T) {
                return w[T] = "",
                w
            }, {});
            !ml(u) || !nu(u) || (Object.assign(u.style, o),
            Object.keys(d).forEach(function(w) {
                u.removeAttribute(w)
            }))
        })
    }
}
const fz = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: hz,
    effect: dz,
    requires: ["computeStyles"]
};
function tu(e) {
    return e.split("-")[0]
}
var pf = Math.max
  , H_ = Math.min
  , Bp = Math.round;
function nx() {
    var e = navigator.userAgentData;
    return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
        return t.brand + "/" + t.version
    }).join(" ") : navigator.userAgent
}
function oT() {
    return !/^((?!chrome|android).)*safari/i.test(nx())
}
function jp(e, t, i) {
    t === void 0 && (t = !1),
    i === void 0 && (i = !1);
    var s = e.getBoundingClientRect()
      , u = 1
      , d = 1;
    t && ml(e) && (u = e.offsetWidth > 0 && Bp(s.width) / e.offsetWidth || 1,
    d = e.offsetHeight > 0 && Bp(s.height) / e.offsetHeight || 1);
    var f = _f(e) ? za(e) : window
      , o = f.visualViewport
      , w = !oT() && i
      , T = (s.left + (w && o ? o.offsetLeft : 0)) / u
      , k = (s.top + (w && o ? o.offsetTop : 0)) / d
      , L = s.width / u
      , z = s.height / d;
    return {
        width: L,
        height: z,
        top: k,
        right: T + L,
        bottom: k + z,
        left: T,
        x: T,
        y: k
    }
}
function qx(e) {
    var t = jp(e)
      , i = e.offsetWidth
      , s = e.offsetHeight;
    return Math.abs(t.width - i) <= 1 && (i = t.width),
    Math.abs(t.height - s) <= 1 && (s = t.height),
    {
        x: e.offsetLeft,
        y: e.offsetTop,
        width: i,
        height: s
    }
}
function sT(e, t) {
    var i = t.getRootNode && t.getRootNode();
    if (e.contains(t))
        return !0;
    if (i && Wx(i)) {
        var s = t;
        do {
            if (s && e.isSameNode(s))
                return !0;
            s = s.parentNode || s.host
        } while (s)
    }
    return !1
}
function lh(e) {
    return za(e).getComputedStyle(e)
}
function pz(e) {
    return ["table", "td", "th"].indexOf(nu(e)) >= 0
}
function td(e) {
    return ((_f(e) ? e.ownerDocument : e.document) || window.document).documentElement
}
function xv(e) {
    return nu(e) === "html" ? e : e.assignedSlot || e.parentNode || (Wx(e) ? e.host : null) || td(e)
}
function pw(e) {
    return !ml(e) || lh(e).position === "fixed" ? null : e.offsetParent
}
function mz(e) {
    var t = /firefox/i.test(nx())
      , i = /Trident/i.test(nx());
    if (i && ml(e)) {
        var s = lh(e);
        if (s.position === "fixed")
            return null
    }
    var u = xv(e);
    for (Wx(u) && (u = u.host); ml(u) && ["html", "body"].indexOf(nu(u)) < 0; ) {
        var d = lh(u);
        if (d.transform !== "none" || d.perspective !== "none" || d.contain === "paint" || ["transform", "perspective"].indexOf(d.willChange) !== -1 || t && d.willChange === "filter" || t && d.filter && d.filter !== "none")
            return u;
        u = u.parentNode
    }
    return null
}
function my(e) {
    for (var t = za(e), i = pw(e); i && pz(i) && lh(i).position === "static"; )
        i = pw(i);
    return i && (nu(i) === "html" || nu(i) === "body" && lh(i).position === "static") ? t : i || mz(e) || t
}
function Hx(e) {
    return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
}
function Og(e, t, i) {
    return pf(e, H_(t, i))
}
function gz(e, t, i) {
    var s = Og(e, t, i);
    return s > i ? i : s
}
function aT() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}
function lT(e) {
    return Object.assign({}, aT(), e)
}
function cT(e, t) {
    return t.reduce(function(i, s) {
        return i[s] = e,
        i
    }, {})
}
var yz = function(t, i) {
    return t = typeof t == "function" ? t(Object.assign({}, i.rects, {
        placement: i.placement
    })) : t,
    lT(typeof t != "number" ? t : cT(t, py))
};
function _z(e) {
    var t, i = e.state, s = e.name, u = e.options, d = i.elements.arrow, f = i.modifiersData.popperOffsets, o = tu(i.placement), w = Hx(o), T = [na, _l].indexOf(o) >= 0, k = T ? "height" : "width";
    if (!(!d || !f)) {
        var L = yz(u.padding, i)
          , z = qx(d)
          , D = w === "y" ? ra : na
          , N = w === "y" ? yl : _l
          , U = i.rects.reference[k] + i.rects.reference[w] - f[w] - i.rects.popper[k]
          , V = f[w] - i.rects.reference[w]
          , re = my(d)
          , ie = re ? w === "y" ? re.clientHeight || 0 : re.clientWidth || 0 : 0
          , ue = U / 2 - V / 2
          , ce = L[D]
          , X = ie - z[k] - L[N]
          , me = ie / 2 - z[k] / 2 + ue
          , K = Og(ce, me, X)
          , be = w;
        i.modifiersData[s] = (t = {},
        t[be] = K,
        t.centerOffset = K - me,
        t)
    }
}
function vz(e) {
    var t = e.state
      , i = e.options
      , s = i.element
      , u = s === void 0 ? "[data-popper-arrow]" : s;
    u != null && (typeof u == "string" && (u = t.elements.popper.querySelector(u),
    !u) || sT(t.elements.popper, u) && (t.elements.arrow = u))
}
const xz = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: _z,
    effect: vz,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};
function Np(e) {
    return e.split("-")[1]
}
var bz = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};
function wz(e, t) {
    var i = e.x
      , s = e.y
      , u = t.devicePixelRatio || 1;
    return {
        x: Bp(i * u) / u || 0,
        y: Bp(s * u) / u || 0
    }
}
function mw(e) {
    var t, i = e.popper, s = e.popperRect, u = e.placement, d = e.variation, f = e.offsets, o = e.position, w = e.gpuAcceleration, T = e.adaptive, k = e.roundOffsets, L = e.isFixed, z = f.x, D = z === void 0 ? 0 : z, N = f.y, U = N === void 0 ? 0 : N, V = typeof k == "function" ? k({
        x: D,
        y: U
    }) : {
        x: D,
        y: U
    };
    D = V.x,
    U = V.y;
    var re = f.hasOwnProperty("x")
      , ie = f.hasOwnProperty("y")
      , ue = na
      , ce = ra
      , X = window;
    if (T) {
        var me = my(i)
          , K = "clientHeight"
          , be = "clientWidth";
        if (me === za(i) && (me = td(i),
        lh(me).position !== "static" && o === "absolute" && (K = "scrollHeight",
        be = "scrollWidth")),
        me = me,
        u === ra || (u === na || u === _l) && d === Xg) {
            ce = yl;
            var Ee = L && me === X && X.visualViewport ? X.visualViewport.height : me[K];
            U -= Ee - s.height,
            U *= w ? 1 : -1
        }
        if (u === na || (u === ra || u === yl) && d === Xg) {
            ue = _l;
            var Ce = L && me === X && X.visualViewport ? X.visualViewport.width : me[be];
            D -= Ce - s.width,
            D *= w ? 1 : -1
        }
    }
    var He = Object.assign({
        position: o
    }, T && bz)
      , ct = k === !0 ? wz({
        x: D,
        y: U
    }, za(i)) : {
        x: D,
        y: U
    };
    if (D = ct.x,
    U = ct.y,
    w) {
        var nt;
        return Object.assign({}, He, (nt = {},
        nt[ce] = ie ? "0" : "",
        nt[ue] = re ? "0" : "",
        nt.transform = (X.devicePixelRatio || 1) <= 1 ? "translate(" + D + "px, " + U + "px)" : "translate3d(" + D + "px, " + U + "px, 0)",
        nt))
    }
    return Object.assign({}, He, (t = {},
    t[ce] = ie ? U + "px" : "",
    t[ue] = re ? D + "px" : "",
    t.transform = "",
    t))
}
function Sz(e) {
    var t = e.state
      , i = e.options
      , s = i.gpuAcceleration
      , u = s === void 0 ? !0 : s
      , d = i.adaptive
      , f = d === void 0 ? !0 : d
      , o = i.roundOffsets
      , w = o === void 0 ? !0 : o
      , T = {
        placement: tu(t.placement),
        variation: Np(t.placement),
        popper: t.elements.popper,
        popperRect: t.rects.popper,
        gpuAcceleration: u,
        isFixed: t.options.strategy === "fixed"
    };
    t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, mw(Object.assign({}, T, {
        offsets: t.modifiersData.popperOffsets,
        position: t.options.strategy,
        adaptive: f,
        roundOffsets: w
    })))),
    t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, mw(Object.assign({}, T, {
        offsets: t.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: w
    })))),
    t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-placement": t.placement
    })
}
const Cz = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: Sz,
    data: {}
};
var Jy = {
    passive: !0
};
function Tz(e) {
    var t = e.state
      , i = e.instance
      , s = e.options
      , u = s.scroll
      , d = u === void 0 ? !0 : u
      , f = s.resize
      , o = f === void 0 ? !0 : f
      , w = za(t.elements.popper)
      , T = [].concat(t.scrollParents.reference, t.scrollParents.popper);
    return d && T.forEach(function(k) {
        k.addEventListener("scroll", i.update, Jy)
    }),
    o && w.addEventListener("resize", i.update, Jy),
    function() {
        d && T.forEach(function(k) {
            k.removeEventListener("scroll", i.update, Jy)
        }),
        o && w.removeEventListener("resize", i.update, Jy)
    }
}
const Pz = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function() {},
    effect: Tz,
    data: {}
};
var Mz = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function O_(e) {
    return e.replace(/left|right|bottom|top/g, function(t) {
        return Mz[t]
    })
}
var kz = {
    start: "end",
    end: "start"
};
function gw(e) {
    return e.replace(/start|end/g, function(t) {
        return kz[t]
    })
}
function Zx(e) {
    var t = za(e)
      , i = t.pageXOffset
      , s = t.pageYOffset;
    return {
        scrollLeft: i,
        scrollTop: s
    }
}
function Xx(e) {
    return jp(td(e)).left + Zx(e).scrollLeft
}
function Ez(e, t) {
    var i = za(e)
      , s = td(e)
      , u = i.visualViewport
      , d = s.clientWidth
      , f = s.clientHeight
      , o = 0
      , w = 0;
    if (u) {
        d = u.width,
        f = u.height;
        var T = oT();
        (T || !T && t === "fixed") && (o = u.offsetLeft,
        w = u.offsetTop)
    }
    return {
        width: d,
        height: f,
        x: o + Xx(e),
        y: w
    }
}
function Iz(e) {
    var t, i = td(e), s = Zx(e), u = (t = e.ownerDocument) == null ? void 0 : t.body, d = pf(i.scrollWidth, i.clientWidth, u ? u.scrollWidth : 0, u ? u.clientWidth : 0), f = pf(i.scrollHeight, i.clientHeight, u ? u.scrollHeight : 0, u ? u.clientHeight : 0), o = -s.scrollLeft + Xx(e), w = -s.scrollTop;
    return lh(u || i).direction === "rtl" && (o += pf(i.clientWidth, u ? u.clientWidth : 0) - d),
    {
        width: d,
        height: f,
        x: o,
        y: w
    }
}
function Yx(e) {
    var t = lh(e)
      , i = t.overflow
      , s = t.overflowX
      , u = t.overflowY;
    return /auto|scroll|overlay|hidden/.test(i + u + s)
}
function uT(e) {
    return ["html", "body", "#document"].indexOf(nu(e)) >= 0 ? e.ownerDocument.body : ml(e) && Yx(e) ? e : uT(xv(e))
}
function Fg(e, t) {
    var i;
    t === void 0 && (t = []);
    var s = uT(e)
      , u = s === ((i = e.ownerDocument) == null ? void 0 : i.body)
      , d = za(s)
      , f = u ? [d].concat(d.visualViewport || [], Yx(s) ? s : []) : s
      , o = t.concat(f);
    return u ? o : o.concat(Fg(xv(f)))
}
function ix(e) {
    return Object.assign({}, e, {
        left: e.x,
        top: e.y,
        right: e.x + e.width,
        bottom: e.y + e.height
    })
}
function Rz(e, t) {
    var i = jp(e, !1, t === "fixed");
    return i.top = i.top + e.clientTop,
    i.left = i.left + e.clientLeft,
    i.bottom = i.top + e.clientHeight,
    i.right = i.left + e.clientWidth,
    i.width = e.clientWidth,
    i.height = e.clientHeight,
    i.x = i.left,
    i.y = i.top,
    i
}
function yw(e, t, i) {
    return t === nT ? ix(Ez(e, i)) : _f(t) ? Rz(t, i) : ix(Iz(td(e)))
}
function Az(e) {
    var t = Fg(xv(e))
      , i = ["absolute", "fixed"].indexOf(lh(e).position) >= 0
      , s = i && ml(e) ? my(e) : e;
    return _f(s) ? t.filter(function(u) {
        return _f(u) && sT(u, s) && nu(u) !== "body"
    }) : []
}
function zz(e, t, i, s) {
    var u = t === "clippingParents" ? Az(e) : [].concat(t)
      , d = [].concat(u, [i])
      , f = d[0]
      , o = d.reduce(function(w, T) {
        var k = yw(e, T, s);
        return w.top = pf(k.top, w.top),
        w.right = H_(k.right, w.right),
        w.bottom = H_(k.bottom, w.bottom),
        w.left = pf(k.left, w.left),
        w
    }, yw(e, f, s));
    return o.width = o.right - o.left,
    o.height = o.bottom - o.top,
    o.x = o.left,
    o.y = o.top,
    o
}
function hT(e) {
    var t = e.reference, i = e.element, s = e.placement, u = s ? tu(s) : null, d = s ? Np(s) : null, f = t.x + t.width / 2 - i.width / 2, o = t.y + t.height / 2 - i.height / 2, w;
    switch (u) {
    case ra:
        w = {
            x: f,
            y: t.y - i.height
        };
        break;
    case yl:
        w = {
            x: f,
            y: t.y + t.height
        };
        break;
    case _l:
        w = {
            x: t.x + t.width,
            y: o
        };
        break;
    case na:
        w = {
            x: t.x - i.width,
            y: o
        };
        break;
    default:
        w = {
            x: t.x,
            y: t.y
        }
    }
    var T = u ? Hx(u) : null;
    if (T != null) {
        var k = T === "y" ? "height" : "width";
        switch (d) {
        case Fp:
            w[T] = w[T] - (t[k] / 2 - i[k] / 2);
            break;
        case Xg:
            w[T] = w[T] + (t[k] / 2 - i[k] / 2);
            break
        }
    }
    return w
}
function Yg(e, t) {
    t === void 0 && (t = {});
    var i = t
      , s = i.placement
      , u = s === void 0 ? e.placement : s
      , d = i.strategy
      , f = d === void 0 ? e.strategy : d
      , o = i.boundary
      , w = o === void 0 ? JA : o
      , T = i.rootBoundary
      , k = T === void 0 ? nT : T
      , L = i.elementContext
      , z = L === void 0 ? Um : L
      , D = i.altBoundary
      , N = D === void 0 ? !1 : D
      , U = i.padding
      , V = U === void 0 ? 0 : U
      , re = lT(typeof V != "number" ? V : cT(V, py))
      , ie = z === Um ? ez : Um
      , ue = e.rects.popper
      , ce = e.elements[N ? ie : z]
      , X = zz(_f(ce) ? ce : ce.contextElement || td(e.elements.popper), w, k, f)
      , me = jp(e.elements.reference)
      , K = hT({
        reference: me,
        element: ue,
        placement: u
    })
      , be = ix(Object.assign({}, ue, K))
      , Ee = z === Um ? be : me
      , Ce = {
        top: X.top - Ee.top + re.top,
        bottom: Ee.bottom - X.bottom + re.bottom,
        left: X.left - Ee.left + re.left,
        right: Ee.right - X.right + re.right
    }
      , He = e.modifiersData.offset;
    if (z === Um && He) {
        var ct = He[u];
        Object.keys(Ce).forEach(function(nt) {
            var J = [_l, yl].indexOf(nt) >= 0 ? 1 : -1
              , he = [ra, yl].indexOf(nt) >= 0 ? "y" : "x";
            Ce[nt] += ct[he] * J
        })
    }
    return Ce
}
function Dz(e, t) {
    t === void 0 && (t = {});
    var i = t
      , s = i.placement
      , u = i.boundary
      , d = i.rootBoundary
      , f = i.padding
      , o = i.flipVariations
      , w = i.allowedAutoPlacements
      , T = w === void 0 ? iT : w
      , k = Np(s)
      , L = k ? o ? fw : fw.filter(function(N) {
        return Np(N) === k
    }) : py
      , z = L.filter(function(N) {
        return T.indexOf(N) >= 0
    });
    z.length === 0 && (z = L);
    var D = z.reduce(function(N, U) {
        return N[U] = Yg(e, {
            placement: U,
            boundary: u,
            rootBoundary: d,
            padding: f
        })[tu(U)],
        N
    }, {});
    return Object.keys(D).sort(function(N, U) {
        return D[N] - D[U]
    })
}
function Lz(e) {
    if (tu(e) === Gx)
        return [];
    var t = O_(e);
    return [gw(e), t, gw(t)]
}
function Oz(e) {
    var t = e.state
      , i = e.options
      , s = e.name;
    if (!t.modifiersData[s]._skip) {
        for (var u = i.mainAxis, d = u === void 0 ? !0 : u, f = i.altAxis, o = f === void 0 ? !0 : f, w = i.fallbackPlacements, T = i.padding, k = i.boundary, L = i.rootBoundary, z = i.altBoundary, D = i.flipVariations, N = D === void 0 ? !0 : D, U = i.allowedAutoPlacements, V = t.options.placement, re = tu(V), ie = re === V, ue = w || (ie || !N ? [O_(V)] : Lz(V)), ce = [V].concat(ue).reduce(function(zt, Qt) {
            return zt.concat(tu(Qt) === Gx ? Dz(t, {
                placement: Qt,
                boundary: k,
                rootBoundary: L,
                padding: T,
                flipVariations: N,
                allowedAutoPlacements: U
            }) : Qt)
        }, []), X = t.rects.reference, me = t.rects.popper, K = new Map, be = !0, Ee = ce[0], Ce = 0; Ce < ce.length; Ce++) {
            var He = ce[Ce]
              , ct = tu(He)
              , nt = Np(He) === Fp
              , J = [ra, yl].indexOf(ct) >= 0
              , he = J ? "width" : "height"
              , ve = Yg(t, {
                placement: He,
                boundary: k,
                rootBoundary: L,
                altBoundary: z,
                padding: T
            })
              , Ne = J ? nt ? _l : na : nt ? yl : ra;
            X[he] > me[he] && (Ne = O_(Ne));
            var je = O_(Ne)
              , lt = [];
            if (d && lt.push(ve[ct] <= 0),
            o && lt.push(ve[Ne] <= 0, ve[je] <= 0),
            lt.every(function(zt) {
                return zt
            })) {
                Ee = He,
                be = !1;
                break
            }
            K.set(He, lt)
        }
        if (be)
            for (var Pt = N ? 3 : 1, We = function(Qt) {
                var Wt = ce.find(function(tr) {
                    var cr = K.get(tr);
                    if (cr)
                        return cr.slice(0, Qt).every(function(Yt) {
                            return Yt
                        })
                });
                if (Wt)
                    return Ee = Wt,
                    "break"
            }, st = Pt; st > 0; st--) {
                var Nt = We(st);
                if (Nt === "break")
                    break
            }
        t.placement !== Ee && (t.modifiersData[s]._skip = !0,
        t.placement = Ee,
        t.reset = !0)
    }
}
const Fz = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: Oz,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};
function _w(e, t, i) {
    return i === void 0 && (i = {
        x: 0,
        y: 0
    }),
    {
        top: e.top - t.height - i.y,
        right: e.right - t.width + i.x,
        bottom: e.bottom - t.height + i.y,
        left: e.left - t.width - i.x
    }
}
function vw(e) {
    return [ra, _l, yl, na].some(function(t) {
        return e[t] >= 0
    })
}
function Bz(e) {
    var t = e.state
      , i = e.name
      , s = t.rects.reference
      , u = t.rects.popper
      , d = t.modifiersData.preventOverflow
      , f = Yg(t, {
        elementContext: "reference"
    })
      , o = Yg(t, {
        altBoundary: !0
    })
      , w = _w(f, s)
      , T = _w(o, u, d)
      , k = vw(w)
      , L = vw(T);
    t.modifiersData[i] = {
        referenceClippingOffsets: w,
        popperEscapeOffsets: T,
        isReferenceHidden: k,
        hasPopperEscaped: L
    },
    t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": k,
        "data-popper-escaped": L
    })
}
const jz = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: Bz
};
function Nz(e, t, i) {
    var s = tu(e)
      , u = [na, ra].indexOf(s) >= 0 ? -1 : 1
      , d = typeof i == "function" ? i(Object.assign({}, t, {
        placement: e
    })) : i
      , f = d[0]
      , o = d[1];
    return f = f || 0,
    o = (o || 0) * u,
    [na, _l].indexOf(s) >= 0 ? {
        x: o,
        y: f
    } : {
        x: f,
        y: o
    }
}
function $z(e) {
    var t = e.state
      , i = e.options
      , s = e.name
      , u = i.offset
      , d = u === void 0 ? [0, 0] : u
      , f = iT.reduce(function(k, L) {
        return k[L] = Nz(L, t.rects, d),
        k
    }, {})
      , o = f[t.placement]
      , w = o.x
      , T = o.y;
    t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += w,
    t.modifiersData.popperOffsets.y += T),
    t.modifiersData[s] = f
}
const Vz = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: $z
};
function Uz(e) {
    var t = e.state
      , i = e.name;
    t.modifiersData[i] = hT({
        reference: t.rects.reference,
        element: t.rects.popper,
        placement: t.placement
    })
}
const Gz = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: Uz,
    data: {}
};
function Wz(e) {
    return e === "x" ? "y" : "x"
}
function qz(e) {
    var t = e.state
      , i = e.options
      , s = e.name
      , u = i.mainAxis
      , d = u === void 0 ? !0 : u
      , f = i.altAxis
      , o = f === void 0 ? !1 : f
      , w = i.boundary
      , T = i.rootBoundary
      , k = i.altBoundary
      , L = i.padding
      , z = i.tether
      , D = z === void 0 ? !0 : z
      , N = i.tetherOffset
      , U = N === void 0 ? 0 : N
      , V = Yg(t, {
        boundary: w,
        rootBoundary: T,
        padding: L,
        altBoundary: k
    })
      , re = tu(t.placement)
      , ie = Np(t.placement)
      , ue = !ie
      , ce = Hx(re)
      , X = Wz(ce)
      , me = t.modifiersData.popperOffsets
      , K = t.rects.reference
      , be = t.rects.popper
      , Ee = typeof U == "function" ? U(Object.assign({}, t.rects, {
        placement: t.placement
    })) : U
      , Ce = typeof Ee == "number" ? {
        mainAxis: Ee,
        altAxis: Ee
    } : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, Ee)
      , He = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null
      , ct = {
        x: 0,
        y: 0
    };
    if (me) {
        if (d) {
            var nt, J = ce === "y" ? ra : na, he = ce === "y" ? yl : _l, ve = ce === "y" ? "height" : "width", Ne = me[ce], je = Ne + V[J], lt = Ne - V[he], Pt = D ? -be[ve] / 2 : 0, We = ie === Fp ? K[ve] : be[ve], st = ie === Fp ? -be[ve] : -K[ve], Nt = t.elements.arrow, zt = D && Nt ? qx(Nt) : {
                width: 0,
                height: 0
            }, Qt = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : aT(), Wt = Qt[J], tr = Qt[he], cr = Og(0, K[ve], zt[ve]), Yt = ue ? K[ve] / 2 - Pt - cr - Wt - Ce.mainAxis : We - cr - Wt - Ce.mainAxis, Gr = ue ? -K[ve] / 2 + Pt + cr + tr + Ce.mainAxis : st + cr + tr + Ce.mainAxis, xr = t.elements.arrow && my(t.elements.arrow), Nr = xr ? ce === "y" ? xr.clientTop || 0 : xr.clientLeft || 0 : 0, ur = (nt = He?.[ce]) != null ? nt : 0, vr = Ne + Yt - ur - Nr, gr = Ne + Gr - ur, hn = Og(D ? H_(je, vr) : je, Ne, D ? pf(lt, gr) : lt);
            me[ce] = hn,
            ct[ce] = hn - Ne
        }
        if (o) {
            var Zr, $r = ce === "x" ? ra : na, gn = ce === "x" ? yl : _l, zr = me[X], Wr = X === "y" ? "height" : "width", $n = zr + V[$r], Dn = zr - V[gn], yn = [ra, na].indexOf(re) !== -1, Tn = (Zr = He?.[X]) != null ? Zr : 0, bn = yn ? $n : zr - K[Wr] - be[Wr] - Tn + Ce.altAxis, sn = yn ? zr + K[Wr] + be[Wr] - Tn - Ce.altAxis : Dn, Mt = D && yn ? gz(bn, zr, sn) : Og(D ? bn : $n, zr, D ? sn : Dn);
            me[X] = Mt,
            ct[X] = Mt - zr
        }
        t.modifiersData[s] = ct
    }
}
const Hz = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: qz,
    requiresIfExists: ["offset"]
};
function Zz(e) {
    return {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
    }
}
function Xz(e) {
    return e === za(e) || !ml(e) ? Zx(e) : Zz(e)
}
function Yz(e) {
    var t = e.getBoundingClientRect()
      , i = Bp(t.width) / e.offsetWidth || 1
      , s = Bp(t.height) / e.offsetHeight || 1;
    return i !== 1 || s !== 1
}
function Kz(e, t, i) {
    i === void 0 && (i = !1);
    var s = ml(t)
      , u = ml(t) && Yz(t)
      , d = td(t)
      , f = jp(e, u, i)
      , o = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , w = {
        x: 0,
        y: 0
    };
    return (s || !s && !i) && ((nu(t) !== "body" || Yx(d)) && (o = Xz(t)),
    ml(t) ? (w = jp(t, !0),
    w.x += t.clientLeft,
    w.y += t.clientTop) : d && (w.x = Xx(d))),
    {
        x: f.left + o.scrollLeft - w.x,
        y: f.top + o.scrollTop - w.y,
        width: f.width,
        height: f.height
    }
}
function Qz(e) {
    var t = new Map
      , i = new Set
      , s = [];
    e.forEach(function(d) {
        t.set(d.name, d)
    });
    function u(d) {
        i.add(d.name);
        var f = [].concat(d.requires || [], d.requiresIfExists || []);
        f.forEach(function(o) {
            if (!i.has(o)) {
                var w = t.get(o);
                w && u(w)
            }
        }),
        s.push(d)
    }
    return e.forEach(function(d) {
        i.has(d.name) || u(d)
    }),
    s
}
function Jz(e) {
    var t = Qz(e);
    return uz.reduce(function(i, s) {
        return i.concat(t.filter(function(u) {
            return u.phase === s
        }))
    }, [])
}
function eD(e) {
    var t;
    return function() {
        return t || (t = new Promise(function(i) {
            Promise.resolve().then(function() {
                t = void 0,
                i(e())
            })
        }
        )),
        t
    }
}
function tD(e) {
    var t = e.reduce(function(i, s) {
        var u = i[s.name];
        return i[s.name] = u ? Object.assign({}, u, s, {
            options: Object.assign({}, u.options, s.options),
            data: Object.assign({}, u.data, s.data)
        }) : s,
        i
    }, {});
    return Object.keys(t).map(function(i) {
        return t[i]
    })
}
var xw = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function bw() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
    return !t.some(function(s) {
        return !(s && typeof s.getBoundingClientRect == "function")
    })
}
function rD(e) {
    e === void 0 && (e = {});
    var t = e
      , i = t.defaultModifiers
      , s = i === void 0 ? [] : i
      , u = t.defaultOptions
      , d = u === void 0 ? xw : u;
    return function(o, w, T) {
        T === void 0 && (T = d);
        var k = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, xw, d),
            modifiersData: {},
            elements: {
                reference: o,
                popper: w
            },
            attributes: {},
            styles: {}
        }
          , L = []
          , z = !1
          , D = {
            state: k,
            setOptions: function(re) {
                var ie = typeof re == "function" ? re(k.options) : re;
                U(),
                k.options = Object.assign({}, d, k.options, ie),
                k.scrollParents = {
                    reference: _f(o) ? Fg(o) : o.contextElement ? Fg(o.contextElement) : [],
                    popper: Fg(w)
                };
                var ue = Jz(tD([].concat(s, k.options.modifiers)));
                return k.orderedModifiers = ue.filter(function(ce) {
                    return ce.enabled
                }),
                N(),
                D.update()
            },
            forceUpdate: function() {
                if (!z) {
                    var re = k.elements
                      , ie = re.reference
                      , ue = re.popper;
                    if (bw(ie, ue)) {
                        k.rects = {
                            reference: Kz(ie, my(ue), k.options.strategy === "fixed"),
                            popper: qx(ue)
                        },
                        k.reset = !1,
                        k.placement = k.options.placement,
                        k.orderedModifiers.forEach(function(Ce) {
                            return k.modifiersData[Ce.name] = Object.assign({}, Ce.data)
                        });
                        for (var ce = 0; ce < k.orderedModifiers.length; ce++) {
                            if (k.reset === !0) {
                                k.reset = !1,
                                ce = -1;
                                continue
                            }
                            var X = k.orderedModifiers[ce]
                              , me = X.fn
                              , K = X.options
                              , be = K === void 0 ? {} : K
                              , Ee = X.name;
                            typeof me == "function" && (k = me({
                                state: k,
                                options: be,
                                name: Ee,
                                instance: D
                            }) || k)
                        }
                    }
                }
            },
            update: eD(function() {
                return new Promise(function(V) {
                    D.forceUpdate(),
                    V(k)
                }
                )
            }),
            destroy: function() {
                U(),
                z = !0
            }
        };
        if (!bw(o, w))
            return D;
        D.setOptions(T).then(function(V) {
            !z && T.onFirstUpdate && T.onFirstUpdate(V)
        });
        function N() {
            k.orderedModifiers.forEach(function(V) {
                var re = V.name
                  , ie = V.options
                  , ue = ie === void 0 ? {} : ie
                  , ce = V.effect;
                if (typeof ce == "function") {
                    var X = ce({
                        state: k,
                        name: re,
                        instance: D,
                        options: ue
                    })
                      , me = function() {};
                    L.push(X || me)
                }
            })
        }
        function U() {
            L.forEach(function(V) {
                return V()
            }),
            L = []
        }
        return D
    }
}
var nD = [Pz, Gz, Cz, fz, Vz, Fz, Hz, xz, jz]
  , iD = rD({
    defaultModifiers: nD
});
function oD(e) {
    return typeof e == "function" ? e() : e
}
const dT = Pe.forwardRef(function(t, i) {
    const {children: s, container: u, disablePortal: d=!1} = t
      , [f,o] = Pe.useState(null)
      , w = ki(Pe.isValidElement(s) ? s.ref : null, i);
    if (gl( () => {
        d || o(oD(u) || document.body)
    }
    , [u, d]),
    gl( () => {
        if (f && !d)
            return W_(i, f),
            () => {
                W_(i, null)
            }
    }
    , [i, f, d]),
    d) {
        if (Pe.isValidElement(s)) {
            const T = {
                ref: w
            };
            return Pe.cloneElement(s, T)
        }
        return G.jsx(Pe.Fragment, {
            children: s
        })
    }
    return G.jsx(Pe.Fragment, {
        children: f && rT.createPortal(s, f)
    })
});
function sD(e) {
    return Kr("MuiPopper", e)
}
Qr("MuiPopper", ["root"]);
const aD = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"]
  , lD = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
function cD(e, t) {
    if (t === "ltr")
        return e;
    switch (e) {
    case "bottom-end":
        return "bottom-start";
    case "bottom-start":
        return "bottom-end";
    case "top-end":
        return "top-start";
    case "top-start":
        return "top-end";
    default:
        return e
    }
}
function ox(e) {
    return typeof e == "function" ? e() : e
}
function uD(e) {
    return e.nodeType !== void 0
}
const hD = e => {
    const {classes: t} = e;
    return Jr({
        root: ["root"]
    }, sD, t)
}
  , dD = {}
  , fD = Pe.forwardRef(function(t, i) {
    var s;
    const {anchorEl: u, children: d, direction: f, disablePortal: o, modifiers: w, open: T, placement: k, popperOptions: L, popperRef: z, slotProps: D={}, slots: N={}, TransitionProps: U} = t
      , V = dr(t, aD)
      , re = Pe.useRef(null)
      , ie = ki(re, i)
      , ue = Pe.useRef(null)
      , ce = ki(ue, z)
      , X = Pe.useRef(ce);
    gl( () => {
        X.current = ce
    }
    , [ce]),
    Pe.useImperativeHandle(z, () => ue.current, []);
    const me = cD(k, f)
      , [K,be] = Pe.useState(me)
      , [Ee,Ce] = Pe.useState(ox(u));
    Pe.useEffect( () => {
        ue.current && ue.current.forceUpdate()
    }
    ),
    Pe.useEffect( () => {
        u && Ce(ox(u))
    }
    , [u]),
    gl( () => {
        if (!Ee || !T)
            return;
        const he = je => {
            be(je.placement)
        }
        ;
        let ve = [{
            name: "preventOverflow",
            options: {
                altBoundary: o
            }
        }, {
            name: "flip",
            options: {
                altBoundary: o
            }
        }, {
            name: "onUpdate",
            enabled: !0,
            phase: "afterWrite",
            fn: ({state: je}) => {
                he(je)
            }
        }];
        w != null && (ve = ve.concat(w)),
        L && L.modifiers != null && (ve = ve.concat(L.modifiers));
        const Ne = iD(Ee, re.current, xe({
            placement: me
        }, L, {
            modifiers: ve
        }));
        return X.current(Ne),
        () => {
            Ne.destroy(),
            X.current(null)
        }
    }
    , [Ee, o, w, T, L, me]);
    const He = {
        placement: K
    };
    U !== null && (He.TransitionProps = U);
    const ct = hD(t)
      , nt = (s = N.root) != null ? s : "div"
      , J = cl({
        elementType: nt,
        externalSlotProps: D.root,
        externalForwardedProps: V,
        additionalProps: {
            role: "tooltip",
            ref: ie
        },
        ownerState: t,
        className: ct.root
    });
    return G.jsx(nt, xe({}, J, {
        children: typeof d == "function" ? d(He) : d
    }))
})
  , pD = Pe.forwardRef(function(t, i) {
    const {anchorEl: s, children: u, container: d, direction: f="ltr", disablePortal: o=!1, keepMounted: w=!1, modifiers: T, open: k, placement: L="bottom", popperOptions: z=dD, popperRef: D, style: N, transition: U=!1, slotProps: V={}, slots: re={}} = t
      , ie = dr(t, lD)
      , [ue,ce] = Pe.useState(!0)
      , X = () => {
        ce(!1)
    }
      , me = () => {
        ce(!0)
    }
    ;
    if (!w && !k && (!U || ue))
        return null;
    let K;
    if (d)
        K = d;
    else if (s) {
        const Ce = ox(s);
        K = Ce && uD(Ce) ? js(Ce).body : js(null).body
    }
    const be = !k && w && (!U || ue) ? "none" : void 0
      , Ee = U ? {
        in: k,
        onEnter: X,
        onExited: me
    } : void 0;
    return G.jsx(dT, {
        disablePortal: o,
        container: K,
        children: G.jsx(fD, xe({
            anchorEl: s,
            direction: f,
            disablePortal: o,
            modifiers: T,
            ref: i,
            open: U ? !ue : k,
            placement: L,
            popperOptions: z,
            popperRef: D,
            slotProps: V,
            slots: re
        }, ie, {
            style: xe({
                position: "fixed",
                top: 0,
                left: 0,
                display: be
            }, N),
            TransitionProps: Ee,
            children: u
        }))
    })
})
  , mD = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"]
  , gD = Jt(pD, {
    name: "MuiPopper",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({})
  , fT = Pe.forwardRef(function(t, i) {
    var s;
    const u = QA()
      , d = nn({
        props: t,
        name: "MuiPopper"
    })
      , {anchorEl: f, component: o, components: w, componentsProps: T, container: k, disablePortal: L, keepMounted: z, modifiers: D, open: N, placement: U, popperOptions: V, popperRef: re, transition: ie, slots: ue, slotProps: ce} = d
      , X = dr(d, mD)
      , me = (s = ue?.root) != null ? s : w?.Root
      , K = xe({
        anchorEl: f,
        container: k,
        disablePortal: L,
        keepMounted: z,
        modifiers: D,
        open: N,
        placement: U,
        popperOptions: V,
        popperRef: re,
        transition: ie
    }, X);
    return G.jsx(gD, xe({
        as: o,
        direction: u?.direction,
        slots: {
            root: me
        },
        slotProps: ce ?? T
    }, K, {
        ref: i
    }))
})
  , yD = rc(G.jsx("path", {
    d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
}), "Cancel");
function _D(e) {
    return Kr("MuiChip", e)
}
const Fn = Qr("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"])
  , vD = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant", "tabIndex", "skipFocusWhenDisabled"]
  , xD = e => {
    const {classes: t, disabled: i, size: s, color: u, iconColor: d, onDelete: f, clickable: o, variant: w} = e
      , T = {
        root: ["root", w, i && "disabled", `size${Ot(s)}`, `color${Ot(u)}`, o && "clickable", o && `clickableColor${Ot(u)}`, f && "deletable", f && `deletableColor${Ot(u)}`, `${w}${Ot(u)}`],
        label: ["label", `label${Ot(s)}`],
        avatar: ["avatar", `avatar${Ot(s)}`, `avatarColor${Ot(u)}`],
        icon: ["icon", `icon${Ot(s)}`, `iconColor${Ot(d)}`],
        deleteIcon: ["deleteIcon", `deleteIcon${Ot(s)}`, `deleteIconColor${Ot(u)}`, `deleteIcon${Ot(w)}Color${Ot(u)}`]
    };
    return Jr(T, _D, t)
}
  , bD = Jt("div", {
    name: "MuiChip",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e
          , {color: s, iconColor: u, clickable: d, onDelete: f, size: o, variant: w} = i;
        return [{
            [`& .${Fn.avatar}`]: t.avatar
        }, {
            [`& .${Fn.avatar}`]: t[`avatar${Ot(o)}`]
        }, {
            [`& .${Fn.avatar}`]: t[`avatarColor${Ot(s)}`]
        }, {
            [`& .${Fn.icon}`]: t.icon
        }, {
            [`& .${Fn.icon}`]: t[`icon${Ot(o)}`]
        }, {
            [`& .${Fn.icon}`]: t[`iconColor${Ot(u)}`]
        }, {
            [`& .${Fn.deleteIcon}`]: t.deleteIcon
        }, {
            [`& .${Fn.deleteIcon}`]: t[`deleteIcon${Ot(o)}`]
        }, {
            [`& .${Fn.deleteIcon}`]: t[`deleteIconColor${Ot(s)}`]
        }, {
            [`& .${Fn.deleteIcon}`]: t[`deleteIcon${Ot(w)}Color${Ot(s)}`]
        }, t.root, t[`size${Ot(o)}`], t[`color${Ot(s)}`], d && t.clickable, d && s !== "default" && t[`clickableColor${Ot(s)})`], f && t.deletable, f && s !== "default" && t[`deletableColor${Ot(s)}`], t[w], t[`${w}${Ot(s)}`]]
    }
})( ({theme: e, ownerState: t}) => {
    const i = e.palette.mode === "light" ? e.palette.grey[700] : e.palette.grey[300];
    return xe({
        maxWidth: "100%",
        fontFamily: e.typography.fontFamily,
        fontSize: e.typography.pxToRem(13),
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        height: 32,
        color: (e.vars || e).palette.text.primary,
        backgroundColor: (e.vars || e).palette.action.selected,
        borderRadius: 32 / 2,
        whiteSpace: "nowrap",
        transition: e.transitions.create(["background-color", "box-shadow"]),
        cursor: "unset",
        outline: 0,
        textDecoration: "none",
        border: 0,
        padding: 0,
        verticalAlign: "middle",
        boxSizing: "border-box",
        [`&.${Fn.disabled}`]: {
            opacity: (e.vars || e).palette.action.disabledOpacity,
            pointerEvents: "none"
        },
        [`& .${Fn.avatar}`]: {
            marginLeft: 5,
            marginRight: -6,
            width: 24,
            height: 24,
            color: e.vars ? e.vars.palette.Chip.defaultAvatarColor : i,
            fontSize: e.typography.pxToRem(12)
        },
        [`& .${Fn.avatarColorPrimary}`]: {
            color: (e.vars || e).palette.primary.contrastText,
            backgroundColor: (e.vars || e).palette.primary.dark
        },
        [`& .${Fn.avatarColorSecondary}`]: {
            color: (e.vars || e).palette.secondary.contrastText,
            backgroundColor: (e.vars || e).palette.secondary.dark
        },
        [`& .${Fn.avatarSmall}`]: {
            marginLeft: 4,
            marginRight: -4,
            width: 18,
            height: 18,
            fontSize: e.typography.pxToRem(10)
        },
        [`& .${Fn.icon}`]: xe({
            marginLeft: 5,
            marginRight: -6
        }, t.size === "small" && {
            fontSize: 18,
            marginLeft: 4,
            marginRight: -4
        }, t.iconColor === t.color && xe({
            color: e.vars ? e.vars.palette.Chip.defaultIconColor : i
        }, t.color !== "default" && {
            color: "inherit"
        })),
        [`& .${Fn.deleteIcon}`]: xe({
            WebkitTapHighlightColor: "transparent",
            color: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / 0.26)` : Or.alpha(e.palette.text.primary, .26),
            fontSize: 22,
            cursor: "pointer",
            margin: "0 5px 0 -6px",
            "&:hover": {
                color: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / 0.4)` : Or.alpha(e.palette.text.primary, .4)
            }
        }, t.size === "small" && {
            fontSize: 16,
            marginRight: 4,
            marginLeft: -4
        }, t.color !== "default" && {
            color: e.vars ? `rgba(${e.vars.palette[t.color].contrastTextChannel} / 0.7)` : Or.alpha(e.palette[t.color].contrastText, .7),
            "&:hover, &:active": {
                color: (e.vars || e).palette[t.color].contrastText
            }
        })
    }, t.size === "small" && {
        height: 24
    }, t.color !== "default" && {
        backgroundColor: (e.vars || e).palette[t.color].main,
        color: (e.vars || e).palette[t.color].contrastText
    }, t.onDelete && {
        [`&.${Fn.focusVisible}`]: {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : Or.alpha(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
        }
    }, t.onDelete && t.color !== "default" && {
        [`&.${Fn.focusVisible}`]: {
            backgroundColor: (e.vars || e).palette[t.color].dark
        }
    })
}
, ({theme: e, ownerState: t}) => xe({}, t.clickable && {
    userSelect: "none",
    WebkitTapHighlightColor: "transparent",
    cursor: "pointer",
    "&:hover": {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Or.alpha(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity)
    },
    [`&.${Fn.focusVisible}`]: {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : Or.alpha(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
    },
    "&:active": {
        boxShadow: (e.vars || e).shadows[1]
    }
}, t.clickable && t.color !== "default" && {
    [`&:hover, &.${Fn.focusVisible}`]: {
        backgroundColor: (e.vars || e).palette[t.color].dark
    }
}), ({theme: e, ownerState: t}) => xe({}, t.variant === "outlined" && {
    backgroundColor: "transparent",
    border: e.vars ? `1px solid ${e.vars.palette.Chip.defaultBorder}` : `1px solid ${e.palette.mode === "light" ? e.palette.grey[400] : e.palette.grey[700]}`,
    [`&.${Fn.clickable}:hover`]: {
        backgroundColor: (e.vars || e).palette.action.hover
    },
    [`&.${Fn.focusVisible}`]: {
        backgroundColor: (e.vars || e).palette.action.focus
    },
    [`& .${Fn.avatar}`]: {
        marginLeft: 4
    },
    [`& .${Fn.avatarSmall}`]: {
        marginLeft: 2
    },
    [`& .${Fn.icon}`]: {
        marginLeft: 4
    },
    [`& .${Fn.iconSmall}`]: {
        marginLeft: 2
    },
    [`& .${Fn.deleteIcon}`]: {
        marginRight: 5
    },
    [`& .${Fn.deleteIconSmall}`]: {
        marginRight: 3
    }
}, t.variant === "outlined" && t.color !== "default" && {
    color: (e.vars || e).palette[t.color].main,
    border: `1px solid ${e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / 0.7)` : Or.alpha(e.palette[t.color].main, .7)}`,
    [`&.${Fn.clickable}:hover`]: {
        backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Or.alpha(e.palette[t.color].main, e.palette.action.hoverOpacity)
    },
    [`&.${Fn.focusVisible}`]: {
        backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.focusOpacity})` : Or.alpha(e.palette[t.color].main, e.palette.action.focusOpacity)
    },
    [`& .${Fn.deleteIcon}`]: {
        color: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / 0.7)` : Or.alpha(e.palette[t.color].main, .7),
        "&:hover, &:active": {
            color: (e.vars || e).palette[t.color].main
        }
    }
}))
  , wD = Jt("span", {
    name: "MuiChip",
    slot: "Label",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e
          , {size: s} = i;
        return [t.label, t[`label${Ot(s)}`]]
    }
})( ({ownerState: e}) => xe({
    overflow: "hidden",
    textOverflow: "ellipsis",
    paddingLeft: 12,
    paddingRight: 12,
    whiteSpace: "nowrap"
}, e.variant === "outlined" && {
    paddingLeft: 11,
    paddingRight: 11
}, e.size === "small" && {
    paddingLeft: 8,
    paddingRight: 8
}, e.size === "small" && e.variant === "outlined" && {
    paddingLeft: 7,
    paddingRight: 7
}));
function ww(e) {
    return e.key === "Backspace" || e.key === "Delete"
}
const lf = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiChip"
    })
      , {avatar: u, className: d, clickable: f, color: o="default", component: w, deleteIcon: T, disabled: k=!1, icon: L, label: z, onClick: D, onDelete: N, onKeyDown: U, onKeyUp: V, size: re="medium", variant: ie="filled", tabIndex: ue, skipFocusWhenDisabled: ce=!1} = s
      , X = dr(s, vD)
      , me = Pe.useRef(null)
      , K = ki(me, i)
      , be = lt => {
        lt.stopPropagation(),
        N && N(lt)
    }
      , Ee = lt => {
        lt.currentTarget === lt.target && ww(lt) && lt.preventDefault(),
        U && U(lt)
    }
      , Ce = lt => {
        lt.currentTarget === lt.target && (N && ww(lt) ? N(lt) : lt.key === "Escape" && me.current && me.current.blur()),
        V && V(lt)
    }
      , He = f !== !1 && D ? !0 : f
      , ct = He || N ? Kh : w || "div"
      , nt = xe({}, s, {
        component: ct,
        disabled: k,
        size: re,
        color: o,
        iconColor: Pe.isValidElement(L) && L.props.color || o,
        onDelete: !!N,
        clickable: He,
        variant: ie
    })
      , J = xD(nt)
      , he = ct === Kh ? xe({
        component: w || "div",
        focusVisibleClassName: J.focusVisible
    }, N && {
        disableRipple: !0
    }) : {};
    let ve = null;
    N && (ve = T && Pe.isValidElement(T) ? Pe.cloneElement(T, {
        className: nr(T.props.className, J.deleteIcon),
        onClick: be
    }) : G.jsx(yD, {
        className: nr(J.deleteIcon),
        onClick: be
    }));
    let Ne = null;
    u && Pe.isValidElement(u) && (Ne = Pe.cloneElement(u, {
        className: nr(J.avatar, u.props.className)
    }));
    let je = null;
    return L && Pe.isValidElement(L) && (je = Pe.cloneElement(L, {
        className: nr(J.icon, L.props.className)
    })),
    G.jsxs(bD, xe({
        as: ct,
        className: nr(J.root, d),
        disabled: He && k ? !0 : void 0,
        onClick: D,
        onKeyDown: Ee,
        onKeyUp: Ce,
        ref: K,
        tabIndex: ce && k ? -1 : ue,
        ownerState: nt
    }, he, X, {
        children: [Ne || je, G.jsx(wD, {
            className: nr(J.label),
            ownerState: nt,
            children: z
        }), ve]
    }))
})
  , SD = ["onChange", "maxRows", "minRows", "style", "value"];
function e_(e) {
    return parseInt(e, 10) || 0
}
const CD = {
    shadow: {
        visibility: "hidden",
        position: "absolute",
        overflow: "hidden",
        height: 0,
        top: 0,
        left: 0,
        transform: "translateZ(0)"
    }
};
function TD(e) {
    return e == null || Object.keys(e).length === 0 || e.outerHeightStyle === 0 && !e.overflowing
}
const PD = Pe.forwardRef(function(t, i) {
    const {onChange: s, maxRows: u, minRows: d=1, style: f, value: o} = t
      , w = dr(t, SD)
      , {current: T} = Pe.useRef(o != null)
      , k = Pe.useRef(null)
      , L = ki(i, k)
      , z = Pe.useRef(null)
      , D = Pe.useRef(null)
      , N = Pe.useCallback( () => {
        const re = k.current
          , ue = Yh(re).getComputedStyle(re);
        if (ue.width === "0px")
            return {
                outerHeightStyle: 0,
                overflowing: !1
            };
        const ce = D.current;
        ce.style.width = ue.width,
        ce.value = re.value || t.placeholder || "x",
        ce.value.slice(-1) === `
` && (ce.value += " ");
        const X = ue.boxSizing
          , me = e_(ue.paddingBottom) + e_(ue.paddingTop)
          , K = e_(ue.borderBottomWidth) + e_(ue.borderTopWidth)
          , be = ce.scrollHeight;
        ce.value = "x";
        const Ee = ce.scrollHeight;
        let Ce = be;
        d && (Ce = Math.max(Number(d) * Ee, Ce)),
        u && (Ce = Math.min(Number(u) * Ee, Ce)),
        Ce = Math.max(Ce, Ee);
        const He = Ce + (X === "border-box" ? me + K : 0)
          , ct = Math.abs(Ce - be) <= 1;
        return {
            outerHeightStyle: He,
            overflowing: ct
        }
    }
    , [u, d, t.placeholder])
      , U = Pe.useCallback( () => {
        const re = N();
        if (TD(re))
            return;
        const ie = re.outerHeightStyle
          , ue = k.current;
        z.current !== ie && (z.current = ie,
        ue.style.height = `${ie}px`),
        ue.style.overflow = re.overflowing ? "hidden" : ""
    }
    , [N]);
    gl( () => {
        const re = () => {
            U()
        }
        ;
        let ie;
        const ue = Fx(re)
          , ce = k.current
          , X = Yh(ce);
        X.addEventListener("resize", ue);
        let me;
        return typeof ResizeObserver < "u" && (me = new ResizeObserver(re),
        me.observe(ce)),
        () => {
            ue.clear(),
            cancelAnimationFrame(ie),
            X.removeEventListener("resize", ue),
            me && me.disconnect()
        }
    }
    , [N, U]),
    gl( () => {
        U()
    }
    );
    const V = re => {
        T || U(),
        s && s(re)
    }
    ;
    return G.jsxs(Pe.Fragment, {
        children: [G.jsx("textarea", xe({
            value: o,
            onChange: V,
            ref: L,
            rows: d,
            style: f
        }, w)), G.jsx("textarea", {
            "aria-hidden": !0,
            className: t.className,
            readOnly: !0,
            ref: D,
            tabIndex: -1,
            style: xe({}, CD.shadow, f, {
                paddingTop: 0,
                paddingBottom: 0
            })
        })]
    })
});
function bv({props: e, states: t, muiFormControl: i}) {
    return t.reduce( (s, u) => (s[u] = e[u],
    i && typeof e[u] > "u" && (s[u] = i[u]),
    s), {})
}
const Kx = Pe.createContext(void 0);
function gy() {
    return Pe.useContext(Kx)
}
function MD(e) {
    return G.jsx(hI, xe({}, e, {
        defaultTheme: jx,
        themeId: Gg
    }))
}
function Sw(e) {
    return e != null && !(Array.isArray(e) && e.length === 0)
}
function sx(e, t=!1) {
    return e && (Sw(e.value) && e.value !== "" || t && Sw(e.defaultValue) && e.defaultValue !== "")
}
function kD(e) {
    return e.startAdornment
}
function ED(e) {
    return Kr("MuiInputBase", e)
}
const ax = Qr("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"])
  , ID = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"]
  , RD = (e, t) => {
    const {ownerState: i} = e;
    return [t.root, i.formControl && t.formControl, i.startAdornment && t.adornedStart, i.endAdornment && t.adornedEnd, i.error && t.error, i.size === "small" && t.sizeSmall, i.multiline && t.multiline, i.color && t[`color${Ot(i.color)}`], i.fullWidth && t.fullWidth, i.hiddenLabel && t.hiddenLabel]
}
  , AD = (e, t) => {
    const {ownerState: i} = e;
    return [t.input, i.size === "small" && t.inputSizeSmall, i.multiline && t.inputMultiline, i.type === "search" && t.inputTypeSearch, i.startAdornment && t.inputAdornedStart, i.endAdornment && t.inputAdornedEnd, i.hiddenLabel && t.inputHiddenLabel]
}
  , zD = e => {
    const {classes: t, color: i, disabled: s, error: u, endAdornment: d, focused: f, formControl: o, fullWidth: w, hiddenLabel: T, multiline: k, readOnly: L, size: z, startAdornment: D, type: N} = e
      , U = {
        root: ["root", `color${Ot(i)}`, s && "disabled", u && "error", w && "fullWidth", f && "focused", o && "formControl", z && z !== "medium" && `size${Ot(z)}`, k && "multiline", D && "adornedStart", d && "adornedEnd", T && "hiddenLabel", L && "readOnly"],
        input: ["input", s && "disabled", N === "search" && "inputTypeSearch", k && "inputMultiline", z === "small" && "inputSizeSmall", T && "inputHiddenLabel", D && "inputAdornedStart", d && "inputAdornedEnd", L && "readOnly"]
    };
    return Jr(U, ED, t)
}
  , DD = Jt("div", {
    name: "MuiInputBase",
    slot: "Root",
    overridesResolver: RD
})( ({theme: e, ownerState: t}) => xe({}, e.typography.body1, {
    color: (e.vars || e).palette.text.primary,
    lineHeight: "1.4375em",
    boxSizing: "border-box",
    position: "relative",
    cursor: "text",
    display: "inline-flex",
    alignItems: "center",
    [`&.${ax.disabled}`]: {
        color: (e.vars || e).palette.text.disabled,
        cursor: "default"
    }
}, t.multiline && xe({
    padding: "4px 0 5px"
}, t.size === "small" && {
    paddingTop: 1
}), t.fullWidth && {
    width: "100%"
}))
  , LD = Jt("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: AD
})( ({theme: e, ownerState: t}) => {
    const i = e.palette.mode === "light"
      , s = xe({
        color: "currentColor"
    }, e.vars ? {
        opacity: e.vars.opacity.inputPlaceholder
    } : {
        opacity: i ? .42 : .5
    }, {
        transition: e.transitions.create("opacity", {
            duration: e.transitions.duration.shorter
        })
    })
      , u = {
        opacity: "0 !important"
    }
      , d = e.vars ? {
        opacity: e.vars.opacity.inputPlaceholder
    } : {
        opacity: i ? .42 : .5
    };
    return xe({
        font: "inherit",
        letterSpacing: "inherit",
        color: "currentColor",
        padding: "4px 0 5px",
        border: 0,
        boxSizing: "content-box",
        background: "none",
        height: "1.4375em",
        margin: 0,
        WebkitTapHighlightColor: "transparent",
        display: "block",
        minWidth: 0,
        width: "100%",
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&::-webkit-input-placeholder": s,
        "&::-moz-placeholder": s,
        "&:-ms-input-placeholder": s,
        "&::-ms-input-placeholder": s,
        "&:focus": {
            outline: 0
        },
        "&:invalid": {
            boxShadow: "none"
        },
        "&::-webkit-search-decoration": {
            WebkitAppearance: "none"
        },
        [`label[data-shrink=false] + .${ax.formControl} &`]: {
            "&::-webkit-input-placeholder": u,
            "&::-moz-placeholder": u,
            "&:-ms-input-placeholder": u,
            "&::-ms-input-placeholder": u,
            "&:focus::-webkit-input-placeholder": d,
            "&:focus::-moz-placeholder": d,
            "&:focus:-ms-input-placeholder": d,
            "&:focus::-ms-input-placeholder": d
        },
        [`&.${ax.disabled}`]: {
            opacity: 1,
            WebkitTextFillColor: (e.vars || e).palette.text.disabled
        },
        "&:-webkit-autofill": {
            animationDuration: "5000s",
            animationName: "mui-auto-fill"
        }
    }, t.size === "small" && {
        paddingTop: 1
    }, t.multiline && {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
    }, t.type === "search" && {
        MozAppearance: "textfield"
    })
}
)
  , OD = G.jsx(MD, {
    styles: {
        "@keyframes mui-auto-fill": {
            from: {
                display: "block"
            }
        },
        "@keyframes mui-auto-fill-cancel": {
            from: {
                display: "block"
            }
        }
    }
})
  , FD = Pe.forwardRef(function(t, i) {
    var s;
    const u = nn({
        props: t,
        name: "MuiInputBase"
    })
      , {"aria-describedby": d, autoComplete: f, autoFocus: o, className: w, components: T={}, componentsProps: k={}, defaultValue: L, disabled: z, disableInjectingGlobalStyles: D, endAdornment: N, fullWidth: U=!1, id: V, inputComponent: re="input", inputProps: ie={}, inputRef: ue, maxRows: ce, minRows: X, multiline: me=!1, name: K, onBlur: be, onChange: Ee, onClick: Ce, onFocus: He, onKeyDown: ct, onKeyUp: nt, placeholder: J, readOnly: he, renderSuffix: ve, rows: Ne, slotProps: je={}, slots: lt={}, startAdornment: Pt, type: We="text", value: st} = u
      , Nt = dr(u, ID)
      , zt = ie.value != null ? ie.value : st
      , {current: Qt} = Pe.useRef(zt != null)
      , Wt = Pe.useRef()
      , tr = Pe.useCallback(Mt => {}
    , [])
      , cr = ki(Wt, ue, ie.ref, tr)
      , [Yt,Gr] = Pe.useState(!1)
      , xr = gy()
      , Nr = bv({
        props: u,
        muiFormControl: xr,
        states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
    });
    Nr.focused = xr ? xr.focused : Yt,
    Pe.useEffect( () => {
        !xr && z && Yt && (Gr(!1),
        be && be())
    }
    , [xr, z, Yt, be]);
    const ur = xr && xr.onFilled
      , vr = xr && xr.onEmpty
      , gr = Pe.useCallback(Mt => {
        sx(Mt) ? ur && ur() : vr && vr()
    }
    , [ur, vr]);
    gl( () => {
        Qt && gr({
            value: zt
        })
    }
    , [zt, gr, Qt]);
    const hn = Mt => {
        if (Nr.disabled) {
            Mt.stopPropagation();
            return
        }
        He && He(Mt),
        ie.onFocus && ie.onFocus(Mt),
        xr && xr.onFocus ? xr.onFocus(Mt) : Gr(!0)
    }
      , Zr = Mt => {
        be && be(Mt),
        ie.onBlur && ie.onBlur(Mt),
        xr && xr.onBlur ? xr.onBlur(Mt) : Gr(!1)
    }
      , $r = (Mt, ...kt) => {
        if (!Qt) {
            const er = Mt.target || Wt.current;
            if (er == null)
                throw new Error(zp(1));
            gr({
                value: er.value
            })
        }
        ie.onChange && ie.onChange(Mt, ...kt),
        Ee && Ee(Mt, ...kt)
    }
    ;
    Pe.useEffect( () => {
        gr(Wt.current)
    }
    , []);
    const gn = Mt => {
        Wt.current && Mt.currentTarget === Mt.target && Wt.current.focus(),
        Ce && Ce(Mt)
    }
    ;
    let zr = re
      , Wr = ie;
    me && zr === "input" && (Ne ? Wr = xe({
        type: void 0,
        minRows: Ne,
        maxRows: Ne
    }, Wr) : Wr = xe({
        type: void 0,
        maxRows: ce,
        minRows: X
    }, Wr),
    zr = PD);
    const $n = Mt => {
        gr(Mt.animationName === "mui-auto-fill-cancel" ? Wt.current : {
            value: "x"
        })
    }
    ;
    Pe.useEffect( () => {
        xr && xr.setAdornedStart(!!Pt)
    }
    , [xr, Pt]);
    const Dn = xe({}, u, {
        color: Nr.color || "primary",
        disabled: Nr.disabled,
        endAdornment: N,
        error: Nr.error,
        focused: Nr.focused,
        formControl: xr,
        fullWidth: U,
        hiddenLabel: Nr.hiddenLabel,
        multiline: me,
        size: Nr.size,
        startAdornment: Pt,
        type: We
    })
      , yn = zD(Dn)
      , Tn = lt.root || T.Root || DD
      , bn = je.root || k.root || {}
      , sn = lt.input || T.Input || LD;
    return Wr = xe({}, Wr, (s = je.input) != null ? s : k.input),
    G.jsxs(Pe.Fragment, {
        children: [!D && OD, G.jsxs(Tn, xe({}, bn, !oh(Tn) && {
            ownerState: xe({}, Dn, bn.ownerState)
        }, {
            ref: i,
            onClick: gn
        }, Nt, {
            className: nr(yn.root, bn.className, w, he && "MuiInputBase-readOnly"),
            children: [Pt, G.jsx(Kx.Provider, {
                value: null,
                children: G.jsx(sn, xe({
                    ownerState: Dn,
                    "aria-invalid": Nr.error,
                    "aria-describedby": d,
                    autoComplete: f,
                    autoFocus: o,
                    defaultValue: L,
                    disabled: Nr.disabled,
                    id: V,
                    onAnimationStart: $n,
                    name: K,
                    placeholder: J,
                    readOnly: he,
                    required: Nr.required,
                    rows: Ne,
                    value: zt,
                    onKeyDown: ct,
                    onKeyUp: nt,
                    type: We
                }, Wr, !oh(sn) && {
                    as: zr,
                    ownerState: xe({}, Dn, Wr.ownerState)
                }, {
                    ref: cr,
                    className: nr(yn.input, Wr.className, he && "MuiInputBase-readOnly"),
                    onBlur: Zr,
                    onChange: $r,
                    onFocus: hn
                }))
            }), N, ve ? ve(xe({}, Nr, {
                startAdornment: Pt
            })) : null]
        }))]
    })
})
  , BD = rc(G.jsx("path", {
    d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
}), "Person");
function jD(e) {
    return Kr("MuiAvatar", e)
}
Qr("MuiAvatar", ["root", "colorDefault", "circular", "rounded", "square", "img", "fallback"]);
const ND = ["alt", "children", "className", "component", "slots", "slotProps", "imgProps", "sizes", "src", "srcSet", "variant"]
  , $D = e => {
    const {classes: t, variant: i, colorDefault: s} = e;
    return Jr({
        root: ["root", i, s && "colorDefault"],
        img: ["img"],
        fallback: ["fallback"]
    }, jD, t)
}
  , VD = Jt("div", {
    name: "MuiAvatar",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, t[i.variant], i.colorDefault && t.colorDefault]
    }
})( ({theme: e}) => ({
    position: "relative",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    width: 40,
    height: 40,
    fontFamily: e.typography.fontFamily,
    fontSize: e.typography.pxToRem(20),
    lineHeight: 1,
    borderRadius: "50%",
    overflow: "hidden",
    userSelect: "none",
    variants: [{
        props: {
            variant: "rounded"
        },
        style: {
            borderRadius: (e.vars || e).shape.borderRadius
        }
    }, {
        props: {
            variant: "square"
        },
        style: {
            borderRadius: 0
        }
    }, {
        props: {
            colorDefault: !0
        },
        style: xe({
            color: (e.vars || e).palette.background.default
        }, e.vars ? {
            backgroundColor: e.vars.palette.Avatar.defaultBg
        } : xe({
            backgroundColor: e.palette.grey[400]
        }, e.applyStyles("dark", {
            backgroundColor: e.palette.grey[600]
        })))
    }]
}))
  , UD = Jt("img", {
    name: "MuiAvatar",
    slot: "Img",
    overridesResolver: (e, t) => t.img
})({
    width: "100%",
    height: "100%",
    textAlign: "center",
    objectFit: "cover",
    color: "transparent",
    textIndent: 1e4
})
  , GD = Jt(BD, {
    name: "MuiAvatar",
    slot: "Fallback",
    overridesResolver: (e, t) => t.fallback
})({
    width: "75%",
    height: "75%"
});
function WD({crossOrigin: e, referrerPolicy: t, src: i, srcSet: s}) {
    const [u,d] = Pe.useState(!1);
    return Pe.useEffect( () => {
        if (!i && !s)
            return;
        d(!1);
        let f = !0;
        const o = new Image;
        return o.onload = () => {
            f && d("loaded")
        }
        ,
        o.onerror = () => {
            f && d("error")
        }
        ,
        o.crossOrigin = e,
        o.referrerPolicy = t,
        o.src = i,
        s && (o.srcset = s),
        () => {
            f = !1
        }
    }
    , [e, t, i, s]),
    u
}
const t_ = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiAvatar"
    })
      , {alt: u, children: d, className: f, component: o="div", slots: w={}, slotProps: T={}, imgProps: k, sizes: L, src: z, srcSet: D, variant: N="circular"} = s
      , U = dr(s, ND);
    let V = null;
    const re = WD(xe({}, k, {
        src: z,
        srcSet: D
    }))
      , ie = z || D
      , ue = ie && re !== "error"
      , ce = xe({}, s, {
        colorDefault: !ue,
        component: o,
        variant: N
    })
      , X = $D(ce)
      , [me,K] = CA("img", {
        className: X.img,
        elementType: UD,
        externalForwardedProps: {
            slots: w,
            slotProps: {
                img: xe({}, k, T.img)
            }
        },
        additionalProps: {
            alt: u,
            src: z,
            srcSet: D,
            sizes: L
        },
        ownerState: ce
    });
    return ue ? V = G.jsx(me, xe({}, K)) : d || d === 0 ? V = d : ie && u ? V = u[0] : V = G.jsx(GD, {
        ownerState: ce,
        className: X.fallback
    }),
    G.jsx(VD, xe({
        as: o,
        ownerState: ce,
        className: nr(X.root, f),
        ref: i
    }, U, {
        children: V
    }))
})
  , qD = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"]
  , HD = {
    entering: {
        opacity: 1
    },
    entered: {
        opacity: 1
    }
}
  , pT = Pe.forwardRef(function(t, i) {
    const s = Kp()
      , u = {
        enter: s.transitions.duration.enteringScreen,
        exit: s.transitions.duration.leavingScreen
    }
      , {addEndListener: d, appear: f=!0, children: o, easing: w, in: T, onEnter: k, onEntered: L, onEntering: z, onExit: D, onExited: N, onExiting: U, style: V, timeout: re=u, TransitionComponent: ie=nc} = t
      , ue = dr(t, qD)
      , ce = Pe.useRef(null)
      , X = ki(ce, o.ref, i)
      , me = J => he => {
        if (J) {
            const ve = ce.current;
            he === void 0 ? J(ve) : J(ve, he)
        }
    }
      , K = me(z)
      , be = me( (J, he) => {
        Ux(J);
        const ve = Op({
            style: V,
            timeout: re,
            easing: w
        }, {
            mode: "enter"
        });
        J.style.webkitTransition = s.transitions.create("opacity", ve),
        J.style.transition = s.transitions.create("opacity", ve),
        k && k(J, he)
    }
    )
      , Ee = me(L)
      , Ce = me(U)
      , He = me(J => {
        const he = Op({
            style: V,
            timeout: re,
            easing: w
        }, {
            mode: "exit"
        });
        J.style.webkitTransition = s.transitions.create("opacity", he),
        J.style.transition = s.transitions.create("opacity", he),
        D && D(J)
    }
    )
      , ct = me(N)
      , nt = J => {
        d && d(ce.current, J)
    }
    ;
    return G.jsx(ie, xe({
        appear: f,
        in: T,
        nodeRef: ce,
        onEnter: be,
        onEntered: Ee,
        onEntering: K,
        onExit: He,
        onExited: ct,
        onExiting: Ce,
        addEndListener: nt,
        timeout: re
    }, ue, {
        children: (J, he) => Pe.cloneElement(o, xe({
            style: xe({
                opacity: 0,
                visibility: J === "exited" && !T ? "hidden" : void 0
            }, HD[J], V, o.props.style),
            ref: X
        }, he))
    }))
});
function ZD(e) {
    return Kr("MuiBackdrop", e)
}
Qr("MuiBackdrop", ["root", "invisible"]);
const XD = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"]
  , YD = e => {
    const {classes: t, invisible: i} = e;
    return Jr({
        root: ["root", i && "invisible"]
    }, ZD, t)
}
  , KD = Jt("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, i.invisible && t.invisible]
    }
})( ({ownerState: e}) => xe({
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent"
}, e.invisible && {
    backgroundColor: "transparent"
}))
  , mT = Pe.forwardRef(function(t, i) {
    var s, u, d;
    const f = nn({
        props: t,
        name: "MuiBackdrop"
    })
      , {children: o, className: w, component: T="div", components: k={}, componentsProps: L={}, invisible: z=!1, open: D, slotProps: N={}, slots: U={}, TransitionComponent: V=pT, transitionDuration: re} = f
      , ie = dr(f, XD)
      , ue = xe({}, f, {
        component: T,
        invisible: z
    })
      , ce = YD(ue)
      , X = (s = N.root) != null ? s : L.root;
    return G.jsx(V, xe({
        in: D,
        timeout: re
    }, ie, {
        children: G.jsx(KD, xe({
            "aria-hidden": !0
        }, X, {
            as: (u = (d = U.root) != null ? d : k.Root) != null ? u : T,
            className: nr(ce.root, w, X?.className),
            ownerState: xe({}, ue, X?.ownerState),
            classes: ce,
            ref: i,
            children: o
        }))
    }))
})
  , QD = rc(G.jsx("path", {
    d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), "MoreHoriz")
  , JD = ["slots", "slotProps"]
  , eL = Jt(Kh)( ({theme: e}) => xe({
    display: "flex",
    marginLeft: `calc(${e.spacing(1)} * 0.5)`,
    marginRight: `calc(${e.spacing(1)} * 0.5)`
}, e.palette.mode === "light" ? {
    backgroundColor: e.palette.grey[100],
    color: e.palette.grey[700]
} : {
    backgroundColor: e.palette.grey[700],
    color: e.palette.grey[100]
}, {
    borderRadius: 2,
    "&:hover, &:focus": xe({}, e.palette.mode === "light" ? {
        backgroundColor: e.palette.grey[200]
    } : {
        backgroundColor: e.palette.grey[600]
    }),
    "&:active": xe({
        boxShadow: e.shadows[0]
    }, e.palette.mode === "light" ? {
        backgroundColor: Or.emphasize(e.palette.grey[200], .12)
    } : {
        backgroundColor: Or.emphasize(e.palette.grey[600], .12)
    })
}))
  , tL = Jt(QD)({
    width: 24,
    height: 16
});
function rL(e) {
    const {slots: t={}, slotProps: i={}} = e
      , s = dr(e, JD)
      , u = e;
    return G.jsx("li", {
        children: G.jsx(eL, xe({
            focusRipple: !0
        }, s, {
            ownerState: u,
            children: G.jsx(tL, xe({
                as: t.CollapsedIcon,
                ownerState: u
            }, i.collapsedIcon))
        }))
    })
}
function nL(e) {
    return Kr("MuiBreadcrumbs", e)
}
const iL = Qr("MuiBreadcrumbs", ["root", "ol", "li", "separator"])
  , oL = ["children", "className", "component", "slots", "slotProps", "expandText", "itemsAfterCollapse", "itemsBeforeCollapse", "maxItems", "separator"]
  , sL = e => {
    const {classes: t} = e;
    return Jr({
        root: ["root"],
        li: ["li"],
        ol: ["ol"],
        separator: ["separator"]
    }, nL, t)
}
  , aL = Jt(qt, {
    name: "MuiBreadcrumbs",
    slot: "Root",
    overridesResolver: (e, t) => [{
        [`& .${iL.li}`]: t.li
    }, t.root]
})({})
  , lL = Jt("ol", {
    name: "MuiBreadcrumbs",
    slot: "Ol",
    overridesResolver: (e, t) => t.ol
})({
    display: "flex",
    flexWrap: "wrap",
    alignItems: "center",
    padding: 0,
    margin: 0,
    listStyle: "none"
})
  , cL = Jt("li", {
    name: "MuiBreadcrumbs",
    slot: "Separator",
    overridesResolver: (e, t) => t.separator
})({
    display: "flex",
    userSelect: "none",
    marginLeft: 8,
    marginRight: 8
});
function uL(e, t, i, s) {
    return e.reduce( (u, d, f) => (f < e.length - 1 ? u = u.concat(d, G.jsx(cL, {
        "aria-hidden": !0,
        className: t,
        ownerState: s,
        children: i
    }, `separator-${f}`)) : u.push(d),
    u), [])
}
const hL = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiBreadcrumbs"
    })
      , {children: u, className: d, component: f="nav", slots: o={}, slotProps: w={}, expandText: T="Show path", itemsAfterCollapse: k=1, itemsBeforeCollapse: L=1, maxItems: z=8, separator: D="/"} = s
      , N = dr(s, oL)
      , [U,V] = Pe.useState(!1)
      , re = xe({}, s, {
        component: f,
        expanded: U,
        expandText: T,
        itemsAfterCollapse: k,
        itemsBeforeCollapse: L,
        maxItems: z,
        separator: D
    })
      , ie = sL(re)
      , ue = cl({
        elementType: o.CollapsedIcon,
        externalSlotProps: w.collapsedIcon,
        ownerState: re
    })
      , ce = Pe.useRef(null)
      , X = K => {
        const be = () => {
            V(!0);
            const Ee = ce.current.querySelector("a[href],button,[tabindex]");
            Ee && Ee.focus()
        }
        ;
        return L + k >= K.length ? K : [...K.slice(0, L), G.jsx(rL, {
            "aria-label": T,
            slots: {
                CollapsedIcon: o.CollapsedIcon
            },
            slotProps: {
                collapsedIcon: ue
            },
            onClick: be
        }, "ellipsis"), ...K.slice(K.length - k, K.length)]
    }
      , me = Pe.Children.toArray(u).filter(K => Pe.isValidElement(K)).map( (K, be) => G.jsx("li", {
        className: ie.li,
        children: K
    }, `child-${be}`));
    return G.jsx(aL, xe({
        ref: i,
        component: f,
        color: "text.secondary",
        className: nr(ie.root, d),
        ownerState: re
    }, N, {
        children: G.jsx(lL, {
            className: ie.ol,
            ref: ce,
            ownerState: re,
            children: uL(U || z && me.length <= z ? me : X(me), ie.separator, D, re)
        })
    }))
});
function dL(e) {
    return Kr("MuiButton", e)
}
const r_ = Qr("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"])
  , fL = Pe.createContext({})
  , pL = Pe.createContext(void 0)
  , mL = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"]
  , gL = e => {
    const {color: t, disableElevation: i, fullWidth: s, size: u, variant: d, classes: f} = e
      , o = {
        root: ["root", d, `${d}${Ot(t)}`, `size${Ot(u)}`, `${d}Size${Ot(u)}`, `color${Ot(t)}`, i && "disableElevation", s && "fullWidth"],
        label: ["label"],
        startIcon: ["icon", "startIcon", `iconSize${Ot(u)}`],
        endIcon: ["icon", "endIcon", `iconSize${Ot(u)}`]
    }
      , w = Jr(o, dL, f);
    return xe({}, f, w)
}
  , gT = e => xe({}, e.size === "small" && {
    "& > *:nth-of-type(1)": {
        fontSize: 18
    }
}, e.size === "medium" && {
    "& > *:nth-of-type(1)": {
        fontSize: 20
    }
}, e.size === "large" && {
    "& > *:nth-of-type(1)": {
        fontSize: 22
    }
})
  , yL = Jt(Kh, {
    shouldForwardProp: e => ed(e) || e === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, t[i.variant], t[`${i.variant}${Ot(i.color)}`], t[`size${Ot(i.size)}`], t[`${i.variant}Size${Ot(i.size)}`], i.color === "inherit" && t.colorInherit, i.disableElevation && t.disableElevation, i.fullWidth && t.fullWidth]
    }
})( ({theme: e, ownerState: t}) => {
    var i, s;
    const u = e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800]
      , d = e.palette.mode === "light" ? e.palette.grey.A100 : e.palette.grey[700];
    return xe({}, e.typography.button, {
        minWidth: 64,
        padding: "6px 16px",
        borderRadius: (e.vars || e).shape.borderRadius,
        transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
            duration: e.transitions.duration.short
        }),
        "&:hover": xe({
            textDecoration: "none",
            backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : Or.alpha(e.palette.text.primary, e.palette.action.hoverOpacity),
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        }, t.variant === "text" && t.color !== "inherit" && {
            backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Or.alpha(e.palette[t.color].main, e.palette.action.hoverOpacity),
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        }, t.variant === "outlined" && t.color !== "inherit" && {
            border: `1px solid ${(e.vars || e).palette[t.color].main}`,
            backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Or.alpha(e.palette[t.color].main, e.palette.action.hoverOpacity),
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        }, t.variant === "contained" && {
            backgroundColor: e.vars ? e.vars.palette.Button.inheritContainedHoverBg : d,
            boxShadow: (e.vars || e).shadows[4],
            "@media (hover: none)": {
                boxShadow: (e.vars || e).shadows[2],
                backgroundColor: (e.vars || e).palette.grey[300]
            }
        }, t.variant === "contained" && t.color !== "inherit" && {
            backgroundColor: (e.vars || e).palette[t.color].dark,
            "@media (hover: none)": {
                backgroundColor: (e.vars || e).palette[t.color].main
            }
        }),
        "&:active": xe({}, t.variant === "contained" && {
            boxShadow: (e.vars || e).shadows[8]
        }),
        [`&.${r_.focusVisible}`]: xe({}, t.variant === "contained" && {
            boxShadow: (e.vars || e).shadows[6]
        }),
        [`&.${r_.disabled}`]: xe({
            color: (e.vars || e).palette.action.disabled
        }, t.variant === "outlined" && {
            border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
        }, t.variant === "contained" && {
            color: (e.vars || e).palette.action.disabled,
            boxShadow: (e.vars || e).shadows[0],
            backgroundColor: (e.vars || e).palette.action.disabledBackground
        })
    }, t.variant === "text" && {
        padding: "6px 8px"
    }, t.variant === "text" && t.color !== "inherit" && {
        color: (e.vars || e).palette[t.color].main
    }, t.variant === "outlined" && {
        padding: "5px 15px",
        border: "1px solid currentColor"
    }, t.variant === "outlined" && t.color !== "inherit" && {
        color: (e.vars || e).palette[t.color].main,
        border: e.vars ? `1px solid rgba(${e.vars.palette[t.color].mainChannel} / 0.5)` : `1px solid ${Or.alpha(e.palette[t.color].main, .5)}`
    }, t.variant === "contained" && {
        color: e.vars ? e.vars.palette.text.primary : (i = (s = e.palette).getContrastText) == null ? void 0 : i.call(s, e.palette.grey[300]),
        backgroundColor: e.vars ? e.vars.palette.Button.inheritContainedBg : u,
        boxShadow: (e.vars || e).shadows[2]
    }, t.variant === "contained" && t.color !== "inherit" && {
        color: (e.vars || e).palette[t.color].contrastText,
        backgroundColor: (e.vars || e).palette[t.color].main
    }, t.color === "inherit" && {
        color: "inherit",
        borderColor: "currentColor"
    }, t.size === "small" && t.variant === "text" && {
        padding: "4px 5px",
        fontSize: e.typography.pxToRem(13)
    }, t.size === "large" && t.variant === "text" && {
        padding: "8px 11px",
        fontSize: e.typography.pxToRem(15)
    }, t.size === "small" && t.variant === "outlined" && {
        padding: "3px 9px",
        fontSize: e.typography.pxToRem(13)
    }, t.size === "large" && t.variant === "outlined" && {
        padding: "7px 21px",
        fontSize: e.typography.pxToRem(15)
    }, t.size === "small" && t.variant === "contained" && {
        padding: "4px 10px",
        fontSize: e.typography.pxToRem(13)
    }, t.size === "large" && t.variant === "contained" && {
        padding: "8px 22px",
        fontSize: e.typography.pxToRem(15)
    }, t.fullWidth && {
        width: "100%"
    })
}
, ({ownerState: e}) => e.disableElevation && {
    boxShadow: "none",
    "&:hover": {
        boxShadow: "none"
    },
    [`&.${r_.focusVisible}`]: {
        boxShadow: "none"
    },
    "&:active": {
        boxShadow: "none"
    },
    [`&.${r_.disabled}`]: {
        boxShadow: "none"
    }
})
  , _L = Jt("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.startIcon, t[`iconSize${Ot(i.size)}`]]
    }
})( ({ownerState: e}) => xe({
    display: "inherit",
    marginRight: 8,
    marginLeft: -4
}, e.size === "small" && {
    marginLeft: -2
}, gT(e)))
  , vL = Jt("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.endIcon, t[`iconSize${Ot(i.size)}`]]
    }
})( ({ownerState: e}) => xe({
    display: "inherit",
    marginRight: -4,
    marginLeft: 8
}, e.size === "small" && {
    marginRight: -2
}, gT(e)))
  , Qx = Pe.forwardRef(function(t, i) {
    const s = Pe.useContext(fL)
      , u = Pe.useContext(pL)
      , d = Zg(s, t)
      , f = nn({
        props: d,
        name: "MuiButton"
    })
      , {children: o, color: w="primary", component: T="button", className: k, disabled: L=!1, disableElevation: z=!1, disableFocusRipple: D=!1, endIcon: N, focusVisibleClassName: U, fullWidth: V=!1, size: re="medium", startIcon: ie, type: ue, variant: ce="text"} = f
      , X = dr(f, mL)
      , me = xe({}, f, {
        color: w,
        component: T,
        disabled: L,
        disableElevation: z,
        disableFocusRipple: D,
        fullWidth: V,
        size: re,
        type: ue,
        variant: ce
    })
      , K = gL(me)
      , be = ie && G.jsx(_L, {
        className: K.startIcon,
        ownerState: me,
        children: ie
    })
      , Ee = N && G.jsx(vL, {
        className: K.endIcon,
        ownerState: me,
        children: N
    })
      , Ce = u || "";
    return G.jsxs(yL, xe({
        ownerState: me,
        className: nr(s.className, K.root, k, Ce),
        component: T,
        disabled: L,
        focusRipple: !D,
        focusVisibleClassName: nr(K.focusVisible, U),
        ref: i,
        type: ue
    }, X, {
        classes: K,
        children: [be, o, Ee]
    }))
});
function xL(e) {
    return Kr("MuiCard", e)
}
Qr("MuiCard", ["root"]);
const bL = ["className", "raised"]
  , wL = e => {
    const {classes: t} = e;
    return Jr({
        root: ["root"]
    }, xL, t)
}
  , SL = Jt(fy, {
    name: "MuiCard",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})( () => ({
    overflow: "hidden"
}))
  , CL = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiCard"
    })
      , {className: u, raised: d=!1} = s
      , f = dr(s, bL)
      , o = xe({}, s, {
        raised: d
    })
      , w = wL(o);
    return G.jsx(SL, xe({
        className: nr(w.root, u),
        elevation: d ? 8 : void 0,
        ref: i,
        ownerState: o
    }, f))
});
function TL(e) {
    return Kr("MuiCardActions", e)
}
Qr("MuiCardActions", ["root", "spacing"]);
const PL = ["disableSpacing", "className"]
  , ML = e => {
    const {classes: t, disableSpacing: i} = e;
    return Jr({
        root: ["root", !i && "spacing"]
    }, TL, t)
}
  , kL = Jt("div", {
    name: "MuiCardActions",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, !i.disableSpacing && t.spacing]
    }
})( ({ownerState: e}) => xe({
    display: "flex",
    alignItems: "center",
    padding: 8
}, !e.disableSpacing && {
    "& > :not(style) ~ :not(style)": {
        marginLeft: 8
    }
}))
  , Jx = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiCardActions"
    })
      , {disableSpacing: u=!1, className: d} = s
      , f = dr(s, PL)
      , o = xe({}, s, {
        disableSpacing: u
    })
      , w = ML(o);
    return G.jsx(kL, xe({
        className: nr(w.root, d),
        ownerState: o,
        ref: i
    }, f))
});
function EL(e) {
    return Kr("MuiCardContent", e)
}
Qr("MuiCardContent", ["root"]);
const IL = ["className", "component"]
  , RL = e => {
    const {classes: t} = e;
    return Jr({
        root: ["root"]
    }, EL, t)
}
  , AL = Jt("div", {
    name: "MuiCardContent",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})( () => ({
    padding: 16,
    "&:last-child": {
        paddingBottom: 24
    }
}))
  , zL = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiCardContent"
    })
      , {className: u, component: d="div"} = s
      , f = dr(s, IL)
      , o = xe({}, s, {
        component: d
    })
      , w = RL(o);
    return G.jsx(AL, xe({
        as: d,
        className: nr(w.root, u),
        ownerState: o,
        ref: i
    }, f))
});
function DL(e) {
    return Kr("PrivateSwitchBase", e)
}
Qr("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const LL = ["autoFocus", "checked", "checkedIcon", "className", "defaultChecked", "disabled", "disableFocusRipple", "edge", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"]
  , OL = e => {
    const {classes: t, checked: i, disabled: s, edge: u} = e
      , d = {
        root: ["root", i && "checked", s && "disabled", u && `edge${Ot(u)}`],
        input: ["input"]
    };
    return Jr(d, DL, t)
}
  , FL = Jt(Kh)( ({ownerState: e}) => xe({
    padding: 9,
    borderRadius: "50%"
}, e.edge === "start" && {
    marginLeft: e.size === "small" ? -3 : -12
}, e.edge === "end" && {
    marginRight: e.size === "small" ? -3 : -12
}))
  , BL = Jt("input", {
    shouldForwardProp: ed
})({
    cursor: "inherit",
    position: "absolute",
    opacity: 0,
    width: "100%",
    height: "100%",
    top: 0,
    left: 0,
    margin: 0,
    padding: 0,
    zIndex: 1
})
  , eb = Pe.forwardRef(function(t, i) {
    const {autoFocus: s, checked: u, checkedIcon: d, className: f, defaultChecked: o, disabled: w, disableFocusRipple: T=!1, edge: k=!1, icon: L, id: z, inputProps: D, inputRef: N, name: U, onBlur: V, onChange: re, onFocus: ie, readOnly: ue, required: ce=!1, tabIndex: X, type: me, value: K} = t
      , be = dr(t, LL)
      , [Ee,Ce] = uy({
        controlled: u,
        default: !!o,
        name: "SwitchBase",
        state: "checked"
    })
      , He = gy()
      , ct = lt => {
        ie && ie(lt),
        He && He.onFocus && He.onFocus(lt)
    }
      , nt = lt => {
        V && V(lt),
        He && He.onBlur && He.onBlur(lt)
    }
      , J = lt => {
        if (lt.nativeEvent.defaultPrevented)
            return;
        const Pt = lt.target.checked;
        Ce(Pt),
        re && re(lt, Pt)
    }
    ;
    let he = w;
    He && typeof he > "u" && (he = He.disabled);
    const ve = me === "checkbox" || me === "radio"
      , Ne = xe({}, t, {
        checked: Ee,
        disabled: he,
        disableFocusRipple: T,
        edge: k
    })
      , je = OL(Ne);
    return G.jsxs(FL, xe({
        component: "span",
        className: nr(je.root, f),
        centerRipple: !0,
        focusRipple: !T,
        disabled: he,
        tabIndex: null,
        role: void 0,
        onFocus: ct,
        onBlur: nt,
        ownerState: Ne,
        ref: i
    }, be, {
        children: [G.jsx(BL, xe({
            autoFocus: s,
            checked: u,
            defaultChecked: o,
            className: je.input,
            disabled: he,
            id: ve ? z : void 0,
            name: U,
            onChange: J,
            readOnly: ue,
            ref: N,
            required: ce,
            ownerState: Ne,
            tabIndex: X,
            type: me
        }, me === "checkbox" && K === void 0 ? {} : {
            value: K
        }, D)), Ee ? d : L]
    }))
})
  , jL = rc(G.jsx("path", {
    d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}), "CheckBoxOutlineBlank")
  , NL = rc(G.jsx("path", {
    d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}), "CheckBox")
  , $L = rc(G.jsx("path", {
    d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}), "IndeterminateCheckBox");
function VL(e) {
    return Kr("MuiCheckbox", e)
}
const w0 = Qr("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"])
  , UL = ["checkedIcon", "color", "icon", "indeterminate", "indeterminateIcon", "inputProps", "size", "className"]
  , GL = e => {
    const {classes: t, indeterminate: i, color: s, size: u} = e
      , d = {
        root: ["root", i && "indeterminate", `color${Ot(s)}`, `size${Ot(u)}`]
    }
      , f = Jr(d, VL, t);
    return xe({}, t, f)
}
  , WL = Jt(eb, {
    shouldForwardProp: e => ed(e) || e === "classes",
    name: "MuiCheckbox",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, i.indeterminate && t.indeterminate, t[`size${Ot(i.size)}`], i.color !== "default" && t[`color${Ot(i.color)}`]]
    }
})( ({theme: e, ownerState: t}) => xe({
    color: (e.vars || e).palette.text.secondary
}, !t.disableRipple && {
    "&:hover": {
        backgroundColor: e.vars ? `rgba(${t.color === "default" ? e.vars.palette.action.activeChannel : e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Or.alpha(t.color === "default" ? e.palette.action.active : e.palette[t.color].main, e.palette.action.hoverOpacity),
        "@media (hover: none)": {
            backgroundColor: "transparent"
        }
    }
}, t.color !== "default" && {
    [`&.${w0.checked}, &.${w0.indeterminate}`]: {
        color: (e.vars || e).palette[t.color].main
    },
    [`&.${w0.disabled}`]: {
        color: (e.vars || e).palette.action.disabled
    }
}))
  , qL = G.jsx(NL, {})
  , HL = G.jsx(jL, {})
  , ZL = G.jsx($L, {})
  , yT = Pe.forwardRef(function(t, i) {
    var s, u;
    const d = nn({
        props: t,
        name: "MuiCheckbox"
    })
      , {checkedIcon: f=qL, color: o="primary", icon: w=HL, indeterminate: T=!1, indeterminateIcon: k=ZL, inputProps: L, size: z="medium", className: D} = d
      , N = dr(d, UL)
      , U = T ? k : w
      , V = T ? k : f
      , re = xe({}, d, {
        color: o,
        indeterminate: T,
        size: z
    })
      , ie = GL(re);
    return G.jsx(WL, xe({
        type: "checkbox",
        inputProps: xe({
            "data-indeterminate": T
        }, L),
        icon: Pe.cloneElement(U, {
            fontSize: (s = U.props.fontSize) != null ? s : z
        }),
        checkedIcon: Pe.cloneElement(V, {
            fontSize: (u = V.props.fontSize) != null ? u : z
        }),
        ownerState: re,
        ref: i,
        className: nr(ie.root, D)
    }, N, {
        classes: ie
    }))
});
function XL(e) {
    const t = js(e);
    return t.body === e ? Yh(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight
}
function Bg(e, t) {
    t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden")
}
function Cw(e) {
    return parseInt(Yh(e).getComputedStyle(e).paddingRight, 10) || 0
}
function YL(e) {
    const i = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].indexOf(e.tagName) !== -1
      , s = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
    return i || s
}
function Tw(e, t, i, s, u) {
    const d = [t, i, ...s];
    [].forEach.call(e.children, f => {
        const o = d.indexOf(f) === -1
          , w = !YL(f);
        o && w && Bg(f, u)
    }
    )
}
function S0(e, t) {
    let i = -1;
    return e.some( (s, u) => t(s) ? (i = u,
    !0) : !1),
    i
}
function KL(e, t) {
    const i = []
      , s = e.container;
    if (!t.disableScrollLock) {
        if (XL(s)) {
            const f = KI(js(s));
            i.push({
                value: s.style.paddingRight,
                property: "padding-right",
                el: s
            }),
            s.style.paddingRight = `${Cw(s) + f}px`;
            const o = js(s).querySelectorAll(".mui-fixed");
            [].forEach.call(o, w => {
                i.push({
                    value: w.style.paddingRight,
                    property: "padding-right",
                    el: w
                }),
                w.style.paddingRight = `${Cw(w) + f}px`
            }
            )
        }
        let d;
        if (s.parentNode instanceof DocumentFragment)
            d = js(s).body;
        else {
            const f = s.parentElement
              , o = Yh(s);
            d = f?.nodeName === "HTML" && o.getComputedStyle(f).overflowY === "scroll" ? f : s
        }
        i.push({
            value: d.style.overflow,
            property: "overflow",
            el: d
        }, {
            value: d.style.overflowX,
            property: "overflow-x",
            el: d
        }, {
            value: d.style.overflowY,
            property: "overflow-y",
            el: d
        }),
        d.style.overflow = "hidden"
    }
    return () => {
        i.forEach( ({value: d, el: f, property: o}) => {
            d ? f.style.setProperty(o, d) : f.style.removeProperty(o)
        }
        )
    }
}
function QL(e) {
    const t = [];
    return [].forEach.call(e.children, i => {
        i.getAttribute("aria-hidden") === "true" && t.push(i)
    }
    ),
    t
}
class JL {
    constructor() {
        this.containers = void 0,
        this.modals = void 0,
        this.modals = [],
        this.containers = []
    }
    add(t, i) {
        let s = this.modals.indexOf(t);
        if (s !== -1)
            return s;
        s = this.modals.length,
        this.modals.push(t),
        t.modalRef && Bg(t.modalRef, !1);
        const u = QL(i);
        Tw(i, t.mount, t.modalRef, u, !0);
        const d = S0(this.containers, f => f.container === i);
        return d !== -1 ? (this.containers[d].modals.push(t),
        s) : (this.containers.push({
            modals: [t],
            container: i,
            restore: null,
            hiddenSiblings: u
        }),
        s)
    }
    mount(t, i) {
        const s = S0(this.containers, d => d.modals.indexOf(t) !== -1)
          , u = this.containers[s];
        u.restore || (u.restore = KL(u, i))
    }
    remove(t, i=!0) {
        const s = this.modals.indexOf(t);
        if (s === -1)
            return s;
        const u = S0(this.containers, f => f.modals.indexOf(t) !== -1)
          , d = this.containers[u];
        if (d.modals.splice(d.modals.indexOf(t), 1),
        this.modals.splice(s, 1),
        d.modals.length === 0)
            d.restore && d.restore(),
            t.modalRef && Bg(t.modalRef, i),
            Tw(d.container, t.mount, t.modalRef, d.hiddenSiblings, !1),
            this.containers.splice(u, 1);
        else {
            const f = d.modals[d.modals.length - 1];
            f.modalRef && Bg(f.modalRef, !1)
        }
        return s
    }
    isTopModal(t) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === t
    }
}
const eO = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function tO(e) {
    const t = parseInt(e.getAttribute("tabindex") || "", 10);
    return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t
}
function rO(e) {
    if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
        return !1;
    const t = s => e.ownerDocument.querySelector(`input[type="radio"]${s}`);
    let i = t(`[name="${e.name}"]:checked`);
    return i || (i = t(`[name="${e.name}"]`)),
    i !== e
}
function nO(e) {
    return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || rO(e))
}
function iO(e) {
    const t = []
      , i = [];
    return Array.from(e.querySelectorAll(eO)).forEach( (s, u) => {
        const d = tO(s);
        d === -1 || !nO(s) || (d === 0 ? t.push(s) : i.push({
            documentOrder: u,
            tabIndex: d,
            node: s
        }))
    }
    ),
    i.sort( (s, u) => s.tabIndex === u.tabIndex ? s.documentOrder - u.documentOrder : s.tabIndex - u.tabIndex).map(s => s.node).concat(t)
}
function oO() {
    return !0
}
function sO(e) {
    const {children: t, disableAutoFocus: i=!1, disableEnforceFocus: s=!1, disableRestoreFocus: u=!1, getTabbable: d=iO, isEnabled: f=oO, open: o} = e
      , w = Pe.useRef(!1)
      , T = Pe.useRef(null)
      , k = Pe.useRef(null)
      , L = Pe.useRef(null)
      , z = Pe.useRef(null)
      , D = Pe.useRef(!1)
      , N = Pe.useRef(null)
      , U = ki(t.ref, N)
      , V = Pe.useRef(null);
    Pe.useEffect( () => {
        !o || !N.current || (D.current = !i)
    }
    , [i, o]),
    Pe.useEffect( () => {
        if (!o || !N.current)
            return;
        const ue = js(N.current);
        return N.current.contains(ue.activeElement) || (N.current.hasAttribute("tabIndex") || N.current.setAttribute("tabIndex", "-1"),
        D.current && N.current.focus()),
        () => {
            u || (L.current && L.current.focus && (w.current = !0,
            L.current.focus()),
            L.current = null)
        }
    }
    , [o]),
    Pe.useEffect( () => {
        if (!o || !N.current)
            return;
        const ue = js(N.current)
          , ce = K => {
            V.current = K,
            !(s || !f() || K.key !== "Tab") && ue.activeElement === N.current && K.shiftKey && (w.current = !0,
            k.current && k.current.focus())
        }
          , X = () => {
            const K = N.current;
            if (K === null)
                return;
            if (!ue.hasFocus() || !f() || w.current) {
                w.current = !1;
                return
            }
            if (K.contains(ue.activeElement) || s && ue.activeElement !== T.current && ue.activeElement !== k.current)
                return;
            if (ue.activeElement !== z.current)
                z.current = null;
            else if (z.current !== null)
                return;
            if (!D.current)
                return;
            let be = [];
            if ((ue.activeElement === T.current || ue.activeElement === k.current) && (be = d(N.current)),
            be.length > 0) {
                var Ee, Ce;
                const He = !!((Ee = V.current) != null && Ee.shiftKey && ((Ce = V.current) == null ? void 0 : Ce.key) === "Tab")
                  , ct = be[0]
                  , nt = be[be.length - 1];
                typeof ct != "string" && typeof nt != "string" && (He ? nt.focus() : ct.focus())
            } else
                K.focus()
        }
        ;
        ue.addEventListener("focusin", X),
        ue.addEventListener("keydown", ce, !0);
        const me = setInterval( () => {
            ue.activeElement && ue.activeElement.tagName === "BODY" && X()
        }
        , 50);
        return () => {
            clearInterval(me),
            ue.removeEventListener("focusin", X),
            ue.removeEventListener("keydown", ce, !0)
        }
    }
    , [i, s, u, f, o, d]);
    const re = ue => {
        L.current === null && (L.current = ue.relatedTarget),
        D.current = !0,
        z.current = ue.target;
        const ce = t.props.onFocus;
        ce && ce(ue)
    }
      , ie = ue => {
        L.current === null && (L.current = ue.relatedTarget),
        D.current = !0
    }
    ;
    return G.jsxs(Pe.Fragment, {
        children: [G.jsx("div", {
            tabIndex: o ? 0 : -1,
            onFocus: ie,
            ref: T,
            "data-testid": "sentinelStart"
        }), Pe.cloneElement(t, {
            ref: U,
            onFocus: re
        }), G.jsx("div", {
            tabIndex: o ? 0 : -1,
            onFocus: ie,
            ref: k,
            "data-testid": "sentinelEnd"
        })]
    })
}
function aO(e) {
    return typeof e == "function" ? e() : e
}
function lO(e) {
    return e ? e.props.hasOwnProperty("in") : !1
}
const cO = new JL;
function uO(e) {
    const {container: t, disableEscapeKeyDown: i=!1, disableScrollLock: s=!1, manager: u=cO, closeAfterTransition: d=!1, onTransitionEnter: f, onTransitionExited: o, children: w, onClose: T, open: k, rootRef: L} = e
      , z = Pe.useRef({})
      , D = Pe.useRef(null)
      , N = Pe.useRef(null)
      , U = ki(N, L)
      , [V,re] = Pe.useState(!k)
      , ie = lO(w);
    let ue = !0;
    (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (ue = !1);
    const ce = () => js(D.current)
      , X = () => (z.current.modalRef = N.current,
    z.current.mount = D.current,
    z.current)
      , me = () => {
        u.mount(X(), {
            disableScrollLock: s
        }),
        N.current && (N.current.scrollTop = 0)
    }
      , K = dl( () => {
        const ve = aO(t) || ce().body;
        u.add(X(), ve),
        N.current && me()
    }
    )
      , be = Pe.useCallback( () => u.isTopModal(X()), [u])
      , Ee = dl(ve => {
        D.current = ve,
        ve && (k && be() ? me() : N.current && Bg(N.current, ue))
    }
    )
      , Ce = Pe.useCallback( () => {
        u.remove(X(), ue)
    }
    , [ue, u]);
    Pe.useEffect( () => () => {
        Ce()
    }
    , [Ce]),
    Pe.useEffect( () => {
        k ? K() : (!ie || !d) && Ce()
    }
    , [k, Ce, ie, d, K]);
    const He = ve => Ne => {
        var je;
        (je = ve.onKeyDown) == null || je.call(ve, Ne),
        !(Ne.key !== "Escape" || Ne.which === 229 || !be()) && (i || (Ne.stopPropagation(),
        T && T(Ne, "escapeKeyDown")))
    }
      , ct = ve => Ne => {
        var je;
        (je = ve.onClick) == null || je.call(ve, Ne),
        Ne.target === Ne.currentTarget && T && T(Ne, "backdropClick")
    }
    ;
    return {
        getRootProps: (ve={}) => {
            const Ne = Dg(e);
            delete Ne.onTransitionEnter,
            delete Ne.onTransitionExited;
            const je = xe({}, Ne, ve);
            return xe({
                role: "presentation"
            }, je, {
                onKeyDown: He(je),
                ref: U
            })
        }
        ,
        getBackdropProps: (ve={}) => {
            const Ne = ve;
            return xe({
                "aria-hidden": !0
            }, Ne, {
                onClick: ct(Ne),
                open: k
            })
        }
        ,
        getTransitionProps: () => {
            const ve = () => {
                re(!1),
                f && f()
            }
              , Ne = () => {
                re(!0),
                o && o(),
                d && Ce()
            }
            ;
            return {
                onEnter: G_(ve, w?.props.onEnter),
                onExited: G_(Ne, w?.props.onExited)
            }
        }
        ,
        rootRef: U,
        portalRef: Ee,
        isTopModal: be,
        exited: V,
        hasTransition: ie
    }
}
function hO(e) {
    return Kr("MuiModal", e)
}
Qr("MuiModal", ["root", "hidden", "backdrop"]);
const dO = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"]
  , fO = e => {
    const {open: t, exited: i, classes: s} = e;
    return Jr({
        root: ["root", !t && i && "hidden"],
        backdrop: ["backdrop"]
    }, hO, s)
}
  , pO = Jt("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, !i.open && i.exited && t.hidden]
    }
})( ({theme: e, ownerState: t}) => xe({
    position: "fixed",
    zIndex: (e.vars || e).zIndex.modal,
    right: 0,
    bottom: 0,
    top: 0,
    left: 0
}, !t.open && t.exited && {
    visibility: "hidden"
}))
  , mO = Jt(mT, {
    name: "MuiModal",
    slot: "Backdrop",
    overridesResolver: (e, t) => t.backdrop
})({
    zIndex: -1
})
  , _T = Pe.forwardRef(function(t, i) {
    var s, u, d, f, o, w;
    const T = nn({
        name: "MuiModal",
        props: t
    })
      , {BackdropComponent: k=mO, BackdropProps: L, className: z, closeAfterTransition: D=!1, children: N, container: U, component: V, components: re={}, componentsProps: ie={}, disableAutoFocus: ue=!1, disableEnforceFocus: ce=!1, disableEscapeKeyDown: X=!1, disablePortal: me=!1, disableRestoreFocus: K=!1, disableScrollLock: be=!1, hideBackdrop: Ee=!1, keepMounted: Ce=!1, onBackdropClick: He, open: ct, slotProps: nt, slots: J} = T
      , he = dr(T, dO)
      , ve = xe({}, T, {
        closeAfterTransition: D,
        disableAutoFocus: ue,
        disableEnforceFocus: ce,
        disableEscapeKeyDown: X,
        disablePortal: me,
        disableRestoreFocus: K,
        disableScrollLock: be,
        hideBackdrop: Ee,
        keepMounted: Ce
    })
      , {getRootProps: Ne, getBackdropProps: je, getTransitionProps: lt, portalRef: Pt, isTopModal: We, exited: st, hasTransition: Nt} = uO(xe({}, ve, {
        rootRef: i
    }))
      , zt = xe({}, ve, {
        exited: st
    })
      , Qt = fO(zt)
      , Wt = {};
    if (N.props.tabIndex === void 0 && (Wt.tabIndex = "-1"),
    Nt) {
        const {onEnter: ur, onExited: vr} = lt();
        Wt.onEnter = ur,
        Wt.onExited = vr
    }
    const tr = (s = (u = J?.root) != null ? u : re.Root) != null ? s : pO
      , cr = (d = (f = J?.backdrop) != null ? f : re.Backdrop) != null ? d : k
      , Yt = (o = nt?.root) != null ? o : ie.root
      , Gr = (w = nt?.backdrop) != null ? w : ie.backdrop
      , xr = cl({
        elementType: tr,
        externalSlotProps: Yt,
        externalForwardedProps: he,
        getSlotProps: Ne,
        additionalProps: {
            ref: i,
            as: V
        },
        ownerState: zt,
        className: nr(z, Yt?.className, Qt?.root, !zt.open && zt.exited && Qt?.hidden)
    })
      , Nr = cl({
        elementType: cr,
        externalSlotProps: Gr,
        additionalProps: L,
        getSlotProps: ur => je(xe({}, ur, {
            onClick: vr => {
                He && He(vr),
                ur != null && ur.onClick && ur.onClick(vr)
            }
        })),
        className: nr(Gr?.className, L?.className, Qt?.backdrop),
        ownerState: zt
    });
    return !Ce && !ct && (!Nt || st) ? null : G.jsx(dT, {
        ref: Pt,
        container: U,
        disablePortal: me,
        children: G.jsxs(tr, xe({}, xr, {
            children: [!Ee && k ? G.jsx(cr, xe({}, Nr)) : null, G.jsx(sO, {
                disableEnforceFocus: ce,
                disableAutoFocus: ue,
                disableRestoreFocus: K,
                isEnabled: We,
                open: ct,
                children: Pe.cloneElement(N, Wt)
            })]
        }))
    })
});
function gO(e) {
    return Kr("MuiDialog", e)
}
const C0 = Qr("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"])
  , yO = Pe.createContext({})
  , _O = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"]
  , vO = Jt(mT, {
    name: "MuiDialog",
    slot: "Backdrop",
    overrides: (e, t) => t.backdrop
})({
    zIndex: -1
})
  , xO = e => {
    const {classes: t, scroll: i, maxWidth: s, fullWidth: u, fullScreen: d} = e
      , f = {
        root: ["root"],
        container: ["container", `scroll${Ot(i)}`],
        paper: ["paper", `paperScroll${Ot(i)}`, `paperWidth${Ot(String(s))}`, u && "paperFullWidth", d && "paperFullScreen"]
    };
    return Jr(f, gO, t)
}
  , bO = Jt(_T, {
    name: "MuiDialog",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    "@media print": {
        position: "absolute !important"
    }
})
  , wO = Jt("div", {
    name: "MuiDialog",
    slot: "Container",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.container, t[`scroll${Ot(i.scroll)}`]]
    }
})( ({ownerState: e}) => xe({
    height: "100%",
    "@media print": {
        height: "auto"
    },
    outline: 0
}, e.scroll === "paper" && {
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
}, e.scroll === "body" && {
    overflowY: "auto",
    overflowX: "hidden",
    textAlign: "center",
    "&::after": {
        content: '""',
        display: "inline-block",
        verticalAlign: "middle",
        height: "100%",
        width: "0"
    }
}))
  , SO = Jt(fy, {
    name: "MuiDialog",
    slot: "Paper",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.paper, t[`scrollPaper${Ot(i.scroll)}`], t[`paperWidth${Ot(String(i.maxWidth))}`], i.fullWidth && t.paperFullWidth, i.fullScreen && t.paperFullScreen]
    }
})( ({theme: e, ownerState: t}) => xe({
    margin: 32,
    position: "relative",
    overflowY: "auto",
    "@media print": {
        overflowY: "visible",
        boxShadow: "none"
    }
}, t.scroll === "paper" && {
    display: "flex",
    flexDirection: "column",
    maxHeight: "calc(100% - 64px)"
}, t.scroll === "body" && {
    display: "inline-block",
    verticalAlign: "middle",
    textAlign: "left"
}, !t.maxWidth && {
    maxWidth: "calc(100% - 64px)"
}, t.maxWidth === "xs" && {
    maxWidth: e.breakpoints.unit === "px" ? Math.max(e.breakpoints.values.xs, 444) : `max(${e.breakpoints.values.xs}${e.breakpoints.unit}, 444px)`,
    [`&.${C0.paperScrollBody}`]: {
        [e.breakpoints.down(Math.max(e.breakpoints.values.xs, 444) + 64)]: {
            maxWidth: "calc(100% - 64px)"
        }
    }
}, t.maxWidth && t.maxWidth !== "xs" && {
    maxWidth: `${e.breakpoints.values[t.maxWidth]}${e.breakpoints.unit}`,
    [`&.${C0.paperScrollBody}`]: {
        [e.breakpoints.down(e.breakpoints.values[t.maxWidth] + 64)]: {
            maxWidth: "calc(100% - 64px)"
        }
    }
}, t.fullWidth && {
    width: "calc(100% - 64px)"
}, t.fullScreen && {
    margin: 0,
    width: "100%",
    maxWidth: "100%",
    height: "100%",
    maxHeight: "none",
    borderRadius: 0,
    [`&.${C0.paperScrollBody}`]: {
        margin: 0,
        maxWidth: "100%"
    }
}))
  , wv = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiDialog"
    })
      , u = Kp()
      , d = {
        enter: u.transitions.duration.enteringScreen,
        exit: u.transitions.duration.leavingScreen
    }
      , {"aria-describedby": f, "aria-labelledby": o, BackdropComponent: w, BackdropProps: T, children: k, className: L, disableEscapeKeyDown: z=!1, fullScreen: D=!1, fullWidth: N=!1, maxWidth: U="sm", onBackdropClick: V, onClick: re, onClose: ie, open: ue, PaperComponent: ce=fy, PaperProps: X={}, scroll: me="paper", TransitionComponent: K=pT, transitionDuration: be=d, TransitionProps: Ee} = s
      , Ce = dr(s, _O)
      , He = xe({}, s, {
        disableEscapeKeyDown: z,
        fullScreen: D,
        fullWidth: N,
        maxWidth: U,
        scroll: me
    })
      , ct = xO(He)
      , nt = Pe.useRef()
      , J = je => {
        nt.current = je.target === je.currentTarget
    }
      , he = je => {
        re && re(je),
        nt.current && (nt.current = null,
        V && V(je),
        ie && ie(je, "backdropClick"))
    }
      , ve = yv(o)
      , Ne = Pe.useMemo( () => ({
        titleId: ve
    }), [ve]);
    return G.jsx(bO, xe({
        className: nr(ct.root, L),
        closeAfterTransition: !0,
        components: {
            Backdrop: vO
        },
        componentsProps: {
            backdrop: xe({
                transitionDuration: be,
                as: w
            }, T)
        },
        disableEscapeKeyDown: z,
        onClose: ie,
        open: ue,
        ref: i,
        onClick: he,
        ownerState: He
    }, Ce, {
        children: G.jsx(K, xe({
            appear: !0,
            in: ue,
            timeout: be,
            role: "presentation"
        }, Ee, {
            children: G.jsx(wO, {
                className: nr(ct.container),
                onMouseDown: J,
                ownerState: He,
                children: G.jsx(SO, xe({
                    as: ce,
                    elevation: 24,
                    role: "dialog",
                    "aria-describedby": f,
                    "aria-labelledby": ve
                }, X, {
                    className: nr(ct.paper, X.className),
                    ownerState: He,
                    children: G.jsx(yO.Provider, {
                        value: Ne,
                        children: k
                    })
                }))
            })
        }))
    }))
});
function CO(e) {
    return Kr("MuiDivider", e)
}
Qr("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
const TO = ["absolute", "children", "className", "component", "flexItem", "light", "orientation", "role", "textAlign", "variant"]
  , PO = e => {
    const {absolute: t, children: i, classes: s, flexItem: u, light: d, orientation: f, textAlign: o, variant: w} = e;
    return Jr({
        root: ["root", t && "absolute", w, d && "light", f === "vertical" && "vertical", u && "flexItem", i && "withChildren", i && f === "vertical" && "withChildrenVertical", o === "right" && f !== "vertical" && "textAlignRight", o === "left" && f !== "vertical" && "textAlignLeft"],
        wrapper: ["wrapper", f === "vertical" && "wrapperVertical"]
    }, CO, s)
}
  , MO = Jt("div", {
    name: "MuiDivider",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, i.absolute && t.absolute, t[i.variant], i.light && t.light, i.orientation === "vertical" && t.vertical, i.flexItem && t.flexItem, i.children && t.withChildren, i.children && i.orientation === "vertical" && t.withChildrenVertical, i.textAlign === "right" && i.orientation !== "vertical" && t.textAlignRight, i.textAlign === "left" && i.orientation !== "vertical" && t.textAlignLeft]
    }
})( ({theme: e, ownerState: t}) => xe({
    margin: 0,
    flexShrink: 0,
    borderWidth: 0,
    borderStyle: "solid",
    borderColor: (e.vars || e).palette.divider,
    borderBottomWidth: "thin"
}, t.absolute && {
    position: "absolute",
    bottom: 0,
    left: 0,
    width: "100%"
}, t.light && {
    borderColor: e.vars ? `rgba(${e.vars.palette.dividerChannel} / 0.08)` : Or.alpha(e.palette.divider, .08)
}, t.variant === "inset" && {
    marginLeft: 72
}, t.variant === "middle" && t.orientation === "horizontal" && {
    marginLeft: e.spacing(2),
    marginRight: e.spacing(2)
}, t.variant === "middle" && t.orientation === "vertical" && {
    marginTop: e.spacing(1),
    marginBottom: e.spacing(1)
}, t.orientation === "vertical" && {
    height: "100%",
    borderBottomWidth: 0,
    borderRightWidth: "thin"
}, t.flexItem && {
    alignSelf: "stretch",
    height: "auto"
}), ({ownerState: e}) => xe({}, e.children && {
    display: "flex",
    whiteSpace: "nowrap",
    textAlign: "center",
    border: 0,
    borderTopStyle: "solid",
    borderLeftStyle: "solid",
    "&::before, &::after": {
        content: '""',
        alignSelf: "center"
    }
}), ({theme: e, ownerState: t}) => xe({}, t.children && t.orientation !== "vertical" && {
    "&::before, &::after": {
        width: "100%",
        borderTop: `thin solid ${(e.vars || e).palette.divider}`,
        borderTopStyle: "inherit"
    }
}), ({theme: e, ownerState: t}) => xe({}, t.children && t.orientation === "vertical" && {
    flexDirection: "column",
    "&::before, &::after": {
        height: "100%",
        borderLeft: `thin solid ${(e.vars || e).palette.divider}`,
        borderLeftStyle: "inherit"
    }
}), ({ownerState: e}) => xe({}, e.textAlign === "right" && e.orientation !== "vertical" && {
    "&::before": {
        width: "90%"
    },
    "&::after": {
        width: "10%"
    }
}, e.textAlign === "left" && e.orientation !== "vertical" && {
    "&::before": {
        width: "10%"
    },
    "&::after": {
        width: "90%"
    }
}))
  , kO = Jt("span", {
    name: "MuiDivider",
    slot: "Wrapper",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.wrapper, i.orientation === "vertical" && t.wrapperVertical]
    }
})( ({theme: e, ownerState: t}) => xe({
    display: "inline-block",
    paddingLeft: `calc(${e.spacing(1)} * 1.2)`,
    paddingRight: `calc(${e.spacing(1)} * 1.2)`
}, t.orientation === "vertical" && {
    paddingTop: `calc(${e.spacing(1)} * 1.2)`,
    paddingBottom: `calc(${e.spacing(1)} * 1.2)`
}))
  , $p = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiDivider"
    })
      , {absolute: u=!1, children: d, className: f, component: o=d ? "div" : "hr", flexItem: w=!1, light: T=!1, orientation: k="horizontal", role: L=o !== "hr" ? "separator" : void 0, textAlign: z="center", variant: D="fullWidth"} = s
      , N = dr(s, TO)
      , U = xe({}, s, {
        absolute: u,
        component: o,
        flexItem: w,
        light: T,
        orientation: k,
        role: L,
        textAlign: z,
        variant: D
    })
      , V = PO(U);
    return G.jsx(MO, xe({
        as: o,
        className: nr(V.root, f),
        role: L,
        ref: i,
        ownerState: U
    }, N, {
        children: d ? G.jsx(kO, {
            className: V.wrapper,
            ownerState: U,
            children: d
        }) : null
    }))
});
$p.muiSkipListHighlight = !0;
const EO = ["addEndListener", "appear", "children", "container", "direction", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function IO(e, t, i) {
    const s = t.getBoundingClientRect()
      , u = i && i.getBoundingClientRect()
      , d = Yh(t);
    let f;
    if (t.fakeTransform)
        f = t.fakeTransform;
    else {
        const T = d.getComputedStyle(t);
        f = T.getPropertyValue("-webkit-transform") || T.getPropertyValue("transform")
    }
    let o = 0
      , w = 0;
    if (f && f !== "none" && typeof f == "string") {
        const T = f.split("(")[1].split(")")[0].split(",");
        o = parseInt(T[4], 10),
        w = parseInt(T[5], 10)
    }
    return e === "left" ? u ? `translateX(${u.right + o - s.left}px)` : `translateX(${d.innerWidth + o - s.left}px)` : e === "right" ? u ? `translateX(-${s.right - u.left - o}px)` : `translateX(-${s.left + s.width - o}px)` : e === "up" ? u ? `translateY(${u.bottom + w - s.top}px)` : `translateY(${d.innerHeight + w - s.top}px)` : u ? `translateY(-${s.top - u.top + s.height - w}px)` : `translateY(-${s.top + s.height - w}px)`
}
function RO(e) {
    return typeof e == "function" ? e() : e
}
function n_(e, t, i) {
    const s = RO(i)
      , u = IO(e, t, s);
    u && (t.style.webkitTransform = u,
    t.style.transform = u)
}
const AO = Pe.forwardRef(function(t, i) {
    const s = Kp()
      , u = {
        enter: s.transitions.easing.easeOut,
        exit: s.transitions.easing.sharp
    }
      , d = {
        enter: s.transitions.duration.enteringScreen,
        exit: s.transitions.duration.leavingScreen
    }
      , {addEndListener: f, appear: o=!0, children: w, container: T, direction: k="down", easing: L=u, in: z, onEnter: D, onEntered: N, onEntering: U, onExit: V, onExited: re, onExiting: ie, style: ue, timeout: ce=d, TransitionComponent: X=nc} = t
      , me = dr(t, EO)
      , K = Pe.useRef(null)
      , be = ki(w.ref, K, i)
      , Ee = je => lt => {
        je && (lt === void 0 ? je(K.current) : je(K.current, lt))
    }
      , Ce = Ee( (je, lt) => {
        n_(k, je, T),
        Ux(je),
        D && D(je, lt)
    }
    )
      , He = Ee( (je, lt) => {
        const Pt = Op({
            timeout: ce,
            style: ue,
            easing: L
        }, {
            mode: "enter"
        });
        je.style.webkitTransition = s.transitions.create("-webkit-transform", xe({}, Pt)),
        je.style.transition = s.transitions.create("transform", xe({}, Pt)),
        je.style.webkitTransform = "none",
        je.style.transform = "none",
        U && U(je, lt)
    }
    )
      , ct = Ee(N)
      , nt = Ee(ie)
      , J = Ee(je => {
        const lt = Op({
            timeout: ce,
            style: ue,
            easing: L
        }, {
            mode: "exit"
        });
        je.style.webkitTransition = s.transitions.create("-webkit-transform", lt),
        je.style.transition = s.transitions.create("transform", lt),
        n_(k, je, T),
        V && V(je)
    }
    )
      , he = Ee(je => {
        je.style.webkitTransition = "",
        je.style.transition = "",
        re && re(je)
    }
    )
      , ve = je => {
        f && f(K.current, je)
    }
      , Ne = Pe.useCallback( () => {
        K.current && n_(k, K.current, T)
    }
    , [k, T]);
    return Pe.useEffect( () => {
        if (z || k === "down" || k === "right")
            return;
        const je = Fx( () => {
            K.current && n_(k, K.current, T)
        }
        )
          , lt = Yh(K.current);
        return lt.addEventListener("resize", je),
        () => {
            je.clear(),
            lt.removeEventListener("resize", je)
        }
    }
    , [k, z, T]),
    Pe.useEffect( () => {
        z || Ne()
    }
    , [z, Ne]),
    G.jsx(X, xe({
        nodeRef: K,
        onEnter: Ce,
        onEntered: ct,
        onEntering: He,
        onExit: J,
        onExited: he,
        onExiting: nt,
        addEndListener: ve,
        appear: o,
        in: z,
        timeout: ce
    }, me, {
        children: (je, lt) => Pe.cloneElement(w, xe({
            ref: be,
            style: xe({
                visibility: je === "exited" && !z ? "hidden" : void 0
            }, ue, w.props.style)
        }, lt))
    }))
});
function zO(e) {
    return Kr("MuiDrawer", e)
}
Qr("MuiDrawer", ["root", "docked", "paper", "paperAnchorLeft", "paperAnchorRight", "paperAnchorTop", "paperAnchorBottom", "paperAnchorDockedLeft", "paperAnchorDockedRight", "paperAnchorDockedTop", "paperAnchorDockedBottom", "modal"]);
const DO = ["BackdropProps"]
  , LO = ["anchor", "BackdropProps", "children", "className", "elevation", "hideBackdrop", "ModalProps", "onClose", "open", "PaperProps", "SlideProps", "TransitionComponent", "transitionDuration", "variant"]
  , vT = (e, t) => {
    const {ownerState: i} = e;
    return [t.root, (i.variant === "permanent" || i.variant === "persistent") && t.docked, t.modal]
}
  , OO = e => {
    const {classes: t, anchor: i, variant: s} = e
      , u = {
        root: ["root"],
        docked: [(s === "permanent" || s === "persistent") && "docked"],
        modal: ["modal"],
        paper: ["paper", `paperAnchor${Ot(i)}`, s !== "temporary" && `paperAnchorDocked${Ot(i)}`]
    };
    return Jr(u, zO, t)
}
  , FO = Jt(_T, {
    name: "MuiDrawer",
    slot: "Root",
    overridesResolver: vT
})( ({theme: e}) => ({
    zIndex: (e.vars || e).zIndex.drawer
}))
  , Pw = Jt("div", {
    shouldForwardProp: ed,
    name: "MuiDrawer",
    slot: "Docked",
    skipVariantsResolver: !1,
    overridesResolver: vT
})({
    flex: "0 0 auto"
})
  , BO = Jt(fy, {
    name: "MuiDrawer",
    slot: "Paper",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.paper, t[`paperAnchor${Ot(i.anchor)}`], i.variant !== "temporary" && t[`paperAnchorDocked${Ot(i.anchor)}`]]
    }
})( ({theme: e, ownerState: t}) => xe({
    overflowY: "auto",
    display: "flex",
    flexDirection: "column",
    height: "100%",
    flex: "1 0 auto",
    zIndex: (e.vars || e).zIndex.drawer,
    WebkitOverflowScrolling: "touch",
    position: "fixed",
    top: 0,
    outline: 0
}, t.anchor === "left" && {
    left: 0
}, t.anchor === "top" && {
    top: 0,
    left: 0,
    right: 0,
    height: "auto",
    maxHeight: "100%"
}, t.anchor === "right" && {
    right: 0
}, t.anchor === "bottom" && {
    top: "auto",
    left: 0,
    bottom: 0,
    right: 0,
    height: "auto",
    maxHeight: "100%"
}, t.anchor === "left" && t.variant !== "temporary" && {
    borderRight: `1px solid ${(e.vars || e).palette.divider}`
}, t.anchor === "top" && t.variant !== "temporary" && {
    borderBottom: `1px solid ${(e.vars || e).palette.divider}`
}, t.anchor === "right" && t.variant !== "temporary" && {
    borderLeft: `1px solid ${(e.vars || e).palette.divider}`
}, t.anchor === "bottom" && t.variant !== "temporary" && {
    borderTop: `1px solid ${(e.vars || e).palette.divider}`
}))
  , xT = {
    left: "right",
    right: "left",
    top: "down",
    bottom: "up"
};
function jO(e) {
    return ["left", "right"].indexOf(e) !== -1
}
function NO({direction: e}, t) {
    return e === "rtl" && jO(t) ? xT[t] : t
}
const $O = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiDrawer"
    })
      , u = Kp()
      , d = Bx()
      , f = {
        enter: u.transitions.duration.enteringScreen,
        exit: u.transitions.duration.leavingScreen
    }
      , {anchor: o="left", BackdropProps: w, children: T, className: k, elevation: L=16, hideBackdrop: z=!1, ModalProps: {BackdropProps: D}={}, onClose: N, open: U=!1, PaperProps: V={}, SlideProps: re, TransitionComponent: ie=AO, transitionDuration: ue=f, variant: ce="temporary"} = s
      , X = dr(s.ModalProps, DO)
      , me = dr(s, LO)
      , K = Pe.useRef(!1);
    Pe.useEffect( () => {
        K.current = !0
    }
    , []);
    const be = NO({
        direction: d ? "rtl" : "ltr"
    }, o)
      , Ce = xe({}, s, {
        anchor: o,
        elevation: L,
        open: U,
        variant: ce
    }, me)
      , He = OO(Ce)
      , ct = G.jsx(BO, xe({
        elevation: ce === "temporary" ? L : 0,
        square: !0
    }, V, {
        className: nr(He.paper, V.className),
        ownerState: Ce,
        children: T
    }));
    if (ce === "permanent")
        return G.jsx(Pw, xe({
            className: nr(He.root, He.docked, k),
            ownerState: Ce,
            ref: i
        }, me, {
            children: ct
        }));
    const nt = G.jsx(ie, xe({
        in: U,
        direction: xT[be],
        timeout: ue,
        appear: K.current
    }, re, {
        children: ct
    }));
    return ce === "persistent" ? G.jsx(Pw, xe({
        className: nr(He.root, He.docked, k),
        ownerState: Ce,
        ref: i
    }, me, {
        children: nt
    })) : G.jsx(FO, xe({
        BackdropProps: xe({}, w, D, {
            transitionDuration: ue
        }),
        className: nr(He.root, He.modal, k),
        open: U,
        ownerState: Ce,
        onClose: N,
        hideBackdrop: z,
        ref: i
    }, me, X, {
        children: nt
    }))
});
function VO(e) {
    return Kr("MuiFormControl", e)
}
Qr("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const UO = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"]
  , GO = e => {
    const {classes: t, margin: i, fullWidth: s} = e
      , u = {
        root: ["root", i !== "none" && `margin${Ot(i)}`, s && "fullWidth"]
    };
    return Jr(u, VO, t)
}
  , WO = Jt("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: ({ownerState: e}, t) => xe({}, t.root, t[`margin${Ot(e.margin)}`], e.fullWidth && t.fullWidth)
})( ({ownerState: e}) => xe({
    display: "inline-flex",
    flexDirection: "column",
    position: "relative",
    minWidth: 0,
    padding: 0,
    margin: 0,
    border: 0,
    verticalAlign: "top"
}, e.margin === "normal" && {
    marginTop: 16,
    marginBottom: 8
}, e.margin === "dense" && {
    marginTop: 8,
    marginBottom: 4
}, e.fullWidth && {
    width: "100%"
}))
  , qO = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiFormControl"
    })
      , {children: u, className: d, color: f="primary", component: o="div", disabled: w=!1, error: T=!1, focused: k, fullWidth: L=!1, hiddenLabel: z=!1, margin: D="none", required: N=!1, size: U="medium", variant: V="outlined"} = s
      , re = dr(s, UO)
      , ie = xe({}, s, {
        color: f,
        component: o,
        disabled: w,
        error: T,
        fullWidth: L,
        hiddenLabel: z,
        margin: D,
        required: N,
        size: U,
        variant: V
    })
      , ue = GO(ie)
      , [ce,X] = Pe.useState( () => {
        let nt = !1;
        return u && Pe.Children.forEach(u, J => {
            if (!zg(J, ["Input", "Select"]))
                return;
            const he = zg(J, ["Select"]) ? J.props.input : J;
            he && kD(he.props) && (nt = !0)
        }
        ),
        nt
    }
    )
      , [me,K] = Pe.useState( () => {
        let nt = !1;
        return u && Pe.Children.forEach(u, J => {
            zg(J, ["Input", "Select"]) && (sx(J.props, !0) || sx(J.props.inputProps, !0)) && (nt = !0)
        }
        ),
        nt
    }
    )
      , [be,Ee] = Pe.useState(!1);
    w && be && Ee(!1);
    const Ce = k !== void 0 && !w ? k : be;
    let He;
    const ct = Pe.useMemo( () => ({
        adornedStart: ce,
        setAdornedStart: X,
        color: f,
        disabled: w,
        error: T,
        filled: me,
        focused: Ce,
        fullWidth: L,
        hiddenLabel: z,
        size: U,
        onBlur: () => {
            Ee(!1)
        }
        ,
        onEmpty: () => {
            K(!1)
        }
        ,
        onFilled: () => {
            K(!0)
        }
        ,
        onFocus: () => {
            Ee(!0)
        }
        ,
        registerEffect: He,
        required: N,
        variant: V
    }), [ce, f, w, T, me, Ce, L, z, He, N, U, V]);
    return G.jsx(Kx.Provider, {
        value: ct,
        children: G.jsx(WO, xe({
            as: o,
            ownerState: ie,
            className: nr(ue.root, d),
            ref: i
        }, re, {
            children: u
        }))
    })
})
  , HO = yR({
    createStyledComponent: Jt("div", {
        name: "MuiStack",
        slot: "Root",
        overridesResolver: (e, t) => t.root
    }),
    useThemeProps: e => nn({
        props: e,
        name: "MuiStack"
    })
});
function ZO(e) {
    return Kr("MuiFormControlLabel", e)
}
const Pg = Qr("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"])
  , XO = ["checked", "className", "componentsProps", "control", "disabled", "disableTypography", "inputRef", "label", "labelPlacement", "name", "onChange", "required", "slotProps", "value"]
  , YO = e => {
    const {classes: t, disabled: i, labelPlacement: s, error: u, required: d} = e
      , f = {
        root: ["root", i && "disabled", `labelPlacement${Ot(s)}`, u && "error", d && "required"],
        label: ["label", i && "disabled"],
        asterisk: ["asterisk", u && "error"]
    };
    return Jr(f, ZO, t)
}
  , KO = Jt("label", {
    name: "MuiFormControlLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [{
            [`& .${Pg.label}`]: t.label
        }, t.root, t[`labelPlacement${Ot(i.labelPlacement)}`]]
    }
})( ({theme: e, ownerState: t}) => xe({
    display: "inline-flex",
    alignItems: "center",
    cursor: "pointer",
    verticalAlign: "middle",
    WebkitTapHighlightColor: "transparent",
    marginLeft: -11,
    marginRight: 16,
    [`&.${Pg.disabled}`]: {
        cursor: "default"
    }
}, t.labelPlacement === "start" && {
    flexDirection: "row-reverse",
    marginLeft: 16,
    marginRight: -11
}, t.labelPlacement === "top" && {
    flexDirection: "column-reverse",
    marginLeft: 16
}, t.labelPlacement === "bottom" && {
    flexDirection: "column",
    marginLeft: 16
}, {
    [`& .${Pg.label}`]: {
        [`&.${Pg.disabled}`]: {
            color: (e.vars || e).palette.text.disabled
        }
    }
}))
  , QO = Jt("span", {
    name: "MuiFormControlLabel",
    slot: "Asterisk",
    overridesResolver: (e, t) => t.asterisk
})( ({theme: e}) => ({
    [`&.${Pg.error}`]: {
        color: (e.vars || e).palette.error.main
    }
}))
  , mf = Pe.forwardRef(function(t, i) {
    var s, u;
    const d = nn({
        props: t,
        name: "MuiFormControlLabel"
    })
      , {className: f, componentsProps: o={}, control: w, disabled: T, disableTypography: k, label: L, labelPlacement: z="end", required: D, slotProps: N={}} = d
      , U = dr(d, XO)
      , V = gy()
      , re = (s = T ?? w.props.disabled) != null ? s : V?.disabled
      , ie = D ?? w.props.required
      , ue = {
        disabled: re,
        required: ie
    };
    ["checked", "name", "onChange", "value", "inputRef"].forEach(Ee => {
        typeof w.props[Ee] > "u" && typeof d[Ee] < "u" && (ue[Ee] = d[Ee])
    }
    );
    const ce = bv({
        props: d,
        muiFormControl: V,
        states: ["error"]
    })
      , X = xe({}, d, {
        disabled: re,
        labelPlacement: z,
        required: ie,
        error: ce.error
    })
      , me = YO(X)
      , K = (u = N.typography) != null ? u : o.typography;
    let be = L;
    return be != null && be.type !== qt && !k && (be = G.jsx(qt, xe({
        component: "span"
    }, K, {
        className: nr(me.label, K?.className),
        children: be
    }))),
    G.jsxs(KO, xe({
        className: nr(me.root, f),
        ownerState: X,
        ref: i
    }, U, {
        children: [Pe.cloneElement(w, ue), ie ? G.jsxs(HO, {
            display: "block",
            children: [be, G.jsxs(QO, {
                ownerState: X,
                "aria-hidden": !0,
                className: me.asterisk,
                children: [" ", "*"]
            })]
        }) : be]
    }))
});
function JO(e) {
    return Kr("MuiFormGroup", e)
}
Qr("MuiFormGroup", ["root", "row", "error"]);
const eF = ["className", "row"]
  , tF = e => {
    const {classes: t, row: i, error: s} = e;
    return Jr({
        root: ["root", i && "row", s && "error"]
    }, JO, t)
}
  , rF = Jt("div", {
    name: "MuiFormGroup",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, i.row && t.row]
    }
})( ({ownerState: e}) => xe({
    display: "flex",
    flexDirection: "column",
    flexWrap: "wrap"
}, e.row && {
    flexDirection: "row"
}))
  , Mg = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiFormGroup"
    })
      , {className: u, row: d=!1} = s
      , f = dr(s, eF)
      , o = gy()
      , w = bv({
        props: s,
        muiFormControl: o,
        states: ["error"]
    })
      , T = xe({}, s, {
        row: d,
        error: w.error
    })
      , k = tF(T);
    return G.jsx(rF, xe({
        className: nr(k.root, u),
        ownerState: T,
        ref: i
    }, f))
});
function nF(e) {
    return Kr("MuiFormLabel", e)
}
const F_ = Qr("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"])
  , iF = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"]
  , oF = e => {
    const {classes: t, color: i, focused: s, disabled: u, error: d, filled: f, required: o} = e
      , w = {
        root: ["root", `color${Ot(i)}`, u && "disabled", d && "error", f && "filled", s && "focused", o && "required"],
        asterisk: ["asterisk", d && "error"]
    };
    return Jr(w, nF, t)
}
  , sF = Jt("label", {
    name: "MuiFormLabel",
    slot: "Root",
    overridesResolver: ({ownerState: e}, t) => xe({}, t.root, e.color === "secondary" && t.colorSecondary, e.filled && t.filled)
})( ({theme: e, ownerState: t}) => xe({
    color: (e.vars || e).palette.text.secondary
}, e.typography.body1, {
    lineHeight: "1.4375em",
    padding: 0,
    position: "relative",
    [`&.${F_.focused}`]: {
        color: (e.vars || e).palette[t.color].main
    },
    [`&.${F_.disabled}`]: {
        color: (e.vars || e).palette.text.disabled
    },
    [`&.${F_.error}`]: {
        color: (e.vars || e).palette.error.main
    }
}))
  , aF = Jt("span", {
    name: "MuiFormLabel",
    slot: "Asterisk",
    overridesResolver: (e, t) => t.asterisk
})( ({theme: e}) => ({
    [`&.${F_.error}`]: {
        color: (e.vars || e).palette.error.main
    }
}))
  , kg = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiFormLabel"
    })
      , {children: u, className: d, component: f="label"} = s
      , o = dr(s, iF)
      , w = gy()
      , T = bv({
        props: s,
        muiFormControl: w,
        states: ["color", "required", "focused", "disabled", "error", "filled"]
    })
      , k = xe({}, s, {
        color: T.color || "primary",
        component: f,
        disabled: T.disabled,
        error: T.error,
        filled: T.filled,
        focused: T.focused,
        required: T.required
    })
      , L = oF(k);
    return G.jsxs(sF, xe({
        as: f,
        ownerState: k,
        className: nr(L.root, d),
        ref: i
    }, o, {
        children: [u, T.required && G.jsxs(aF, {
            ownerState: k,
            "aria-hidden": !0,
            className: L.asterisk,
            children: [" ", "*"]
        })]
    }))
})
  , lF = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function lx(e) {
    return `scale(${e}, ${e ** 2})`
}
const cF = {
    entering: {
        opacity: 1,
        transform: lx(1)
    },
    entered: {
        opacity: 1,
        transform: "none"
    }
}
  , T0 = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent)
  , cx = Pe.forwardRef(function(t, i) {
    const {addEndListener: s, appear: u=!0, children: d, easing: f, in: o, onEnter: w, onEntered: T, onEntering: k, onExit: L, onExited: z, onExiting: D, style: N, timeout: U="auto", TransitionComponent: V=nc} = t
      , re = dr(t, lF)
      , ie = Pp()
      , ue = Pe.useRef()
      , ce = Kp()
      , X = Pe.useRef(null)
      , me = ki(X, d.ref, i)
      , K = he => ve => {
        if (he) {
            const Ne = X.current;
            ve === void 0 ? he(Ne) : he(Ne, ve)
        }
    }
      , be = K(k)
      , Ee = K( (he, ve) => {
        Ux(he);
        const {duration: Ne, delay: je, easing: lt} = Op({
            style: N,
            timeout: U,
            easing: f
        }, {
            mode: "enter"
        });
        let Pt;
        U === "auto" ? (Pt = ce.transitions.getAutoHeightDuration(he.clientHeight),
        ue.current = Pt) : Pt = Ne,
        he.style.transition = [ce.transitions.create("opacity", {
            duration: Pt,
            delay: je
        }), ce.transitions.create("transform", {
            duration: T0 ? Pt : Pt * .666,
            delay: je,
            easing: lt
        })].join(","),
        w && w(he, ve)
    }
    )
      , Ce = K(T)
      , He = K(D)
      , ct = K(he => {
        const {duration: ve, delay: Ne, easing: je} = Op({
            style: N,
            timeout: U,
            easing: f
        }, {
            mode: "exit"
        });
        let lt;
        U === "auto" ? (lt = ce.transitions.getAutoHeightDuration(he.clientHeight),
        ue.current = lt) : lt = ve,
        he.style.transition = [ce.transitions.create("opacity", {
            duration: lt,
            delay: Ne
        }), ce.transitions.create("transform", {
            duration: T0 ? lt : lt * .666,
            delay: T0 ? Ne : Ne || lt * .333,
            easing: je
        })].join(","),
        he.style.opacity = 0,
        he.style.transform = lx(.75),
        L && L(he)
    }
    )
      , nt = K(z)
      , J = he => {
        U === "auto" && ie.start(ue.current || 0, he),
        s && s(X.current, he)
    }
    ;
    return G.jsx(V, xe({
        appear: u,
        in: o,
        nodeRef: X,
        onEnter: Ee,
        onEntered: Ce,
        onEntering: be,
        onExit: ct,
        onExited: nt,
        onExiting: He,
        addEndListener: J,
        timeout: U === "auto" ? null : U
    }, re, {
        children: (he, ve) => Pe.cloneElement(d, xe({
            style: xe({
                opacity: 0,
                transform: lx(.75),
                visibility: he === "exited" && !o ? "hidden" : void 0
            }, cF[he], N, d.props.style),
            ref: me
        }, ve))
    }))
});
cx.muiSupportAuto = !0;
function uF(e) {
    return Kr("MuiLink", e)
}
const hF = Qr("MuiLink", ["root", "underlineNone", "underlineHover", "underlineAlways", "button", "focusVisible"])
  , bT = {
    primary: "primary.main",
    textPrimary: "text.primary",
    secondary: "secondary.main",
    textSecondary: "text.secondary",
    error: "error.main"
}
  , dF = e => bT[e] || e
  , fF = ({theme: e, ownerState: t}) => {
    const i = dF(t.color)
      , s = Lp(e, `palette.${i}`, !1) || t.color
      , u = Lp(e, `palette.${i}Channel`);
    return "vars"in e && u ? `rgba(${u} / 0.4)` : Or.alpha(s, .4)
}
  , pF = ["className", "color", "component", "onBlur", "onFocus", "TypographyClasses", "underline", "variant", "sx"]
  , mF = e => {
    const {classes: t, component: i, focusVisible: s, underline: u} = e
      , d = {
        root: ["root", `underline${Ot(u)}`, i === "button" && "button", s && "focusVisible"]
    };
    return Jr(d, uF, t)
}
  , gF = Jt(qt, {
    name: "MuiLink",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, t[`underline${Ot(i.underline)}`], i.component === "button" && t.button]
    }
})( ({theme: e, ownerState: t}) => xe({}, t.underline === "none" && {
    textDecoration: "none"
}, t.underline === "hover" && {
    textDecoration: "none",
    "&:hover": {
        textDecoration: "underline"
    }
}, t.underline === "always" && xe({
    textDecoration: "underline"
}, t.color !== "inherit" && {
    textDecorationColor: fF({
        theme: e,
        ownerState: t
    })
}, {
    "&:hover": {
        textDecorationColor: "inherit"
    }
}), t.component === "button" && {
    position: "relative",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    outline: 0,
    border: 0,
    margin: 0,
    borderRadius: 0,
    padding: 0,
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    WebkitAppearance: "none",
    "&::-moz-focus-inner": {
        borderStyle: "none"
    },
    [`&.${hF.focusVisible}`]: {
        outline: "auto"
    }
}))
  , Hr = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiLink"
    })
      , {className: u, color: d="primary", component: f="a", onBlur: o, onFocus: w, TypographyClasses: T, underline: k="always", variant: L="inherit", sx: z} = s
      , D = dr(s, pF)
      , {isFocusVisibleRef: N, onBlur: U, onFocus: V, ref: re} = dy()
      , [ie,ue] = Pe.useState(!1)
      , ce = ki(i, re)
      , X = Ee => {
        U(Ee),
        N.current === !1 && ue(!1),
        o && o(Ee)
    }
      , me = Ee => {
        V(Ee),
        N.current === !0 && ue(!0),
        w && w(Ee)
    }
      , K = xe({}, s, {
        color: d,
        component: f,
        focusVisible: ie,
        underline: k,
        variant: L
    })
      , be = mF(K);
    return G.jsx(gF, xe({
        color: d,
        className: nr(be.root, u),
        classes: T,
        component: f,
        onBlur: X,
        onFocus: me,
        ref: ce,
        ownerState: K,
        variant: L,
        sx: [...Object.keys(bT).includes(d) ? [] : [{
            color: d
        }], ...Array.isArray(z) ? z : [z]]
    }, D))
})
  , sh = Pe.createContext({});
function yF(e) {
    return Kr("MuiList", e)
}
Qr("MuiList", ["root", "padding", "dense", "subheader"]);
const _F = ["children", "className", "component", "dense", "disablePadding", "subheader"]
  , vF = e => {
    const {classes: t, disablePadding: i, dense: s, subheader: u} = e;
    return Jr({
        root: ["root", !i && "padding", s && "dense", u && "subheader"]
    }, yF, t)
}
  , xF = Jt("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, !i.disablePadding && t.padding, i.dense && t.dense, i.subheader && t.subheader]
    }
})( ({ownerState: e}) => xe({
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative"
}, !e.disablePadding && {
    paddingTop: 8,
    paddingBottom: 8
}, e.subheader && {
    paddingTop: 0
}))
  , B_ = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiList"
    })
      , {children: u, className: d, component: f="ul", dense: o=!1, disablePadding: w=!1, subheader: T} = s
      , k = dr(s, _F)
      , L = Pe.useMemo( () => ({
        dense: o
    }), [o])
      , z = xe({}, s, {
        component: f,
        dense: o,
        disablePadding: w
    })
      , D = vF(z);
    return G.jsx(sh.Provider, {
        value: L,
        children: G.jsxs(xF, xe({
            as: f,
            className: nr(D.root, d),
            ref: i,
            ownerState: z
        }, k, {
            children: [T, u]
        }))
    })
});
function bF(e) {
    return Kr("MuiListItem", e)
}
const Cp = Qr("MuiListItem", ["root", "container", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "padding", "button", "secondaryAction", "selected"]);
function wF(e) {
    return Kr("MuiListItemButton", e)
}
const Tp = Qr("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"])
  , SF = ["alignItems", "autoFocus", "component", "children", "dense", "disableGutters", "divider", "focusVisibleClassName", "selected", "className"]
  , CF = (e, t) => {
    const {ownerState: i} = e;
    return [t.root, i.dense && t.dense, i.alignItems === "flex-start" && t.alignItemsFlexStart, i.divider && t.divider, !i.disableGutters && t.gutters]
}
  , TF = e => {
    const {alignItems: t, classes: i, dense: s, disabled: u, disableGutters: d, divider: f, selected: o} = e
      , T = Jr({
        root: ["root", s && "dense", !d && "gutters", f && "divider", u && "disabled", t === "flex-start" && "alignItemsFlexStart", o && "selected"]
    }, wF, i);
    return xe({}, i, T)
}
  , PF = Jt(Kh, {
    shouldForwardProp: e => ed(e) || e === "classes",
    name: "MuiListItemButton",
    slot: "Root",
    overridesResolver: CF
})( ({theme: e, ownerState: t}) => xe({
    display: "flex",
    flexGrow: 1,
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    minWidth: 0,
    boxSizing: "border-box",
    textAlign: "left",
    paddingTop: 8,
    paddingBottom: 8,
    transition: e.transitions.create("background-color", {
        duration: e.transitions.duration.shortest
    }),
    "&:hover": {
        textDecoration: "none",
        backgroundColor: (e.vars || e).palette.action.hover,
        "@media (hover: none)": {
            backgroundColor: "transparent"
        }
    },
    [`&.${Tp.selected}`]: {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Or.alpha(e.palette.primary.main, e.palette.action.selectedOpacity),
        [`&.${Tp.focusVisible}`]: {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : Or.alpha(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
        }
    },
    [`&.${Tp.selected}:hover`]: {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Or.alpha(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
        "@media (hover: none)": {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Or.alpha(e.palette.primary.main, e.palette.action.selectedOpacity)
        }
    },
    [`&.${Tp.focusVisible}`]: {
        backgroundColor: (e.vars || e).palette.action.focus
    },
    [`&.${Tp.disabled}`]: {
        opacity: (e.vars || e).palette.action.disabledOpacity
    }
}, t.divider && {
    borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
    backgroundClip: "padding-box"
}, t.alignItems === "flex-start" && {
    alignItems: "flex-start"
}, !t.disableGutters && {
    paddingLeft: 16,
    paddingRight: 16
}, t.dense && {
    paddingTop: 4,
    paddingBottom: 4
}))
  , MF = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiListItemButton"
    })
      , {alignItems: u="center", autoFocus: d=!1, component: f="div", children: o, dense: w=!1, disableGutters: T=!1, divider: k=!1, focusVisibleClassName: L, selected: z=!1, className: D} = s
      , N = dr(s, SF)
      , U = Pe.useContext(sh)
      , V = Pe.useMemo( () => ({
        dense: w || U.dense || !1,
        alignItems: u,
        disableGutters: T
    }), [u, U.dense, w, T])
      , re = Pe.useRef(null);
    gl( () => {
        d && re.current && re.current.focus()
    }
    , [d]);
    const ie = xe({}, s, {
        alignItems: u,
        dense: V.dense,
        disableGutters: T,
        divider: k,
        selected: z
    })
      , ue = TF(ie)
      , ce = ki(re, i);
    return G.jsx(sh.Provider, {
        value: V,
        children: G.jsx(PF, xe({
            ref: ce,
            href: N.href || N.to,
            component: (N.href || N.to) && f === "div" ? "button" : f,
            focusVisibleClassName: nr(ue.focusVisible, L),
            ownerState: ie,
            className: nr(ue.root, D)
        }, N, {
            classes: ue,
            children: o
        }))
    })
});
function kF(e) {
    return Kr("MuiListItemSecondaryAction", e)
}
Qr("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const EF = ["className"]
  , IF = e => {
    const {disableGutters: t, classes: i} = e;
    return Jr({
        root: ["root", t && "disableGutters"]
    }, kF, i)
}
  , RF = Jt("div", {
    name: "MuiListItemSecondaryAction",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, i.disableGutters && t.disableGutters]
    }
})( ({ownerState: e}) => xe({
    position: "absolute",
    right: 16,
    top: "50%",
    transform: "translateY(-50%)"
}, e.disableGutters && {
    right: 0
}))
  , wT = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiListItemSecondaryAction"
    })
      , {className: u} = s
      , d = dr(s, EF)
      , f = Pe.useContext(sh)
      , o = xe({}, s, {
        disableGutters: f.disableGutters
    })
      , w = IF(o);
    return G.jsx(RF, xe({
        className: nr(w.root, u),
        ownerState: o,
        ref: i
    }, d))
});
wT.muiName = "ListItemSecondaryAction";
const AF = ["className"]
  , zF = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"]
  , DF = (e, t) => {
    const {ownerState: i} = e;
    return [t.root, i.dense && t.dense, i.alignItems === "flex-start" && t.alignItemsFlexStart, i.divider && t.divider, !i.disableGutters && t.gutters, !i.disablePadding && t.padding, i.button && t.button, i.hasSecondaryAction && t.secondaryAction]
}
  , LF = e => {
    const {alignItems: t, button: i, classes: s, dense: u, disabled: d, disableGutters: f, disablePadding: o, divider: w, hasSecondaryAction: T, selected: k} = e;
    return Jr({
        root: ["root", u && "dense", !f && "gutters", !o && "padding", w && "divider", d && "disabled", i && "button", t === "flex-start" && "alignItemsFlexStart", T && "secondaryAction", k && "selected"],
        container: ["container"]
    }, bF, s)
}
  , OF = Jt("div", {
    name: "MuiListItem",
    slot: "Root",
    overridesResolver: DF
})( ({theme: e, ownerState: t}) => xe({
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    width: "100%",
    boxSizing: "border-box",
    textAlign: "left"
}, !t.disablePadding && xe({
    paddingTop: 8,
    paddingBottom: 8
}, t.dense && {
    paddingTop: 4,
    paddingBottom: 4
}, !t.disableGutters && {
    paddingLeft: 16,
    paddingRight: 16
}, !!t.secondaryAction && {
    paddingRight: 48
}), !!t.secondaryAction && {
    [`& > .${Tp.root}`]: {
        paddingRight: 48
    }
}, {
    [`&.${Cp.focusVisible}`]: {
        backgroundColor: (e.vars || e).palette.action.focus
    },
    [`&.${Cp.selected}`]: {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Or.alpha(e.palette.primary.main, e.palette.action.selectedOpacity),
        [`&.${Cp.focusVisible}`]: {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : Or.alpha(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
        }
    },
    [`&.${Cp.disabled}`]: {
        opacity: (e.vars || e).palette.action.disabledOpacity
    }
}, t.alignItems === "flex-start" && {
    alignItems: "flex-start"
}, t.divider && {
    borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
    backgroundClip: "padding-box"
}, t.button && {
    transition: e.transitions.create("background-color", {
        duration: e.transitions.duration.shortest
    }),
    "&:hover": {
        textDecoration: "none",
        backgroundColor: (e.vars || e).palette.action.hover,
        "@media (hover: none)": {
            backgroundColor: "transparent"
        }
    },
    [`&.${Cp.selected}:hover`]: {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Or.alpha(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
        "@media (hover: none)": {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Or.alpha(e.palette.primary.main, e.palette.action.selectedOpacity)
        }
    }
}, t.hasSecondaryAction && {
    paddingRight: 48
}))
  , FF = Jt("li", {
    name: "MuiListItem",
    slot: "Container",
    overridesResolver: (e, t) => t.container
})({
    position: "relative"
})
  , Vh = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiListItem"
    })
      , {alignItems: u="center", autoFocus: d=!1, button: f=!1, children: o, className: w, component: T, components: k={}, componentsProps: L={}, ContainerComponent: z="li", ContainerProps: {className: D}={}, dense: N=!1, disabled: U=!1, disableGutters: V=!1, disablePadding: re=!1, divider: ie=!1, focusVisibleClassName: ue, secondaryAction: ce, selected: X=!1, slotProps: me={}, slots: K={}} = s
      , be = dr(s.ContainerProps, AF)
      , Ee = dr(s, zF)
      , Ce = Pe.useContext(sh)
      , He = Pe.useMemo( () => ({
        dense: N || Ce.dense || !1,
        alignItems: u,
        disableGutters: V
    }), [u, Ce.dense, N, V])
      , ct = Pe.useRef(null);
    gl( () => {
        d && ct.current && ct.current.focus()
    }
    , [d]);
    const nt = Pe.Children.toArray(o)
      , J = nt.length && zg(nt[nt.length - 1], ["ListItemSecondaryAction"])
      , he = xe({}, s, {
        alignItems: u,
        autoFocus: d,
        button: f,
        dense: He.dense,
        disabled: U,
        disableGutters: V,
        disablePadding: re,
        divider: ie,
        hasSecondaryAction: J,
        selected: X
    })
      , ve = LF(he)
      , Ne = ki(ct, i)
      , je = K.root || k.Root || OF
      , lt = me.root || L.root || {}
      , Pt = xe({
        className: nr(ve.root, lt.className, w),
        disabled: U
    }, Ee);
    let We = T || "li";
    return f && (Pt.component = T || "div",
    Pt.focusVisibleClassName = nr(Cp.focusVisible, ue),
    We = Kh),
    J ? (We = !Pt.component && !T ? "div" : We,
    z === "li" && (We === "li" ? We = "div" : Pt.component === "li" && (Pt.component = "div")),
    G.jsx(sh.Provider, {
        value: He,
        children: G.jsxs(FF, xe({
            as: z,
            className: nr(ve.container, D),
            ref: Ne,
            ownerState: he
        }, be, {
            children: [G.jsx(je, xe({}, lt, !oh(je) && {
                as: We,
                ownerState: xe({}, he, lt.ownerState)
            }, Pt, {
                children: nt
            })), nt.pop()]
        }))
    })) : G.jsx(sh.Provider, {
        value: He,
        children: G.jsxs(je, xe({}, lt, {
            as: We,
            ref: Ne
        }, !oh(je) && {
            ownerState: xe({}, he, lt.ownerState)
        }, Pt, {
            children: [nt, ce && G.jsx(wT, {
                children: ce
            })]
        }))
    })
});
function BF(e) {
    return Kr("MuiListItemIcon", e)
}
Qr("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
const jF = ["className"]
  , NF = e => {
    const {alignItems: t, classes: i} = e;
    return Jr({
        root: ["root", t === "flex-start" && "alignItemsFlexStart"]
    }, BF, i)
}
  , $F = Jt("div", {
    name: "MuiListItemIcon",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, i.alignItems === "flex-start" && t.alignItemsFlexStart]
    }
})( ({theme: e, ownerState: t}) => xe({
    minWidth: 56,
    color: (e.vars || e).palette.action.active,
    flexShrink: 0,
    display: "inline-flex"
}, t.alignItems === "flex-start" && {
    marginTop: 8
}))
  , xp = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiListItemIcon"
    })
      , {className: u} = s
      , d = dr(s, jF)
      , f = Pe.useContext(sh)
      , o = xe({}, s, {
        alignItems: f.alignItems
    })
      , w = NF(o);
    return G.jsx($F, xe({
        className: nr(w.root, u),
        ownerState: o,
        ref: i
    }, d))
});
function VF(e) {
    return Kr("MuiListItemText", e)
}
const Mw = Qr("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"])
  , UF = ["children", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"]
  , GF = e => {
    const {classes: t, inset: i, primary: s, secondary: u, dense: d} = e;
    return Jr({
        root: ["root", i && "inset", d && "dense", s && u && "multiline"],
        primary: ["primary"],
        secondary: ["secondary"]
    }, VF, t)
}
  , WF = Jt("div", {
    name: "MuiListItemText",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [{
            [`& .${Mw.primary}`]: t.primary
        }, {
            [`& .${Mw.secondary}`]: t.secondary
        }, t.root, i.inset && t.inset, i.primary && i.secondary && t.multiline, i.dense && t.dense]
    }
})( ({ownerState: e}) => xe({
    flex: "1 1 auto",
    minWidth: 0,
    marginTop: 4,
    marginBottom: 4
}, e.primary && e.secondary && {
    marginTop: 6,
    marginBottom: 6
}, e.inset && {
    paddingLeft: 56
}))
  , eh = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiListItemText"
    })
      , {children: u, className: d, disableTypography: f=!1, inset: o=!1, primary: w, primaryTypographyProps: T, secondary: k, secondaryTypographyProps: L} = s
      , z = dr(s, UF)
      , {dense: D} = Pe.useContext(sh);
    let N = w ?? u
      , U = k;
    const V = xe({}, s, {
        disableTypography: f,
        inset: o,
        primary: !!N,
        secondary: !!U,
        dense: D
    })
      , re = GF(V);
    return N != null && N.type !== qt && !f && (N = G.jsx(qt, xe({
        variant: D ? "body2" : "body1",
        className: re.primary,
        component: T != null && T.variant ? void 0 : "span",
        display: "block"
    }, T, {
        children: N
    }))),
    U != null && U.type !== qt && !f && (U = G.jsx(qt, xe({
        variant: "body2",
        className: re.secondary,
        color: "text.secondary",
        display: "block"
    }, L, {
        children: U
    }))),
    G.jsxs(WF, xe({
        className: nr(re.root, d),
        ownerState: V,
        ref: i
    }, z, {
        children: [N, U]
    }))
})
  , qF = rc(G.jsx("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "RadioButtonUnchecked")
  , HF = rc(G.jsx("path", {
    d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"
}), "RadioButtonChecked")
  , ZF = Jt("span", {
    shouldForwardProp: ed
})({
    position: "relative",
    display: "flex"
})
  , XF = Jt(qF)({
    transform: "scale(1)"
})
  , YF = Jt(HF)( ({theme: e, ownerState: t}) => xe({
    left: 0,
    position: "absolute",
    transform: "scale(0)",
    transition: e.transitions.create("transform", {
        easing: e.transitions.easing.easeIn,
        duration: e.transitions.duration.shortest
    })
}, t.checked && {
    transform: "scale(1)",
    transition: e.transitions.create("transform", {
        easing: e.transitions.easing.easeOut,
        duration: e.transitions.duration.shortest
    })
}));
function ST(e) {
    const {checked: t=!1, classes: i={}, fontSize: s} = e
      , u = xe({}, e, {
        checked: t
    });
    return G.jsxs(ZF, {
        className: i.root,
        ownerState: u,
        children: [G.jsx(XF, {
            fontSize: s,
            className: i.background,
            ownerState: u
        }), G.jsx(YF, {
            fontSize: s,
            className: i.dot,
            ownerState: u
        })]
    })
}
const CT = Pe.createContext(void 0);
function KF() {
    return Pe.useContext(CT)
}
function QF(e) {
    return Kr("MuiRadio", e)
}
const kw = Qr("MuiRadio", ["root", "checked", "disabled", "colorPrimary", "colorSecondary", "sizeSmall"])
  , JF = ["checked", "checkedIcon", "color", "icon", "name", "onChange", "size", "className"]
  , e3 = e => {
    const {classes: t, color: i, size: s} = e
      , u = {
        root: ["root", `color${Ot(i)}`, s !== "medium" && `size${Ot(s)}`]
    };
    return xe({}, t, Jr(u, QF, t))
}
  , t3 = Jt(eb, {
    shouldForwardProp: e => ed(e) || e === "classes",
    name: "MuiRadio",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, i.size !== "medium" && t[`size${Ot(i.size)}`], t[`color${Ot(i.color)}`]]
    }
})( ({theme: e, ownerState: t}) => xe({
    color: (e.vars || e).palette.text.secondary
}, !t.disableRipple && {
    "&:hover": {
        backgroundColor: e.vars ? `rgba(${t.color === "default" ? e.vars.palette.action.activeChannel : e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Or.alpha(t.color === "default" ? e.palette.action.active : e.palette[t.color].main, e.palette.action.hoverOpacity),
        "@media (hover: none)": {
            backgroundColor: "transparent"
        }
    }
}, t.color !== "default" && {
    [`&.${kw.checked}`]: {
        color: (e.vars || e).palette[t.color].main
    }
}, {
    [`&.${kw.disabled}`]: {
        color: (e.vars || e).palette.action.disabled
    }
}));
function r3(e, t) {
    return typeof t == "object" && t !== null ? e === t : String(e) === String(t)
}
const Ew = G.jsx(ST, {
    checked: !0
})
  , Iw = G.jsx(ST, {})
  , Z_ = Pe.forwardRef(function(t, i) {
    var s, u;
    const d = nn({
        props: t,
        name: "MuiRadio"
    })
      , {checked: f, checkedIcon: o=Ew, color: w="primary", icon: T=Iw, name: k, onChange: L, size: z="medium", className: D} = d
      , N = dr(d, JF)
      , U = xe({}, d, {
        color: w,
        size: z
    })
      , V = e3(U)
      , re = KF();
    let ie = f;
    const ue = G_(L, re && re.onChange);
    let ce = k;
    return re && (typeof ie > "u" && (ie = r3(re.value, d.value)),
    typeof ce > "u" && (ce = re.name)),
    G.jsx(t3, xe({
        type: "radio",
        icon: Pe.cloneElement(T, {
            fontSize: (s = Iw.props.fontSize) != null ? s : z
        }),
        checkedIcon: Pe.cloneElement(o, {
            fontSize: (u = Ew.props.fontSize) != null ? u : z
        }),
        ownerState: U,
        classes: V,
        name: ce,
        checked: ie,
        onChange: ue,
        ref: i,
        className: nr(V.root, D)
    }, N))
});
function n3(e) {
    return Kr("MuiRadioGroup", e)
}
Qr("MuiRadioGroup", ["root", "row", "error"]);
const i3 = ["actions", "children", "className", "defaultValue", "name", "onChange", "value"]
  , o3 = e => {
    const {classes: t, row: i, error: s} = e;
    return Jr({
        root: ["root", i && "row", s && "error"]
    }, n3, t)
}
  , TT = Pe.forwardRef(function(t, i) {
    const {actions: s, children: u, className: d, defaultValue: f, name: o, onChange: w, value: T} = t
      , k = dr(t, i3)
      , L = Pe.useRef(null)
      , z = o3(t)
      , [D,N] = uy({
        controlled: T,
        default: f,
        name: "RadioGroup"
    });
    Pe.useImperativeHandle(s, () => ({
        focus: () => {
            let ie = L.current.querySelector("input:not(:disabled):checked");
            ie || (ie = L.current.querySelector("input:not(:disabled)")),
            ie && ie.focus()
        }
    }), []);
    const U = ki(i, L)
      , V = yv(o)
      , re = Pe.useMemo( () => ({
        name: V,
        onChange(ie) {
            N(ie.target.value),
            w && w(ie, ie.target.value)
        },
        value: D
    }), [V, w, N, D]);
    return G.jsx(CT.Provider, {
        value: re,
        children: G.jsx(Mg, xe({
            role: "radiogroup",
            ref: U,
            className: nr(z.root, d)
        }, k, {
            children: u
        }))
    })
});
function s3(e, t, i= (s, u) => s === u) {
    return e.length === t.length && e.every( (s, u) => i(s, t[u]))
}
const a3 = 2;
function PT(e, t) {
    return e - t
}
function Rw(e, t) {
    var i;
    const {index: s} = (i = e.reduce( (u, d, f) => {
        const o = Math.abs(t - d);
        return u === null || o < u.distance || o === u.distance ? {
            distance: o,
            index: f
        } : u
    }
    , null)) != null ? i : {};
    return s
}
function i_(e, t) {
    if (t.current !== void 0 && e.changedTouches) {
        const i = e;
        for (let s = 0; s < i.changedTouches.length; s += 1) {
            const u = i.changedTouches[s];
            if (u.identifier === t.current)
                return {
                    x: u.clientX,
                    y: u.clientY
                }
        }
        return !1
    }
    return {
        x: e.clientX,
        y: e.clientY
    }
}
function X_(e, t, i) {
    return (e - t) * 100 / (i - t)
}
function l3(e, t, i) {
    return (i - t) * e + t
}
function c3(e) {
    if (Math.abs(e) < 1) {
        const i = e.toExponential().split("e-")
          , s = i[0].split(".")[1];
        return (s ? s.length : 0) + parseInt(i[1], 10)
    }
    const t = e.toString().split(".")[1];
    return t ? t.length : 0
}
function u3(e, t, i) {
    const s = Math.round((e - i) / t) * t + i;
    return Number(s.toFixed(c3(t)))
}
function Aw({values: e, newValue: t, index: i}) {
    const s = e.slice();
    return s[i] = t,
    s.sort(PT)
}
function o_({sliderRef: e, activeIndex: t, setActive: i}) {
    var s, u;
    const d = js(e.current);
    if (!((s = e.current) != null && s.contains(d.activeElement)) || Number(d == null || (u = d.activeElement) == null ? void 0 : u.getAttribute("data-index")) !== t) {
        var f;
        (f = e.current) == null || f.querySelector(`[type="range"][data-index="${t}"]`).focus()
    }
    i && i(t)
}
function s_(e, t) {
    return typeof e == "number" && typeof t == "number" ? e === t : typeof e == "object" && typeof t == "object" ? s3(e, t) : !1
}
const h3 = {
    horizontal: {
        offset: e => ({
            left: `${e}%`
        }),
        leap: e => ({
            width: `${e}%`
        })
    },
    "horizontal-reverse": {
        offset: e => ({
            right: `${e}%`
        }),
        leap: e => ({
            width: `${e}%`
        })
    },
    vertical: {
        offset: e => ({
            bottom: `${e}%`
        }),
        leap: e => ({
            height: `${e}%`
        })
    }
}
  , d3 = e => e;
let a_;
function zw() {
    return a_ === void 0 && (typeof CSS < "u" && typeof CSS.supports == "function" ? a_ = CSS.supports("touch-action", "none") : a_ = !0),
    a_
}
function f3(e) {
    const {"aria-labelledby": t, defaultValue: i, disabled: s=!1, disableSwap: u=!1, isRtl: d=!1, marks: f=!1, max: o=100, min: w=0, name: T, onChange: k, onChangeCommitted: L, orientation: z="horizontal", rootRef: D, scale: N=d3, step: U=1, shiftStep: V=10, tabIndex: re, value: ie} = e
      , ue = Pe.useRef()
      , [ce,X] = Pe.useState(-1)
      , [me,K] = Pe.useState(-1)
      , [be,Ee] = Pe.useState(!1)
      , Ce = Pe.useRef(0)
      , [He,ct] = uy({
        controlled: ie,
        default: i ?? w,
        name: "Slider"
    })
      , nt = k && ( (Mt, kt, er) => {
        const Er = Mt.nativeEvent || Mt
          , Ue = new Er.constructor(Er.type,Er);
        Object.defineProperty(Ue, "target", {
            writable: !0,
            value: {
                value: kt,
                name: T
            }
        }),
        k(Ue, kt, er)
    }
    )
      , J = Array.isArray(He);
    let he = J ? He.slice().sort(PT) : [He];
    he = he.map(Mt => Mt == null ? w : wp(Mt, w, o));
    const ve = f === !0 && U !== null ? [...Array(Math.floor((o - w) / U) + 1)].map( (Mt, kt) => ({
        value: w + U * kt
    })) : f || []
      , Ne = ve.map(Mt => Mt.value)
      , {isFocusVisibleRef: je, onBlur: lt, onFocus: Pt, ref: We} = dy()
      , [st,Nt] = Pe.useState(-1)
      , zt = Pe.useRef()
      , Qt = ki(We, zt)
      , Wt = ki(D, Qt)
      , tr = Mt => kt => {
        var er;
        const Er = Number(kt.currentTarget.getAttribute("data-index"));
        Pt(kt),
        je.current === !0 && Nt(Er),
        K(Er),
        Mt == null || (er = Mt.onFocus) == null || er.call(Mt, kt)
    }
      , cr = Mt => kt => {
        var er;
        lt(kt),
        je.current === !1 && Nt(-1),
        K(-1),
        Mt == null || (er = Mt.onBlur) == null || er.call(Mt, kt)
    }
      , Yt = (Mt, kt) => {
        const er = Number(Mt.currentTarget.getAttribute("data-index"))
          , Er = he[er]
          , Ue = Ne.indexOf(Er);
        let se = kt;
        if (ve && U == null) {
            const fe = Ne[Ne.length - 1];
            se > fe ? se = fe : se < Ne[0] ? se = Ne[0] : se = se < Er ? Ne[Ue - 1] : Ne[Ue + 1]
        }
        if (se = wp(se, w, o),
        J) {
            u && (se = wp(se, he[er - 1] || -1 / 0, he[er + 1] || 1 / 0));
            const fe = se;
            se = Aw({
                values: he,
                newValue: se,
                index: er
            });
            let ge = er;
            u || (ge = se.indexOf(fe)),
            o_({
                sliderRef: zt,
                activeIndex: ge
            })
        }
        ct(se),
        Nt(er),
        nt && !s_(se, He) && nt(Mt, se, er),
        L && L(Mt, se)
    }
      , Gr = Mt => kt => {
        var er;
        if (U !== null) {
            const Er = Number(kt.currentTarget.getAttribute("data-index"))
              , Ue = he[Er];
            let se = null;
            (kt.key === "ArrowLeft" || kt.key === "ArrowDown") && kt.shiftKey || kt.key === "PageDown" ? se = Math.max(Ue - V, w) : ((kt.key === "ArrowRight" || kt.key === "ArrowUp") && kt.shiftKey || kt.key === "PageUp") && (se = Math.min(Ue + V, o)),
            se !== null && (Yt(kt, se),
            kt.preventDefault())
        }
        Mt == null || (er = Mt.onKeyDown) == null || er.call(Mt, kt)
    }
    ;
    gl( () => {
        if (s && zt.current.contains(document.activeElement)) {
            var Mt;
            (Mt = document.activeElement) == null || Mt.blur()
        }
    }
    , [s]),
    s && ce !== -1 && X(-1),
    s && st !== -1 && Nt(-1);
    const xr = Mt => kt => {
        var er;
        (er = Mt.onChange) == null || er.call(Mt, kt),
        Yt(kt, kt.target.valueAsNumber)
    }
      , Nr = Pe.useRef();
    let ur = z;
    d && z === "horizontal" && (ur += "-reverse");
    const vr = ({finger: Mt, move: kt=!1}) => {
        const {current: er} = zt
          , {width: Er, height: Ue, bottom: se, left: fe} = er.getBoundingClientRect();
        let ge;
        ur.indexOf("vertical") === 0 ? ge = (se - Mt.y) / Ue : ge = (Mt.x - fe) / Er,
        ur.indexOf("-reverse") !== -1 && (ge = 1 - ge);
        let Me;
        if (Me = l3(ge, w, o),
        U)
            Me = u3(Me, U, w);
        else {
            const et = Rw(Ne, Me);
            Me = Ne[et]
        }
        Me = wp(Me, w, o);
        let $e = 0;
        if (J) {
            kt ? $e = Nr.current : $e = Rw(he, Me),
            u && (Me = wp(Me, he[$e - 1] || -1 / 0, he[$e + 1] || 1 / 0));
            const et = Me;
            Me = Aw({
                values: he,
                newValue: Me,
                index: $e
            }),
            u && kt || ($e = Me.indexOf(et),
            Nr.current = $e)
        }
        return {
            newValue: Me,
            activeIndex: $e
        }
    }
      , gr = dl(Mt => {
        const kt = i_(Mt, ue);
        if (!kt)
            return;
        if (Ce.current += 1,
        Mt.type === "mousemove" && Mt.buttons === 0) {
            hn(Mt);
            return
        }
        const {newValue: er, activeIndex: Er} = vr({
            finger: kt,
            move: !0
        });
        o_({
            sliderRef: zt,
            activeIndex: Er,
            setActive: X
        }),
        ct(er),
        !be && Ce.current > a3 && Ee(!0),
        nt && !s_(er, He) && nt(Mt, er, Er)
    }
    )
      , hn = dl(Mt => {
        const kt = i_(Mt, ue);
        if (Ee(!1),
        !kt)
            return;
        const {newValue: er} = vr({
            finger: kt,
            move: !0
        });
        X(-1),
        Mt.type === "touchend" && K(-1),
        L && L(Mt, er),
        ue.current = void 0,
        $r()
    }
    )
      , Zr = dl(Mt => {
        if (s)
            return;
        zw() || Mt.preventDefault();
        const kt = Mt.changedTouches[0];
        kt != null && (ue.current = kt.identifier);
        const er = i_(Mt, ue);
        if (er !== !1) {
            const {newValue: Ue, activeIndex: se} = vr({
                finger: er
            });
            o_({
                sliderRef: zt,
                activeIndex: se,
                setActive: X
            }),
            ct(Ue),
            nt && !s_(Ue, He) && nt(Mt, Ue, se)
        }
        Ce.current = 0;
        const Er = js(zt.current);
        Er.addEventListener("touchmove", gr, {
            passive: !0
        }),
        Er.addEventListener("touchend", hn, {
            passive: !0
        })
    }
    )
      , $r = Pe.useCallback( () => {
        const Mt = js(zt.current);
        Mt.removeEventListener("mousemove", gr),
        Mt.removeEventListener("mouseup", hn),
        Mt.removeEventListener("touchmove", gr),
        Mt.removeEventListener("touchend", hn)
    }
    , [hn, gr]);
    Pe.useEffect( () => {
        const {current: Mt} = zt;
        return Mt.addEventListener("touchstart", Zr, {
            passive: zw()
        }),
        () => {
            Mt.removeEventListener("touchstart", Zr),
            $r()
        }
    }
    , [$r, Zr]),
    Pe.useEffect( () => {
        s && $r()
    }
    , [s, $r]);
    const gn = Mt => kt => {
        var er;
        if ((er = Mt.onMouseDown) == null || er.call(Mt, kt),
        s || kt.defaultPrevented || kt.button !== 0)
            return;
        kt.preventDefault();
        const Er = i_(kt, ue);
        if (Er !== !1) {
            const {newValue: se, activeIndex: fe} = vr({
                finger: Er
            });
            o_({
                sliderRef: zt,
                activeIndex: fe,
                setActive: X
            }),
            ct(se),
            nt && !s_(se, He) && nt(kt, se, fe)
        }
        Ce.current = 0;
        const Ue = js(zt.current);
        Ue.addEventListener("mousemove", gr, {
            passive: !0
        }),
        Ue.addEventListener("mouseup", hn)
    }
      , zr = X_(J ? he[0] : w, w, o)
      , Wr = X_(he[he.length - 1], w, o) - zr
      , $n = (Mt={}) => {
        const kt = Dg(Mt)
          , er = {
            onMouseDown: gn(kt || {})
        }
          , Er = xe({}, kt, er);
        return xe({}, Mt, {
            ref: Wt
        }, Er)
    }
      , Dn = Mt => kt => {
        var er;
        (er = Mt.onMouseOver) == null || er.call(Mt, kt);
        const Er = Number(kt.currentTarget.getAttribute("data-index"));
        K(Er)
    }
      , yn = Mt => kt => {
        var er;
        (er = Mt.onMouseLeave) == null || er.call(Mt, kt),
        K(-1)
    }
    ;
    return {
        active: ce,
        axis: ur,
        axisProps: h3,
        dragging: be,
        focusedThumbIndex: st,
        getHiddenInputProps: (Mt={}) => {
            var kt;
            const er = Dg(Mt)
              , Er = {
                onChange: xr(er || {}),
                onFocus: tr(er || {}),
                onBlur: cr(er || {}),
                onKeyDown: Gr(er || {})
            }
              , Ue = xe({}, er, Er);
            return xe({
                tabIndex: re,
                "aria-labelledby": t,
                "aria-orientation": z,
                "aria-valuemax": N(o),
                "aria-valuemin": N(w),
                name: T,
                type: "range",
                min: e.min,
                max: e.max,
                step: e.step === null && e.marks ? "any" : (kt = e.step) != null ? kt : void 0,
                disabled: s
            }, Mt, Ue, {
                style: xe({}, QI, {
                    direction: d ? "rtl" : "ltr",
                    width: "100%",
                    height: "100%"
                })
            })
        }
        ,
        getRootProps: $n,
        getThumbProps: (Mt={}) => {
            const kt = Dg(Mt)
              , er = {
                onMouseOver: Dn(kt || {}),
                onMouseLeave: yn(kt || {})
            };
            return xe({}, Mt, kt, er)
        }
        ,
        marks: ve,
        open: me,
        range: J,
        rootRef: Wt,
        trackLeap: Wr,
        trackOffset: zr,
        values: he,
        getThumbStyle: Mt => ({
            pointerEvents: ce !== -1 && ce !== Mt ? "none" : void 0
        })
    }
}
const p3 = e => !e || !oh(e);
function m3(e) {
    return Kr("MuiSlider", e)
}
const fl = Qr("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "thumbColorError", "thumbColorSuccess", "thumbColorInfo", "thumbColorWarning", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"])
  , g3 = e => {
    const {open: t} = e;
    return {
        offset: nr(t && fl.valueLabelOpen),
        circle: fl.valueLabelCircle,
        label: fl.valueLabelLabel
    }
}
;
function y3(e) {
    const {children: t, className: i, value: s} = e
      , u = g3(e);
    return t ? Pe.cloneElement(t, {
        className: nr(t.props.className)
    }, G.jsxs(Pe.Fragment, {
        children: [t.props.children, G.jsx("span", {
            className: nr(u.offset, i),
            "aria-hidden": !0,
            children: G.jsx("span", {
                className: u.circle,
                children: G.jsx("span", {
                    className: u.label,
                    children: s
                })
            })
        })]
    })) : null
}
const _3 = ["aria-label", "aria-valuetext", "aria-labelledby", "component", "components", "componentsProps", "color", "classes", "className", "disableSwap", "disabled", "getAriaLabel", "getAriaValueText", "marks", "max", "min", "name", "onChange", "onChangeCommitted", "orientation", "shiftStep", "size", "step", "scale", "slotProps", "slots", "tabIndex", "track", "value", "valueLabelDisplay", "valueLabelFormat"];
function Dw(e) {
    return e
}
const v3 = Jt("span", {
    name: "MuiSlider",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, t[`color${Ot(i.color)}`], i.size !== "medium" && t[`size${Ot(i.size)}`], i.marked && t.marked, i.orientation === "vertical" && t.vertical, i.track === "inverted" && t.trackInverted, i.track === !1 && t.trackFalse]
    }
})( ({theme: e}) => {
    var t;
    return {
        borderRadius: 12,
        boxSizing: "content-box",
        display: "inline-block",
        position: "relative",
        cursor: "pointer",
        touchAction: "none",
        WebkitTapHighlightColor: "transparent",
        "@media print": {
            colorAdjust: "exact"
        },
        [`&.${fl.disabled}`]: {
            pointerEvents: "none",
            cursor: "default",
            color: (e.vars || e).palette.grey[400]
        },
        [`&.${fl.dragging}`]: {
            [`& .${fl.thumb}, & .${fl.track}`]: {
                transition: "none"
            }
        },
        variants: [...Object.keys(((t = e.vars) != null ? t : e).palette).filter(i => {
            var s;
            return ((s = e.vars) != null ? s : e).palette[i].main
        }
        ).map(i => ({
            props: {
                color: i
            },
            style: {
                color: (e.vars || e).palette[i].main
            }
        })), {
            props: {
                orientation: "horizontal"
            },
            style: {
                height: 4,
                width: "100%",
                padding: "13px 0",
                "@media (pointer: coarse)": {
                    padding: "20px 0"
                }
            }
        }, {
            props: {
                orientation: "horizontal",
                size: "small"
            },
            style: {
                height: 2
            }
        }, {
            props: {
                orientation: "horizontal",
                marked: !0
            },
            style: {
                marginBottom: 20
            }
        }, {
            props: {
                orientation: "vertical"
            },
            style: {
                height: "100%",
                width: 4,
                padding: "0 13px",
                "@media (pointer: coarse)": {
                    padding: "0 20px"
                }
            }
        }, {
            props: {
                orientation: "vertical",
                size: "small"
            },
            style: {
                width: 2
            }
        }, {
            props: {
                orientation: "vertical",
                marked: !0
            },
            style: {
                marginRight: 44
            }
        }]
    }
}
)
  , x3 = Jt("span", {
    name: "MuiSlider",
    slot: "Rail",
    overridesResolver: (e, t) => t.rail
})({
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    backgroundColor: "currentColor",
    opacity: .38,
    variants: [{
        props: {
            orientation: "horizontal"
        },
        style: {
            width: "100%",
            height: "inherit",
            top: "50%",
            transform: "translateY(-50%)"
        }
    }, {
        props: {
            orientation: "vertical"
        },
        style: {
            height: "100%",
            width: "inherit",
            left: "50%",
            transform: "translateX(-50%)"
        }
    }, {
        props: {
            track: "inverted"
        },
        style: {
            opacity: 1
        }
    }]
})
  , b3 = Jt("span", {
    name: "MuiSlider",
    slot: "Track",
    overridesResolver: (e, t) => t.track
})( ({theme: e}) => {
    var t;
    return {
        display: "block",
        position: "absolute",
        borderRadius: "inherit",
        border: "1px solid currentColor",
        backgroundColor: "currentColor",
        transition: e.transitions.create(["left", "width", "bottom", "height"], {
            duration: e.transitions.duration.shortest
        }),
        variants: [{
            props: {
                size: "small"
            },
            style: {
                border: "none"
            }
        }, {
            props: {
                orientation: "horizontal"
            },
            style: {
                height: "inherit",
                top: "50%",
                transform: "translateY(-50%)"
            }
        }, {
            props: {
                orientation: "vertical"
            },
            style: {
                width: "inherit",
                left: "50%",
                transform: "translateX(-50%)"
            }
        }, {
            props: {
                track: !1
            },
            style: {
                display: "none"
            }
        }, ...Object.keys(((t = e.vars) != null ? t : e).palette).filter(i => {
            var s;
            return ((s = e.vars) != null ? s : e).palette[i].main
        }
        ).map(i => ({
            props: {
                color: i,
                track: "inverted"
            },
            style: xe({}, e.vars ? {
                backgroundColor: e.vars.palette.Slider[`${i}Track`],
                borderColor: e.vars.palette.Slider[`${i}Track`]
            } : xe({
                backgroundColor: Or.lighten(e.palette[i].main, .62),
                borderColor: Or.lighten(e.palette[i].main, .62)
            }, e.applyStyles("dark", {
                backgroundColor: Or.darken(e.palette[i].main, .5)
            }), e.applyStyles("dark", {
                borderColor: Or.darken(e.palette[i].main, .5)
            })))
        }))]
    }
}
)
  , w3 = Jt("span", {
    name: "MuiSlider",
    slot: "Thumb",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.thumb, t[`thumbColor${Ot(i.color)}`], i.size !== "medium" && t[`thumbSize${Ot(i.size)}`]]
    }
})( ({theme: e}) => {
    var t;
    return {
        position: "absolute",
        width: 20,
        height: 20,
        boxSizing: "border-box",
        borderRadius: "50%",
        outline: 0,
        backgroundColor: "currentColor",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        transition: e.transitions.create(["box-shadow", "left", "bottom"], {
            duration: e.transitions.duration.shortest
        }),
        "&::before": {
            position: "absolute",
            content: '""',
            borderRadius: "inherit",
            width: "100%",
            height: "100%",
            boxShadow: (e.vars || e).shadows[2]
        },
        "&::after": {
            position: "absolute",
            content: '""',
            borderRadius: "50%",
            width: 42,
            height: 42,
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)"
        },
        [`&.${fl.disabled}`]: {
            "&:hover": {
                boxShadow: "none"
            }
        },
        variants: [{
            props: {
                size: "small"
            },
            style: {
                width: 12,
                height: 12,
                "&::before": {
                    boxShadow: "none"
                }
            }
        }, {
            props: {
                orientation: "horizontal"
            },
            style: {
                top: "50%",
                transform: "translate(-50%, -50%)"
            }
        }, {
            props: {
                orientation: "vertical"
            },
            style: {
                left: "50%",
                transform: "translate(-50%, 50%)"
            }
        }, ...Object.keys(((t = e.vars) != null ? t : e).palette).filter(i => {
            var s;
            return ((s = e.vars) != null ? s : e).palette[i].main
        }
        ).map(i => ({
            props: {
                color: i
            },
            style: {
                [`&:hover, &.${fl.focusVisible}`]: xe({}, e.vars ? {
                    boxShadow: `0px 0px 0px 8px rgba(${e.vars.palette[i].mainChannel} / 0.16)`
                } : {
                    boxShadow: `0px 0px 0px 8px ${Or.alpha(e.palette[i].main, .16)}`
                }, {
                    "@media (hover: none)": {
                        boxShadow: "none"
                    }
                }),
                [`&.${fl.active}`]: xe({}, e.vars ? {
                    boxShadow: `0px 0px 0px 14px rgba(${e.vars.palette[i].mainChannel} / 0.16)`
                } : {
                    boxShadow: `0px 0px 0px 14px ${Or.alpha(e.palette[i].main, .16)}`
                })
            }
        }))]
    }
}
)
  , S3 = Jt(y3, {
    name: "MuiSlider",
    slot: "ValueLabel",
    overridesResolver: (e, t) => t.valueLabel
})( ({theme: e}) => xe({
    zIndex: 1,
    whiteSpace: "nowrap"
}, e.typography.body2, {
    fontWeight: 500,
    transition: e.transitions.create(["transform"], {
        duration: e.transitions.duration.shortest
    }),
    position: "absolute",
    backgroundColor: (e.vars || e).palette.grey[600],
    borderRadius: 2,
    color: (e.vars || e).palette.common.white,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: "0.25rem 0.75rem",
    variants: [{
        props: {
            orientation: "horizontal"
        },
        style: {
            transform: "translateY(-100%) scale(0)",
            top: "-10px",
            transformOrigin: "bottom center",
            "&::before": {
                position: "absolute",
                content: '""',
                width: 8,
                height: 8,
                transform: "translate(-50%, 50%) rotate(45deg)",
                backgroundColor: "inherit",
                bottom: 0,
                left: "50%"
            },
            [`&.${fl.valueLabelOpen}`]: {
                transform: "translateY(-100%) scale(1)"
            }
        }
    }, {
        props: {
            orientation: "vertical"
        },
        style: {
            transform: "translateY(-50%) scale(0)",
            right: "30px",
            top: "50%",
            transformOrigin: "right center",
            "&::before": {
                position: "absolute",
                content: '""',
                width: 8,
                height: 8,
                transform: "translate(-50%, -50%) rotate(45deg)",
                backgroundColor: "inherit",
                right: -8,
                top: "50%"
            },
            [`&.${fl.valueLabelOpen}`]: {
                transform: "translateY(-50%) scale(1)"
            }
        }
    }, {
        props: {
            size: "small"
        },
        style: {
            fontSize: e.typography.pxToRem(12),
            padding: "0.25rem 0.5rem"
        }
    }, {
        props: {
            orientation: "vertical",
            size: "small"
        },
        style: {
            right: "20px"
        }
    }]
}))
  , C3 = Jt("span", {
    name: "MuiSlider",
    slot: "Mark",
    shouldForwardProp: e => Nx(e) && e !== "markActive",
    overridesResolver: (e, t) => {
        const {markActive: i} = e;
        return [t.mark, i && t.markActive]
    }
})( ({theme: e}) => ({
    position: "absolute",
    width: 2,
    height: 2,
    borderRadius: 1,
    backgroundColor: "currentColor",
    variants: [{
        props: {
            orientation: "horizontal"
        },
        style: {
            top: "50%",
            transform: "translate(-1px, -50%)"
        }
    }, {
        props: {
            orientation: "vertical"
        },
        style: {
            left: "50%",
            transform: "translate(-50%, 1px)"
        }
    }, {
        props: {
            markActive: !0
        },
        style: {
            backgroundColor: (e.vars || e).palette.background.paper,
            opacity: .8
        }
    }]
}))
  , T3 = Jt("span", {
    name: "MuiSlider",
    slot: "MarkLabel",
    shouldForwardProp: e => Nx(e) && e !== "markLabelActive",
    overridesResolver: (e, t) => t.markLabel
})( ({theme: e}) => xe({}, e.typography.body2, {
    color: (e.vars || e).palette.text.secondary,
    position: "absolute",
    whiteSpace: "nowrap",
    variants: [{
        props: {
            orientation: "horizontal"
        },
        style: {
            top: 30,
            transform: "translateX(-50%)",
            "@media (pointer: coarse)": {
                top: 40
            }
        }
    }, {
        props: {
            orientation: "vertical"
        },
        style: {
            left: 36,
            transform: "translateY(50%)",
            "@media (pointer: coarse)": {
                left: 44
            }
        }
    }, {
        props: {
            markLabelActive: !0
        },
        style: {
            color: (e.vars || e).palette.text.primary
        }
    }]
}))
  , P3 = e => {
    const {disabled: t, dragging: i, marked: s, orientation: u, track: d, classes: f, color: o, size: w} = e
      , T = {
        root: ["root", t && "disabled", i && "dragging", s && "marked", u === "vertical" && "vertical", d === "inverted" && "trackInverted", d === !1 && "trackFalse", o && `color${Ot(o)}`, w && `size${Ot(w)}`],
        rail: ["rail"],
        track: ["track"],
        mark: ["mark"],
        markActive: ["markActive"],
        markLabel: ["markLabel"],
        markLabelActive: ["markLabelActive"],
        valueLabel: ["valueLabel"],
        thumb: ["thumb", t && "disabled", w && `thumbSize${Ot(w)}`, o && `thumbColor${Ot(o)}`],
        active: ["active"],
        disabled: ["disabled"],
        focusVisible: ["focusVisible"]
    };
    return Jr(T, m3, f)
}
  , M3 = ({children: e}) => e
  , P0 = Pe.forwardRef(function(t, i) {
    var s, u, d, f, o, w, T, k, L, z, D, N, U, V, re, ie, ue, ce, X, me, K, be, Ee, Ce;
    const He = nn({
        props: t,
        name: "MuiSlider"
    })
      , ct = Bx()
      , {"aria-label": nt, "aria-valuetext": J, "aria-labelledby": he, component: ve="span", components: Ne={}, componentsProps: je={}, color: lt="primary", classes: Pt, className: We, disableSwap: st=!1, disabled: Nt=!1, getAriaLabel: zt, getAriaValueText: Qt, marks: Wt=!1, max: tr=100, min: cr=0, orientation: Yt="horizontal", shiftStep: Gr=10, size: xr="medium", step: Nr=1, scale: ur=Dw, slotProps: vr, slots: gr, track: hn="normal", valueLabelDisplay: Zr="off", valueLabelFormat: $r=Dw} = He
      , gn = dr(He, _3)
      , zr = xe({}, He, {
        isRtl: ct,
        max: tr,
        min: cr,
        classes: Pt,
        disabled: Nt,
        disableSwap: st,
        orientation: Yt,
        marks: Wt,
        color: lt,
        size: xr,
        step: Nr,
        shiftStep: Gr,
        scale: ur,
        track: hn,
        valueLabelDisplay: Zr,
        valueLabelFormat: $r
    })
      , {axisProps: Wr, getRootProps: $n, getHiddenInputProps: Dn, getThumbProps: yn, open: Tn, active: bn, axis: sn, focusedThumbIndex: Mt, range: kt, dragging: er, marks: Er, values: Ue, trackOffset: se, trackLeap: fe, getThumbStyle: ge} = f3(xe({}, zr, {
        rootRef: i
    }));
    zr.marked = Er.length > 0 && Er.some(it => it.label),
    zr.dragging = er,
    zr.focusedThumbIndex = Mt;
    const Me = P3(zr)
      , $e = (s = (u = gr?.root) != null ? u : Ne.Root) != null ? s : v3
      , et = (d = (f = gr?.rail) != null ? f : Ne.Rail) != null ? d : x3
      , at = (o = (w = gr?.track) != null ? w : Ne.Track) != null ? o : b3
      , Qe = (T = (k = gr?.thumb) != null ? k : Ne.Thumb) != null ? T : w3
      , _t = (L = (z = gr?.valueLabel) != null ? z : Ne.ValueLabel) != null ? L : S3
      , dt = (D = (N = gr?.mark) != null ? N : Ne.Mark) != null ? D : C3
      , tt = (U = (V = gr?.markLabel) != null ? V : Ne.MarkLabel) != null ? U : T3
      , St = (re = (ie = gr?.input) != null ? ie : Ne.Input) != null ? re : "input"
      , Ve = (ue = vr?.root) != null ? ue : je.root
      , Ut = (ce = vr?.rail) != null ? ce : je.rail
      , yr = (X = vr?.track) != null ? X : je.track
      , Ht = (me = vr?.thumb) != null ? me : je.thumb
      , sr = (K = vr?.valueLabel) != null ? K : je.valueLabel
      , br = (be = vr?.mark) != null ? be : je.mark
      , en = (Ee = vr?.markLabel) != null ? Ee : je.markLabel
      , qr = (Ce = vr?.input) != null ? Ce : je.input
      , Dr = cl({
        elementType: $e,
        getSlotProps: $n,
        externalSlotProps: Ve,
        externalForwardedProps: gn,
        additionalProps: xe({}, p3($e) && {
            as: ve
        }),
        ownerState: xe({}, zr, Ve?.ownerState),
        className: [Me.root, We]
    })
      , fr = cl({
        elementType: et,
        externalSlotProps: Ut,
        ownerState: zr,
        className: Me.rail
    })
      , ke = cl({
        elementType: at,
        externalSlotProps: yr,
        additionalProps: {
            style: xe({}, Wr[sn].offset(se), Wr[sn].leap(fe))
        },
        ownerState: xe({}, zr, yr?.ownerState),
        className: Me.track
    })
      , le = cl({
        elementType: Qe,
        getSlotProps: yn,
        externalSlotProps: Ht,
        ownerState: xe({}, zr, Ht?.ownerState),
        className: Me.thumb
    })
      , ee = cl({
        elementType: _t,
        externalSlotProps: sr,
        ownerState: xe({}, zr, sr?.ownerState),
        className: Me.valueLabel
    })
      , Ze = cl({
        elementType: dt,
        externalSlotProps: br,
        ownerState: zr,
        className: Me.mark
    })
      , Ge = cl({
        elementType: tt,
        externalSlotProps: en,
        ownerState: zr,
        className: Me.markLabel
    })
      , vt = cl({
        elementType: St,
        getSlotProps: Dn,
        externalSlotProps: qr,
        ownerState: zr
    });
    return G.jsxs($e, xe({}, Dr, {
        children: [G.jsx(et, xe({}, fr)), G.jsx(at, xe({}, ke)), Er.filter(it => it.value >= cr && it.value <= tr).map( (it, Xe) => {
            const wt = X_(it.value, cr, tr)
              , Ct = Wr[sn].offset(wt);
            let Gt;
            return hn === !1 ? Gt = Ue.indexOf(it.value) !== -1 : Gt = hn === "normal" && (kt ? it.value >= Ue[0] && it.value <= Ue[Ue.length - 1] : it.value <= Ue[0]) || hn === "inverted" && (kt ? it.value <= Ue[0] || it.value >= Ue[Ue.length - 1] : it.value >= Ue[0]),
            G.jsxs(Pe.Fragment, {
                children: [G.jsx(dt, xe({
                    "data-index": Xe
                }, Ze, !oh(dt) && {
                    markActive: Gt
                }, {
                    style: xe({}, Ct, Ze.style),
                    className: nr(Ze.className, Gt && Me.markActive)
                })), it.label != null ? G.jsx(tt, xe({
                    "aria-hidden": !0,
                    "data-index": Xe
                }, Ge, !oh(tt) && {
                    markLabelActive: Gt
                }, {
                    style: xe({}, Ct, Ge.style),
                    className: nr(Me.markLabel, Ge.className, Gt && Me.markLabelActive),
                    children: it.label
                })) : null]
            }, Xe)
        }
        ), Ue.map( (it, Xe) => {
            const wt = X_(it, cr, tr)
              , Ct = Wr[sn].offset(wt)
              , Gt = Zr === "off" ? M3 : _t;
            return G.jsx(Gt, xe({}, !oh(Gt) && {
                valueLabelFormat: $r,
                valueLabelDisplay: Zr,
                value: typeof $r == "function" ? $r(ur(it), Xe) : $r,
                index: Xe,
                open: Tn === Xe || bn === Xe || Zr === "on",
                disabled: Nt
            }, ee, {
                children: G.jsx(Qe, xe({
                    "data-index": Xe
                }, le, {
                    className: nr(Me.thumb, le.className, bn === Xe && Me.active, Mt === Xe && Me.focusVisible),
                    style: xe({}, Ct, ge(Xe), le.style),
                    children: G.jsx(St, xe({
                        "data-index": Xe,
                        "aria-label": zt ? zt(Xe) : nt,
                        "aria-valuenow": ur(it),
                        "aria-labelledby": he,
                        "aria-valuetext": Qt ? Qt(ur(it), Xe) : J,
                        value: Ue[Xe]
                    }, vt))
                }))
            }), Xe)
        }
        )]
    }))
});
function k3(e) {
    return Kr("MuiTooltip", e)
}
const Hh = Qr("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"])
  , E3 = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];
function I3(e) {
    return Math.round(e * 1e5) / 1e5
}
const R3 = e => {
    const {classes: t, disableInteractive: i, arrow: s, touch: u, placement: d} = e
      , f = {
        popper: ["popper", !i && "popperInteractive", s && "popperArrow"],
        tooltip: ["tooltip", s && "tooltipArrow", u && "touch", `tooltipPlacement${Ot(d.split("-")[0])}`],
        arrow: ["arrow"]
    };
    return Jr(f, k3, t)
}
  , A3 = Jt(fT, {
    name: "MuiTooltip",
    slot: "Popper",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.popper, !i.disableInteractive && t.popperInteractive, i.arrow && t.popperArrow, !i.open && t.popperClose]
    }
})( ({theme: e, ownerState: t, open: i}) => xe({
    zIndex: (e.vars || e).zIndex.tooltip,
    pointerEvents: "none"
}, !t.disableInteractive && {
    pointerEvents: "auto"
}, !i && {
    pointerEvents: "none"
}, t.arrow && {
    [`&[data-popper-placement*="bottom"] .${Hh.arrow}`]: {
        top: 0,
        marginTop: "-0.71em",
        "&::before": {
            transformOrigin: "0 100%"
        }
    },
    [`&[data-popper-placement*="top"] .${Hh.arrow}`]: {
        bottom: 0,
        marginBottom: "-0.71em",
        "&::before": {
            transformOrigin: "100% 0"
        }
    },
    [`&[data-popper-placement*="right"] .${Hh.arrow}`]: xe({}, t.isRtl ? {
        right: 0,
        marginRight: "-0.71em"
    } : {
        left: 0,
        marginLeft: "-0.71em"
    }, {
        height: "1em",
        width: "0.71em",
        "&::before": {
            transformOrigin: "100% 100%"
        }
    }),
    [`&[data-popper-placement*="left"] .${Hh.arrow}`]: xe({}, t.isRtl ? {
        left: 0,
        marginLeft: "-0.71em"
    } : {
        right: 0,
        marginRight: "-0.71em"
    }, {
        height: "1em",
        width: "0.71em",
        "&::before": {
            transformOrigin: "0 0"
        }
    })
}))
  , z3 = Jt("div", {
    name: "MuiTooltip",
    slot: "Tooltip",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.tooltip, i.touch && t.touch, i.arrow && t.tooltipArrow, t[`tooltipPlacement${Ot(i.placement.split("-")[0])}`]]
    }
})( ({theme: e, ownerState: t}) => xe({
    backgroundColor: e.vars ? e.vars.palette.Tooltip.bg : Or.alpha(e.palette.grey[700], .92),
    borderRadius: (e.vars || e).shape.borderRadius,
    color: (e.vars || e).palette.common.white,
    fontFamily: e.typography.fontFamily,
    padding: "4px 8px",
    fontSize: e.typography.pxToRem(11),
    maxWidth: 300,
    margin: 2,
    wordWrap: "break-word",
    fontWeight: e.typography.fontWeightMedium
}, t.arrow && {
    position: "relative",
    margin: 0
}, t.touch && {
    padding: "8px 16px",
    fontSize: e.typography.pxToRem(14),
    lineHeight: `${I3(16 / 14)}em`,
    fontWeight: e.typography.fontWeightRegular
}, {
    [`.${Hh.popper}[data-popper-placement*="left"] &`]: xe({
        transformOrigin: "right center"
    }, t.isRtl ? xe({
        marginLeft: "14px"
    }, t.touch && {
        marginLeft: "24px"
    }) : xe({
        marginRight: "14px"
    }, t.touch && {
        marginRight: "24px"
    })),
    [`.${Hh.popper}[data-popper-placement*="right"] &`]: xe({
        transformOrigin: "left center"
    }, t.isRtl ? xe({
        marginRight: "14px"
    }, t.touch && {
        marginRight: "24px"
    }) : xe({
        marginLeft: "14px"
    }, t.touch && {
        marginLeft: "24px"
    })),
    [`.${Hh.popper}[data-popper-placement*="top"] &`]: xe({
        transformOrigin: "center bottom",
        marginBottom: "14px"
    }, t.touch && {
        marginBottom: "24px"
    }),
    [`.${Hh.popper}[data-popper-placement*="bottom"] &`]: xe({
        transformOrigin: "center top",
        marginTop: "14px"
    }, t.touch && {
        marginTop: "24px"
    })
}))
  , D3 = Jt("span", {
    name: "MuiTooltip",
    slot: "Arrow",
    overridesResolver: (e, t) => t.arrow
})( ({theme: e}) => ({
    overflow: "hidden",
    position: "absolute",
    width: "1em",
    height: "0.71em",
    boxSizing: "border-box",
    color: e.vars ? e.vars.palette.Tooltip.bg : Or.alpha(e.palette.grey[700], .9),
    "&::before": {
        content: '""',
        margin: "auto",
        display: "block",
        width: "100%",
        height: "100%",
        backgroundColor: "currentColor",
        transform: "rotate(45deg)"
    }
}));
let l_ = !1;
const Lw = new hy;
let Gm = {
    x: 0,
    y: 0
};
function c_(e, t) {
    return (i, ...s) => {
        t && t(i, ...s),
        e(i, ...s)
    }
}
const tb = Pe.forwardRef(function(t, i) {
    var s, u, d, f, o, w, T, k, L, z, D, N, U, V, re, ie, ue, ce, X;
    const me = nn({
        props: t,
        name: "MuiTooltip"
    })
      , {arrow: K=!1, children: be, components: Ee={}, componentsProps: Ce={}, describeChild: He=!1, disableFocusListener: ct=!1, disableHoverListener: nt=!1, disableInteractive: J=!1, disableTouchListener: he=!1, enterDelay: ve=100, enterNextDelay: Ne=0, enterTouchDelay: je=700, followCursor: lt=!1, id: Pt, leaveDelay: We=0, leaveTouchDelay: st=1500, onClose: Nt, onOpen: zt, open: Qt, placement: Wt="bottom", PopperComponent: tr, PopperProps: cr={}, slotProps: Yt={}, slots: Gr={}, title: xr, TransitionComponent: Nr=cx, TransitionProps: ur} = me
      , vr = dr(me, E3)
      , gr = Pe.isValidElement(be) ? be : G.jsx("span", {
        children: be
    })
      , hn = Kp()
      , Zr = Bx()
      , [$r,gn] = Pe.useState()
      , [zr,Wr] = Pe.useState(null)
      , $n = Pe.useRef(!1)
      , Dn = J || lt
      , yn = Pp()
      , Tn = Pp()
      , bn = Pp()
      , sn = Pp()
      , [Mt,kt] = uy({
        controlled: Qt,
        default: !1,
        name: "Tooltip",
        state: "open"
    });
    let er = Mt;
    const Er = yv(Pt)
      , Ue = Pe.useRef()
      , se = dl( () => {
        Ue.current !== void 0 && (document.body.style.WebkitUserSelect = Ue.current,
        Ue.current = void 0),
        sn.clear()
    }
    );
    Pe.useEffect( () => se, [se]);
    const fe = Xt => {
        Lw.clear(),
        l_ = !0,
        kt(!0),
        zt && !er && zt(Xt)
    }
      , ge = dl(Xt => {
        Lw.start(800 + We, () => {
            l_ = !1
        }
        ),
        kt(!1),
        Nt && er && Nt(Xt),
        yn.start(hn.transitions.duration.shortest, () => {
            $n.current = !1
        }
        )
    }
    )
      , Me = Xt => {
        $n.current && Xt.type !== "touchstart" || ($r && $r.removeAttribute("title"),
        Tn.clear(),
        bn.clear(),
        ve || l_ && Ne ? Tn.start(l_ ? Ne : ve, () => {
            fe(Xt)
        }
        ) : fe(Xt))
    }
      , $e = Xt => {
        Tn.clear(),
        bn.start(We, () => {
            ge(Xt)
        }
        )
    }
      , {isFocusVisibleRef: et, onBlur: at, onFocus: Qe, ref: _t} = dy()
      , [,dt] = Pe.useState(!1)
      , tt = Xt => {
        at(Xt),
        et.current === !1 && (dt(!1),
        $e(Xt))
    }
      , St = Xt => {
        $r || gn(Xt.currentTarget),
        Qe(Xt),
        et.current === !0 && (dt(!0),
        Me(Xt))
    }
      , Ve = Xt => {
        $n.current = !0;
        const lr = gr.props;
        lr.onTouchStart && lr.onTouchStart(Xt)
    }
      , Ut = Xt => {
        Ve(Xt),
        bn.clear(),
        yn.clear(),
        se(),
        Ue.current = document.body.style.WebkitUserSelect,
        document.body.style.WebkitUserSelect = "none",
        sn.start(je, () => {
            document.body.style.WebkitUserSelect = Ue.current,
            Me(Xt)
        }
        )
    }
      , yr = Xt => {
        gr.props.onTouchEnd && gr.props.onTouchEnd(Xt),
        se(),
        bn.start(st, () => {
            ge(Xt)
        }
        )
    }
    ;
    Pe.useEffect( () => {
        if (!er)
            return;
        function Xt(lr) {
            (lr.key === "Escape" || lr.key === "Esc") && ge(lr)
        }
        return document.addEventListener("keydown", Xt),
        () => {
            document.removeEventListener("keydown", Xt)
        }
    }
    , [ge, er]);
    const Ht = ki(gr.ref, _t, gn, i);
    !xr && xr !== 0 && (er = !1);
    const sr = Pe.useRef()
      , br = Xt => {
        const lr = gr.props;
        lr.onMouseMove && lr.onMouseMove(Xt),
        Gm = {
            x: Xt.clientX,
            y: Xt.clientY
        },
        sr.current && sr.current.update()
    }
      , en = {}
      , qr = typeof xr == "string";
    He ? (en.title = !er && qr && !nt ? xr : null,
    en["aria-describedby"] = er ? Er : null) : (en["aria-label"] = qr ? xr : null,
    en["aria-labelledby"] = er && !qr ? Er : null);
    const Dr = xe({}, en, vr, gr.props, {
        className: nr(vr.className, gr.props.className),
        onTouchStart: Ve,
        ref: Ht
    }, lt ? {
        onMouseMove: br
    } : {})
      , fr = {};
    he || (Dr.onTouchStart = Ut,
    Dr.onTouchEnd = yr),
    nt || (Dr.onMouseOver = c_(Me, Dr.onMouseOver),
    Dr.onMouseLeave = c_($e, Dr.onMouseLeave),
    Dn || (fr.onMouseOver = Me,
    fr.onMouseLeave = $e)),
    ct || (Dr.onFocus = c_(St, Dr.onFocus),
    Dr.onBlur = c_(tt, Dr.onBlur),
    Dn || (fr.onFocus = St,
    fr.onBlur = tt));
    const ke = Pe.useMemo( () => {
        var Xt;
        let lr = [{
            name: "arrow",
            enabled: !!zr,
            options: {
                element: zr,
                padding: 4
            }
        }];
        return (Xt = cr.popperOptions) != null && Xt.modifiers && (lr = lr.concat(cr.popperOptions.modifiers)),
        xe({}, cr.popperOptions, {
            modifiers: lr
        })
    }
    , [zr, cr])
      , le = xe({}, me, {
        isRtl: Zr,
        arrow: K,
        disableInteractive: Dn,
        placement: Wt,
        PopperComponentProp: tr,
        touch: $n.current
    })
      , ee = R3(le)
      , Ze = (s = (u = Gr.popper) != null ? u : Ee.Popper) != null ? s : A3
      , Ge = (d = (f = (o = Gr.transition) != null ? o : Ee.Transition) != null ? f : Nr) != null ? d : cx
      , vt = (w = (T = Gr.tooltip) != null ? T : Ee.Tooltip) != null ? w : z3
      , it = (k = (L = Gr.arrow) != null ? L : Ee.Arrow) != null ? k : D3
      , Xe = Mp(Ze, xe({}, cr, (z = Yt.popper) != null ? z : Ce.popper, {
        className: nr(ee.popper, cr?.className, (D = (N = Yt.popper) != null ? N : Ce.popper) == null ? void 0 : D.className)
    }), le)
      , wt = Mp(Ge, xe({}, ur, (U = Yt.transition) != null ? U : Ce.transition), le)
      , Ct = Mp(vt, xe({}, (V = Yt.tooltip) != null ? V : Ce.tooltip, {
        className: nr(ee.tooltip, (re = (ie = Yt.tooltip) != null ? ie : Ce.tooltip) == null ? void 0 : re.className)
    }), le)
      , Gt = Mp(it, xe({}, (ue = Yt.arrow) != null ? ue : Ce.arrow, {
        className: nr(ee.arrow, (ce = (X = Yt.arrow) != null ? X : Ce.arrow) == null ? void 0 : ce.className)
    }), le);
    return G.jsxs(Pe.Fragment, {
        children: [Pe.cloneElement(gr, Dr), G.jsx(Ze, xe({
            as: tr ?? fT,
            placement: Wt,
            anchorEl: lt ? {
                getBoundingClientRect: () => ({
                    top: Gm.y,
                    left: Gm.x,
                    right: Gm.x,
                    bottom: Gm.y,
                    width: 0,
                    height: 0
                })
            } : $r,
            popperRef: sr,
            open: $r ? er : !1,
            id: Er,
            transition: !0
        }, fr, Xe, {
            popperOptions: ke,
            children: ({TransitionProps: Xt}) => G.jsx(Ge, xe({
                timeout: hn.transitions.duration.shorter
            }, Xt, wt, {
                children: G.jsxs(vt, xe({}, Ct, {
                    children: [xr, K ? G.jsx(it, xe({}, Gt, {
                        ref: Wr
                    })) : null]
                }))
            }))
        }))]
    })
});
function L3(e) {
    return Kr("MuiSwitch", e)
}
const Os = Qr("MuiSwitch", ["root", "edgeStart", "edgeEnd", "switchBase", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium", "checked", "disabled", "input", "thumb", "track"])
  , O3 = ["className", "color", "edge", "size", "sx"]
  , F3 = e => {
    const {classes: t, edge: i, size: s, color: u, checked: d, disabled: f} = e
      , o = {
        root: ["root", i && `edge${Ot(i)}`, `size${Ot(s)}`],
        switchBase: ["switchBase", `color${Ot(u)}`, d && "checked", f && "disabled"],
        thumb: ["thumb"],
        track: ["track"],
        input: ["input"]
    }
      , w = Jr(o, L3, t);
    return xe({}, t, w)
}
  , B3 = Jt("span", {
    name: "MuiSwitch",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, i.edge && t[`edge${Ot(i.edge)}`], t[`size${Ot(i.size)}`]]
    }
})({
    display: "inline-flex",
    width: 58,
    height: 38,
    overflow: "hidden",
    padding: 12,
    boxSizing: "border-box",
    position: "relative",
    flexShrink: 0,
    zIndex: 0,
    verticalAlign: "middle",
    "@media print": {
        colorAdjust: "exact"
    },
    variants: [{
        props: {
            edge: "start"
        },
        style: {
            marginLeft: -8
        }
    }, {
        props: {
            edge: "end"
        },
        style: {
            marginRight: -8
        }
    }, {
        props: {
            size: "small"
        },
        style: {
            width: 40,
            height: 24,
            padding: 7,
            [`& .${Os.thumb}`]: {
                width: 16,
                height: 16
            },
            [`& .${Os.switchBase}`]: {
                padding: 4,
                [`&.${Os.checked}`]: {
                    transform: "translateX(16px)"
                }
            }
        }
    }]
})
  , j3 = Jt(eb, {
    name: "MuiSwitch",
    slot: "SwitchBase",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.switchBase, {
            [`& .${Os.input}`]: t.input
        }, i.color !== "default" && t[`color${Ot(i.color)}`]]
    }
})( ({theme: e}) => ({
    position: "absolute",
    top: 0,
    left: 0,
    zIndex: 1,
    color: e.vars ? e.vars.palette.Switch.defaultColor : `${e.palette.mode === "light" ? e.palette.common.white : e.palette.grey[300]}`,
    transition: e.transitions.create(["left", "transform"], {
        duration: e.transitions.duration.shortest
    }),
    [`&.${Os.checked}`]: {
        transform: "translateX(20px)"
    },
    [`&.${Os.disabled}`]: {
        color: e.vars ? e.vars.palette.Switch.defaultDisabledColor : `${e.palette.mode === "light" ? e.palette.grey[100] : e.palette.grey[600]}`
    },
    [`&.${Os.checked} + .${Os.track}`]: {
        opacity: .5
    },
    [`&.${Os.disabled} + .${Os.track}`]: {
        opacity: e.vars ? e.vars.opacity.switchTrackDisabled : `${e.palette.mode === "light" ? .12 : .2}`
    },
    [`& .${Os.input}`]: {
        left: "-100%",
        width: "300%"
    }
}), ({theme: e}) => ({
    "&:hover": {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : Or.alpha(e.palette.action.active, e.palette.action.hoverOpacity),
        "@media (hover: none)": {
            backgroundColor: "transparent"
        }
    },
    variants: [...Object.entries(e.palette).filter( ([,t]) => t.main && t.light).map( ([t]) => ({
        props: {
            color: t
        },
        style: {
            [`&.${Os.checked}`]: {
                color: (e.vars || e).palette[t].main,
                "&:hover": {
                    backgroundColor: e.vars ? `rgba(${e.vars.palette[t].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Or.alpha(e.palette[t].main, e.palette.action.hoverOpacity),
                    "@media (hover: none)": {
                        backgroundColor: "transparent"
                    }
                },
                [`&.${Os.disabled}`]: {
                    color: e.vars ? e.vars.palette.Switch[`${t}DisabledColor`] : `${e.palette.mode === "light" ? Or.lighten(e.palette[t].main, .62) : Or.darken(e.palette[t].main, .55)}`
                }
            },
            [`&.${Os.checked} + .${Os.track}`]: {
                backgroundColor: (e.vars || e).palette[t].main
            }
        }
    }))]
}))
  , N3 = Jt("span", {
    name: "MuiSwitch",
    slot: "Track",
    overridesResolver: (e, t) => t.track
})( ({theme: e}) => ({
    height: "100%",
    width: "100%",
    borderRadius: 14 / 2,
    zIndex: -1,
    transition: e.transitions.create(["opacity", "background-color"], {
        duration: e.transitions.duration.shortest
    }),
    backgroundColor: e.vars ? e.vars.palette.common.onBackground : `${e.palette.mode === "light" ? e.palette.common.black : e.palette.common.white}`,
    opacity: e.vars ? e.vars.opacity.switchTrack : `${e.palette.mode === "light" ? .38 : .3}`
}))
  , $3 = Jt("span", {
    name: "MuiSwitch",
    slot: "Thumb",
    overridesResolver: (e, t) => t.thumb
})( ({theme: e}) => ({
    boxShadow: (e.vars || e).shadows[1],
    backgroundColor: "currentColor",
    width: 20,
    height: 20,
    borderRadius: "50%"
}))
  , V3 = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiSwitch"
    })
      , {className: u, color: d="primary", edge: f=!1, size: o="medium", sx: w} = s
      , T = dr(s, O3)
      , k = xe({}, s, {
        color: d,
        edge: f,
        size: o
    })
      , L = F3(k)
      , z = G.jsx($3, {
        className: L.thumb,
        ownerState: k
    });
    return G.jsxs(B3, {
        className: nr(L.root, u),
        sx: w,
        ownerState: k,
        children: [G.jsx(j3, xe({
            type: "checkbox",
            icon: z,
            checkedIcon: z,
            ref: i,
            ownerState: k
        }, T, {
            classes: xe({}, L, {
                root: L.switchBase
            })
        })), G.jsx(N3, {
            className: L.track,
            ownerState: k
        })]
    })
})
  , MT = Pe.createContext();
function U3(e) {
    return Kr("MuiTable", e)
}
Qr("MuiTable", ["root", "stickyHeader"]);
const G3 = ["className", "component", "padding", "size", "stickyHeader"]
  , W3 = e => {
    const {classes: t, stickyHeader: i} = e;
    return Jr({
        root: ["root", i && "stickyHeader"]
    }, U3, t)
}
  , q3 = Jt("table", {
    name: "MuiTable",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, i.stickyHeader && t.stickyHeader]
    }
})( ({theme: e, ownerState: t}) => xe({
    display: "table",
    width: "100%",
    borderCollapse: "collapse",
    borderSpacing: 0,
    "& caption": xe({}, e.typography.body2, {
        padding: e.spacing(2),
        color: (e.vars || e).palette.text.secondary,
        textAlign: "left",
        captionSide: "bottom"
    })
}, t.stickyHeader && {
    borderCollapse: "separate"
}))
  , Ow = "table"
  , H3 = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiTable"
    })
      , {className: u, component: d=Ow, padding: f="normal", size: o="medium", stickyHeader: w=!1} = s
      , T = dr(s, G3)
      , k = xe({}, s, {
        component: d,
        padding: f,
        size: o,
        stickyHeader: w
    })
      , L = W3(k)
      , z = Pe.useMemo( () => ({
        padding: f,
        size: o,
        stickyHeader: w
    }), [f, o, w]);
    return G.jsx(MT.Provider, {
        value: z,
        children: G.jsx(q3, xe({
            as: d,
            role: d === Ow ? null : "table",
            ref: i,
            className: nr(L.root, u),
            ownerState: k
        }, T))
    })
})
  , Sv = Pe.createContext();
function Z3(e) {
    return Kr("MuiTableBody", e)
}
Qr("MuiTableBody", ["root"]);
const X3 = ["className", "component"]
  , Y3 = e => {
    const {classes: t} = e;
    return Jr({
        root: ["root"]
    }, Z3, t)
}
  , K3 = Jt("tbody", {
    name: "MuiTableBody",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    display: "table-row-group"
})
  , Q3 = {
    variant: "body"
}
  , Fw = "tbody"
  , J3 = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiTableBody"
    })
      , {className: u, component: d=Fw} = s
      , f = dr(s, X3)
      , o = xe({}, s, {
        component: d
    })
      , w = Y3(o);
    return G.jsx(Sv.Provider, {
        value: Q3,
        children: G.jsx(K3, xe({
            className: nr(w.root, u),
            as: d,
            ref: i,
            role: d === Fw ? null : "rowgroup",
            ownerState: o
        }, f))
    })
});
function e5(e) {
    return Kr("MuiTableCell", e)
}
const t5 = Qr("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"])
  , r5 = ["align", "className", "component", "padding", "scope", "size", "sortDirection", "variant"]
  , n5 = e => {
    const {classes: t, variant: i, align: s, padding: u, size: d, stickyHeader: f} = e
      , o = {
        root: ["root", i, f && "stickyHeader", s !== "inherit" && `align${Ot(s)}`, u !== "normal" && `padding${Ot(u)}`, `size${Ot(d)}`]
    };
    return Jr(o, e5, t)
}
  , i5 = Jt("td", {
    name: "MuiTableCell",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, t[i.variant], t[`size${Ot(i.size)}`], i.padding !== "normal" && t[`padding${Ot(i.padding)}`], i.align !== "inherit" && t[`align${Ot(i.align)}`], i.stickyHeader && t.stickyHeader]
    }
})( ({theme: e, ownerState: t}) => xe({}, e.typography.body2, {
    display: "table-cell",
    verticalAlign: "inherit",
    borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? Or.lighten(Or.alpha(e.palette.divider, 1), .88) : Or.darken(Or.alpha(e.palette.divider, 1), .68)}`,
    textAlign: "left",
    padding: 16
}, t.variant === "head" && {
    color: (e.vars || e).palette.text.primary,
    lineHeight: e.typography.pxToRem(24),
    fontWeight: e.typography.fontWeightMedium
}, t.variant === "body" && {
    color: (e.vars || e).palette.text.primary
}, t.variant === "footer" && {
    color: (e.vars || e).palette.text.secondary,
    lineHeight: e.typography.pxToRem(21),
    fontSize: e.typography.pxToRem(12)
}, t.size === "small" && {
    padding: "6px 16px",
    [`&.${t5.paddingCheckbox}`]: {
        width: 24,
        padding: "0 12px 0 16px",
        "& > *": {
            padding: 0
        }
    }
}, t.padding === "checkbox" && {
    width: 48,
    padding: "0 0 0 4px"
}, t.padding === "none" && {
    padding: 0
}, t.align === "left" && {
    textAlign: "left"
}, t.align === "center" && {
    textAlign: "center"
}, t.align === "right" && {
    textAlign: "right",
    flexDirection: "row-reverse"
}, t.align === "justify" && {
    textAlign: "justify"
}, t.stickyHeader && {
    position: "sticky",
    top: 0,
    zIndex: 2,
    backgroundColor: (e.vars || e).palette.background.default
}))
  , al = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiTableCell"
    })
      , {align: u="inherit", className: d, component: f, padding: o, scope: w, size: T, sortDirection: k, variant: L} = s
      , z = dr(s, r5)
      , D = Pe.useContext(MT)
      , N = Pe.useContext(Sv)
      , U = N && N.variant === "head";
    let V;
    f ? V = f : V = U ? "th" : "td";
    let re = w;
    V === "td" ? re = void 0 : !re && U && (re = "col");
    const ie = L || N && N.variant
      , ue = xe({}, s, {
        align: u,
        component: V,
        padding: o || (D && D.padding ? D.padding : "normal"),
        size: T || (D && D.size ? D.size : "medium"),
        sortDirection: k,
        stickyHeader: ie === "head" && D && D.stickyHeader,
        variant: ie
    })
      , ce = n5(ue);
    let X = null;
    return k && (X = k === "asc" ? "ascending" : "descending"),
    G.jsx(i5, xe({
        as: V,
        ref: i,
        className: nr(ce.root, d),
        "aria-sort": X,
        scope: re,
        ownerState: ue
    }, z))
});
function o5(e) {
    return Kr("MuiTableContainer", e)
}
Qr("MuiTableContainer", ["root"]);
const s5 = ["className", "component"]
  , a5 = e => {
    const {classes: t} = e;
    return Jr({
        root: ["root"]
    }, o5, t)
}
  , l5 = Jt("div", {
    name: "MuiTableContainer",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    width: "100%",
    overflowX: "auto"
})
  , c5 = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiTableContainer"
    })
      , {className: u, component: d="div"} = s
      , f = dr(s, s5)
      , o = xe({}, s, {
        component: d
    })
      , w = a5(o);
    return G.jsx(l5, xe({
        ref: i,
        as: d,
        className: nr(w.root, u),
        ownerState: o
    }, f))
});
function u5(e) {
    return Kr("MuiTableHead", e)
}
Qr("MuiTableHead", ["root"]);
const h5 = ["className", "component"]
  , d5 = e => {
    const {classes: t} = e;
    return Jr({
        root: ["root"]
    }, u5, t)
}
  , f5 = Jt("thead", {
    name: "MuiTableHead",
    slot: "Root",
    overridesResolver: (e, t) => t.root
})({
    display: "table-header-group"
})
  , p5 = {
    variant: "head"
}
  , Bw = "thead"
  , m5 = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiTableHead"
    })
      , {className: u, component: d=Bw} = s
      , f = dr(s, h5)
      , o = xe({}, s, {
        component: d
    })
      , w = d5(o);
    return G.jsx(Sv.Provider, {
        value: p5,
        children: G.jsx(f5, xe({
            as: d,
            className: nr(w.root, u),
            ref: i,
            role: d === Bw ? null : "rowgroup",
            ownerState: o
        }, f))
    })
});
function g5(e) {
    return Kr("MuiTableRow", e)
}
const jw = Qr("MuiTableRow", ["root", "selected", "hover", "head", "footer"])
  , y5 = ["className", "component", "hover", "selected"]
  , _5 = e => {
    const {classes: t, selected: i, hover: s, head: u, footer: d} = e;
    return Jr({
        root: ["root", i && "selected", s && "hover", u && "head", d && "footer"]
    }, g5, t)
}
  , v5 = Jt("tr", {
    name: "MuiTableRow",
    slot: "Root",
    overridesResolver: (e, t) => {
        const {ownerState: i} = e;
        return [t.root, i.head && t.head, i.footer && t.footer]
    }
})( ({theme: e}) => ({
    color: "inherit",
    display: "table-row",
    verticalAlign: "middle",
    outline: 0,
    [`&.${jw.hover}:hover`]: {
        backgroundColor: (e.vars || e).palette.action.hover
    },
    [`&.${jw.selected}`]: {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Or.alpha(e.palette.primary.main, e.palette.action.selectedOpacity),
        "&:hover": {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Or.alpha(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity)
        }
    }
}))
  , Nw = "tr"
  , u_ = Pe.forwardRef(function(t, i) {
    const s = nn({
        props: t,
        name: "MuiTableRow"
    })
      , {className: u, component: d=Nw, hover: f=!1, selected: o=!1} = s
      , w = dr(s, y5)
      , T = Pe.useContext(Sv)
      , k = xe({}, s, {
        component: d,
        hover: f,
        selected: o,
        head: T && T.variant === "head",
        footer: T && T.variant === "footer"
    })
      , L = _5(k);
    return G.jsx(v5, xe({
        as: d,
        ref: i,
        className: nr(L.root, u),
        role: d === Nw ? null : "row",
        ownerState: k
    }, w))
});
var Wm = {}
  , M0 = {};
const x5 = ou(aA);
var $w;
function ls() {
    return $w || ($w = 1,
    function(e) {
        "use client";
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        Object.defineProperty(e, "default", {
            enumerable: !0,
            get: function() {
                return t.createSvgIcon
            }
        });
        var t = x5
    }(M0)),
    M0
}
var Vw;
function b5() {
    if (Vw)
        return Wm;
    Vw = 1;
    var e = Io();
    Object.defineProperty(Wm, "__esModule", {
        value: !0
    }),
    Wm.default = void 0;
    var t = e(ls())
      , i = Uo();
    return Wm.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
    }), "Close"),
    Wm
}
var w5 = b5();
const S5 = Ni(w5)
  , kT = e => G.jsx(Lg, {
    "aria-label": "Close",
    onClick: e.onClick,
    size: e.size ?? "medium",
    children: G.jsx(S5, {})
})
  , C5 = Jt("div")( ({theme: e}) => ({
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    paddingBottom: e.spacing(1)
}))
  , Cv = e => G.jsxs(C5, {
    children: [G.jsx("div", {
        children: e.children
    }), G.jsx(kT, {
        onClick: e.onClose,
        size: "large"
    })]
});
class T5 extends Pe.Component {
    render() {
        return G.jsxs(G.Fragment, {
            children: [G.jsx(Cv, {
                onClose: () => this.props.eventBus.closeAboutInfo(),
                children: G.jsx(qt, {
                    variant: "h5",
                    id: "modal-title",
                    children: "About"
                })
            }), G.jsxs(qt, {
                paragraph: !0,
                children: ["This map uses OpenStreetMap and Skimap.org data to show ski areas, runs, and lifts around the world. Backcountry ski routes, winter hiking, and sled trails are also displayed. You can add ski trails and lifts by", " ", G.jsx(Hr, {
                    onClick: t => {
                        t.preventDefault(),
                        this.props.eventBus.editMap()
                    }
                    ,
                    href: "#",
                    className: "edit-map-button",
                    children: "editing the map"
                }), ". After editing, it may take several days your changes to show up on the OpenSkiMap."]
            }), G.jsxs(qt, {
                paragraph: !0,
                children: ["Want to see the world's largest collection of traditional ski maps? Visit", " ", G.jsx(Hr, {
                    href: "http://www.skimap.org",
                    target: "_blank",
                    children: "skimap.org"
                }), "."]
            }), G.jsxs(qt, {
                paragraph: !0,
                children: ["Suggestions for improvements? Email", " ", G.jsx(Hr, {
                    href: "mailto:contact@skimap.org",
                    children: "contact@skimap.org"
                }), "."]
            }), G.jsx(qt, {
                variant: "h6",
                id: "modal-title",
                children: "Acceptable Use"
            }), G.jsx(qt, {
                paragraph: !0,
                children: "To manage costs, embedding of the website and direct use of tiles hosted at tiles.openskimap.org is not permitted. Please prepare and host your own tiles using the data below instead."
            }), G.jsx(qt, {
                variant: "h6",
                id: "modal-title",
                children: "Code"
            }), G.jsxs(qt, {
                paragraph: !0,
                children: ["This project is", " ", G.jsx(Hr, {
                    href: "https://www.github.com/russellporter/openskimap.org",
                    target: "_blank",
                    children: "open source on GitHub"
                }), "."]
            }), G.jsx(qt, {
                variant: "h6",
                id: "modal-title",
                children: "Data Downloads"
            }), G.jsx(qt, {
                paragraph: !0,
                children: "The following data is available for download under the license. GeoJSON format is spatial data with all attributes, while CSV is tabular data for easier analysis. Note that data formats are not stable and may change as the project evolves."
            }), G.jsx(qt, {
                paragraph: !0,
                children: "Use is subject to the Open Database license. You must attribute OpenSkiMap.org and OpenStreetMap appropriately."
            }), G.jsx(c5, {
                sx: {
                    marginBottom: 2
                },
                children: G.jsxs(H3, {
                    size: "small",
                    children: [G.jsx(m5, {
                        style: {
                            backgroundColor: "#f5f5f5"
                        },
                        children: G.jsxs(u_, {
                            children: [G.jsx(al, {
                                style: {
                                    fontWeight: "bold"
                                },
                                children: "Dataset"
                            }), G.jsx(al, {
                                style: {
                                    fontWeight: "bold"
                                },
                                children: "GeoJSON"
                            }), G.jsx(al, {
                                style: {
                                    fontWeight: "bold"
                                },
                                children: "CSV"
                            })]
                        })
                    }), G.jsxs(J3, {
                        children: [G.jsxs(u_, {
                            children: [G.jsx(al, {
                                children: "Ski Areas"
                            }), G.jsx(al, {
                                children: G.jsx(Hr, {
                                    href: "https://tiles.openskimap.org/geojson/ski_areas.geojson",
                                    children: "Download"
                                })
                            }), G.jsx(al, {
                                children: G.jsx(Hr, {
                                    href: "https://tiles.openskimap.org/csv/ski_areas.csv",
                                    children: "Download"
                                })
                            })]
                        }), G.jsxs(u_, {
                            children: [G.jsx(al, {
                                children: "Lifts"
                            }), G.jsx(al, {
                                children: G.jsx(Hr, {
                                    href: "https://tiles.openskimap.org/geojson/lifts.geojson",
                                    children: "Download"
                                })
                            }), G.jsx(al, {
                                children: G.jsx(Hr, {
                                    href: "https://tiles.openskimap.org/csv/lifts.csv",
                                    children: "Download"
                                })
                            })]
                        }), G.jsxs(u_, {
                            children: [G.jsx(al, {
                                children: "Runs"
                            }), G.jsx(al, {
                                children: G.jsx(Hr, {
                                    href: "https://tiles.openskimap.org/geojson/runs.geojson",
                                    children: "Download"
                                })
                            }), G.jsx(al, {
                                children: G.jsx(Hr, {
                                    href: "https://tiles.openskimap.org/csv/runs.csv",
                                    children: "Download"
                                })
                            })]
                        })]
                    })]
                })
            }), G.jsx(qt, {
                paragraph: !0,
                children: "The data is generally updated daily. It's permitted to automatically download the above files once per day."
            })]
        })
    }
}
const P5 = e => G.jsx(wv, {
    open: e.open,
    onClose: () => {
        e.eventBus.closeAboutInfo()
    }
    ,
    children: G.jsx(ka, {
        sx: {
            p: 4
        },
        children: G.jsx(T5, {
            eventBus: e.eventBus
        })
    })
});
function M5() {
    rb("https://skimap.org/pages/privacyPolicy")
}
function k5() {
    rb("https://skimap.org/pages/cookiePolicy")
}
function E5(e) {
    let t = e.getCenter().wrap();
    rb("https://www.openstreetmap.org/edit?editor=id#map=" + e.getZoom() + "/" + t.lat + "/" + t.lng)
}
function rb(e) {
    let t = document.createElement("a");
    t.href = e,
    t.setAttribute("target", "_blank"),
    t.click()
}
class I5 {
    _container;
    _button;
    _map;
    _eventBus;
    constructor(t) {
        this._eventBus = t,
        this._container = document.createElement("div"),
        this._container.className = "maplibregl-ctrl maplibregl-ctrl-group",
        this._button = document.createElement("button"),
        this._button.className = "maplibregl-ctrl-icon",
        this._button.type = "button",
        this._button.setAttribute("aria-label", "Layers"),
        this._button.title = "Layers",
        this._button.innerHTML = `
      <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
        <path d="M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16zm0-11.47L17.74 9 12 13.47 6.26 9 12 4.53z"/>
      </svg>
    `,
        this._container.appendChild(this._button),
        this._container.addEventListener("contextmenu", i => i.preventDefault()),
        this._button.addEventListener("click", this._onButtonClick.bind(this))
    }
    onAdd = t => (this._map = t,
    this._container);
    onRemove = () => {
        const t = this._container.parentNode;
        t && t.removeChild(this._container),
        this._map = void 0
    }
    ;
    getDefaultPosition = () => "bottom-right";
    _onButtonClick = () => {
        this._eventBus.openLayers()
    }
}
const R5 = rc(G.jsx("path", {
    d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close")
  , A5 = rc(G.jsx("path", {
    d: "M5 20h14v-2H5zm0-10h4v6h6v-6h4l-7-7z"
}), "Upload");
var Yc = (e => (e.Satellite = "satellite",
e.Terrain = "terrain",
e))(Yc || {})
  , Vp = (e => (e.Slope = "slope",
e))(Vp || {});
const z5 = {
    satellite: "https://tiles.openskimap.org/styles/satellite_v2.json?v=1756581669430",
    terrain: "https://tiles.openskimap.org/styles/terrain_v2.json?v=1756581669430"
};
var Ma = 63710088e-1
  , ET = {
    centimeters: Ma * 100,
    centimetres: Ma * 100,
    degrees: 360 / (2 * Math.PI),
    feet: Ma * 3.28084,
    inches: Ma * 39.37,
    kilometers: Ma / 1e3,
    kilometres: Ma / 1e3,
    meters: Ma,
    metres: Ma,
    miles: Ma / 1609.344,
    millimeters: Ma * 1e3,
    millimetres: Ma * 1e3,
    nauticalmiles: Ma / 1852,
    radians: 1,
    yards: Ma * 1.0936
};
function Up(e, t, i={}) {
    const s = {
        type: "Feature"
    };
    return (i.id === 0 || i.id) && (s.id = i.id),
    i.bbox && (s.bbox = i.bbox),
    s.properties = t || {},
    s.geometry = e,
    s
}
function Ap(e, t, i={}) {
    if (!e)
        throw new Error("coordinates is required");
    if (!Array.isArray(e))
        throw new Error("coordinates must be an Array");
    if (e.length < 2)
        throw new Error("coordinates must be at least 2 numbers long");
    if (!Gw(e[0]) || !Gw(e[1]))
        throw new Error("coordinates must contain numbers");
    return Up({
        type: "Point",
        coordinates: e
    }, t, i)
}
function cf(e, t, i={}) {
    if (e.length < 2)
        throw new Error("coordinates must be an array of two or more positions");
    return Up({
        type: "LineString",
        coordinates: e
    }, t, i)
}
function Uw(e, t={}) {
    const i = {
        type: "FeatureCollection"
    };
    return t.id && (i.id = t.id),
    t.bbox && (i.bbox = t.bbox),
    i.features = e,
    i
}
function D5(e, t="kilometers") {
    const i = ET[t];
    if (!i)
        throw new Error(t + " units is invalid");
    return e * i
}
function L5(e, t="kilometers") {
    const i = ET[t];
    if (!i)
        throw new Error(t + " units is invalid");
    return e / i
}
function ux(e) {
    return e % (2 * Math.PI) * 180 / Math.PI
}
function Jl(e) {
    return e % 360 * Math.PI / 180
}
function Gw(e) {
    return !isNaN(e) && e !== null && !Array.isArray(e)
}
function O5(e) {
    return e !== null && typeof e == "object" && !Array.isArray(e)
}
function Kg(e) {
    if (!e)
        throw new Error("coord is required");
    if (!Array.isArray(e)) {
        if (e.type === "Feature" && e.geometry !== null && e.geometry.type === "Point")
            return [...e.geometry.coordinates];
        if (e.type === "Point")
            return [...e.coordinates]
    }
    if (Array.isArray(e) && e.length >= 2 && !Array.isArray(e[0]) && !Array.isArray(e[1]))
        return [...e];
    throw new Error("coord must be GeoJSON Point or an Array of numbers")
}
function F5(e) {
    if (Array.isArray(e))
        return e;
    if (e.type === "Feature") {
        if (e.geometry !== null)
            return e.geometry.coordinates
    } else if (e.coordinates)
        return e.coordinates;
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")
}
function uf(e, t, i={}) {
    var s = Kg(e)
      , u = Kg(t)
      , d = Jl(u[1] - s[1])
      , f = Jl(u[0] - s[0])
      , o = Jl(s[1])
      , w = Jl(u[1])
      , T = Math.pow(Math.sin(d / 2), 2) + Math.pow(Math.sin(f / 2), 2) * Math.cos(o) * Math.cos(w);
    return D5(2 * Math.atan2(Math.sqrt(T), Math.sqrt(1 - T)), i.units)
}
var IT = uf;
function B5(e) {
    if (e.length < 2)
        return 0;
    let t = 0;
    for (let i = 1; i < e.length; i++) {
        const s = e[i - 1]
          , u = e[i];
        t += IT(s, u, {
            units: "kilometers"
        })
    }
    return Math.round(t * 10) / 10
}
function j5(e, t) {
    const s = new DOMParser().parseFromString(e, "application/xml");
    if (s.querySelector("parsererror"))
        throw new Error("Invalid GPX file format");
    const d = s.querySelectorAll("trkpt");
    if (d.length === 0)
        throw new Error("No track points found in GPX file");
    const f = [];
    if (d.forEach(z => {
        const D = parseFloat(z.getAttribute("lat") || "0")
          , N = parseFloat(z.getAttribute("lon") || "0");
        !isNaN(D) && !isNaN(N) && f.push([N, D])
    }
    ),
    f.length === 0)
        throw new Error("No valid coordinates found in GPX file");
    const w = s.querySelector("trk > name")?.textContent || t.replace(".gpx", "")
      , T = `track_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
      , k = "#FF9A56"
      , L = B5(f);
    return {
        id: T,
        name: w,
        coordinates: f,
        color: k,
        lengthKm: L
    }
}
function N5(e) {
    return new Promise( (t, i) => {
        const s = new FileReader;
        s.onload = u => {
            try {
                const d = u.target?.result
                  , f = j5(d, e.name);
                t(f)
            } catch (d) {
                i(d)
            }
        }
        ,
        s.onerror = () => {
            i(new Error("Failed to read file"))
        }
        ,
        s.readAsText(e)
    }
    )
}
const $5 = e => {
    const [t,i] = Pe.useState(!1)
      , s = Pe.useRef(null)
      , u = T => {
        const k = T.target.value;
        e.eventBus.setMapStyle(k)
    }
      , d = T => {
        const k = T.target.checked;
        e.eventBus.setMapStyleOverlay(k ? Vp.Slope : null)
    }
      , f = async T => {
        const k = T.target.files?.[0];
        if (k) {
            if (!k.name.toLowerCase().endsWith(".gpx")) {
                alert("Please select a GPX file");
                return
            }
            i(!0);
            try {
                const L = await N5(k);
                e.eventBus.addTrack(L)
            } catch (L) {
                console.error("Error parsing GPX file:", L),
                alert(L instanceof Error ? L.message : "Failed to parse GPX file")
            } finally {
                i(!1),
                s.current && (s.current.value = "")
            }
        }
    }
      , o = T => {
        e.eventBus.removeTrack(T)
    }
      , w = () => {
        s.current?.click()
    }
    ;
    return G.jsx(wv, {
        open: e.open,
        onClose: () => {
            e.eventBus.closeLayers()
        }
        ,
        maxWidth: "sm",
        fullWidth: !0,
        children: G.jsxs(ka, {
            sx: {
                p: 3
            },
            children: [G.jsx(Cv, {
                onClose: () => e.eventBus.closeLayers(),
                children: G.jsx(qt, {
                    variant: "h6",
                    children: "Layers"
                })
            }), G.jsxs(ka, {
                sx: {
                    mt: 2
                },
                children: [G.jsx(qt, {
                    variant: "subtitle1",
                    sx: {
                        mb: 2
                    },
                    children: "Base Map"
                }), G.jsxs(TT, {
                    value: e.currentMapStyle,
                    onChange: u,
                    sx: {
                        pl: 1
                    },
                    children: [G.jsx(mf, {
                        value: Yc.Terrain,
                        control: G.jsx(Z_, {}),
                        label: "Terrain"
                    }), G.jsx(mf, {
                        value: Yc.Satellite,
                        control: G.jsx(Z_, {}),
                        label: "Satellite"
                    })]
                })]
            }), G.jsxs(ka, {
                sx: {
                    mt: 3
                },
                children: [G.jsx(qt, {
                    variant: "subtitle1",
                    sx: {
                        mb: 2
                    },
                    children: "Overlays"
                }), G.jsx(mf, {
                    control: G.jsx(V3, {
                        checked: e.currentMapStyleOverlay === Vp.Slope,
                        onChange: d
                    }),
                    label: "Slope",
                    sx: {
                        pl: 1
                    }
                })]
            }), G.jsxs(ka, {
                sx: {
                    mt: 3
                },
                children: [G.jsx(qt, {
                    variant: "subtitle1",
                    sx: {
                        mb: 2
                    },
                    children: "GPX Tracks"
                }), e.tracks.length > 0 && G.jsx(ka, {
                    sx: {
                        mb: 2,
                        pl: 1
                    },
                    children: e.tracks.map(T => G.jsxs(ka, {
                        sx: {
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "space-between",
                            mb: 1,
                            p: 1,
                            border: "1px solid",
                            borderColor: "divider",
                            borderRadius: 1,
                            bgcolor: "background.paper"
                        },
                        children: [G.jsxs(ka, {
                            sx: {
                                display: "flex",
                                alignItems: "center",
                                gap: 1
                            },
                            children: [G.jsx(ka, {
                                sx: {
                                    width: 12,
                                    height: 12,
                                    borderRadius: "50%",
                                    bgcolor: T.color,
                                    flexShrink: 0
                                }
                            }), G.jsx(qt, {
                                variant: "body2",
                                sx: {
                                    fontWeight: 500
                                },
                                children: T.name
                            }), G.jsxs(qt, {
                                variant: "caption",
                                color: "text.secondary",
                                children: ["(", T.lengthKm, " km)"]
                            })]
                        }), G.jsx(Lg, {
                            size: "small",
                            onClick: () => o(T.id),
                            sx: {
                                ml: 1
                            },
                            children: G.jsx(R5, {
                                fontSize: "small"
                            })
                        })]
                    }, T.id))
                }), G.jsxs(ka, {
                    sx: {
                        pl: 1
                    },
                    children: [G.jsx(Qx, {
                        variant: "outlined",
                        startIcon: G.jsx(A5, {}),
                        onClick: w,
                        disabled: t,
                        size: "small",
                        children: t ? "Uploading..." : "Add GPX Track"
                    }), G.jsx("input", {
                        ref: s,
                        type: "file",
                        accept: ".gpx",
                        onChange: f,
                        style: {
                            display: "none"
                        }
                    })]
                })]
            })]
        })
    })
}
  , V5 = e => G.jsx(wv, {
    open: e.open,
    onClose: () => {
        e.eventBus.closeLegal()
    }
    ,
    children: G.jsxs(ka, {
        sx: {
            p: 4
        },
        children: [G.jsx(Cv, {
            onClose: () => {
                e.eventBus.closeLegal()
            }
            ,
            children: G.jsx(qt, {
                variant: "h5",
                children: "Credits & Legal"
            })
        }), G.jsx(qt, {
            variant: "subtitle1",
            sx: {
                fontWeight: "bold",
                mb: 1
            },
            children: "Map Data"
        }), G.jsxs(qt, {
            paragraph: !0,
            sx: {
                mb: 2
            },
            children: [G.jsx(Hr, {
                href: "https://www.openstreetmap.org/copyright",
                target: "_blank",
                children: "© OpenStreetMap contributors"
            }), " ", "and ", G.jsx(Hr, {
                href: "https://openskimap.org/?about",
                children: "OpenSkiMap.org"
            }), "."]
        }), G.jsx(qt, {
            variant: "subtitle1",
            sx: {
                fontWeight: "bold",
                mb: 1
            },
            children: "Base Map"
        }), G.jsxs(qt, {
            paragraph: !0,
            sx: {
                mb: 2
            },
            children: ["Graciously provided by", " ", G.jsx(Hr, {
                href: "https://openfreemap.org/",
                target: "_blank",
                children: "OpenFreeMap"
            }), " ", "and", " ", G.jsx(Hr, {
                href: "https://www.openmaptiles.org/",
                target: "_blank",
                children: "© OpenMapTiles"
            }), "."]
        }), G.jsx(qt, {
            variant: "subtitle1",
            sx: {
                fontWeight: "bold",
                mb: 1
            },
            children: "Satellite Imagery"
        }), G.jsxs(qt, {
            paragraph: !0,
            sx: {
                mb: 2
            },
            children: ["Powered by", " ", G.jsx(Hr, {
                href: "https://www.esri.com/",
                target: "_blank",
                children: "Esri"
            })]
        }), G.jsx(qt, {
            variant: "subtitle1",
            sx: {
                fontWeight: "bold",
                mb: 1
            },
            children: "Terrain Data"
        }), G.jsxs(qt, {
            paragraph: !0,
            sx: {
                mb: 3
            },
            children: ["High-resolution elevation data from multiple national and international providers. Data preparation and compilation by", " ", G.jsx(Hr, {
                href: "https://techidiots.net/downloads/open-base-map-torrents/mbtiles/merged-terrainrgb",
                target: "_blank",
                children: "TechIdiots.net"
            }), "."]
        }), G.jsxs(ka, {
            component: "ul",
            sx: {
                pl: 2,
                m: 0,
                lineHeight: 1.6
            },
            children: [G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Global:"
                }), " ", G.jsx(Hr, {
                    href: "https://www.eorc.jaxa.jp/ALOS/en/dataset/aw3d30/aw3d30_e.htm",
                    target: "_blank",
                    children: "JAXA AW3D30"
                }), " "]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Europe:"
                }), " ", G.jsx(Hr, {
                    href: "https://sonny.4lima.de/",
                    target: "_blank",
                    children: "Sonny DTM"
                }), " "]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "France:"
                }), " ", G.jsx(Hr, {
                    href: "https://geoservices.ign.fr/rgealti",
                    target: "_blank",
                    children: "IGN RGE Alti"
                }), " "]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Italy:"
                }), " Tarquini S., I. Isola, M. Favalli, A. Battistini, G. Dotta (2023). TINITALY, a digital elevation model of Italy with a 10 meters cell size (Version 1.1). Istituto Nazionale di Geofisica e Vulcanologia (INGV).", " ", G.jsx(Hr, {
                    href: "https://doi.org/10.13127/tinitaly/1.1",
                    target: "_blank",
                    children: "https://doi.org/10.13127/tinitaly/1.1"
                })]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Italy (South Tyrol):"
                }), " ", G.jsx(Hr, {
                    href: "https://natur-raum.provinz.bz.it/de/digitale-hohenmodelle",
                    target: "_blank",
                    children: "Autonome Provinz Bozen - Südtirol"
                }), " "]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Switzerland:"
                }), " ", G.jsx(Hr, {
                    href: "https://www.swisstopo.admin.ch/fr/geodata/height/alti3d.html",
                    target: "_blank",
                    children: "SwissAlti3D"
                }), " "]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Austria:"
                }), " ", G.jsx(Hr, {
                    href: "https://data.bev.gv.at/geonetwork/srv/api/records/5ce253fc-b7c5-4362-97af-6556c18a45d9",
                    target: "_blank",
                    children: "BEV Austria"
                }), " "]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany:"
                }), " Data prepared by", " ", G.jsx(Hr, {
                    href: "https://www.opendem.info/opendtm_de.html",
                    target: "_blank",
                    children: "OpenDEM.info"
                })]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Thuringia):"
                }), " © GDI-Th", " ", G.jsx(Hr, {
                    href: "https://geoportal.thueringen.de/gdi-th/download-offene-geodaten",
                    target: "_blank",
                    children: "geoportal.thueringen.de"
                }), " ", "- Datenlizenz Deutschland – Namensnennung – Version 2.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Saxony-Anhalt):"
                }), " © 2024 Geodatenportal Sachsen-Anhalt", " ", G.jsx(Hr, {
                    href: "https://www.lvermgeo.sachsen-anhalt.de/",
                    target: "_blank",
                    children: "lvermgeo.sachsen-anhalt.de"
                }), " ", "- Datenlizenz Deutschland – Namensnennung – Version 2.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Lower Saxony):"
                }), " © GeoBasis-DE/LGLN 2024", " ", G.jsx(Hr, {
                    href: "https://www.lgln.niedersachsen.de/",
                    target: "_blank",
                    children: "lgln.niedersachsen.de"
                }), " ", "- CC BY 4.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Bavaria):"
                }), " © Bayerische Vermessungsverwaltung", " ", G.jsx(Hr, {
                    href: "https://www.geodaten.bayern.de/",
                    target: "_blank",
                    children: "geodaten.bayern.de"
                }), " ", "- CC BY 4.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Hesse):"
                }), " © Hessische Verwaltung für Bodenmanagement und Geoinformation", " ", G.jsx(Hr, {
                    href: "https://hvbg.hessen.de/",
                    target: "_blank",
                    children: "hvbg.hessen.de"
                })]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Saxony):"
                }), " © Landesamt für Geobasisinformation Sachsen", " ", G.jsx(Hr, {
                    href: "https://www.geosn.sachsen.de/",
                    target: "_blank",
                    children: "geosn.sachsen.de"
                }), " ", "- CC BY 4.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (North Rhine-Westphalia):"
                }), " © Geobasis NRW", " ", G.jsx(Hr, {
                    href: "https://www.bezreg-koeln.nrw.de/geobasis-nrw",
                    target: "_blank",
                    children: "bezreg-koeln.nrw.de/geobasis-nrw"
                }), " ", "- Datenlizenz Deutschland – Namensnennung – Version 2.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Rhineland-Palatinate):"
                }), " © GeoBasis-DE / LVermGeoRP2024", " ", G.jsx(Hr, {
                    href: "https://www.lvermgeo.rlp.de/",
                    target: "_blank",
                    children: "lvermgeo.rlp.de"
                }), " ", "- Datenlizenz Deutschland – Namensnennung – Version 2.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Saarland):"
                }), " © GeoBasis DE/LVGL-SL (2024)", " ", G.jsx(Hr, {
                    href: "https://www.saarland.de/lvgl/DE/home",
                    target: "_blank",
                    children: "saarland.de/lvgl"
                }), " ", "- Datenlizenz Deutschland – Namensnennung – Version 2.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Schleswig-Holstein):"
                }), " © GeoBasis-DE/LVermGeo SH", " ", G.jsx(Hr, {
                    href: "https://www.schleswig-holstein.de/DE/landesregierung/ministerien-behoerden/LVERMGEOSH",
                    target: "_blank",
                    children: "schleswig-holstein.de/LVERMGEOSH"
                }), " ", "- CC BY 4.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Mecklenburg-Vorpommern):"
                }), " © GeoBasis-DE/M-V 2024", " ", G.jsx(Hr, {
                    href: "https://www.geoportal-mv.de/",
                    target: "_blank",
                    children: "geoportal-mv.de"
                }), " ", "- CC BY 4.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Brandenburg):"
                }), " © GeoBasis-DE/LGB", " ", G.jsx(Hr, {
                    href: "https://geobasis-bb.de/lgb/de/",
                    target: "_blank",
                    children: "geobasis-bb.de"
                }), " ", "- Datenlizenz Deutschland – Namensnennung – Version 2.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Hamburg):"
                }), " © Freie und Hansestadt Hamburg, LGV", " ", G.jsx(Hr, {
                    href: "https://www.hamburg.de/politik-und-verwaltung/behoerden/behoerde-fuer-stadtentwicklung-und-wohnen/aemter-und-landesbetrieb/landesbetrieb-geoinformation-und-vermessung",
                    target: "_blank",
                    children: "hamburg.de/LGV"
                }), " ", "- Datenlizenz Deutschland – Namensnennung – Version 2.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Bremen):"
                }), " © Landesamt GeoInformation Bremen", " ", G.jsx(Hr, {
                    href: "https://www.geo.bremen.de/",
                    target: "_blank",
                    children: "geo.bremen.de"
                }), " ", "- CC BY 4.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Berlin):"
                }), " © Geoportal Berlin", " ", G.jsx(Hr, {
                    href: "https://www.berlin.de/sen/sbw/stadtdaten/geoportal/",
                    target: "_blank",
                    children: "berlin.de/geoportal"
                }), " ", "- Datenlizenz Deutschland – Namensnennung – Version 2.0"]
            }), G.jsxs(qt, {
                component: "li",
                sx: {
                    mb: 1
                },
                children: [G.jsx("strong", {
                    children: "Germany (Baden-Württemberg):"
                }), " © LGL", " ", G.jsx(Hr, {
                    href: "https://www.lgl-bw.de/",
                    target: "_blank",
                    children: "lgl-bw.de"
                }), " ", "- Datenlizenz Deutschland – Namensnennung – Version 2.0"]
            })]
        })]
    })
});
var h_, k0, hx;
function nb(e, t) {
    if (!h_)
        h_ = t;
    else if (!k0)
        k0 = t;
    else {
        var i = "var sharedChunk = {}; (" + h_ + ")(sharedChunk); (" + k0 + ")(sharedChunk);"
          , s = {};
        h_(s),
        hx = t(s),
        typeof window < "u" && (hx.workerUrl = window.URL.createObjectURL(new Blob([i],{
            type: "text/javascript"
        })))
    }
}
nb(["exports"], function(e) {
    class t {
        constructor(le, ee) {
            this.start = le,
            this.end = ee,
            this.points = [],
            this.append = this.append.bind(this),
            this.prepend = this.prepend.bind(this)
        }
        append(le, ee) {
            this.points.push(Math.round(le), Math.round(ee))
        }
        prepend(le, ee) {
            this.points.splice(0, 0, Math.round(le), Math.round(ee))
        }
        lineString() {
            return this.toArray()
        }
        isEmpty() {
            return this.points.length < 2
        }
        appendFragment(le) {
            this.points.push(...le.points),
            this.end = le.end
        }
        toArray() {
            return this.points
        }
    }
    const i = [[], [[[1, 2], [0, 1]]], [[[2, 1], [1, 2]]], [[[2, 1], [0, 1]]], [[[1, 0], [2, 1]]], [[[1, 2], [0, 1]], [[1, 0], [2, 1]]], [[[1, 0], [1, 2]]], [[[1, 0], [0, 1]]], [[[0, 1], [1, 0]]], [[[1, 2], [1, 0]]], [[[0, 1], [1, 0]], [[2, 1], [1, 2]]], [[[2, 1], [1, 0]]], [[[0, 1], [2, 1]]], [[[1, 2], [2, 1]]], [[[0, 1], [1, 2]]], []];
    function s(ke, le, ee, Ze) {
        return le = le * 2 + Ze[0],
        ee = ee * 2 + Ze[1],
        le + ee * (ke + 1) * 2
    }
    function u(ke, le, ee) {
        return (le - ke) / (ee - ke)
    }
    function d(ke, le, ee=4096, Ze=1) {
        if (!ke)
            return {};
        const Ge = ee / (le.width - 1);
        let vt, it, Xe, wt, Ct, Gt;
        const Xt = {}
          , lr = new Map
          , _r = new Map;
        function ri(ni, kr, ci) {
            ni[0] === 0 ? ci(Ge * (Gt - 1), Ge * (Ct - u(Xe, kr, vt))) : ni[0] === 2 ? ci(Ge * Gt, Ge * (Ct - u(wt, kr, it))) : ni[1] === 0 ? ci(Ge * (Gt - u(it, kr, vt)), Ge * (Ct - 1)) : ci(Ge * (Gt - u(wt, kr, Xe)), Ge * Ct)
        }
        for (Ct = 1 - Ze; Ct < le.height + Ze; Ct++) {
            it = le.get(0, Ct - 1),
            wt = le.get(0, Ct);
            let ni = Math.min(it, wt)
              , kr = Math.max(it, wt);
            for (Gt = 1 - Ze; Gt < le.width + Ze; Gt++) {
                vt = it,
                Xe = wt,
                it = le.get(Gt, Ct - 1),
                wt = le.get(Gt, Ct);
                const ci = ni
                  , Si = kr;
                if (ni = Math.min(it, wt),
                kr = Math.max(it, wt),
                isNaN(vt) || isNaN(it) || isNaN(wt) || isNaN(Xe))
                    continue;
                const $i = Math.min(ci, ni)
                  , Ro = Math.max(Si, kr)
                  , Ln = Math.ceil($i / ke) * ke
                  , an = Math.floor(Ro / ke) * ke;
                for (let qn = Ln; qn <= an; qn += ke) {
                    const Ei = vt > qn
                      , Ao = it > qn
                      , Hn = Xe > qn
                      , Go = wt > qn;
                    for (const xl of i[(Ei ? 8 : 0) | (Ao ? 4 : 0) | (Go ? 2 : 0) | (Hn ? 1 : 0)]) {
                        let Wo = lr.get(qn);
                        Wo || lr.set(qn, Wo = new Map);
                        let qo = _r.get(qn);
                        qo || _r.set(qn, qo = new Map);
                        const Ho = xl[0]
                          , xs = xl[1]
                          , bs = s(le.width, Gt, Ct, Ho)
                          , Zo = s(le.width, Gt, Ct, xs);
                        let Vi, oa;
                        if (Vi = qo.get(bs))
                            if (qo.delete(bs),
                            oa = Wo.get(Zo))
                                if (Wo.delete(Zo),
                                Vi === oa) {
                                    if (ri(xs, qn, Vi.append),
                                    !Vi.isEmpty()) {
                                        let Ki = Xt[qn];
                                        Ki || (Xt[qn] = Ki = []),
                                        Ki.push(Vi.lineString())
                                    }
                                } else
                                    Vi.appendFragment(oa),
                                    qo.set(Vi.end = oa.end, Vi);
                            else
                                ri(xs, qn, Vi.append),
                                qo.set(Vi.end = Zo, Vi);
                        else if (Vi = Wo.get(Zo))
                            Wo.delete(Zo),
                            ri(Ho, qn, Vi.prepend),
                            Wo.set(Vi.start = bs, Vi);
                        else {
                            const Ki = new t(bs,Zo);
                            ri(Ho, qn, Ki.append),
                            ri(xs, qn, Ki.append),
                            Wo.set(bs, Ki),
                            qo.set(Zo, Ki)
                        }
                    }
                }
            }
        }
        for (const [ni,kr] of lr.entries()) {
            let ci = null;
            for (const Si of kr.values())
                Si.isEmpty() || (ci == null && (ci = Xt[ni] || (Xt[ni] = [])),
                ci.push(Si.lineString()))
        }
        return Xt
    }
    /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
    function f(ke, le) {
        var ee = {};
        for (var Ze in ke)
            Object.prototype.hasOwnProperty.call(ke, Ze) && le.indexOf(Ze) < 0 && (ee[Ze] = ke[Ze]);
        if (ke != null && typeof Object.getOwnPropertySymbols == "function")
            for (var Ge = 0, Ze = Object.getOwnPropertySymbols(ke); Ge < Ze.length; Ge++)
                le.indexOf(Ze[Ge]) < 0 && Object.prototype.propertyIsEnumerable.call(ke, Ze[Ge]) && (ee[Ze[Ge]] = ke[Ze[Ge]]);
        return ee
    }
    function o(ke, le, ee, Ze) {
        function Ge(vt) {
            return vt instanceof ee ? vt : new ee(function(it) {
                it(vt)
            }
            )
        }
        return new (ee || (ee = Promise))(function(vt, it) {
            function Xe(Gt) {
                try {
                    Ct(Ze.next(Gt))
                } catch (Xt) {
                    it(Xt)
                }
            }
            function wt(Gt) {
                try {
                    Ct(Ze.throw(Gt))
                } catch (Xt) {
                    it(Xt)
                }
            }
            function Ct(Gt) {
                Gt.done ? vt(Gt.value) : Ge(Gt.value).then(Xe, wt)
            }
            Ct((Ze = Ze.apply(ke, le || [])).next())
        }
        )
    }
    function w(ke) {
        const le = Object.entries(ke);
        return le.sort( ([ee], [Ze]) => ee < Ze ? -1 : ee > Ze ? 1 : 0),
        le
    }
    function T(ke) {
        return w(ke).map( ([le,ee]) => [le, ...typeof ee == "number" ? [ee] : ee].join("*")).join("~")
    }
    function k(ke) {
        return Object.fromEntries(ke.split("~").map(le => le.split("*").map(Number)).map( ([le,...ee]) => [le, ee]))
    }
    function L(ke) {
        var {thresholds: le} = ke
          , ee = f(ke, ["thresholds"]);
        return w(Object.assign({
            thresholds: T(le)
        }, ee)).map( ([Ze,Ge]) => `${encodeURIComponent(Ze)}=${encodeURIComponent(Ge)}`).join("&")
    }
    function z(ke) {
        return Object.fromEntries(ke.replace(/^.*\?/, "").split("&").map(le => {
            const ee = le.split("=").map(decodeURIComponent)
              , Ze = ee[0];
            let Ge = ee[1];
            switch (Ze) {
            case "thresholds":
                Ge = k(Ge);
                break;
            case "extent":
            case "multiplier":
            case "overzoom":
            case "buffer":
                Ge = Number(Ge)
            }
            return [Ze, Ge]
        }
        ))
    }
    function D(ke) {
        return w(ke).map( ([le,ee]) => `${encodeURIComponent(le)}=${encodeURIComponent(ee)}`).join(",")
    }
    function N(ke, le) {
        const {thresholds: ee} = ke
          , Ze = f(ke, ["thresholds"]);
        let Ge = []
          , vt = -1 / 0;
        return Object.entries(ee).forEach( ([it,Xe]) => {
            const wt = Number(it);
            wt <= le && wt > vt && (vt = wt,
            Ge = typeof Xe == "number" ? [Xe] : Xe)
        }
        ),
        Object.assign({
            levels: Ge
        }, Ze)
    }
    function U(ke) {
        const le = new ArrayBuffer(ke.byteLength);
        return new Uint8Array(le).set(new Uint8Array(ke)),
        le
    }
    function V(ke, le) {
        return ke.then(ee => {
            var {data: Ze} = ee
              , Ge = f(ee, ["data"]);
            let vt = Ze;
            return le && (vt = new Float32Array(Ze.length),
            vt.set(Ze)),
            Object.assign(Object.assign({}, Ge), {
                data: vt,
                transferrables: [vt.buffer]
            })
        }
        )
    }
    function re(ke) {
        return ke.then( ({arrayBuffer: le}) => {
            const ee = U(le);
            return {
                arrayBuffer: ee,
                transferrables: [ee]
            }
        }
        )
    }
    let ie = null;
    function ue() {
        return ie == null && (ie = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") && typeof createImageBitmap == "function"),
        ie || !1
    }
    let ce = null;
    function X() {
        if (ce == null && (ce = !1,
        ue() && typeof VideoFrame < "u")) {
            const ee = new OffscreenCanvas(5,5).getContext("2d", {
                willReadFrequently: !0
            });
            if (ee) {
                for (let Ge = 0; Ge < 25; Ge++) {
                    const vt = Ge * 4;
                    ee.fillStyle = `rgb(${vt},${vt + 1},${vt + 2})`,
                    ee.fillRect(Ge % 5, Math.floor(Ge / 5), 1, 1)
                }
                const Ze = ee.getImageData(0, 0, 5, 5).data;
                for (let Ge = 0; Ge < 100; Ge++)
                    if (Ge % 4 !== 3 && Ze[Ge] !== Ge) {
                        ce = !0;
                        break
                    }
            }
        }
        return ce || !1
    }
    function me(ke, le, ee) {
        let Ze = () => {}
        ;
        const Ge = setTimeout( () => {
            Ze(new Error("timed out")),
            ee?.abort()
        }
        , ke);
        K(ee, () => {
            Ze(new Error("aborted")),
            clearTimeout(Ge)
        }
        );
        const vt = new Promise( (it, Xe) => {
            Ze = Xe
        }
        );
        return Promise.race([vt, le.finally( () => clearTimeout(Ge))])
    }
    function K(ke, le) {
        le && ke?.signal.addEventListener("abort", le)
    }
    function be(ke) {
        var le;
        return !!(!((le = ke?.signal) === null || le === void 0) && le.aborted)
    }
    let Ee = 0;
    class Ce {
        constructor(le=100) {
            this.size = () => this.items.size,
            this.get = (ee, Ze, Ge) => {
                let vt = this.items.get(ee);
                if (vt)
                    vt.lastUsed = ++Ee,
                    vt.waiting++;
                else {
                    const Ct = new AbortController
                      , Gt = Ze(ee, Ct);
                    vt = {
                        abortController: Ct,
                        item: Gt,
                        lastUsed: ++Ee,
                        waiting: 1
                    },
                    this.items.set(ee, vt),
                    this.prune()
                }
                const it = this.items
                  , Xe = vt.item.then(Ct => Ct, Ct => (it.delete(ee),
                Promise.reject(Ct)));
                let wt = !1;
                return K(Ge, () => {
                    var Ct;
                    vt && vt.abortController && !wt && (wt = !0,
                    --vt.waiting <= 0 && ((Ct = vt.abortController) === null || Ct === void 0 || Ct.abort(),
                    it.delete(ee)))
                }
                ),
                Xe
            }
            ,
            this.clear = () => this.items.clear(),
            this.maxSize = le,
            this.items = new Map
        }
        prune() {
            if (this.items.size > this.maxSize) {
                let le, ee = 1 / 0;
                this.items.forEach( (Ze, Ge) => {
                    Ze.lastUsed < ee && (ee = Ze.lastUsed,
                    le = Ge)
                }
                ),
                typeof le < "u" && this.items.delete(le)
            }
        }
    }
    let He, ct, nt, J;
    function he(ke, le, ee) {
        return o(this, void 0, void 0, function*() {
            const Ze = yield createImageBitmap(ke);
            return be(ee) ? null : ve(Ze, le)
        })
    }
    function ve(ke, le) {
        return He || (He = new OffscreenCanvas(ke.width,ke.height),
        ct = He.getContext("2d", {
            willReadFrequently: !0
        })),
        st(ke, le, He, ct)
    }
    function Ne(ke, le, ee) {
        return o(this, void 0, void 0, function*() {
            var Ze, Ge, vt;
            const it = yield createImageBitmap(ke);
            if (be(ee))
                return null;
            const Xe = new VideoFrame(it,{
                timestamp: 0
            });
            try {
                if (!(((Ze = Xe?.format) === null || Ze === void 0 ? void 0 : Ze.startsWith("BGR")) || ((Ge = Xe?.format) === null || Ge === void 0 ? void 0 : Ge.startsWith("RGB"))))
                    throw new Error(`Unrecognized format: ${Xe?.format}`);
                const Ct = (vt = Xe?.format) === null || vt === void 0 ? void 0 : vt.startsWith("BGR")
                  , Gt = Xe.allocationSize()
                  , Xt = new Uint8ClampedArray(Gt);
                if (yield Xe.copyTo(Xt),
                Ct)
                    for (let lr = 0; lr < Xt.length; lr += 4) {
                        const _r = Xt[lr];
                        Xt[lr] = Xt[lr + 2],
                        Xt[lr + 2] = _r
                    }
                return Nt(it.width, it.height, le, Xt)
            } catch {
                return be(ee) ? null : ve(it, le)
            } finally {
                Xe.close()
            }
        })
    }
    function je(ke, le, ee) {
        return o(this, void 0, void 0, function*() {
            nt || (nt = document.createElement("canvas"),
            J = nt.getContext("2d", {
                willReadFrequently: !0
            }));
            const Ze = new Image;
            K(ee, () => Ze.src = "");
            const Ge = yield new Promise( (vt, it) => {
                Ze.onload = () => {
                    be(ee) || vt(Ze),
                    URL.revokeObjectURL(Ze.src),
                    Ze.onload = null
                }
                ,
                Ze.onerror = () => it(new Error("Could not load image.")),
                Ze.src = ke.size ? URL.createObjectURL(ke) : ""
            }
            );
            return st(Ge, le, nt, J)
        })
    }
    function lt(ke, le, ee) {
        return self.actor.send("decodeImage", [], ee, void 0, ke, le)
    }
    function Pt() {
        return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope
    }
    const We = X() ? Ne : ue() ? he : Pt() ? lt : je;
    function st(ke, le, ee, Ze) {
        if (ee.width = ke.width,
        ee.height = ke.height,
        !Ze)
            throw new Error("failed to get context");
        Ze.drawImage(ke, 0, 0, ke.width, ke.height);
        const Ge = Ze.getImageData(0, 0, ke.width, ke.height).data;
        return Nt(ke.width, ke.height, le, Ge)
    }
    function Nt(ke, le, ee, Ze) {
        const Ge = ee === "mapbox" ? (it, Xe, wt) => -1e4 + (it * 256 * 256 + Xe * 256 + wt) * .1 : (it, Xe, wt) => it * 256 + Xe + wt / 256 - 32768
          , vt = new Float32Array(ke * le);
        for (let it = 0; it < Ze.length; it += 4)
            vt[it / 4] = Ge(Ze[it], Ze[it + 1], Ze[it + 2]);
        return {
            width: ke,
            height: le,
            data: vt
        }
    }
    const zt = -12e3
      , Qt = 9e3;
    function Wt(ke) {
        return !isNaN(ke) && ke >= zt && ke <= Qt
    }
    class tr {
        constructor(le, ee, Ze) {
            this.split = (Ge, vt, it) => {
                if (Ge === 0)
                    return this;
                const Xe = 1 << Ge
                  , wt = vt * this.width / Xe
                  , Ct = it * this.height / Xe;
                return new tr(this.width / Xe,this.height / Xe, (Gt, Xt) => this.get(Gt + wt, Xt + Ct))
            }
            ,
            this.subsamplePixelCenters = Ge => {
                const vt = (wt, Ct, Gt) => isNaN(wt) ? Ct : isNaN(Ct) ? wt : wt + (Ct - wt) * Gt;
                if (Ge <= 1)
                    return this;
                const it = .5 - 1 / (2 * Ge)
                  , Xe = (wt, Ct) => {
                    const Gt = wt / Ge - it
                      , Xt = Ct / Ge - it
                      , lr = Math.floor(Gt)
                      , _r = Math.floor(Xt)
                      , ri = this.get(lr, _r)
                      , ni = this.get(lr + 1, _r)
                      , kr = this.get(lr, _r + 1)
                      , ci = this.get(lr + 1, _r + 1)
                      , Si = Gt - lr
                      , $i = Xt - _r
                      , Ro = vt(ri, ni, Si)
                      , Ln = vt(kr, ci, Si);
                    return vt(Ro, Ln, $i)
                }
                ;
                return new tr(this.width * Ge,this.height * Ge,Xe)
            }
            ,
            this.averagePixelCentersToGrid = (Ge=1) => new tr(this.width + 1,this.height + 1, (vt, it) => {
                let Xe = 0
                  , wt = 0
                  , Ct = 0;
                for (let Gt = vt - Ge; Gt < vt + Ge; Gt++)
                    for (let Xt = it - Ge; Xt < it + Ge; Xt++)
                        isNaN(Ct = this.get(Gt, Xt)) || (wt++,
                        Xe += Ct);
                return wt === 0 ? NaN : Xe / wt
            }
            ),
            this.scaleElevation = Ge => Ge === 1 ? this : new tr(this.width,this.height, (vt, it) => this.get(vt, it) * Ge),
            this.materialize = (Ge=2) => {
                const vt = this.width + 2 * Ge
                  , it = new Float32Array(vt * (this.height + 2 * Ge));
                let Xe = 0;
                for (let wt = -Ge; wt < this.height + Ge; wt++)
                    for (let Ct = -Ge; Ct < this.width + Ge; Ct++)
                        it[Xe++] = this.get(Ct, wt);
                return new tr(this.width,this.height, (wt, Ct) => it[(Ct + Ge) * vt + wt + Ge])
            }
            ,
            this.get = Ze,
            this.width = le,
            this.height = ee
        }
        static fromRawDem(le) {
            return new tr(le.width,le.height, (ee, Ze) => {
                const Ge = le.data[Ze * le.width + ee];
                return Wt(Ge) ? Ge : NaN
            }
            )
        }
        static combineNeighbors(le) {
            if (le.length !== 9)
                throw new Error("Must include a tile plus 8 neighbors");
            const ee = le[4];
            if (!ee)
                return;
            const Ze = ee.width
              , Ge = ee.height;
            return new tr(Ze,Ge, (vt, it) => {
                let Xe = 0;
                it < 0 ? it += Ge : it < Ge ? Xe += 3 : (it -= Ge,
                Xe += 6),
                vt < 0 ? vt += Ze : vt < Ze ? Xe += 1 : (vt -= Ze,
                Xe += 2);
                const wt = le[Xe];
                return wt ? wt.get(vt, it) : NaN
            }
            )
        }
    }
    const cr = 65536 * 65536
      , Yt = 1 / cr
      , Gr = 12
      , xr = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8")
      , Nr = 0
      , ur = 1
      , vr = 2
      , gr = 5;
    class hn {
        constructor(le=new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(le) ? le : new Uint8Array(le),
            this.dataView = new DataView(this.buf.buffer),
            this.pos = 0,
            this.type = 0,
            this.length = this.buf.length
        }
        readFields(le, ee, Ze=this.length) {
            for (; this.pos < Ze; ) {
                const Ge = this.readVarint()
                  , vt = Ge >> 3
                  , it = this.pos;
                this.type = Ge & 7,
                le(vt, ee, this),
                this.pos === it && this.skip(Ge)
            }
            return ee
        }
        readMessage(le, ee) {
            return this.readFields(le, ee, this.readVarint() + this.pos)
        }
        readFixed32() {
            const le = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4,
            le
        }
        readSFixed32() {
            const le = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4,
            le
        }
        readFixed64() {
            const le = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * cr;
            return this.pos += 8,
            le
        }
        readSFixed64() {
            const le = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * cr;
            return this.pos += 8,
            le
        }
        readFloat() {
            const le = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4,
            le
        }
        readDouble() {
            const le = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8,
            le
        }
        readVarint(le) {
            const ee = this.buf;
            let Ze, Ge;
            return Ge = ee[this.pos++],
            Ze = Ge & 127,
            Ge < 128 || (Ge = ee[this.pos++],
            Ze |= (Ge & 127) << 7,
            Ge < 128) || (Ge = ee[this.pos++],
            Ze |= (Ge & 127) << 14,
            Ge < 128) || (Ge = ee[this.pos++],
            Ze |= (Ge & 127) << 21,
            Ge < 128) ? Ze : (Ge = ee[this.pos],
            Ze |= (Ge & 15) << 28,
            Zr(Ze, le, this))
        }
        readVarint64() {
            return this.readVarint(!0)
        }
        readSVarint() {
            const le = this.readVarint();
            return le % 2 === 1 ? (le + 1) / -2 : le / 2
        }
        readBoolean() {
            return !!this.readVarint()
        }
        readString() {
            const le = this.readVarint() + this.pos
              , ee = this.pos;
            return this.pos = le,
            le - ee >= Gr && xr ? xr.decode(this.buf.subarray(ee, le)) : Ue(this.buf, ee, le)
        }
        readBytes() {
            const le = this.readVarint() + this.pos
              , ee = this.buf.subarray(this.pos, le);
            return this.pos = le,
            ee
        }
        readPackedVarint(le=[], ee) {
            const Ze = this.readPackedEnd();
            for (; this.pos < Ze; )
                le.push(this.readVarint(ee));
            return le
        }
        readPackedSVarint(le=[]) {
            const ee = this.readPackedEnd();
            for (; this.pos < ee; )
                le.push(this.readSVarint());
            return le
        }
        readPackedBoolean(le=[]) {
            const ee = this.readPackedEnd();
            for (; this.pos < ee; )
                le.push(this.readBoolean());
            return le
        }
        readPackedFloat(le=[]) {
            const ee = this.readPackedEnd();
            for (; this.pos < ee; )
                le.push(this.readFloat());
            return le
        }
        readPackedDouble(le=[]) {
            const ee = this.readPackedEnd();
            for (; this.pos < ee; )
                le.push(this.readDouble());
            return le
        }
        readPackedFixed32(le=[]) {
            const ee = this.readPackedEnd();
            for (; this.pos < ee; )
                le.push(this.readFixed32());
            return le
        }
        readPackedSFixed32(le=[]) {
            const ee = this.readPackedEnd();
            for (; this.pos < ee; )
                le.push(this.readSFixed32());
            return le
        }
        readPackedFixed64(le=[]) {
            const ee = this.readPackedEnd();
            for (; this.pos < ee; )
                le.push(this.readFixed64());
            return le
        }
        readPackedSFixed64(le=[]) {
            const ee = this.readPackedEnd();
            for (; this.pos < ee; )
                le.push(this.readSFixed64());
            return le
        }
        readPackedEnd() {
            return this.type === vr ? this.readVarint() + this.pos : this.pos + 1
        }
        skip(le) {
            const ee = le & 7;
            if (ee === Nr)
                for (; this.buf[this.pos++] > 127; )
                    ;
            else if (ee === vr)
                this.pos = this.readVarint() + this.pos;
            else if (ee === gr)
                this.pos += 4;
            else if (ee === ur)
                this.pos += 8;
            else
                throw new Error(`Unimplemented type: ${ee}`)
        }
        writeTag(le, ee) {
            this.writeVarint(le << 3 | ee)
        }
        realloc(le) {
            let ee = this.length || 16;
            for (; ee < this.pos + le; )
                ee *= 2;
            if (ee !== this.length) {
                const Ze = new Uint8Array(ee);
                Ze.set(this.buf),
                this.buf = Ze,
                this.dataView = new DataView(Ze.buffer),
                this.length = ee
            }
        }
        finish() {
            return this.length = this.pos,
            this.pos = 0,
            this.buf.subarray(0, this.length)
        }
        writeFixed32(le) {
            this.realloc(4),
            this.dataView.setInt32(this.pos, le, !0),
            this.pos += 4
        }
        writeSFixed32(le) {
            this.realloc(4),
            this.dataView.setInt32(this.pos, le, !0),
            this.pos += 4
        }
        writeFixed64(le) {
            this.realloc(8),
            this.dataView.setInt32(this.pos, le & -1, !0),
            this.dataView.setInt32(this.pos + 4, Math.floor(le * Yt), !0),
            this.pos += 8
        }
        writeSFixed64(le) {
            this.realloc(8),
            this.dataView.setInt32(this.pos, le & -1, !0),
            this.dataView.setInt32(this.pos + 4, Math.floor(le * Yt), !0),
            this.pos += 8
        }
        writeVarint(le) {
            if (le = +le || 0,
            le > 268435455 || le < 0) {
                gn(le, this);
                return
            }
            this.realloc(4),
            this.buf[this.pos++] = le & 127 | (le > 127 ? 128 : 0),
            !(le <= 127) && (this.buf[this.pos++] = (le >>>= 7) & 127 | (le > 127 ? 128 : 0),
            !(le <= 127) && (this.buf[this.pos++] = (le >>>= 7) & 127 | (le > 127 ? 128 : 0),
            !(le <= 127) && (this.buf[this.pos++] = le >>> 7 & 127)))
        }
        writeSVarint(le) {
            this.writeVarint(le < 0 ? -le * 2 - 1 : le * 2)
        }
        writeBoolean(le) {
            this.writeVarint(+le)
        }
        writeString(le) {
            le = String(le),
            this.realloc(le.length * 4),
            this.pos++;
            const ee = this.pos;
            this.pos = se(this.buf, le, this.pos);
            const Ze = this.pos - ee;
            Ze >= 128 && $n(ee, Ze, this),
            this.pos = ee - 1,
            this.writeVarint(Ze),
            this.pos += Ze
        }
        writeFloat(le) {
            this.realloc(4),
            this.dataView.setFloat32(this.pos, le, !0),
            this.pos += 4
        }
        writeDouble(le) {
            this.realloc(8),
            this.dataView.setFloat64(this.pos, le, !0),
            this.pos += 8
        }
        writeBytes(le) {
            const ee = le.length;
            this.writeVarint(ee),
            this.realloc(ee);
            for (let Ze = 0; Ze < ee; Ze++)
                this.buf[this.pos++] = le[Ze]
        }
        writeRawMessage(le, ee) {
            this.pos++;
            const Ze = this.pos;
            le(ee, this);
            const Ge = this.pos - Ze;
            Ge >= 128 && $n(Ze, Ge, this),
            this.pos = Ze - 1,
            this.writeVarint(Ge),
            this.pos += Ge
        }
        writeMessage(le, ee, Ze) {
            this.writeTag(le, vr),
            this.writeRawMessage(ee, Ze)
        }
        writePackedVarint(le, ee) {
            ee.length && this.writeMessage(le, Dn, ee)
        }
        writePackedSVarint(le, ee) {
            ee.length && this.writeMessage(le, yn, ee)
        }
        writePackedBoolean(le, ee) {
            ee.length && this.writeMessage(le, sn, ee)
        }
        writePackedFloat(le, ee) {
            ee.length && this.writeMessage(le, Tn, ee)
        }
        writePackedDouble(le, ee) {
            ee.length && this.writeMessage(le, bn, ee)
        }
        writePackedFixed32(le, ee) {
            ee.length && this.writeMessage(le, Mt, ee)
        }
        writePackedSFixed32(le, ee) {
            ee.length && this.writeMessage(le, kt, ee)
        }
        writePackedFixed64(le, ee) {
            ee.length && this.writeMessage(le, er, ee)
        }
        writePackedSFixed64(le, ee) {
            ee.length && this.writeMessage(le, Er, ee)
        }
        writeBytesField(le, ee) {
            this.writeTag(le, vr),
            this.writeBytes(ee)
        }
        writeFixed32Field(le, ee) {
            this.writeTag(le, gr),
            this.writeFixed32(ee)
        }
        writeSFixed32Field(le, ee) {
            this.writeTag(le, gr),
            this.writeSFixed32(ee)
        }
        writeFixed64Field(le, ee) {
            this.writeTag(le, ur),
            this.writeFixed64(ee)
        }
        writeSFixed64Field(le, ee) {
            this.writeTag(le, ur),
            this.writeSFixed64(ee)
        }
        writeVarintField(le, ee) {
            this.writeTag(le, Nr),
            this.writeVarint(ee)
        }
        writeSVarintField(le, ee) {
            this.writeTag(le, Nr),
            this.writeSVarint(ee)
        }
        writeStringField(le, ee) {
            this.writeTag(le, vr),
            this.writeString(ee)
        }
        writeFloatField(le, ee) {
            this.writeTag(le, gr),
            this.writeFloat(ee)
        }
        writeDoubleField(le, ee) {
            this.writeTag(le, ur),
            this.writeDouble(ee)
        }
        writeBooleanField(le, ee) {
            this.writeVarintField(le, +ee)
        }
    }
    function Zr(ke, le, ee) {
        const Ze = ee.buf;
        let Ge, vt;
        if (vt = Ze[ee.pos++],
        Ge = (vt & 112) >> 4,
        vt < 128 || (vt = Ze[ee.pos++],
        Ge |= (vt & 127) << 3,
        vt < 128) || (vt = Ze[ee.pos++],
        Ge |= (vt & 127) << 10,
        vt < 128) || (vt = Ze[ee.pos++],
        Ge |= (vt & 127) << 17,
        vt < 128) || (vt = Ze[ee.pos++],
        Ge |= (vt & 127) << 24,
        vt < 128) || (vt = Ze[ee.pos++],
        Ge |= (vt & 1) << 31,
        vt < 128))
            return $r(ke, Ge, le);
        throw new Error("Expected varint not more than 10 bytes")
    }
    function $r(ke, le, ee) {
        return ee ? le * 4294967296 + (ke >>> 0) : (le >>> 0) * 4294967296 + (ke >>> 0)
    }
    function gn(ke, le) {
        let ee, Ze;
        if (ke >= 0 ? (ee = ke % 4294967296 | 0,
        Ze = ke / 4294967296 | 0) : (ee = ~(-ke % 4294967296),
        Ze = ~(-ke / 4294967296),
        ee ^ 4294967295 ? ee = ee + 1 | 0 : (ee = 0,
        Ze = Ze + 1 | 0)),
        ke >= 18446744073709552e3 || ke < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
        le.realloc(10),
        zr(ee, Ze, le),
        Wr(Ze, le)
    }
    function zr(ke, le, ee) {
        ee.buf[ee.pos++] = ke & 127 | 128,
        ke >>>= 7,
        ee.buf[ee.pos++] = ke & 127 | 128,
        ke >>>= 7,
        ee.buf[ee.pos++] = ke & 127 | 128,
        ke >>>= 7,
        ee.buf[ee.pos++] = ke & 127 | 128,
        ke >>>= 7,
        ee.buf[ee.pos] = ke & 127
    }
    function Wr(ke, le) {
        const ee = (ke & 7) << 4;
        le.buf[le.pos++] |= ee | ((ke >>>= 3) ? 128 : 0),
        ke && (le.buf[le.pos++] = ke & 127 | ((ke >>>= 7) ? 128 : 0),
        ke && (le.buf[le.pos++] = ke & 127 | ((ke >>>= 7) ? 128 : 0),
        ke && (le.buf[le.pos++] = ke & 127 | ((ke >>>= 7) ? 128 : 0),
        ke && (le.buf[le.pos++] = ke & 127 | ((ke >>>= 7) ? 128 : 0),
        ke && (le.buf[le.pos++] = ke & 127)))))
    }
    function $n(ke, le, ee) {
        const Ze = le <= 16383 ? 1 : le <= 2097151 ? 2 : le <= 268435455 ? 3 : Math.floor(Math.log(le) / (Math.LN2 * 7));
        ee.realloc(Ze);
        for (let Ge = ee.pos - 1; Ge >= ke; Ge--)
            ee.buf[Ge + Ze] = ee.buf[Ge]
    }
    function Dn(ke, le) {
        for (let ee = 0; ee < ke.length; ee++)
            le.writeVarint(ke[ee])
    }
    function yn(ke, le) {
        for (let ee = 0; ee < ke.length; ee++)
            le.writeSVarint(ke[ee])
    }
    function Tn(ke, le) {
        for (let ee = 0; ee < ke.length; ee++)
            le.writeFloat(ke[ee])
    }
    function bn(ke, le) {
        for (let ee = 0; ee < ke.length; ee++)
            le.writeDouble(ke[ee])
    }
    function sn(ke, le) {
        for (let ee = 0; ee < ke.length; ee++)
            le.writeBoolean(ke[ee])
    }
    function Mt(ke, le) {
        for (let ee = 0; ee < ke.length; ee++)
            le.writeFixed32(ke[ee])
    }
    function kt(ke, le) {
        for (let ee = 0; ee < ke.length; ee++)
            le.writeSFixed32(ke[ee])
    }
    function er(ke, le) {
        for (let ee = 0; ee < ke.length; ee++)
            le.writeFixed64(ke[ee])
    }
    function Er(ke, le) {
        for (let ee = 0; ee < ke.length; ee++)
            le.writeSFixed64(ke[ee])
    }
    function Ue(ke, le, ee) {
        let Ze = ""
          , Ge = le;
        for (; Ge < ee; ) {
            const vt = ke[Ge];
            let it = null
              , Xe = vt > 239 ? 4 : vt > 223 ? 3 : vt > 191 ? 2 : 1;
            if (Ge + Xe > ee)
                break;
            let wt, Ct, Gt;
            Xe === 1 ? vt < 128 && (it = vt) : Xe === 2 ? (wt = ke[Ge + 1],
            (wt & 192) === 128 && (it = (vt & 31) << 6 | wt & 63,
            it <= 127 && (it = null))) : Xe === 3 ? (wt = ke[Ge + 1],
            Ct = ke[Ge + 2],
            (wt & 192) === 128 && (Ct & 192) === 128 && (it = (vt & 15) << 12 | (wt & 63) << 6 | Ct & 63,
            (it <= 2047 || it >= 55296 && it <= 57343) && (it = null))) : Xe === 4 && (wt = ke[Ge + 1],
            Ct = ke[Ge + 2],
            Gt = ke[Ge + 3],
            (wt & 192) === 128 && (Ct & 192) === 128 && (Gt & 192) === 128 && (it = (vt & 15) << 18 | (wt & 63) << 12 | (Ct & 63) << 6 | Gt & 63,
            (it <= 65535 || it >= 1114112) && (it = null))),
            it === null ? (it = 65533,
            Xe = 1) : it > 65535 && (it -= 65536,
            Ze += String.fromCharCode(it >>> 10 & 1023 | 55296),
            it = 56320 | it & 1023),
            Ze += String.fromCharCode(it),
            Ge += Xe
        }
        return Ze
    }
    function se(ke, le, ee) {
        for (let Ze = 0, Ge, vt; Ze < le.length; Ze++) {
            if (Ge = le.charCodeAt(Ze),
            Ge > 55295 && Ge < 57344)
                if (vt)
                    if (Ge < 56320) {
                        ke[ee++] = 239,
                        ke[ee++] = 191,
                        ke[ee++] = 189,
                        vt = Ge;
                        continue
                    } else
                        Ge = vt - 55296 << 10 | Ge - 56320 | 65536,
                        vt = null;
                else {
                    Ge > 56319 || Ze + 1 === le.length ? (ke[ee++] = 239,
                    ke[ee++] = 191,
                    ke[ee++] = 189) : vt = Ge;
                    continue
                }
            else
                vt && (ke[ee++] = 239,
                ke[ee++] = 191,
                ke[ee++] = 189,
                vt = null);
            Ge < 128 ? ke[ee++] = Ge : (Ge < 2048 ? ke[ee++] = Ge >> 6 | 192 : (Ge < 65536 ? ke[ee++] = Ge >> 12 | 224 : (ke[ee++] = Ge >> 18 | 240,
            ke[ee++] = Ge >> 12 & 63 | 128),
            ke[ee++] = Ge >> 6 & 63 | 128),
            ke[ee++] = Ge & 63 | 128)
        }
        return ee
    }
    var fe;
    (function(ke) {
        ke[ke.UNKNOWN = 0] = "UNKNOWN",
        ke[ke.POINT = 1] = "POINT",
        ke[ke.LINESTRING = 2] = "LINESTRING",
        ke[ke.POLYGON = 3] = "POLYGON"
    }
    )(fe || (fe = {}));
    function ge(ke) {
        const le = new hn;
        for (const ee in ke.layers) {
            const Ze = ke.layers[ee];
            Ze.extent || (Ze.extent = ke.extent),
            le.writeMessage(3, Me, Object.assign(Object.assign({}, Ze), {
                id: ee
            }))
        }
        return le.finish()
    }
    function Me(ke, le) {
        if (!le)
            throw new Error("pbf undefined");
        le.writeVarintField(15, 2),
        le.writeStringField(1, ke.id || ""),
        le.writeVarintField(5, ke.extent || 4096);
        const ee = {
            keys: [],
            values: [],
            keycache: {},
            valuecache: {}
        };
        for (const Ze of ke.features)
            ee.feature = Ze,
            le.writeMessage(2, $e, ee);
        for (const Ze of ee.keys)
            le.writeStringField(3, Ze);
        for (const Ze of ee.values)
            le.writeMessage(4, dt, Ze)
    }
    function $e(ke, le) {
        const ee = ke.feature;
        if (!ee || !le)
            throw new Error;
        le.writeMessage(2, et, ke),
        le.writeVarintField(3, ee.type),
        le.writeMessage(4, _t, ee)
    }
    function et(ke, le) {
        const ee = ke.feature;
        if (!ee || !le)
            throw new Error;
        const Ze = ke.keys
          , Ge = ke.values
          , vt = ke.keycache
          , it = ke.valuecache;
        for (const Xe in ee.properties) {
            let wt = ee.properties[Xe]
              , Ct = vt[Xe];
            if (wt === null)
                continue;
            typeof Ct > "u" && (Ze.push(Xe),
            Ct = Ze.length - 1,
            vt[Xe] = Ct),
            le.writeVarint(Ct);
            const Gt = typeof wt;
            Gt !== "string" && Gt !== "boolean" && Gt !== "number" && (wt = JSON.stringify(wt));
            const Xt = `${Gt}:${wt}`;
            let lr = it[Xt];
            typeof lr > "u" && (Ge.push(wt),
            lr = Ge.length - 1,
            it[Xt] = lr),
            le.writeVarint(lr)
        }
    }
    function at(ke, le) {
        return (le << 3) + (ke & 7)
    }
    function Qe(ke) {
        return ke << 1 ^ ke >> 31
    }
    function _t(ke, le) {
        if (!le)
            throw new Error;
        const ee = ke.geometry
          , Ze = ke.type;
        let Ge = 0
          , vt = 0;
        for (const it of ee) {
            let Xe = 1;
            Ze === fe.POINT && (Xe = it.length / 2),
            le.writeVarint(at(1, Xe));
            const wt = it.length / 2
              , Ct = Ze === fe.POLYGON ? wt - 1 : wt;
            for (let Gt = 0; Gt < Ct; Gt++) {
                Gt === 1 && Ze !== 1 && le.writeVarint(at(2, Ct - 1));
                const Xt = it[Gt * 2] - Ge
                  , lr = it[Gt * 2 + 1] - vt;
                le.writeVarint(Qe(Xt)),
                le.writeVarint(Qe(lr)),
                Ge += Xt,
                vt += lr
            }
            Ze === fe.POLYGON && le.writeVarint(at(7, 1))
        }
    }
    function dt(ke, le) {
        if (!le)
            throw new Error;
        typeof ke == "string" ? le.writeStringField(1, ke) : typeof ke == "boolean" ? le.writeBooleanField(7, ke) : typeof ke == "number" && (ke % 1 !== 0 ? le.writeDoubleField(3, ke) : ke < 0 ? le.writeSVarintField(6, ke) : le.writeVarintField(5, ke))
    }
    const tt = typeof performance < "u" ? performance : void 0
      , St = tt ? tt.timeOrigin || new Date().getTime() - tt.now() : new Date().getTime();
    function Ve(ke) {
        var le;
        return JSON.parse(JSON.stringify(((le = tt?.getEntriesByName) === null || le === void 0 ? void 0 : le.call(tt, ke)) || []))
    }
    function Ut() {
        return tt ? tt.now() : new Date().getTime()
    }
    function yr(ke) {
        const le = [];
        for (const ee of ke)
            le.push(...ee);
        return le
    }
    class Ht {
        constructor(le) {
            this.marks = {},
            this.urls = [],
            this.fetched = [],
            this.resources = [],
            this.tilesFetched = 0,
            this.timeOrigin = St,
            this.finish = ee => {
                this.markFinish();
                const Ze = wt => {
                    const Ct = this.marks[wt] || []
                      , Gt = Math.max(...Ct.map(lr => Math.max(...lr)))
                      , Xt = Math.min(...Ct.map(lr => Math.min(...lr)));
                    return Number.isFinite(Gt) ? Gt - Xt : void 0
                }
                  , Ge = Ze("main") || 0
                  , vt = Ze("fetch")
                  , it = Ze("decode")
                  , Xe = Ze("isoline");
                return {
                    url: ee,
                    tilesUsed: this.tilesFetched,
                    origin: this.timeOrigin,
                    marks: this.marks,
                    resources: [...this.resources, ...yr(this.fetched.map(Ve))],
                    duration: Ge,
                    fetch: vt,
                    decode: it,
                    process: Xe,
                    wait: Ge - (vt || 0) - (it || 0) - (Xe || 0)
                }
            }
            ,
            this.error = ee => Object.assign(Object.assign({}, this.finish(ee)), {
                error: !0
            }),
            this.marker = ee => {
                var Ze;
                this.marks[ee] || (this.marks[ee] = []);
                const Ge = [Ut()];
                return (Ze = this.marks[ee]) === null || Ze === void 0 || Ze.push(Ge),
                () => Ge.push(Ut())
            }
            ,
            this.useTile = ee => {
                this.urls.indexOf(ee) < 0 && (this.urls.push(ee),
                this.tilesFetched++)
            }
            ,
            this.fetchTile = ee => {
                this.fetched.indexOf(ee) < 0 && this.fetched.push(ee)
            }
            ,
            this.addAll = ee => {
                var Ze;
                this.tilesFetched += ee.tilesUsed;
                const Ge = ee.origin - this.timeOrigin;
                for (const vt in ee.marks) {
                    const it = vt;
                    (this.marks[it] || (this.marks[it] = [])).push(...((Ze = ee.marks[it]) === null || Ze === void 0 ? void 0 : Ze.map(wt => wt.map(Ct => Ct + Ge))) || [])
                }
                this.resources.push(...ee.resources.map(vt => br(vt, Ge)))
            }
            ,
            this.markFinish = this.marker(le)
        }
    }
    const sr = /(Start$|End$|^start|^end)/;
    function br(ke, le) {
        const ee = {};
        for (const Ze in ke)
            ke[Ze] !== 0 && sr.test(Ze) ? ee[Ze] = Number(ke[Ze]) + le : ee[Ze] = ke[Ze];
        return ee
    }
    const en = (ke, le) => o(void 0, void 0, void 0, function*() {
        const ee = {
            signal: le.signal
        }
          , Ze = yield fetch(ke, ee);
        if (!Ze.ok)
            throw new Error(`Bad response: ${Ze.status} for ${ke}`);
        return {
            data: yield Ze.blob(),
            expires: Ze.headers.get("expires") || void 0,
            cacheControl: Ze.headers.get("cache-control") || void 0
        }
    });
    class qr {
        constructor(le) {
            this.loaded = Promise.resolve(),
            this.fetchAndParseTile = (ee, Ze, Ge, vt, it) => {
                const Xe = this
                  , wt = this.demUrlPattern.replace("{z}", ee.toString()).replace("{x}", Ze.toString()).replace("{y}", Ge.toString());
                return it?.useTile(wt),
                this.parsedCache.get(wt, (Ct, Gt) => o(this, void 0, void 0, function*() {
                    const Xt = yield Xe.fetchTile(ee, Ze, Ge, Gt, it);
                    if (be(Gt))
                        throw new Error("canceled");
                    const lr = Xe.decodeImage(Xt.data, Xe.encoding, Gt)
                      , _r = it?.marker("decode")
                      , ri = yield lr;
                    return _r?.(),
                    ri
                }), vt)
            }
            ,
            this.tileCache = new Ce(le.cacheSize),
            this.parsedCache = new Ce(le.cacheSize),
            this.contourCache = new Ce(le.cacheSize),
            this.timeoutMs = le.timeoutMs,
            this.demUrlPattern = le.demUrlPattern,
            this.encoding = le.encoding,
            this.maxzoom = le.maxzoom,
            this.decodeImage = le.decodeImage || We,
            this.getTile = le.getTile || en
        }
        fetchTile(le, ee, Ze, Ge, vt) {
            const it = this.demUrlPattern.replace("{z}", le.toString()).replace("{x}", ee.toString()).replace("{y}", Ze.toString());
            return vt?.useTile(it),
            this.tileCache.get(it, (Xe, wt) => {
                vt?.fetchTile(it);
                const Ct = vt?.marker("fetch");
                return me(this.timeoutMs, this.getTile(it, wt).finally( () => Ct?.()), wt)
            }
            , Ge)
        }
        fetchDem(le, ee, Ze, Ge, vt, it) {
            return o(this, void 0, void 0, function*() {
                const Xe = Math.min(le - (Ge.overzoom || 0), this.maxzoom)
                  , wt = le - Xe
                  , Ct = 1 << wt
                  , Gt = Math.floor(ee / Ct)
                  , Xt = Math.floor(Ze / Ct)
                  , lr = yield this.fetchAndParseTile(Xe, Gt, Xt, vt, it);
                return tr.fromRawDem(lr).split(wt, ee % Ct, Ze % Ct)
            })
        }
        fetchContourTile(le, ee, Ze, Ge, vt, it) {
            const {levels: Xe, multiplier: wt=1, buffer: Ct=1, extent: Gt=4096, contourLayer: Xt="contours", elevationKey: lr="ele", levelKey: _r="level", subsampleBelow: ri=100} = Ge;
            if (!Xe || Xe.length === 0)
                return Promise.resolve({
                    arrayBuffer: new ArrayBuffer(0)
                });
            const ni = [le, ee, Ze, D(Ge)].join("/");
            return this.contourCache.get(ni, (kr, ci) => o(this, void 0, void 0, function*() {
                const Si = 1 << le
                  , $i = [];
                for (let Ao = Ze - 1; Ao <= Ze + 1; Ao++)
                    for (let Hn = ee - 1; Hn <= ee + 1; Hn++)
                        $i.push(Ao < 0 || Ao >= Si ? void 0 : this.fetchDem(le, (Hn + Si) % Si, Ao, Ge, ci, it));
                const Ro = yield Promise.all($i);
                let Ln = tr.combineNeighbors(Ro);
                if (!Ln || be(ci))
                    return {
                        arrayBuffer: new Uint8Array().buffer
                    };
                const an = it?.marker("isoline");
                if (Ln.width >= ri)
                    Ln = Ln.materialize(2);
                else
                    for (; Ln.width < ri; )
                        Ln = Ln.subsamplePixelCenters(2).materialize(2);
                Ln = Ln.averagePixelCentersToGrid().scaleElevation(wt).materialize(1);
                const qn = d(Xe[0], Ln, Gt, Ct);
                an?.();
                const Ei = ge({
                    extent: Gt,
                    layers: {
                        [Xt]: {
                            features: Object.entries(qn).map( ([Ao,Hn]) => {
                                const Go = Number(Ao);
                                return {
                                    type: fe.LINESTRING,
                                    geometry: Hn,
                                    properties: {
                                        [lr]: Go,
                                        [_r]: Math.max(...Xe.map( (xl, Wo) => Go % xl === 0 ? Wo : 0))
                                    }
                                }
                            }
                            )
                        }
                    }
                });
                return an?.(),
                {
                    arrayBuffer: Ei.buffer
                }
            }), vt)
        }
    }
    let Dr = 0;
    class fr {
        constructor(le, ee, Ze=2e4) {
            this.callbacks = {},
            this.cancels = {},
            this.dest = le,
            this.timeoutMs = Ze,
            this.dest.onmessage = Ge => o(this, [Ge], void 0, function*({data: vt}) {
                const it = vt;
                if (it.type === "cancel") {
                    const Xe = this.cancels[it.id];
                    delete this.cancels[it.id],
                    Xe?.abort()
                } else if (it.type === "response") {
                    const Xe = this.callbacks[it.id];
                    delete this.callbacks[it.id],
                    Xe && Xe(it.error ? new Error(it.error) : void 0, it.response, it.timings)
                } else if (it.type === "request") {
                    const Xe = new Ht("worker")
                      , wt = ee[it.name]
                      , Ct = new AbortController
                      , Gt = wt.apply(wt, [...it.args, Ct, Xe])
                      , Xt = `${it.name}_${it.id}`;
                    if (it.id && Gt) {
                        this.cancels[it.id] = Ct;
                        try {
                            const lr = yield Gt
                              , _r = lr?.transferrables;
                            this.postMessage({
                                id: it.id,
                                type: "response",
                                response: lr,
                                timings: Xe.finish(Xt)
                            }, _r)
                        } catch (lr) {
                            this.postMessage({
                                id: it.id,
                                type: "response",
                                error: lr?.toString() || "error",
                                timings: Xe.finish(Xt)
                            })
                        }
                        delete this.cancels[it.id]
                    }
                }
            })
        }
        postMessage(le, ee) {
            this.dest.postMessage(le, ee || [])
        }
        send(le, ee, Ze, Ge, ...vt) {
            const it = ++Dr
              , Xe = new Promise( (wt, Ct) => {
                this.postMessage({
                    id: it,
                    type: "request",
                    name: le,
                    args: vt
                }, ee),
                this.callbacks[it] = (Gt, Xt, lr) => {
                    Ge?.addAll(lr),
                    Gt ? Ct(Gt) : wt(Xt)
                }
            }
            );
            return K(Ze, () => {
                delete this.callbacks[it],
                this.postMessage({
                    id: it,
                    type: "cancel"
                })
            }
            ),
            me(this.timeoutMs, Xe, Ze)
        }
    }
    e.A = fr,
    e.H = tr,
    e.L = qr,
    e.T = Ht,
    e._ = o,
    e.a = z,
    e.b = d,
    e.c = Nt,
    e.d = We,
    e.e = L,
    e.f = re,
    e.g = N,
    e.p = V
});
nb(["./shared"], function(e) {
    const t = u => Promise.reject(new Error(`No manager registered for ${u}`));
    class i {
        constructor() {
            this.managers = {},
            this.init = (d, f) => (this.managers[d.managerId] = new e.L(d),
            Promise.resolve()),
            this.fetchTile = (d, f, o, w, T, k) => {
                var L;
                return ((L = this.managers[d]) === null || L === void 0 ? void 0 : L.fetchTile(f, o, w, T, k)) || t(d)
            }
            ,
            this.fetchAndParseTile = (d, f, o, w, T, k) => {
                var L;
                return e.p(((L = this.managers[d]) === null || L === void 0 ? void 0 : L.fetchAndParseTile(f, o, w, T, k)) || t(d), !0)
            }
            ,
            this.fetchContourTile = (d, f, o, w, T, k, L) => {
                var z;
                return e.f(((z = this.managers[d]) === null || z === void 0 ? void 0 : z.fetchContourTile(f, o, w, T, k, L)) || t(d))
            }
        }
    }
    const s = typeof self < "u" ? self : typeof window < "u" ? window : global;
    s.actor = new e.A(s,new i)
});
nb(["./shared"], function(e) {
    const t = {
        workerUrl: ""
    };
    let i, s = 0;
    class u {
        constructor() {
            this.decodeImage = (z, D, N) => e.p(e.d(z, D, N), !1)
        }
    }
    function d() {
        if (!i) {
            const L = new Worker(t.workerUrl)
              , z = new u;
            i = new e.A(L,z)
        }
        return i
    }
    class f {
        constructor(z) {
            this.fetchTile = (N, U, V, re, ie) => this.actor.send("fetchTile", [], re, ie, this.managerId, N, U, V),
            this.fetchAndParseTile = (N, U, V, re, ie) => this.actor.send("fetchAndParseTile", [], re, ie, this.managerId, N, U, V),
            this.fetchContourTile = (N, U, V, re, ie, ue) => this.actor.send("fetchContourTile", [], ie, ue, this.managerId, N, U, V, re);
            const D = this.managerId = ++s;
            this.actor = z.actor || d(),
            this.loaded = this.actor.send("init", [], new AbortController, void 0, Object.assign(Object.assign({}, z), {
                managerId: D
            }))
        }
    }
    Blob.prototype.arrayBuffer || (Blob.prototype.arrayBuffer = function() {
        return new Promise( (z, D) => {
            const N = new FileReader;
            N.onload = U => {
                var V;
                return z((V = U.target) === null || V === void 0 ? void 0 : V.result)
            }
            ,
            N.onerror = D,
            N.readAsArrayBuffer(this)
        }
        )
    }
    );
    const o = L => (z, D) => {
        if (D instanceof AbortController)
            return L(z, D);
        {
            const N = new AbortController;
            return L(z, N).then(U => D(void 0, U.data, U.cacheControl, U.expires), U => D(U)).catch(U => D(U)),
            {
                cancel: () => N.abort()
            }
        }
    }
      , w = new Set;
    class T {
        constructor({url: z, cacheSize: D=100, id: N="dem", encoding: U="terrarium", maxzoom: V=12, worker: re=!0, timeoutMs: ie=1e4, actor: ue}) {
            this.timingCallbacks = [],
            this.onTiming = K => {
                this.timingCallbacks.push(K)
            }
            ,
            this.setupMaplibre = K => {
                K.addProtocol(this.sharedDemProtocolId, this.sharedDemProtocol),
                K.addProtocol(this.contourProtocolId, this.contourProtocol)
            }
            ,
            this.sharedDemProtocolV4 = (K, be) => e._(this, void 0, void 0, function*() {
                const [Ee,Ce,He] = this.parseUrl(K.url)
                  , ct = new e.T("main");
                let nt;
                try {
                    const J = yield this.manager.fetchTile(Ee, Ce, He, be, ct);
                    return nt = ct.finish(K.url),
                    {
                        data: yield J.data.arrayBuffer(),
                        cacheControl: J.cacheControl,
                        expires: J.expires
                    }
                } catch (J) {
                    throw nt = ct.error(K.url),
                    J
                } finally {
                    this.timingCallbacks.forEach(J => J(nt))
                }
            }),
            this.contourProtocolV4 = (K, be) => e._(this, void 0, void 0, function*() {
                const Ee = new e.T("main");
                let Ce;
                try {
                    const [He,ct,nt] = this.parseUrl(K.url)
                      , J = e.a(K.url)
                      , he = yield this.manager.fetchContourTile(He, ct, nt, e.g(J, He), be, Ee);
                    return Ce = Ee.finish(K.url),
                    {
                        data: he.arrayBuffer
                    }
                } catch (He) {
                    throw Ce = Ee.error(K.url),
                    He
                } finally {
                    this.timingCallbacks.forEach(He => He(Ce))
                }
            }),
            this.contourProtocol = o(this.contourProtocolV4),
            this.sharedDemProtocol = o(this.sharedDemProtocolV4),
            this.contourProtocolUrl = K => `${this.contourProtocolUrlBase}?${e.e(K)}`;
            let ce = N
              , X = 1;
            for (; w.has(ce); )
                ce = N + X++;
            w.add(ce),
            this.sharedDemProtocolId = `${ce}-shared`,
            this.contourProtocolId = `${ce}-contour`,
            this.sharedDemProtocolUrl = `${this.sharedDemProtocolId}://{z}/{x}/{y}`,
            this.contourProtocolUrlBase = `${this.contourProtocolId}://{z}/{x}/{y}`;
            const me = re ? f : e.L;
            this.manager = new me({
                demUrlPattern: z,
                cacheSize: D,
                encoding: U,
                maxzoom: V,
                timeoutMs: ie,
                actor: ue
            })
        }
        getDemTile(z, D, N, U) {
            return this.manager.fetchAndParseTile(z, D, N, U || new AbortController)
        }
        parseUrl(z) {
            const [,D,N,U] = /\/\/(\d+)\/(\d+)\/(\d+)/.exec(z) || [];
            return [Number(D), Number(N), Number(U)]
        }
    }
    return {
        generateIsolines: e.b,
        DemSource: T,
        HeightTile: e.H,
        LocalDemManager: e.L,
        decodeParsedImage: e.c,
        set workerUrl(L) {
            t.workerUrl = L
        },
        get workerUrl() {
            return t.workerUrl
        }
    }
});
var U5 = hx;
function Y_(e, t, i) {
    var s = i || {}, u = s.noTrailing, d = u === void 0 ? !1 : u, f = s.noLeading, o = f === void 0 ? !1 : f, w = s.debounceMode, T = w === void 0 ? void 0 : w, k, L = !1, z = 0;
    function D() {
        k && clearTimeout(k)
    }
    function N(V) {
        var re = V || {}
          , ie = re.upcomingOnly
          , ue = ie === void 0 ? !1 : ie;
        D(),
        L = !ue
    }
    function U() {
        for (var V = arguments.length, re = new Array(V), ie = 0; ie < V; ie++)
            re[ie] = arguments[ie];
        var ue = this
          , ce = Date.now() - z;
        if (L)
            return;
        function X() {
            z = Date.now(),
            t.apply(ue, re)
        }
        function me() {
            k = void 0
        }
        !o && T && !k && X(),
        D(),
        T === void 0 && ce > e ? o ? (z = Date.now(),
        d || (k = setTimeout(T ? me : X, e))) : X() : d !== !0 && (k = setTimeout(T ? me : X, T === void 0 ? e - ce : e))
    }
    return U.cancel = N,
    U
}
function RT(e, t, i) {
    var s = i || {}
      , u = s.atBegin
      , d = u === void 0 ? !1 : u;
    return Y_(e, t, {
        debounceMode: d !== !1
    })
}
class G5 {
    map;
    attributionUrl;
    attributions = [];
    isActive = !1;
    attributionControl = null;
    constructor(t, i, s) {
        this.map = t,
        this.attributionUrl = i,
        this.attributionControl = s
    }
    async fetchAttributionData() {
        try {
            const i = await (await fetch(this.attributionUrl)).json();
            this.attributions = [],
            i.contributors.forEach(s => {
                s.coverageAreas.forEach(u => {
                    this.attributions.push({
                        attribution: s.attribution,
                        score: u.score,
                        bounds: {
                            south: u.bbox[0],
                            west: u.bbox[1],
                            north: u.bbox[2],
                            east: u.bbox[3]
                        },
                        minZoom: u.zoomMin,
                        maxZoom: u.zoomMax
                    })
                }
                )
            }
            ),
            this.attributions.sort( (s, u) => u.score - s.score),
            this.isActive && this.updateAttribution()
        } catch (t) {
            console.warn("Failed to fetch Esri attribution data:", t)
        }
    }
    activate() {
        this.isActive || (this.isActive = !0,
        this.map.on("moveend", this.updateAttribution.bind(this)),
        this.map.on("zoomend", this.updateAttribution.bind(this)),
        this.updateAttribution(),
        this.attributions.length === 0 && this.fetchAttributionData())
    }
    deactivate() {
        this.isActive && (this.isActive = !1,
        this.map.off("moveend", this.updateAttribution.bind(this)),
        this.map.off("zoomend", this.updateAttribution.bind(this)))
    }
    autoManage() {
        const t = () => {
            const i = this.map.getSource("satellite") !== void 0;
            i && !this.isActive ? this.activate() : !i && this.isActive && this.deactivate()
        }
        ;
        t(),
        this.map.on("styledata", t)
    }
    updateAttribution() {
        if (!this.attributions.length || !this.isActive || !this.attributionControl)
            return;
        const t = this.map.getSource("satellite");
        if (!t)
            return;
        const i = this.map.getBounds()
          , s = this.map.getZoom()
          , u = Math.floor(s) - 1
          , d = Math.ceil(s) + 1
          , f = new Set;
        for (const w of this.attributions)
            (u >= w.minZoom && u <= w.maxZoom || d >= w.minZoom && d <= w.maxZoom) && this.boundsIntersect(i, w.bounds) && f.add(w.attribution);
        let o = "";
        f.size > 0 && (o = Array.from(f).join(", ")),
        t.attribution = "Powered by Esri, " + o,
        this.attributionControl._updateAttributions()
    }
    boundsIntersect(t, i) {
        const s = t.getSouthWest()
          , u = t.getNorthEast();
        let d = s.lng
          , f = u.lng;
        d > 180 && (d -= 360),
        f > 180 && (f -= 360),
        d < -180 && (d += 360),
        f < -180 && (f += 360);
        const o = s.lat <= i.north && u.lat >= i.south;
        let w;
        return d <= f ? w = d <= i.east && f >= i.west : w = d <= i.east || f >= i.west,
        o && w
    }
}
const AT = {
    hiddenActivities: [],
    minVertical: null,
    minElevation: null,
    minRunLength: null,
    selectedObjectID: null
};
function ib(e) {
    const i = e.getCanvasContainer().offsetWidth - 20
      , s = 400;
    return i > s ? s : i
}
var E0 = {}
  , dx = function(e, t) {
    return dx = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(i, s) {
        i.__proto__ = s
    }
    || function(i, s) {
        for (var u in s)
            Object.prototype.hasOwnProperty.call(s, u) && (i[u] = s[u])
    }
    ,
    dx(e, t)
};
function zT(e, t) {
    if (typeof t != "function" && t !== null)
        throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    dx(e, t);
    function i() {
        this.constructor = e
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype,
    new i)
}
var K_ = function() {
    return K_ = Object.assign || function(t) {
        for (var i, s = 1, u = arguments.length; s < u; s++) {
            i = arguments[s];
            for (var d in i)
                Object.prototype.hasOwnProperty.call(i, d) && (t[d] = i[d])
        }
        return t
    }
    ,
    K_.apply(this, arguments)
};
function DT(e, t) {
    var i = {};
    for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (i[s] = e[s]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var u = 0, s = Object.getOwnPropertySymbols(e); u < s.length; u++)
            t.indexOf(s[u]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[u]) && (i[s[u]] = e[s[u]]);
    return i
}
function LT(e, t, i, s) {
    var u = arguments.length, d = u < 3 ? t : s === null ? s = Object.getOwnPropertyDescriptor(t, i) : s, f;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        d = Reflect.decorate(e, t, i, s);
    else
        for (var o = e.length - 1; o >= 0; o--)
            (f = e[o]) && (d = (u < 3 ? f(d) : u > 3 ? f(t, i, d) : f(t, i)) || d);
    return u > 3 && d && Object.defineProperty(t, i, d),
    d
}
function OT(e, t) {
    return function(i, s) {
        t(i, s, e)
    }
}
function FT(e, t, i, s, u, d) {
    function f(re) {
        if (re !== void 0 && typeof re != "function")
            throw new TypeError("Function expected");
        return re
    }
    for (var o = s.kind, w = o === "getter" ? "get" : o === "setter" ? "set" : "value", T = !t && e ? s.static ? e : e.prototype : null, k = t || (T ? Object.getOwnPropertyDescriptor(T, s.name) : {}), L, z = !1, D = i.length - 1; D >= 0; D--) {
        var N = {};
        for (var U in s)
            N[U] = U === "access" ? {} : s[U];
        for (var U in s.access)
            N.access[U] = s.access[U];
        N.addInitializer = function(re) {
            if (z)
                throw new TypeError("Cannot add initializers after decoration has completed");
            d.push(f(re || null))
        }
        ;
        var V = (0,
        i[D])(o === "accessor" ? {
            get: k.get,
            set: k.set
        } : k[w], N);
        if (o === "accessor") {
            if (V === void 0)
                continue;
            if (V === null || typeof V != "object")
                throw new TypeError("Object expected");
            (L = f(V.get)) && (k.get = L),
            (L = f(V.set)) && (k.set = L),
            (L = f(V.init)) && u.unshift(L)
        } else
            (L = f(V)) && (o === "field" ? u.unshift(L) : k[w] = L)
    }
    T && Object.defineProperty(T, s.name, k),
    z = !0
}
function BT(e, t, i) {
    for (var s = arguments.length > 2, u = 0; u < t.length; u++)
        i = s ? t[u].call(e, i) : t[u].call(e);
    return s ? i : void 0
}
function jT(e) {
    return typeof e == "symbol" ? e : "".concat(e)
}
function NT(e, t, i) {
    return typeof t == "symbol" && (t = t.description ? "[".concat(t.description, "]") : ""),
    Object.defineProperty(e, "name", {
        configurable: !0,
        value: i ? "".concat(i, " ", t) : t
    })
}
function $T(e, t) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(e, t)
}
function VT(e, t, i, s) {
    function u(d) {
        return d instanceof i ? d : new i(function(f) {
            f(d)
        }
        )
    }
    return new (i || (i = Promise))(function(d, f) {
        function o(k) {
            try {
                T(s.next(k))
            } catch (L) {
                f(L)
            }
        }
        function w(k) {
            try {
                T(s.throw(k))
            } catch (L) {
                f(L)
            }
        }
        function T(k) {
            k.done ? d(k.value) : u(k.value).then(o, w)
        }
        T((s = s.apply(e, t || [])).next())
    }
    )
}
function UT(e, t) {
    var i = {
        label: 0,
        sent: function() {
            if (d[0] & 1)
                throw d[1];
            return d[1]
        },
        trys: [],
        ops: []
    }, s, u, d, f = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
    return f.next = o(0),
    f.throw = o(1),
    f.return = o(2),
    typeof Symbol == "function" && (f[Symbol.iterator] = function() {
        return this
    }
    ),
    f;
    function o(T) {
        return function(k) {
            return w([T, k])
        }
    }
    function w(T) {
        if (s)
            throw new TypeError("Generator is already executing.");
        for (; f && (f = 0,
        T[0] && (i = 0)),
        i; )
            try {
                if (s = 1,
                u && (d = T[0] & 2 ? u.return : T[0] ? u.throw || ((d = u.return) && d.call(u),
                0) : u.next) && !(d = d.call(u, T[1])).done)
                    return d;
                switch (u = 0,
                d && (T = [T[0] & 2, d.value]),
                T[0]) {
                case 0:
                case 1:
                    d = T;
                    break;
                case 4:
                    return i.label++,
                    {
                        value: T[1],
                        done: !1
                    };
                case 5:
                    i.label++,
                    u = T[1],
                    T = [0];
                    continue;
                case 7:
                    T = i.ops.pop(),
                    i.trys.pop();
                    continue;
                default:
                    if (d = i.trys,
                    !(d = d.length > 0 && d[d.length - 1]) && (T[0] === 6 || T[0] === 2)) {
                        i = 0;
                        continue
                    }
                    if (T[0] === 3 && (!d || T[1] > d[0] && T[1] < d[3])) {
                        i.label = T[1];
                        break
                    }
                    if (T[0] === 6 && i.label < d[1]) {
                        i.label = d[1],
                        d = T;
                        break
                    }
                    if (d && i.label < d[2]) {
                        i.label = d[2],
                        i.ops.push(T);
                        break
                    }
                    d[2] && i.ops.pop(),
                    i.trys.pop();
                    continue
                }
                T = t.call(e, i)
            } catch (k) {
                T = [6, k],
                u = 0
            } finally {
                s = d = 0
            }
        if (T[0] & 5)
            throw T[1];
        return {
            value: T[0] ? T[1] : void 0,
            done: !0
        }
    }
}
var Tv = Object.create ? function(e, t, i, s) {
    s === void 0 && (s = i);
    var u = Object.getOwnPropertyDescriptor(t, i);
    (!u || ("get"in u ? !t.__esModule : u.writable || u.configurable)) && (u = {
        enumerable: !0,
        get: function() {
            return t[i]
        }
    }),
    Object.defineProperty(e, s, u)
}
: function(e, t, i, s) {
    s === void 0 && (s = i),
    e[s] = t[i]
}
;
function GT(e, t) {
    for (var i in e)
        i !== "default" && !Object.prototype.hasOwnProperty.call(t, i) && Tv(t, e, i)
}
function Q_(e) {
    var t = typeof Symbol == "function" && Symbol.iterator
      , i = t && e[t]
      , s = 0;
    if (i)
        return i.call(e);
    if (e && typeof e.length == "number")
        return {
            next: function() {
                return e && s >= e.length && (e = void 0),
                {
                    value: e && e[s++],
                    done: !e
                }
            }
        };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function ob(e, t) {
    var i = typeof Symbol == "function" && e[Symbol.iterator];
    if (!i)
        return e;
    var s = i.call(e), u, d = [], f;
    try {
        for (; (t === void 0 || t-- > 0) && !(u = s.next()).done; )
            d.push(u.value)
    } catch (o) {
        f = {
            error: o
        }
    } finally {
        try {
            u && !u.done && (i = s.return) && i.call(s)
        } finally {
            if (f)
                throw f.error
        }
    }
    return d
}
function WT() {
    for (var e = [], t = 0; t < arguments.length; t++)
        e = e.concat(ob(arguments[t]));
    return e
}
function qT() {
    for (var e = 0, t = 0, i = arguments.length; t < i; t++)
        e += arguments[t].length;
    for (var s = Array(e), u = 0, t = 0; t < i; t++)
        for (var d = arguments[t], f = 0, o = d.length; f < o; f++,
        u++)
            s[u] = d[f];
    return s
}
function HT(e, t, i) {
    if (i || arguments.length === 2)
        for (var s = 0, u = t.length, d; s < u; s++)
            (d || !(s in t)) && (d || (d = Array.prototype.slice.call(t, 0, s)),
            d[s] = t[s]);
    return e.concat(d || Array.prototype.slice.call(t))
}
function Gp(e) {
    return this instanceof Gp ? (this.v = e,
    this) : new Gp(e)
}
function ZT(e, t, i) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var s = i.apply(e, t || []), u, d = [];
    return u = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype),
    o("next"),
    o("throw"),
    o("return", f),
    u[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    u;
    function f(D) {
        return function(N) {
            return Promise.resolve(N).then(D, L)
        }
    }
    function o(D, N) {
        s[D] && (u[D] = function(U) {
            return new Promise(function(V, re) {
                d.push([D, U, V, re]) > 1 || w(D, U)
            }
            )
        }
        ,
        N && (u[D] = N(u[D])))
    }
    function w(D, N) {
        try {
            T(s[D](N))
        } catch (U) {
            z(d[0][3], U)
        }
    }
    function T(D) {
        D.value instanceof Gp ? Promise.resolve(D.value.v).then(k, L) : z(d[0][2], D)
    }
    function k(D) {
        w("next", D)
    }
    function L(D) {
        w("throw", D)
    }
    function z(D, N) {
        D(N),
        d.shift(),
        d.length && w(d[0][0], d[0][1])
    }
}
function XT(e) {
    var t, i;
    return t = {},
    s("next"),
    s("throw", function(u) {
        throw u
    }),
    s("return"),
    t[Symbol.iterator] = function() {
        return this
    }
    ,
    t;
    function s(u, d) {
        t[u] = e[u] ? function(f) {
            return (i = !i) ? {
                value: Gp(e[u](f)),
                done: !1
            } : d ? d(f) : f
        }
        : d
    }
}
function YT(e) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var t = e[Symbol.asyncIterator], i;
    return t ? t.call(e) : (e = typeof Q_ == "function" ? Q_(e) : e[Symbol.iterator](),
    i = {},
    s("next"),
    s("throw"),
    s("return"),
    i[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    i);
    function s(d) {
        i[d] = e[d] && function(f) {
            return new Promise(function(o, w) {
                f = e[d](f),
                u(o, w, f.done, f.value)
            }
            )
        }
    }
    function u(d, f, o, w) {
        Promise.resolve(w).then(function(T) {
            d({
                value: T,
                done: o
            })
        }, f)
    }
}
function KT(e, t) {
    return Object.defineProperty ? Object.defineProperty(e, "raw", {
        value: t
    }) : e.raw = t,
    e
}
var W5 = Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    })
}
: function(e, t) {
    e.default = t
}
  , fx = function(e) {
    return fx = Object.getOwnPropertyNames || function(t) {
        var i = [];
        for (var s in t)
            Object.prototype.hasOwnProperty.call(t, s) && (i[i.length] = s);
        return i
    }
    ,
    fx(e)
};
function QT(e) {
    if (e && e.__esModule)
        return e;
    var t = {};
    if (e != null)
        for (var i = fx(e), s = 0; s < i.length; s++)
            i[s] !== "default" && Tv(t, e, i[s]);
    return W5(t, e),
    t
}
function JT(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}
function eP(e, t, i, s) {
    if (i === "a" && !s)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !s : !t.has(e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return i === "m" ? s : i === "a" ? s.call(e) : s ? s.value : t.get(e)
}
function tP(e, t, i, s, u) {
    if (s === "m")
        throw new TypeError("Private method is not writable");
    if (s === "a" && !u)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !u : !t.has(e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return s === "a" ? u.call(e, i) : u ? u.value = i : t.set(e, i),
    i
}
function rP(e, t) {
    if (t === null || typeof t != "object" && typeof t != "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof e == "function" ? t === e : e.has(t)
}
function nP(e, t, i) {
    if (t != null) {
        if (typeof t != "object" && typeof t != "function")
            throw new TypeError("Object expected.");
        var s, u;
        if (i) {
            if (!Symbol.asyncDispose)
                throw new TypeError("Symbol.asyncDispose is not defined.");
            s = t[Symbol.asyncDispose]
        }
        if (s === void 0) {
            if (!Symbol.dispose)
                throw new TypeError("Symbol.dispose is not defined.");
            s = t[Symbol.dispose],
            i && (u = s)
        }
        if (typeof s != "function")
            throw new TypeError("Object not disposable.");
        u && (s = function() {
            try {
                u.call(this)
            } catch (d) {
                return Promise.reject(d)
            }
        }
        ),
        e.stack.push({
            value: t,
            dispose: s,
            async: i
        })
    } else
        i && e.stack.push({
            async: !0
        });
    return t
}
var q5 = typeof SuppressedError == "function" ? SuppressedError : function(e, t, i) {
    var s = new Error(i);
    return s.name = "SuppressedError",
    s.error = e,
    s.suppressed = t,
    s
}
;
function iP(e) {
    function t(d) {
        e.error = e.hasError ? new q5(d,e.error,"An error was suppressed during disposal.") : d,
        e.hasError = !0
    }
    var i, s = 0;
    function u() {
        for (; i = e.stack.pop(); )
            try {
                if (!i.async && s === 1)
                    return s = 0,
                    e.stack.push(i),
                    Promise.resolve().then(u);
                if (i.dispose) {
                    var d = i.dispose.call(i.value);
                    if (i.async)
                        return s |= 2,
                        Promise.resolve(d).then(u, function(f) {
                            return t(f),
                            u()
                        })
                } else
                    s |= 1
            } catch (f) {
                t(f)
            }
        if (s === 1)
            return e.hasError ? Promise.reject(e.error) : Promise.resolve();
        if (e.hasError)
            throw e.error
    }
    return u()
}
function oP(e, t) {
    return typeof e == "string" && /^\.\.?\//.test(e) ? e.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(i, s, u, d, f) {
        return s ? t ? ".jsx" : ".js" : u && (!d || !f) ? i : u + d + "." + f.toLowerCase() + "js"
    }) : e
}
const H5 = {
    __extends: zT,
    __assign: K_,
    __rest: DT,
    __decorate: LT,
    __param: OT,
    __esDecorate: FT,
    __runInitializers: BT,
    __propKey: jT,
    __setFunctionName: NT,
    __metadata: $T,
    __awaiter: VT,
    __generator: UT,
    __createBinding: Tv,
    __exportStar: GT,
    __values: Q_,
    __read: ob,
    __spread: WT,
    __spreadArrays: qT,
    __spreadArray: HT,
    __await: Gp,
    __asyncGenerator: ZT,
    __asyncDelegator: XT,
    __asyncValues: YT,
    __makeTemplateObject: KT,
    __importStar: QT,
    __importDefault: JT,
    __classPrivateFieldGet: eP,
    __classPrivateFieldSet: tP,
    __classPrivateFieldIn: rP,
    __addDisposableResource: nP,
    __disposeResources: iP,
    __rewriteRelativeImportExtension: oP
}
  , Z5 = Object.freeze(Object.defineProperty({
    __proto__: null,
    __addDisposableResource: nP,
    get __assign() {
        return K_
    },
    __asyncDelegator: XT,
    __asyncGenerator: ZT,
    __asyncValues: YT,
    __await: Gp,
    __awaiter: VT,
    __classPrivateFieldGet: eP,
    __classPrivateFieldIn: rP,
    __classPrivateFieldSet: tP,
    __createBinding: Tv,
    __decorate: LT,
    __disposeResources: iP,
    __esDecorate: FT,
    __exportStar: GT,
    __extends: zT,
    __generator: UT,
    __importDefault: JT,
    __importStar: QT,
    __makeTemplateObject: KT,
    __metadata: $T,
    __param: OT,
    __propKey: jT,
    __read: ob,
    __rest: DT,
    __rewriteRelativeImportExtension: oP,
    __runInitializers: BT,
    __setFunctionName: NT,
    __spread: WT,
    __spreadArray: HT,
    __spreadArrays: qT,
    __values: Q_,
    default: H5
}, Symbol.toStringTag, {
    value: "Module"
}))
  , sP = ou(Z5);
var Uh = {}, qm = {}, Yl = {}, En = {}, Ww;
function aP() {
    if (Ww)
        return En;
    Ww = 1,
    Object.defineProperty(En, "__esModule", {
        value: !0
    });
    var e = 63710088e-1
      , t = {
        centimeters: e * 100,
        centimetres: e * 100,
        degrees: 360 / (2 * Math.PI),
        feet: e * 3.28084,
        inches: e * 39.37,
        kilometers: e / 1e3,
        kilometres: e / 1e3,
        meters: e,
        metres: e,
        miles: e / 1609.344,
        millimeters: e * 1e3,
        millimetres: e * 1e3,
        nauticalmiles: e / 1852,
        radians: 1,
        yards: e * 1.0936
    }
      , i = {
        acres: 247105e-9,
        centimeters: 1e4,
        centimetres: 1e4,
        feet: 10.763910417,
        hectares: 1e-4,
        inches: 1550.003100006,
        kilometers: 1e-6,
        kilometres: 1e-6,
        meters: 1,
        metres: 1,
        miles: 386e-9,
        nauticalmiles: 29155334959812285e-23,
        millimeters: 1e6,
        millimetres: 1e6,
        yards: 1.195990046
    };
    function s(J, he, ve={}) {
        const Ne = {
            type: "Feature"
        };
        return (ve.id === 0 || ve.id) && (Ne.id = ve.id),
        ve.bbox && (Ne.bbox = ve.bbox),
        Ne.properties = he || {},
        Ne.geometry = J,
        Ne
    }
    function u(J, he, ve={}) {
        switch (J) {
        case "Point":
            return d(he).geometry;
        case "LineString":
            return T(he).geometry;
        case "Polygon":
            return o(he).geometry;
        case "MultiPoint":
            return D(he).geometry;
        case "MultiLineString":
            return z(he).geometry;
        case "MultiPolygon":
            return N(he).geometry;
        default:
            throw new Error(J + " is invalid")
        }
    }
    function d(J, he, ve={}) {
        if (!J)
            throw new Error("coordinates is required");
        if (!Array.isArray(J))
            throw new Error("coordinates must be an Array");
        if (J.length < 2)
            throw new Error("coordinates must be at least 2 numbers long");
        if (!Ce(J[0]) || !Ce(J[1]))
            throw new Error("coordinates must contain numbers");
        return s({
            type: "Point",
            coordinates: J
        }, he, ve)
    }
    function f(J, he, ve={}) {
        return L(J.map(Ne => d(Ne, he)), ve)
    }
    function o(J, he, ve={}) {
        for (const je of J) {
            if (je.length < 4)
                throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
            if (je[je.length - 1].length !== je[0].length)
                throw new Error("First and last Position are not equivalent.");
            for (let lt = 0; lt < je[je.length - 1].length; lt++)
                if (je[je.length - 1][lt] !== je[0][lt])
                    throw new Error("First and last Position are not equivalent.")
        }
        return s({
            type: "Polygon",
            coordinates: J
        }, he, ve)
    }
    function w(J, he, ve={}) {
        return L(J.map(Ne => o(Ne, he)), ve)
    }
    function T(J, he, ve={}) {
        if (J.length < 2)
            throw new Error("coordinates must be an array of two or more positions");
        return s({
            type: "LineString",
            coordinates: J
        }, he, ve)
    }
    function k(J, he, ve={}) {
        return L(J.map(Ne => T(Ne, he)), ve)
    }
    function L(J, he={}) {
        const ve = {
            type: "FeatureCollection"
        };
        return he.id && (ve.id = he.id),
        he.bbox && (ve.bbox = he.bbox),
        ve.features = J,
        ve
    }
    function z(J, he, ve={}) {
        return s({
            type: "MultiLineString",
            coordinates: J
        }, he, ve)
    }
    function D(J, he, ve={}) {
        return s({
            type: "MultiPoint",
            coordinates: J
        }, he, ve)
    }
    function N(J, he, ve={}) {
        return s({
            type: "MultiPolygon",
            coordinates: J
        }, he, ve)
    }
    function U(J, he, ve={}) {
        return s({
            type: "GeometryCollection",
            geometries: J
        }, he, ve)
    }
    function V(J, he=0) {
        if (he && !(he >= 0))
            throw new Error("precision must be a positive number");
        const ve = Math.pow(10, he || 0);
        return Math.round(J * ve) / ve
    }
    function re(J, he="kilometers") {
        const ve = t[he];
        if (!ve)
            throw new Error(he + " units is invalid");
        return J * ve
    }
    function ie(J, he="kilometers") {
        const ve = t[he];
        if (!ve)
            throw new Error(he + " units is invalid");
        return J / ve
    }
    function ue(J, he) {
        return me(ie(J, he))
    }
    function ce(J) {
        let he = J % 360;
        return he < 0 && (he += 360),
        he
    }
    function X(J) {
        return J = J % 360,
        J > 180 ? J - 360 : J < -180 ? J + 360 : J
    }
    function me(J) {
        return J % (2 * Math.PI) * 180 / Math.PI
    }
    function K(J) {
        return J % 360 * Math.PI / 180
    }
    function be(J, he="kilometers", ve="kilometers") {
        if (!(J >= 0))
            throw new Error("length must be a positive number");
        return re(ie(J, he), ve)
    }
    function Ee(J, he="meters", ve="kilometers") {
        if (!(J >= 0))
            throw new Error("area must be a positive number");
        const Ne = i[he];
        if (!Ne)
            throw new Error("invalid original units");
        const je = i[ve];
        if (!je)
            throw new Error("invalid final units");
        return J / Ne * je
    }
    function Ce(J) {
        return !isNaN(J) && J !== null && !Array.isArray(J)
    }
    function He(J) {
        return J !== null && typeof J == "object" && !Array.isArray(J)
    }
    function ct(J) {
        if (!J)
            throw new Error("bbox is required");
        if (!Array.isArray(J))
            throw new Error("bbox must be an Array");
        if (J.length !== 4 && J.length !== 6)
            throw new Error("bbox must be an Array of 4 or 6 numbers");
        J.forEach(he => {
            if (!Ce(he))
                throw new Error("bbox must only contain numbers")
        }
        )
    }
    function nt(J) {
        if (!J)
            throw new Error("id is required");
        if (["string", "number"].indexOf(typeof J) === -1)
            throw new Error("id must be a number or a string")
    }
    return En.areaFactors = i,
    En.azimuthToBearing = X,
    En.bearingToAzimuth = ce,
    En.convertArea = Ee,
    En.convertLength = be,
    En.degreesToRadians = K,
    En.earthRadius = e,
    En.factors = t,
    En.feature = s,
    En.featureCollection = L,
    En.geometry = u,
    En.geometryCollection = U,
    En.isNumber = Ce,
    En.isObject = He,
    En.lengthToDegrees = ue,
    En.lengthToRadians = ie,
    En.lineString = T,
    En.lineStrings = k,
    En.multiLineString = z,
    En.multiPoint = D,
    En.multiPolygon = N,
    En.point = d,
    En.points = f,
    En.polygon = o,
    En.polygons = w,
    En.radiansToDegrees = me,
    En.radiansToLength = re,
    En.round = V,
    En.validateBBox = ct,
    En.validateId = nt,
    En
}
var qw;
function X5() {
    if (qw)
        return Yl;
    qw = 1,
    Object.defineProperty(Yl, "__esModule", {
        value: !0
    });
    var e = aP();
    function t(T) {
        if (!T)
            throw new Error("coord is required");
        if (!Array.isArray(T)) {
            if (T.type === "Feature" && T.geometry !== null && T.geometry.type === "Point")
                return [...T.geometry.coordinates];
            if (T.type === "Point")
                return [...T.coordinates]
        }
        if (Array.isArray(T) && T.length >= 2 && !Array.isArray(T[0]) && !Array.isArray(T[1]))
            return [...T];
        throw new Error("coord must be GeoJSON Point or an Array of numbers")
    }
    function i(T) {
        if (Array.isArray(T))
            return T;
        if (T.type === "Feature") {
            if (T.geometry !== null)
                return T.geometry.coordinates
        } else if (T.coordinates)
            return T.coordinates;
        throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")
    }
    function s(T) {
        if (T.length > 1 && e.isNumber.call(void 0, T[0]) && e.isNumber.call(void 0, T[1]))
            return !0;
        if (Array.isArray(T[0]) && T[0].length)
            return s(T[0]);
        throw new Error("coordinates must only contain numbers")
    }
    function u(T, k, L) {
        if (!k || !L)
            throw new Error("type and name required");
        if (!T || T.type !== k)
            throw new Error("Invalid input to " + L + ": must be a " + k + ", given " + T.type)
    }
    function d(T, k, L) {
        if (!T)
            throw new Error("No feature passed");
        if (!L)
            throw new Error(".featureOf() requires a name");
        if (!T || T.type !== "Feature" || !T.geometry)
            throw new Error("Invalid input to " + L + ", Feature with geometry required");
        if (!T.geometry || T.geometry.type !== k)
            throw new Error("Invalid input to " + L + ": must be a " + k + ", given " + T.geometry.type)
    }
    function f(T, k, L) {
        if (!T)
            throw new Error("No featureCollection passed");
        if (!L)
            throw new Error(".collectionOf() requires a name");
        if (!T || T.type !== "FeatureCollection")
            throw new Error("Invalid input to " + L + ", FeatureCollection required");
        for (const z of T.features) {
            if (!z || z.type !== "Feature" || !z.geometry)
                throw new Error("Invalid input to " + L + ", Feature with geometry required");
            if (!z.geometry || z.geometry.type !== k)
                throw new Error("Invalid input to " + L + ": must be a " + k + ", given " + z.geometry.type)
        }
    }
    function o(T) {
        return T.type === "Feature" ? T.geometry : T
    }
    function w(T, k) {
        return T.type === "FeatureCollection" ? "FeatureCollection" : T.type === "GeometryCollection" ? "GeometryCollection" : T.type === "Feature" && T.geometry !== null ? T.geometry.type : T.type
    }
    return Yl.collectionOf = f,
    Yl.containsNumber = s,
    Yl.featureOf = d,
    Yl.geojsonType = u,
    Yl.getCoord = t,
    Yl.getCoords = i,
    Yl.getGeom = o,
    Yl.getType = w,
    Yl
}
var Hw;
function Y5() {
    if (Hw)
        return qm;
    Hw = 1,
    Object.defineProperty(qm, "__esModule", {
        value: !0
    });
    var e = X5()
      , t = aP();
    function i(u, d, f={}) {
        var o = e.getCoord.call(void 0, u)
          , w = e.getCoord.call(void 0, d)
          , T = t.degreesToRadians.call(void 0, w[1] - o[1])
          , k = t.degreesToRadians.call(void 0, w[0] - o[0])
          , L = t.degreesToRadians.call(void 0, o[1])
          , z = t.degreesToRadians.call(void 0, w[1])
          , D = Math.pow(Math.sin(T / 2), 2) + Math.pow(Math.sin(k / 2), 2) * Math.cos(L) * Math.cos(z);
        return t.radiansToLength.call(void 0, 2 * Math.atan2(Math.sqrt(D), Math.sqrt(1 - D)), f.units)
    }
    var s = i;
    return qm.default = s,
    qm.distance = i,
    qm
}
var Hm = {}, Zm = {}, Kl = {}, In = {}, Zw;
function lP() {
    if (Zw)
        return In;
    Zw = 1,
    Object.defineProperty(In, "__esModule", {
        value: !0
    });
    var e = 63710088e-1
      , t = {
        centimeters: e * 100,
        centimetres: e * 100,
        degrees: 360 / (2 * Math.PI),
        feet: e * 3.28084,
        inches: e * 39.37,
        kilometers: e / 1e3,
        kilometres: e / 1e3,
        meters: e,
        metres: e,
        miles: e / 1609.344,
        millimeters: e * 1e3,
        millimetres: e * 1e3,
        nauticalmiles: e / 1852,
        radians: 1,
        yards: e * 1.0936
    }
      , i = {
        acres: 247105e-9,
        centimeters: 1e4,
        centimetres: 1e4,
        feet: 10.763910417,
        hectares: 1e-4,
        inches: 1550.003100006,
        kilometers: 1e-6,
        kilometres: 1e-6,
        meters: 1,
        metres: 1,
        miles: 386e-9,
        nauticalmiles: 29155334959812285e-23,
        millimeters: 1e6,
        millimetres: 1e6,
        yards: 1.195990046
    };
    function s(J, he, ve={}) {
        const Ne = {
            type: "Feature"
        };
        return (ve.id === 0 || ve.id) && (Ne.id = ve.id),
        ve.bbox && (Ne.bbox = ve.bbox),
        Ne.properties = he || {},
        Ne.geometry = J,
        Ne
    }
    function u(J, he, ve={}) {
        switch (J) {
        case "Point":
            return d(he).geometry;
        case "LineString":
            return T(he).geometry;
        case "Polygon":
            return o(he).geometry;
        case "MultiPoint":
            return D(he).geometry;
        case "MultiLineString":
            return z(he).geometry;
        case "MultiPolygon":
            return N(he).geometry;
        default:
            throw new Error(J + " is invalid")
        }
    }
    function d(J, he, ve={}) {
        if (!J)
            throw new Error("coordinates is required");
        if (!Array.isArray(J))
            throw new Error("coordinates must be an Array");
        if (J.length < 2)
            throw new Error("coordinates must be at least 2 numbers long");
        if (!Ce(J[0]) || !Ce(J[1]))
            throw new Error("coordinates must contain numbers");
        return s({
            type: "Point",
            coordinates: J
        }, he, ve)
    }
    function f(J, he, ve={}) {
        return L(J.map(Ne => d(Ne, he)), ve)
    }
    function o(J, he, ve={}) {
        for (const je of J) {
            if (je.length < 4)
                throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
            if (je[je.length - 1].length !== je[0].length)
                throw new Error("First and last Position are not equivalent.");
            for (let lt = 0; lt < je[je.length - 1].length; lt++)
                if (je[je.length - 1][lt] !== je[0][lt])
                    throw new Error("First and last Position are not equivalent.")
        }
        return s({
            type: "Polygon",
            coordinates: J
        }, he, ve)
    }
    function w(J, he, ve={}) {
        return L(J.map(Ne => o(Ne, he)), ve)
    }
    function T(J, he, ve={}) {
        if (J.length < 2)
            throw new Error("coordinates must be an array of two or more positions");
        return s({
            type: "LineString",
            coordinates: J
        }, he, ve)
    }
    function k(J, he, ve={}) {
        return L(J.map(Ne => T(Ne, he)), ve)
    }
    function L(J, he={}) {
        const ve = {
            type: "FeatureCollection"
        };
        return he.id && (ve.id = he.id),
        he.bbox && (ve.bbox = he.bbox),
        ve.features = J,
        ve
    }
    function z(J, he, ve={}) {
        return s({
            type: "MultiLineString",
            coordinates: J
        }, he, ve)
    }
    function D(J, he, ve={}) {
        return s({
            type: "MultiPoint",
            coordinates: J
        }, he, ve)
    }
    function N(J, he, ve={}) {
        return s({
            type: "MultiPolygon",
            coordinates: J
        }, he, ve)
    }
    function U(J, he, ve={}) {
        return s({
            type: "GeometryCollection",
            geometries: J
        }, he, ve)
    }
    function V(J, he=0) {
        if (he && !(he >= 0))
            throw new Error("precision must be a positive number");
        const ve = Math.pow(10, he || 0);
        return Math.round(J * ve) / ve
    }
    function re(J, he="kilometers") {
        const ve = t[he];
        if (!ve)
            throw new Error(he + " units is invalid");
        return J * ve
    }
    function ie(J, he="kilometers") {
        const ve = t[he];
        if (!ve)
            throw new Error(he + " units is invalid");
        return J / ve
    }
    function ue(J, he) {
        return me(ie(J, he))
    }
    function ce(J) {
        let he = J % 360;
        return he < 0 && (he += 360),
        he
    }
    function X(J) {
        return J = J % 360,
        J > 180 ? J - 360 : J < -180 ? J + 360 : J
    }
    function me(J) {
        return J % (2 * Math.PI) * 180 / Math.PI
    }
    function K(J) {
        return J % 360 * Math.PI / 180
    }
    function be(J, he="kilometers", ve="kilometers") {
        if (!(J >= 0))
            throw new Error("length must be a positive number");
        return re(ie(J, he), ve)
    }
    function Ee(J, he="meters", ve="kilometers") {
        if (!(J >= 0))
            throw new Error("area must be a positive number");
        const Ne = i[he];
        if (!Ne)
            throw new Error("invalid original units");
        const je = i[ve];
        if (!je)
            throw new Error("invalid final units");
        return J / Ne * je
    }
    function Ce(J) {
        return !isNaN(J) && J !== null && !Array.isArray(J)
    }
    function He(J) {
        return J !== null && typeof J == "object" && !Array.isArray(J)
    }
    function ct(J) {
        if (!J)
            throw new Error("bbox is required");
        if (!Array.isArray(J))
            throw new Error("bbox must be an Array");
        if (J.length !== 4 && J.length !== 6)
            throw new Error("bbox must be an Array of 4 or 6 numbers");
        J.forEach(he => {
            if (!Ce(he))
                throw new Error("bbox must only contain numbers")
        }
        )
    }
    function nt(J) {
        if (!J)
            throw new Error("id is required");
        if (["string", "number"].indexOf(typeof J) === -1)
            throw new Error("id must be a number or a string")
    }
    return In.areaFactors = i,
    In.azimuthToBearing = X,
    In.bearingToAzimuth = ce,
    In.convertArea = Ee,
    In.convertLength = be,
    In.degreesToRadians = K,
    In.earthRadius = e,
    In.factors = t,
    In.feature = s,
    In.featureCollection = L,
    In.geometry = u,
    In.geometryCollection = U,
    In.isNumber = Ce,
    In.isObject = He,
    In.lengthToDegrees = ue,
    In.lengthToRadians = ie,
    In.lineString = T,
    In.lineStrings = k,
    In.multiLineString = z,
    In.multiPoint = D,
    In.multiPolygon = N,
    In.point = d,
    In.points = f,
    In.polygon = o,
    In.polygons = w,
    In.radiansToDegrees = me,
    In.radiansToLength = re,
    In.round = V,
    In.validateBBox = ct,
    In.validateId = nt,
    In
}
var Xw;
function K5() {
    if (Xw)
        return Kl;
    Xw = 1,
    Object.defineProperty(Kl, "__esModule", {
        value: !0
    });
    var e = lP();
    function t(T) {
        if (!T)
            throw new Error("coord is required");
        if (!Array.isArray(T)) {
            if (T.type === "Feature" && T.geometry !== null && T.geometry.type === "Point")
                return [...T.geometry.coordinates];
            if (T.type === "Point")
                return [...T.coordinates]
        }
        if (Array.isArray(T) && T.length >= 2 && !Array.isArray(T[0]) && !Array.isArray(T[1]))
            return [...T];
        throw new Error("coord must be GeoJSON Point or an Array of numbers")
    }
    function i(T) {
        if (Array.isArray(T))
            return T;
        if (T.type === "Feature") {
            if (T.geometry !== null)
                return T.geometry.coordinates
        } else if (T.coordinates)
            return T.coordinates;
        throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")
    }
    function s(T) {
        if (T.length > 1 && e.isNumber.call(void 0, T[0]) && e.isNumber.call(void 0, T[1]))
            return !0;
        if (Array.isArray(T[0]) && T[0].length)
            return s(T[0]);
        throw new Error("coordinates must only contain numbers")
    }
    function u(T, k, L) {
        if (!k || !L)
            throw new Error("type and name required");
        if (!T || T.type !== k)
            throw new Error("Invalid input to " + L + ": must be a " + k + ", given " + T.type)
    }
    function d(T, k, L) {
        if (!T)
            throw new Error("No feature passed");
        if (!L)
            throw new Error(".featureOf() requires a name");
        if (!T || T.type !== "Feature" || !T.geometry)
            throw new Error("Invalid input to " + L + ", Feature with geometry required");
        if (!T.geometry || T.geometry.type !== k)
            throw new Error("Invalid input to " + L + ": must be a " + k + ", given " + T.geometry.type)
    }
    function f(T, k, L) {
        if (!T)
            throw new Error("No featureCollection passed");
        if (!L)
            throw new Error(".collectionOf() requires a name");
        if (!T || T.type !== "FeatureCollection")
            throw new Error("Invalid input to " + L + ", FeatureCollection required");
        for (const z of T.features) {
            if (!z || z.type !== "Feature" || !z.geometry)
                throw new Error("Invalid input to " + L + ", Feature with geometry required");
            if (!z.geometry || z.geometry.type !== k)
                throw new Error("Invalid input to " + L + ": must be a " + k + ", given " + z.geometry.type)
        }
    }
    function o(T) {
        return T.type === "Feature" ? T.geometry : T
    }
    function w(T, k) {
        return T.type === "FeatureCollection" ? "FeatureCollection" : T.type === "GeometryCollection" ? "GeometryCollection" : T.type === "Feature" && T.geometry !== null ? T.geometry.type : T.type
    }
    return Kl.collectionOf = f,
    Kl.containsNumber = s,
    Kl.featureOf = d,
    Kl.geojsonType = u,
    Kl.getCoord = t,
    Kl.getCoords = i,
    Kl.getGeom = o,
    Kl.getType = w,
    Kl
}
var Yw;
function Q5() {
    if (Yw)
        return Zm;
    Yw = 1,
    Object.defineProperty(Zm, "__esModule", {
        value: !0
    });
    var e = K5()
      , t = lP();
    function i(u, d, f={}) {
        var o = e.getCoord.call(void 0, u)
          , w = e.getCoord.call(void 0, d)
          , T = t.degreesToRadians.call(void 0, w[1] - o[1])
          , k = t.degreesToRadians.call(void 0, w[0] - o[0])
          , L = t.degreesToRadians.call(void 0, o[1])
          , z = t.degreesToRadians.call(void 0, w[1])
          , D = Math.pow(Math.sin(T / 2), 2) + Math.pow(Math.sin(k / 2), 2) * Math.cos(L) * Math.cos(z);
        return t.radiansToLength.call(void 0, 2 * Math.atan2(Math.sqrt(D), Math.sqrt(1 - D)), f.units)
    }
    var s = i;
    return Zm.default = s,
    Zm.distance = i,
    Zm
}
var co = {}, Rn = {}, Kw;
function J5() {
    if (Kw)
        return Rn;
    Kw = 1,
    Object.defineProperty(Rn, "__esModule", {
        value: !0
    });
    var e = 63710088e-1
      , t = {
        centimeters: e * 100,
        centimetres: e * 100,
        degrees: 360 / (2 * Math.PI),
        feet: e * 3.28084,
        inches: e * 39.37,
        kilometers: e / 1e3,
        kilometres: e / 1e3,
        meters: e,
        metres: e,
        miles: e / 1609.344,
        millimeters: e * 1e3,
        millimetres: e * 1e3,
        nauticalmiles: e / 1852,
        radians: 1,
        yards: e * 1.0936
    }
      , i = {
        acres: 247105e-9,
        centimeters: 1e4,
        centimetres: 1e4,
        feet: 10.763910417,
        hectares: 1e-4,
        inches: 1550.003100006,
        kilometers: 1e-6,
        kilometres: 1e-6,
        meters: 1,
        metres: 1,
        miles: 386e-9,
        nauticalmiles: 29155334959812285e-23,
        millimeters: 1e6,
        millimetres: 1e6,
        yards: 1.195990046
    };
    function s(J, he, ve={}) {
        const Ne = {
            type: "Feature"
        };
        return (ve.id === 0 || ve.id) && (Ne.id = ve.id),
        ve.bbox && (Ne.bbox = ve.bbox),
        Ne.properties = he || {},
        Ne.geometry = J,
        Ne
    }
    function u(J, he, ve={}) {
        switch (J) {
        case "Point":
            return d(he).geometry;
        case "LineString":
            return T(he).geometry;
        case "Polygon":
            return o(he).geometry;
        case "MultiPoint":
            return D(he).geometry;
        case "MultiLineString":
            return z(he).geometry;
        case "MultiPolygon":
            return N(he).geometry;
        default:
            throw new Error(J + " is invalid")
        }
    }
    function d(J, he, ve={}) {
        if (!J)
            throw new Error("coordinates is required");
        if (!Array.isArray(J))
            throw new Error("coordinates must be an Array");
        if (J.length < 2)
            throw new Error("coordinates must be at least 2 numbers long");
        if (!Ce(J[0]) || !Ce(J[1]))
            throw new Error("coordinates must contain numbers");
        return s({
            type: "Point",
            coordinates: J
        }, he, ve)
    }
    function f(J, he, ve={}) {
        return L(J.map(Ne => d(Ne, he)), ve)
    }
    function o(J, he, ve={}) {
        for (const je of J) {
            if (je.length < 4)
                throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
            if (je[je.length - 1].length !== je[0].length)
                throw new Error("First and last Position are not equivalent.");
            for (let lt = 0; lt < je[je.length - 1].length; lt++)
                if (je[je.length - 1][lt] !== je[0][lt])
                    throw new Error("First and last Position are not equivalent.")
        }
        return s({
            type: "Polygon",
            coordinates: J
        }, he, ve)
    }
    function w(J, he, ve={}) {
        return L(J.map(Ne => o(Ne, he)), ve)
    }
    function T(J, he, ve={}) {
        if (J.length < 2)
            throw new Error("coordinates must be an array of two or more positions");
        return s({
            type: "LineString",
            coordinates: J
        }, he, ve)
    }
    function k(J, he, ve={}) {
        return L(J.map(Ne => T(Ne, he)), ve)
    }
    function L(J, he={}) {
        const ve = {
            type: "FeatureCollection"
        };
        return he.id && (ve.id = he.id),
        he.bbox && (ve.bbox = he.bbox),
        ve.features = J,
        ve
    }
    function z(J, he, ve={}) {
        return s({
            type: "MultiLineString",
            coordinates: J
        }, he, ve)
    }
    function D(J, he, ve={}) {
        return s({
            type: "MultiPoint",
            coordinates: J
        }, he, ve)
    }
    function N(J, he, ve={}) {
        return s({
            type: "MultiPolygon",
            coordinates: J
        }, he, ve)
    }
    function U(J, he, ve={}) {
        return s({
            type: "GeometryCollection",
            geometries: J
        }, he, ve)
    }
    function V(J, he=0) {
        if (he && !(he >= 0))
            throw new Error("precision must be a positive number");
        const ve = Math.pow(10, he || 0);
        return Math.round(J * ve) / ve
    }
    function re(J, he="kilometers") {
        const ve = t[he];
        if (!ve)
            throw new Error(he + " units is invalid");
        return J * ve
    }
    function ie(J, he="kilometers") {
        const ve = t[he];
        if (!ve)
            throw new Error(he + " units is invalid");
        return J / ve
    }
    function ue(J, he) {
        return me(ie(J, he))
    }
    function ce(J) {
        let he = J % 360;
        return he < 0 && (he += 360),
        he
    }
    function X(J) {
        return J = J % 360,
        J > 180 ? J - 360 : J < -180 ? J + 360 : J
    }
    function me(J) {
        return J % (2 * Math.PI) * 180 / Math.PI
    }
    function K(J) {
        return J % 360 * Math.PI / 180
    }
    function be(J, he="kilometers", ve="kilometers") {
        if (!(J >= 0))
            throw new Error("length must be a positive number");
        return re(ie(J, he), ve)
    }
    function Ee(J, he="meters", ve="kilometers") {
        if (!(J >= 0))
            throw new Error("area must be a positive number");
        const Ne = i[he];
        if (!Ne)
            throw new Error("invalid original units");
        const je = i[ve];
        if (!je)
            throw new Error("invalid final units");
        return J / Ne * je
    }
    function Ce(J) {
        return !isNaN(J) && J !== null && !Array.isArray(J)
    }
    function He(J) {
        return J !== null && typeof J == "object" && !Array.isArray(J)
    }
    function ct(J) {
        if (!J)
            throw new Error("bbox is required");
        if (!Array.isArray(J))
            throw new Error("bbox must be an Array");
        if (J.length !== 4 && J.length !== 6)
            throw new Error("bbox must be an Array of 4 or 6 numbers");
        J.forEach(he => {
            if (!Ce(he))
                throw new Error("bbox must only contain numbers")
        }
        )
    }
    function nt(J) {
        if (!J)
            throw new Error("id is required");
        if (["string", "number"].indexOf(typeof J) === -1)
            throw new Error("id must be a number or a string")
    }
    return Rn.areaFactors = i,
    Rn.azimuthToBearing = X,
    Rn.bearingToAzimuth = ce,
    Rn.convertArea = Ee,
    Rn.convertLength = be,
    Rn.degreesToRadians = K,
    Rn.earthRadius = e,
    Rn.factors = t,
    Rn.feature = s,
    Rn.featureCollection = L,
    Rn.geometry = u,
    Rn.geometryCollection = U,
    Rn.isNumber = Ce,
    Rn.isObject = He,
    Rn.lengthToDegrees = ue,
    Rn.lengthToRadians = ie,
    Rn.lineString = T,
    Rn.lineStrings = k,
    Rn.multiLineString = z,
    Rn.multiPoint = D,
    Rn.multiPolygon = N,
    Rn.point = d,
    Rn.points = f,
    Rn.polygon = o,
    Rn.polygons = w,
    Rn.radiansToDegrees = me,
    Rn.radiansToLength = re,
    Rn.round = V,
    Rn.validateBBox = ct,
    Rn.validateId = nt,
    Rn
}
var Qw;
function cP() {
    if (Qw)
        return co;
    Qw = 1,
    Object.defineProperty(co, "__esModule", {
        value: !0
    });
    var e = J5();
    function t(ie, ue, ce) {
        if (ie !== null)
            for (var X, me, K, be, Ee, Ce, He, ct = 0, nt = 0, J, he = ie.type, ve = he === "FeatureCollection", Ne = he === "Feature", je = ve ? ie.features.length : 1, lt = 0; lt < je; lt++) {
                He = ve ? ie.features[lt].geometry : Ne ? ie.geometry : ie,
                J = He ? He.type === "GeometryCollection" : !1,
                Ee = J ? He.geometries.length : 1;
                for (var Pt = 0; Pt < Ee; Pt++) {
                    var We = 0
                      , st = 0;
                    if (be = J ? He.geometries[Pt] : He,
                    be !== null) {
                        Ce = be.coordinates;
                        var Nt = be.type;
                        switch (ct = ce && (Nt === "Polygon" || Nt === "MultiPolygon") ? 1 : 0,
                        Nt) {
                        case null:
                            break;
                        case "Point":
                            if (ue(Ce, nt, lt, We, st) === !1)
                                return !1;
                            nt++,
                            We++;
                            break;
                        case "LineString":
                        case "MultiPoint":
                            for (X = 0; X < Ce.length; X++) {
                                if (ue(Ce[X], nt, lt, We, st) === !1)
                                    return !1;
                                nt++,
                                Nt === "MultiPoint" && We++
                            }
                            Nt === "LineString" && We++;
                            break;
                        case "Polygon":
                        case "MultiLineString":
                            for (X = 0; X < Ce.length; X++) {
                                for (me = 0; me < Ce[X].length - ct; me++) {
                                    if (ue(Ce[X][me], nt, lt, We, st) === !1)
                                        return !1;
                                    nt++
                                }
                                Nt === "MultiLineString" && We++,
                                Nt === "Polygon" && st++
                            }
                            Nt === "Polygon" && We++;
                            break;
                        case "MultiPolygon":
                            for (X = 0; X < Ce.length; X++) {
                                for (st = 0,
                                me = 0; me < Ce[X].length; me++) {
                                    for (K = 0; K < Ce[X][me].length - ct; K++) {
                                        if (ue(Ce[X][me][K], nt, lt, We, st) === !1)
                                            return !1;
                                        nt++
                                    }
                                    st++
                                }
                                We++
                            }
                            break;
                        case "GeometryCollection":
                            for (X = 0; X < be.geometries.length; X++)
                                if (t(be.geometries[X], ue, ce) === !1)
                                    return !1;
                            break;
                        default:
                            throw new Error("Unknown Geometry Type")
                        }
                    }
                }
            }
    }
    function i(ie, ue, ce, X) {
        var me = ce;
        return t(ie, function(K, be, Ee, Ce, He) {
            be === 0 && ce === void 0 ? me = K : me = ue(me, K, be, Ee, Ce, He)
        }, X),
        me
    }
    function s(ie, ue) {
        var ce;
        switch (ie.type) {
        case "FeatureCollection":
            for (ce = 0; ce < ie.features.length && ue(ie.features[ce].properties, ce) !== !1; ce++)
                ;
            break;
        case "Feature":
            ue(ie.properties, 0);
            break
        }
    }
    function u(ie, ue, ce) {
        var X = ce;
        return s(ie, function(me, K) {
            K === 0 && ce === void 0 ? X = me : X = ue(X, me, K)
        }),
        X
    }
    function d(ie, ue) {
        if (ie.type === "Feature")
            ue(ie, 0);
        else if (ie.type === "FeatureCollection")
            for (var ce = 0; ce < ie.features.length && ue(ie.features[ce], ce) !== !1; ce++)
                ;
    }
    function f(ie, ue, ce) {
        var X = ce;
        return d(ie, function(me, K) {
            K === 0 && ce === void 0 ? X = me : X = ue(X, me, K)
        }),
        X
    }
    function o(ie) {
        var ue = [];
        return t(ie, function(ce) {
            ue.push(ce)
        }),
        ue
    }
    function w(ie, ue) {
        var ce, X, me, K, be, Ee, Ce, He, ct, nt, J = 0, he = ie.type === "FeatureCollection", ve = ie.type === "Feature", Ne = he ? ie.features.length : 1;
        for (ce = 0; ce < Ne; ce++) {
            for (Ee = he ? ie.features[ce].geometry : ve ? ie.geometry : ie,
            He = he ? ie.features[ce].properties : ve ? ie.properties : {},
            ct = he ? ie.features[ce].bbox : ve ? ie.bbox : void 0,
            nt = he ? ie.features[ce].id : ve ? ie.id : void 0,
            Ce = Ee ? Ee.type === "GeometryCollection" : !1,
            be = Ce ? Ee.geometries.length : 1,
            me = 0; me < be; me++) {
                if (K = Ce ? Ee.geometries[me] : Ee,
                K === null) {
                    if (ue(null, J, He, ct, nt) === !1)
                        return !1;
                    continue
                }
                switch (K.type) {
                case "Point":
                case "LineString":
                case "MultiPoint":
                case "Polygon":
                case "MultiLineString":
                case "MultiPolygon":
                    {
                        if (ue(K, J, He, ct, nt) === !1)
                            return !1;
                        break
                    }
                case "GeometryCollection":
                    {
                        for (X = 0; X < K.geometries.length; X++)
                            if (ue(K.geometries[X], J, He, ct, nt) === !1)
                                return !1;
                        break
                    }
                default:
                    throw new Error("Unknown Geometry Type")
                }
            }
            J++
        }
    }
    function T(ie, ue, ce) {
        var X = ce;
        return w(ie, function(me, K, be, Ee, Ce) {
            K === 0 && ce === void 0 ? X = me : X = ue(X, me, K, be, Ee, Ce)
        }),
        X
    }
    function k(ie, ue) {
        w(ie, function(ce, X, me, K, be) {
            var Ee = ce === null ? null : ce.type;
            switch (Ee) {
            case null:
            case "Point":
            case "LineString":
            case "Polygon":
                return ue(e.feature.call(void 0, ce, me, {
                    bbox: K,
                    id: be
                }), X, 0) === !1 ? !1 : void 0
            }
            var Ce;
            switch (Ee) {
            case "MultiPoint":
                Ce = "Point";
                break;
            case "MultiLineString":
                Ce = "LineString";
                break;
            case "MultiPolygon":
                Ce = "Polygon";
                break
            }
            for (var He = 0; He < ce.coordinates.length; He++) {
                var ct = ce.coordinates[He]
                  , nt = {
                    type: Ce,
                    coordinates: ct
                };
                if (ue(e.feature.call(void 0, nt, me), X, He) === !1)
                    return !1
            }
        })
    }
    function L(ie, ue, ce) {
        var X = ce;
        return k(ie, function(me, K, be) {
            K === 0 && be === 0 && ce === void 0 ? X = me : X = ue(X, me, K, be)
        }),
        X
    }
    function z(ie, ue) {
        k(ie, function(ce, X, me) {
            var K = 0;
            if (ce.geometry) {
                var be = ce.geometry.type;
                if (!(be === "Point" || be === "MultiPoint")) {
                    var Ee, Ce = 0, He = 0, ct = 0;
                    if (t(ce, function(nt, J, he, ve, Ne) {
                        if (Ee === void 0 || X > Ce || ve > He || Ne > ct) {
                            Ee = nt,
                            Ce = X,
                            He = ve,
                            ct = Ne,
                            K = 0;
                            return
                        }
                        var je = e.lineString.call(void 0, [Ee, nt], ce.properties);
                        if (ue(je, X, me, Ne, K) === !1)
                            return !1;
                        K++,
                        Ee = nt
                    }) === !1)
                        return !1
                }
            }
        })
    }
    function D(ie, ue, ce) {
        var X = ce
          , me = !1;
        return z(ie, function(K, be, Ee, Ce, He) {
            me === !1 && ce === void 0 ? X = K : X = ue(X, K, be, Ee, Ce, He),
            me = !0
        }),
        X
    }
    function N(ie, ue) {
        if (!ie)
            throw new Error("geojson is required");
        k(ie, function(ce, X, me) {
            if (ce.geometry !== null) {
                var K = ce.geometry.type
                  , be = ce.geometry.coordinates;
                switch (K) {
                case "LineString":
                    if (ue(ce, X, me, 0, 0) === !1)
                        return !1;
                    break;
                case "Polygon":
                    for (var Ee = 0; Ee < be.length; Ee++)
                        if (ue(e.lineString.call(void 0, be[Ee], ce.properties), X, me, Ee) === !1)
                            return !1;
                    break
                }
            }
        })
    }
    function U(ie, ue, ce) {
        var X = ce;
        return N(ie, function(me, K, be, Ee) {
            K === 0 && ce === void 0 ? X = me : X = ue(X, me, K, be, Ee)
        }),
        X
    }
    function V(ie, ue) {
        if (ue = ue || {},
        !e.isObject.call(void 0, ue))
            throw new Error("options is invalid");
        var ce = ue.featureIndex || 0, X = ue.multiFeatureIndex || 0, me = ue.geometryIndex || 0, K = ue.segmentIndex || 0, be = ue.properties, Ee;
        switch (ie.type) {
        case "FeatureCollection":
            ce < 0 && (ce = ie.features.length + ce),
            be = be || ie.features[ce].properties,
            Ee = ie.features[ce].geometry;
            break;
        case "Feature":
            be = be || ie.properties,
            Ee = ie.geometry;
            break;
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
            Ee = ie;
            break;
        default:
            throw new Error("geojson is invalid")
        }
        if (Ee === null)
            return null;
        var Ce = Ee.coordinates;
        switch (Ee.type) {
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
            return K < 0 && (K = Ce.length + K - 1),
            e.lineString.call(void 0, [Ce[K], Ce[K + 1]], be, ue);
        case "Polygon":
            return me < 0 && (me = Ce.length + me),
            K < 0 && (K = Ce[me].length + K - 1),
            e.lineString.call(void 0, [Ce[me][K], Ce[me][K + 1]], be, ue);
        case "MultiLineString":
            return X < 0 && (X = Ce.length + X),
            K < 0 && (K = Ce[X].length + K - 1),
            e.lineString.call(void 0, [Ce[X][K], Ce[X][K + 1]], be, ue);
        case "MultiPolygon":
            return X < 0 && (X = Ce.length + X),
            me < 0 && (me = Ce[X].length + me),
            K < 0 && (K = Ce[X][me].length - K - 1),
            e.lineString.call(void 0, [Ce[X][me][K], Ce[X][me][K + 1]], be, ue)
        }
        throw new Error("geojson is invalid")
    }
    function re(ie, ue) {
        if (ue = ue || {},
        !e.isObject.call(void 0, ue))
            throw new Error("options is invalid");
        var ce = ue.featureIndex || 0, X = ue.multiFeatureIndex || 0, me = ue.geometryIndex || 0, K = ue.coordIndex || 0, be = ue.properties, Ee;
        switch (ie.type) {
        case "FeatureCollection":
            ce < 0 && (ce = ie.features.length + ce),
            be = be || ie.features[ce].properties,
            Ee = ie.features[ce].geometry;
            break;
        case "Feature":
            be = be || ie.properties,
            Ee = ie.geometry;
            break;
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
            Ee = ie;
            break;
        default:
            throw new Error("geojson is invalid")
        }
        if (Ee === null)
            return null;
        var Ce = Ee.coordinates;
        switch (Ee.type) {
        case "Point":
            return e.point.call(void 0, Ce, be, ue);
        case "MultiPoint":
            return X < 0 && (X = Ce.length + X),
            e.point.call(void 0, Ce[X], be, ue);
        case "LineString":
            return K < 0 && (K = Ce.length + K),
            e.point.call(void 0, Ce[K], be, ue);
        case "Polygon":
            return me < 0 && (me = Ce.length + me),
            K < 0 && (K = Ce[me].length + K),
            e.point.call(void 0, Ce[me][K], be, ue);
        case "MultiLineString":
            return X < 0 && (X = Ce.length + X),
            K < 0 && (K = Ce[X].length + K),
            e.point.call(void 0, Ce[X][K], be, ue);
        case "MultiPolygon":
            return X < 0 && (X = Ce.length + X),
            me < 0 && (me = Ce[X].length + me),
            K < 0 && (K = Ce[X][me].length - K),
            e.point.call(void 0, Ce[X][me][K], be, ue)
        }
        throw new Error("geojson is invalid")
    }
    return co.coordAll = o,
    co.coordEach = t,
    co.coordReduce = i,
    co.featureEach = d,
    co.featureReduce = f,
    co.findPoint = re,
    co.findSegment = V,
    co.flattenEach = k,
    co.flattenReduce = L,
    co.geomEach = w,
    co.geomReduce = T,
    co.lineEach = N,
    co.lineReduce = U,
    co.propEach = s,
    co.propReduce = u,
    co.segmentEach = z,
    co.segmentReduce = D,
    co
}
var Jw;
function uP() {
    if (Jw)
        return Hm;
    Jw = 1,
    Object.defineProperty(Hm, "__esModule", {
        value: !0
    });
    var e = Q5()
      , t = cP();
    function i(u, d={}) {
        return t.segmentReduce.call(void 0, u, (f, o) => {
            const w = o.geometry.coordinates;
            return f + e.distance.call(void 0, w[0], w[1], d)
        }
        , 0)
    }
    var s = i;
    return Hm.default = s,
    Hm.length = i,
    Hm
}
var Xm = {}, Ym = {}, Km = {}, An = {}, eS;
function Qp() {
    if (eS)
        return An;
    eS = 1,
    Object.defineProperty(An, "__esModule", {
        value: !0
    });
    var e = 63710088e-1
      , t = {
        centimeters: e * 100,
        centimetres: e * 100,
        degrees: 360 / (2 * Math.PI),
        feet: e * 3.28084,
        inches: e * 39.37,
        kilometers: e / 1e3,
        kilometres: e / 1e3,
        meters: e,
        metres: e,
        miles: e / 1609.344,
        millimeters: e * 1e3,
        millimetres: e * 1e3,
        nauticalmiles: e / 1852,
        radians: 1,
        yards: e * 1.0936
    }
      , i = {
        acres: 247105e-9,
        centimeters: 1e4,
        centimetres: 1e4,
        feet: 10.763910417,
        hectares: 1e-4,
        inches: 1550.003100006,
        kilometers: 1e-6,
        kilometres: 1e-6,
        meters: 1,
        metres: 1,
        miles: 386e-9,
        nauticalmiles: 29155334959812285e-23,
        millimeters: 1e6,
        millimetres: 1e6,
        yards: 1.195990046
    };
    function s(J, he, ve={}) {
        const Ne = {
            type: "Feature"
        };
        return (ve.id === 0 || ve.id) && (Ne.id = ve.id),
        ve.bbox && (Ne.bbox = ve.bbox),
        Ne.properties = he || {},
        Ne.geometry = J,
        Ne
    }
    function u(J, he, ve={}) {
        switch (J) {
        case "Point":
            return d(he).geometry;
        case "LineString":
            return T(he).geometry;
        case "Polygon":
            return o(he).geometry;
        case "MultiPoint":
            return D(he).geometry;
        case "MultiLineString":
            return z(he).geometry;
        case "MultiPolygon":
            return N(he).geometry;
        default:
            throw new Error(J + " is invalid")
        }
    }
    function d(J, he, ve={}) {
        if (!J)
            throw new Error("coordinates is required");
        if (!Array.isArray(J))
            throw new Error("coordinates must be an Array");
        if (J.length < 2)
            throw new Error("coordinates must be at least 2 numbers long");
        if (!Ce(J[0]) || !Ce(J[1]))
            throw new Error("coordinates must contain numbers");
        return s({
            type: "Point",
            coordinates: J
        }, he, ve)
    }
    function f(J, he, ve={}) {
        return L(J.map(Ne => d(Ne, he)), ve)
    }
    function o(J, he, ve={}) {
        for (const je of J) {
            if (je.length < 4)
                throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
            if (je[je.length - 1].length !== je[0].length)
                throw new Error("First and last Position are not equivalent.");
            for (let lt = 0; lt < je[je.length - 1].length; lt++)
                if (je[je.length - 1][lt] !== je[0][lt])
                    throw new Error("First and last Position are not equivalent.")
        }
        return s({
            type: "Polygon",
            coordinates: J
        }, he, ve)
    }
    function w(J, he, ve={}) {
        return L(J.map(Ne => o(Ne, he)), ve)
    }
    function T(J, he, ve={}) {
        if (J.length < 2)
            throw new Error("coordinates must be an array of two or more positions");
        return s({
            type: "LineString",
            coordinates: J
        }, he, ve)
    }
    function k(J, he, ve={}) {
        return L(J.map(Ne => T(Ne, he)), ve)
    }
    function L(J, he={}) {
        const ve = {
            type: "FeatureCollection"
        };
        return he.id && (ve.id = he.id),
        he.bbox && (ve.bbox = he.bbox),
        ve.features = J,
        ve
    }
    function z(J, he, ve={}) {
        return s({
            type: "MultiLineString",
            coordinates: J
        }, he, ve)
    }
    function D(J, he, ve={}) {
        return s({
            type: "MultiPoint",
            coordinates: J
        }, he, ve)
    }
    function N(J, he, ve={}) {
        return s({
            type: "MultiPolygon",
            coordinates: J
        }, he, ve)
    }
    function U(J, he, ve={}) {
        return s({
            type: "GeometryCollection",
            geometries: J
        }, he, ve)
    }
    function V(J, he=0) {
        if (he && !(he >= 0))
            throw new Error("precision must be a positive number");
        const ve = Math.pow(10, he || 0);
        return Math.round(J * ve) / ve
    }
    function re(J, he="kilometers") {
        const ve = t[he];
        if (!ve)
            throw new Error(he + " units is invalid");
        return J * ve
    }
    function ie(J, he="kilometers") {
        const ve = t[he];
        if (!ve)
            throw new Error(he + " units is invalid");
        return J / ve
    }
    function ue(J, he) {
        return me(ie(J, he))
    }
    function ce(J) {
        let he = J % 360;
        return he < 0 && (he += 360),
        he
    }
    function X(J) {
        return J = J % 360,
        J > 180 ? J - 360 : J < -180 ? J + 360 : J
    }
    function me(J) {
        return J % (2 * Math.PI) * 180 / Math.PI
    }
    function K(J) {
        return J % 360 * Math.PI / 180
    }
    function be(J, he="kilometers", ve="kilometers") {
        if (!(J >= 0))
            throw new Error("length must be a positive number");
        return re(ie(J, he), ve)
    }
    function Ee(J, he="meters", ve="kilometers") {
        if (!(J >= 0))
            throw new Error("area must be a positive number");
        const Ne = i[he];
        if (!Ne)
            throw new Error("invalid original units");
        const je = i[ve];
        if (!je)
            throw new Error("invalid final units");
        return J / Ne * je
    }
    function Ce(J) {
        return !isNaN(J) && J !== null && !Array.isArray(J)
    }
    function He(J) {
        return J !== null && typeof J == "object" && !Array.isArray(J)
    }
    function ct(J) {
        if (!J)
            throw new Error("bbox is required");
        if (!Array.isArray(J))
            throw new Error("bbox must be an Array");
        if (J.length !== 4 && J.length !== 6)
            throw new Error("bbox must be an Array of 4 or 6 numbers");
        J.forEach(he => {
            if (!Ce(he))
                throw new Error("bbox must only contain numbers")
        }
        )
    }
    function nt(J) {
        if (!J)
            throw new Error("id is required");
        if (["string", "number"].indexOf(typeof J) === -1)
            throw new Error("id must be a number or a string")
    }
    return An.areaFactors = i,
    An.azimuthToBearing = X,
    An.bearingToAzimuth = ce,
    An.convertArea = Ee,
    An.convertLength = be,
    An.degreesToRadians = K,
    An.earthRadius = e,
    An.factors = t,
    An.feature = s,
    An.featureCollection = L,
    An.geometry = u,
    An.geometryCollection = U,
    An.isNumber = Ce,
    An.isObject = He,
    An.lengthToDegrees = ue,
    An.lengthToRadians = ie,
    An.lineString = T,
    An.lineStrings = k,
    An.multiLineString = z,
    An.multiPoint = D,
    An.multiPolygon = N,
    An.point = d,
    An.points = f,
    An.polygon = o,
    An.polygons = w,
    An.radiansToDegrees = me,
    An.radiansToLength = re,
    An.round = V,
    An.validateBBox = ct,
    An.validateId = nt,
    An
}
var Ql = {}, tS;
function sb() {
    if (tS)
        return Ql;
    tS = 1,
    Object.defineProperty(Ql, "__esModule", {
        value: !0
    });
    var e = Qp();
    function t(T) {
        if (!T)
            throw new Error("coord is required");
        if (!Array.isArray(T)) {
            if (T.type === "Feature" && T.geometry !== null && T.geometry.type === "Point")
                return [...T.geometry.coordinates];
            if (T.type === "Point")
                return [...T.coordinates]
        }
        if (Array.isArray(T) && T.length >= 2 && !Array.isArray(T[0]) && !Array.isArray(T[1]))
            return [...T];
        throw new Error("coord must be GeoJSON Point or an Array of numbers")
    }
    function i(T) {
        if (Array.isArray(T))
            return T;
        if (T.type === "Feature") {
            if (T.geometry !== null)
                return T.geometry.coordinates
        } else if (T.coordinates)
            return T.coordinates;
        throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")
    }
    function s(T) {
        if (T.length > 1 && e.isNumber.call(void 0, T[0]) && e.isNumber.call(void 0, T[1]))
            return !0;
        if (Array.isArray(T[0]) && T[0].length)
            return s(T[0]);
        throw new Error("coordinates must only contain numbers")
    }
    function u(T, k, L) {
        if (!k || !L)
            throw new Error("type and name required");
        if (!T || T.type !== k)
            throw new Error("Invalid input to " + L + ": must be a " + k + ", given " + T.type)
    }
    function d(T, k, L) {
        if (!T)
            throw new Error("No feature passed");
        if (!L)
            throw new Error(".featureOf() requires a name");
        if (!T || T.type !== "Feature" || !T.geometry)
            throw new Error("Invalid input to " + L + ", Feature with geometry required");
        if (!T.geometry || T.geometry.type !== k)
            throw new Error("Invalid input to " + L + ": must be a " + k + ", given " + T.geometry.type)
    }
    function f(T, k, L) {
        if (!T)
            throw new Error("No featureCollection passed");
        if (!L)
            throw new Error(".collectionOf() requires a name");
        if (!T || T.type !== "FeatureCollection")
            throw new Error("Invalid input to " + L + ", FeatureCollection required");
        for (const z of T.features) {
            if (!z || z.type !== "Feature" || !z.geometry)
                throw new Error("Invalid input to " + L + ", Feature with geometry required");
            if (!z.geometry || z.geometry.type !== k)
                throw new Error("Invalid input to " + L + ": must be a " + k + ", given " + z.geometry.type)
        }
    }
    function o(T) {
        return T.type === "Feature" ? T.geometry : T
    }
    function w(T, k) {
        return T.type === "FeatureCollection" ? "FeatureCollection" : T.type === "GeometryCollection" ? "GeometryCollection" : T.type === "Feature" && T.geometry !== null ? T.geometry.type : T.type
    }
    return Ql.collectionOf = f,
    Ql.containsNumber = s,
    Ql.featureOf = d,
    Ql.geojsonType = u,
    Ql.getCoord = t,
    Ql.getCoords = i,
    Ql.getGeom = o,
    Ql.getType = w,
    Ql
}
var rS;
function eB() {
    if (rS)
        return Km;
    rS = 1,
    Object.defineProperty(Km, "__esModule", {
        value: !0
    });
    var e = Qp()
      , t = sb();
    function i(d, f, o={}) {
        if (o.final === !0)
            return s(d, f);
        const w = t.getCoord.call(void 0, d)
          , T = t.getCoord.call(void 0, f)
          , k = e.degreesToRadians.call(void 0, w[0])
          , L = e.degreesToRadians.call(void 0, T[0])
          , z = e.degreesToRadians.call(void 0, w[1])
          , D = e.degreesToRadians.call(void 0, T[1])
          , N = Math.sin(L - k) * Math.cos(D)
          , U = Math.cos(z) * Math.sin(D) - Math.sin(z) * Math.cos(D) * Math.cos(L - k);
        return e.radiansToDegrees.call(void 0, Math.atan2(N, U))
    }
    function s(d, f) {
        let o = i(f, d);
        return o = (o + 180) % 360,
        o
    }
    var u = i;
    return Km.bearing = i,
    Km.default = u,
    Km
}
var Qm = {}, nS;
function tB() {
    if (nS)
        return Qm;
    nS = 1,
    Object.defineProperty(Qm, "__esModule", {
        value: !0
    });
    var e = sb()
      , t = Qp();
    function i(u, d, f={}) {
        var o = e.getCoord.call(void 0, u)
          , w = e.getCoord.call(void 0, d)
          , T = t.degreesToRadians.call(void 0, w[1] - o[1])
          , k = t.degreesToRadians.call(void 0, w[0] - o[0])
          , L = t.degreesToRadians.call(void 0, o[1])
          , z = t.degreesToRadians.call(void 0, w[1])
          , D = Math.pow(Math.sin(T / 2), 2) + Math.pow(Math.sin(k / 2), 2) * Math.cos(L) * Math.cos(z);
        return t.radiansToLength.call(void 0, 2 * Math.atan2(Math.sqrt(D), Math.sqrt(1 - D)), f.units)
    }
    var s = i;
    return Qm.default = s,
    Qm.distance = i,
    Qm
}
var Jm = {}, iS;
function rB() {
    if (iS)
        return Jm;
    iS = 1,
    Object.defineProperty(Jm, "__esModule", {
        value: !0
    });
    var e = Qp()
      , t = sb();
    function i(u, d, f, o={}) {
        const w = t.getCoord.call(void 0, u)
          , T = e.degreesToRadians.call(void 0, w[0])
          , k = e.degreesToRadians.call(void 0, w[1])
          , L = e.degreesToRadians.call(void 0, f)
          , z = e.lengthToRadians.call(void 0, d, o.units)
          , D = Math.asin(Math.sin(k) * Math.cos(z) + Math.cos(k) * Math.sin(z) * Math.cos(L))
          , N = T + Math.atan2(Math.sin(L) * Math.sin(z) * Math.cos(k), Math.cos(z) - Math.sin(k) * Math.sin(D))
          , U = e.radiansToDegrees.call(void 0, N)
          , V = e.radiansToDegrees.call(void 0, D);
        return e.point.call(void 0, [U, V], o.properties)
    }
    var s = i;
    return Jm.default = s,
    Jm.destination = i,
    Jm
}
var oS;
function nB() {
    if (oS)
        return Ym;
    oS = 1,
    Object.defineProperty(Ym, "__esModule", {
        value: !0
    });
    var e = eB()
      , t = tB()
      , i = rB()
      , s = Qp();
    function u(f, o, w, T) {
        if (T = T || {},
        !s.isObject.call(void 0, T))
            throw new Error("options is invalid");
        var k, L = [];
        if (f.type === "Feature")
            k = f.geometry.coordinates;
        else if (f.type === "LineString")
            k = f.coordinates;
        else
            throw new Error("input must be a LineString Feature or Geometry");
        for (var z = k.length, D = 0, N, U, V, re = 0; re < k.length && !(o >= D && re === k.length - 1); re++) {
            if (D > o && L.length === 0) {
                if (N = o - D,
                !N)
                    return L.push(k[re]),
                    s.lineString.call(void 0, L);
                U = e.bearing.call(void 0, k[re], k[re - 1]) - 180,
                V = i.destination.call(void 0, k[re], N, U, T),
                L.push(V.geometry.coordinates)
            }
            if (D >= w)
                return N = w - D,
                N ? (U = e.bearing.call(void 0, k[re], k[re - 1]) - 180,
                V = i.destination.call(void 0, k[re], N, U, T),
                L.push(V.geometry.coordinates),
                s.lineString.call(void 0, L)) : (L.push(k[re]),
                s.lineString.call(void 0, L));
            if (D >= o && L.push(k[re]),
            re === k.length - 1)
                return s.lineString.call(void 0, L);
            D += t.distance.call(void 0, k[re], k[re + 1], T)
        }
        if (D < o && k.length === z)
            throw new Error("Start position is beyond line");
        var ie = k[k.length - 1];
        return s.lineString.call(void 0, [ie, ie])
    }
    var d = u;
    return Ym.default = d,
    Ym.lineSliceAlong = u,
    Ym
}
var sS;
function iB() {
    if (sS)
        return Xm;
    sS = 1,
    Object.defineProperty(Xm, "__esModule", {
        value: !0
    });
    var e = uP()
      , t = nB()
      , i = cP()
      , s = Qp();
    function u(o, w, T) {
        if (T = T || {},
        !s.isObject.call(void 0, T))
            throw new Error("options is invalid");
        var k = T.units
          , L = T.reverse;
        if (!o)
            throw new Error("geojson is required");
        if (w <= 0)
            throw new Error("segmentLength must be greater than 0");
        var z = [];
        return i.flattenEach.call(void 0, o, function(D) {
            L && (D.geometry.coordinates = D.geometry.coordinates.reverse()),
            d(D, w, k, function(N) {
                z.push(N)
            })
        }),
        s.featureCollection.call(void 0, z)
    }
    function d(o, w, T, k) {
        var L = e.length.call(void 0, o, {
            units: T
        });
        if (L <= w)
            return k(o);
        var z = L / w;
        Number.isInteger(z) || (z = Math.floor(z) + 1);
        for (var D = 0; D < z; D++) {
            var N = t.lineSliceAlong.call(void 0, o, w * D, w * (D + 1), {
                units: T
            });
            k(N, D)
        }
    }
    var f = u;
    return Xm.default = f,
    Xm.lineChunk = u,
    Xm
}
var aS;
function ab() {
    if (aS)
        return Uh;
    aS = 1,
    Object.defineProperty(Uh, "__esModule", {
        value: !0
    }),
    Uh.getElevationData = u,
    Uh.getPitchData = d,
    Uh.getProfileGeometry = f,
    Uh.extractPointsForElevationProfile = o,
    Uh.getAscentAndDescent = T;
    const e = sP
      , t = e.__importDefault(Y5())
      , i = e.__importDefault(uP())
      , s = iB();
    function u(L) {
        return {
            ...T(L),
            ...d(L),
            profileGeometry: L
        }
    }
    function d(L, z=25) {
        const D = L.coordinates;
        if (D[0].length < 3)
            throw "Elevation data is required for slope analysis";
        let N = 0
          , U = 0
          , V = 0;
        for (let X = 0; X < D.length - 1; X++) {
            const me = D[X]
              , K = D[X + 1]
              , be = K[2] - me[2]
              , Ce = {
                type: "Feature",
                geometry: {
                    type: "LineString",
                    coordinates: [me, K]
                },
                properties: {}
            }
              , He = (0,
            i.default)(Ce, {
                units: "meters"
            });
            N += He,
            U += Math.sqrt(Math.pow(He, 2) + Math.pow(be, 2)),
            V += Math.abs(be)
        }
        const re = (0,
        s.lineChunk)(L, z, {
            units: "meters"
        }).features.map(X => X.geometry);
        k(re);
        let ie = null;
        for (const X of re) {
            const me = X.coordinates
              , K = me[0]
              , Ee = me[me.length - 1][2] - K[2]
              , Ce = (0,
            i.default)({
                type: "Feature",
                geometry: X,
                properties: {}
            }, {
                units: "meters"
            });
            if (Ce < z / 2)
                continue;
            const He = Math.abs(Ee / Ce);
            (ie === null || He > ie) && (ie = He)
        }
        const ue = V / N
          , ce = Math.abs(D[D.length - 1][2] - D[0][2]);
        return ie === null ? {
            averagePitchInPercent: null,
            maxPitchInPercent: null,
            inclinedLengthInMeters: U,
            overallPitchInPercent: null
        } : {
            averagePitchInPercent: ue,
            maxPitchInPercent: ie,
            inclinedLengthInMeters: U,
            overallPitchInPercent: ce / N
        }
    }
    function f(L, z) {
        const D = w(L, z.resolution);
        var N = 0;
        for (let U of D) {
            const V = U.coordinates[0];
            if (V.length === 2 && V.push(z.heights[N]),
            N++,
            N === z.heights.length)
                throw "Mismatch of points & elevation profile.";
            const re = U.coordinates[U.coordinates.length - 1];
            re.length === 2 && re.push(z.heights[N])
        }
        if (N !== z.heights.length - 1)
            throw "Mismatch of points & elevation profile";
        for (let U of D)
            for (let V of U.coordinates)
                if (V.length < 3)
                    throw "All points should have an elevation at this point.";
        return {
            type: "LineString",
            coordinates: D.flatMap(U => U.coordinates)
        }
    }
    function o(L, z) {
        const D = w(L, z)
          , N = [];
        for (let U of D) {
            const V = U.coordinates[0];
            N.push([V[0], V[1]])
        }
        if (D.length > 0) {
            const V = D[D.length - 1].coordinates;
            if (V.length > 1) {
                const re = V[V.length - 1];
                N.push([re[0], re[1]])
            }
        }
        return {
            type: "LineString",
            coordinates: N
        }
    }
    function w(L, z) {
        return (0,
        s.lineChunk)(L, z, {
            units: "meters"
        }).features.map(D => D.geometry)
    }
    function T(L) {
        const z = L.coordinates;
        if (z.length === 0)
            throw "Empty coordinates are not supported for elevation data analysis";
        if (z[0].length < 3)
            throw "Elevation data is required for elevation data analysis";
        const D = z[0][2]
          , N = z.map(U => U[2]).reduce( (U, V) => {
            const re = V - U.lastElevation;
            return re > 0 ? U.ascent += re : U.descent -= re,
            U.lastElevation = V,
            U.minElevation = Math.min(V, U.minElevation),
            U.maxElevation = Math.max(V, U.maxElevation),
            U
        }
        , {
            ascent: 0,
            descent: 0,
            minElevation: D,
            maxElevation: D,
            lastElevation: D
        });
        return {
            ascentInMeters: N.ascent,
            descentInMeters: N.descent,
            minElevationInMeters: N.minElevation,
            maxElevationInMeters: N.maxElevation,
            verticalInMeters: N.maxElevation - N.minElevation
        }
    }
    function k(L) {
        if (L.length === 0)
            return;
        const z = [];
        let D = 0
          , N = 0
          , U = null;
        for (const re of L)
            for (const ie of re.coordinates) {
                if (U) {
                    const ce = (0,
                    t.default)(U, ie, {
                        units: "meters"
                    });
                    N += ce
                }
                const ue = ie.length >= 3;
                z.push({
                    point: ie,
                    hasElevation: ue,
                    index: D++,
                    distanceFromStart: N
                }),
                U = ie
            }
        const V = z.filter(re => re.hasElevation);
        if (V.length <= 1)
            throw "At least two points with elevation data are required";
        for (let re = 0; re < V.length - 1; re++) {
            const ie = V[re]
              , ue = V[re + 1];
            if (ue.index <= ie.index)
                throw "Reference points must be in sequence";
            const ce = ie.point[2]
              , me = ue.point[2] - ce
              , K = ue.distanceFromStart - ie.distanceFromStart;
            for (let be = ie.index + 1; be < ue.index; be++) {
                const Ee = z[be];
                if (Ee.hasElevation)
                    throw "Can't interpolate elevation for points that already have it";
                const Ce = Ee.distanceFromStart - ie.distanceFromStart;
                let He = ce;
                if (K > 0) {
                    const ct = Ce / K;
                    He = ce + me * ct
                }
                Ee.point.push(He)
            }
        }
    }
    return Uh
}
var eg = {}, lS;
function oB() {
    if (lS)
        return eg;
    lS = 1,
    Object.defineProperty(eg, "__esModule", {
        value: !0
    }),
    eg.FeatureType = void 0;
    var e;
    return function(t) {
        t.Run = "run",
        t.Lift = "lift",
        t.SkiArea = "skiArea"
    }(e || (eg.FeatureType = e = {})),
    eg
}
var Gh = {}, tg = {}, cS;
function hP() {
    if (cS)
        return tg;
    cS = 1,
    Object.defineProperty(tg, "__esModule", {
        value: !0
    }),
    tg.Status = void 0;
    var e;
    return function(t) {
        t.Operating = "operating",
        t.Disused = "disused",
        t.Abandoned = "abandoned",
        t.Proposed = "proposed",
        t.Planned = "planned",
        t.Construction = "construction"
    }(e || (tg.Status = e = {})),
    tg
}
var rg = {}, uS;
function lb() {
    if (uS)
        return rg;
    uS = 1,
    Object.defineProperty(rg, "__esModule", {
        value: !0
    }),
    rg.exhaustiveMatchingGuard = void 0;
    const e = t => {
        throw new Error(`Unhandled case: ${t}`)
    }
    ;
    return rg.exhaustiveMatchingGuard = e,
    rg
}
var hS;
function dP() {
    if (hS)
        return Gh;
    hS = 1,
    Object.defineProperty(Gh, "__esModule", {
        value: !0
    }),
    Gh.LiftType = void 0,
    Gh.getLiftElevationData = u,
    Gh.getFormattedLiftType = d,
    Gh.getLiftColor = f;
    const e = ab()
      , t = hP()
      , i = lb();
    var s;
    (function(o) {
        o.CableCar = "cable_car",
        o.Gondola = "gondola",
        o.ChairLift = "chair_lift",
        o.MixedLift = "mixed_lift",
        o.DragLift = "drag_lift",
        o.TBar = "t-bar",
        o.JBar = "j-bar",
        o.Platter = "platter",
        o.RopeTow = "rope_tow",
        o.MagicCarpet = "magic_carpet",
        o.Funicular = "funicular",
        o.Railway = "railway"
    }
    )(s || (Gh.LiftType = s = {}));
    function u(o) {
        const w = o.geometry;
        if (!w || w.type !== "LineString" || w.coordinates[0].length < 3)
            return null;
        const T = (0,
        e.getElevationData)(w)
          , k = o.properties.duration;
        return {
            ...T,
            speedInMetersPerSecond: k ? T.inclinedLengthInMeters / k : null,
            verticalSpeedInMetersPerSecond: k ? T.verticalInMeters / k : null
        }
    }
    function d(o) {
        switch (o) {
        case s.CableCar:
            return "Cable Car";
        case s.Gondola:
            return "Gondola";
        case s.ChairLift:
            return "Chairlift";
        case s.MixedLift:
            return "Hybrid";
        case s.DragLift:
            return "Drag lift";
        case s.TBar:
            return "T-bar";
        case s.JBar:
            return "J-bar";
        case s.Platter:
            return "Platter";
        case s.RopeTow:
            return "Ropetow";
        case s.MagicCarpet:
            return "Magic Carpet";
        case s.Funicular:
            return "Funicular";
        case s.Railway:
            return "Railway";
        default:
            return (0,
            i.exhaustiveMatchingGuard)(o)
        }
    }
    function f(o) {
        const w = "hsl(0, 82%, 42%)"
          , T = "hsl(0, 53%, 42%)";
        switch (o) {
        case t.Status.Disused:
        case t.Status.Abandoned:
            return T;
        case t.Status.Proposed:
        case t.Status.Planned:
        case t.Status.Construction:
        case t.Status.Operating:
            return w;
        default:
            return (0,
            i.exhaustiveMatchingGuard)(o)
        }
    }
    return Gh
}
var d_ = {}, dS;
function sB() {
    if (dS)
        return d_;
    dS = 1,
    Object.defineProperty(d_, "__esModule", {
        value: !0
    }),
    d_.getLiftNameAndType = t;
    const e = dP();
    function t(f) {
        const o = f.name
          , w = i(f);
        return o && w ? `${o} (${w})` : o || w
    }
    function i(f) {
        const o = []
          , w = f.heating
          , T = f.bubble;
        w === !0 && o.push("Heated"),
        T === !0 && f.liftType !== e.LiftType.CableCar && f.liftType !== e.LiftType.Gondola && o.push("Bubble"),
        !u(f) && f.occupancy && o.push(f.occupancy + "p");
        const k = s(f) || (0,
        e.getFormattedLiftType)(f.liftType);
        return k !== null && o.push(k),
        o.join(" ")
    }
    function s(f) {
        const o = f.occupancy;
        if (f.liftType === e.LiftType.ChairLift)
            switch (o) {
            case 1:
                return "Single";
            case 2:
                return "Double";
            case 3:
                return "Triple";
            case 4:
                return "Quad";
            default:
                return null
            }
        switch (f.liftType) {
        case e.LiftType.TBar:
            return "T-bar";
        case e.LiftType.JBar:
            return "J-bar";
        case e.LiftType.Platter:
            return "Platter";
        case e.LiftType.RopeTow:
            return "Ropetow";
        case e.LiftType.MagicCarpet:
            return "Magic Carpet"
        }
        return null
    }
    function u(f) {
        return s(f) ? !0 : d(f.name, ["t-bar", "j-bar", "platter", "rope tow", "ropetow", "rope-tow", "carpet", "single", "double", "triple", "quad", "1er", "2er", "3er", "4er", "6er", "8er"])
    }
    function d(f, o) {
        if (f === null)
            return !1;
        const w = f.toLowerCase();
        return o.some(T => w.includes(T))
    }
    return d_
}
var I0 = {}, fS;
function aB() {
    return fS || (fS = 1,
    Object.defineProperty(I0, "__esModule", {
        value: !0
    })),
    I0
}
var ko = {}, pS;
function lB() {
    if (pS)
        return ko;
    pS = 1,
    Object.defineProperty(ko, "__esModule", {
        value: !0
    }),
    ko.RunDifficultyConvention = ko.RunColorValue = ko.RunColorName = ko.RunDifficulty = ko.RunGrooming = ko.RunUse = void 0,
    ko.getRunElevationData = w,
    ko.getRunColor = T,
    ko.runColorNameToValue = k,
    ko.getRunColorName = L;
    const e = ab()
      , t = lb();
    var i;
    (function(z) {
        z.Downhill = "downhill",
        z.Nordic = "nordic",
        z.Skitour = "skitour",
        z.Sled = "sled",
        z.Hike = "hike",
        z.Sleigh = "sleigh",
        z.IceSkate = "ice_skate",
        z.SnowPark = "snow_park",
        z.Playground = "playground",
        z.Connection = "connection",
        z.Fatbike = "fatbike"
    }
    )(i || (ko.RunUse = i = {}));
    var s;
    (function(z) {
        z.Classic = "classic",
        z.Mogul = "mogul",
        z.ClassicAndSkating = "classic+skating",
        z.Skating = "skating",
        z.Scooter = "scooter",
        z.Backcountry = "backcountry"
    }
    )(s || (ko.RunGrooming = s = {}));
    var u;
    (function(z) {
        z.NOVICE = "novice",
        z.EASY = "easy",
        z.INTERMEDIATE = "intermediate",
        z.ADVANCED = "advanced",
        z.EXPERT = "expert",
        z.FREERIDE = "freeride",
        z.EXTREME = "extreme"
    }
    )(u || (ko.RunDifficulty = u = {}));
    var d;
    (function(z) {
        z.GREEN = "green",
        z.BLUE = "blue",
        z.RED = "red",
        z.BLACK = "black",
        z.ORANGE = "orange",
        z.GREY = "grey"
    }
    )(d || (ko.RunColorName = d = {}));
    var f;
    (function(z) {
        z.GREEN = "hsl(125, 100%, 33%)",
        z.BLUE = "hsl(208, 100%, 33%)",
        z.RED = "hsl(359, 94%, 53%)",
        z.BLACK = "hsl(0, 0%, 0%)",
        z.ORANGE = "hsl(34, 100%, 50%)",
        z.GREY = "hsl(0, 0%, 35%)"
    }
    )(f || (ko.RunColorValue = f = {}));
    var o;
    (function(z) {
        z.EUROPE = "europe",
        z.JAPAN = "japan",
        z.NORTH_AMERICA = "north_america"
    }
    )(o || (ko.RunDifficultyConvention = o = {}));
    function w(z) {
        const D = z.geometry
          , N = z.properties.elevationProfile;
        if (!N || !D || D.type !== "LineString")
            return null;
        const U = (0,
        e.getProfileGeometry)(D, N);
        return (0,
        e.getElevationData)(U)
    }
    function T(z, D) {
        return k(L(z, D))
    }
    function k(z) {
        switch (z) {
        case d.GREEN:
            return f.GREEN;
        case d.BLUE:
            return f.BLUE;
        case d.RED:
            return f.RED;
        case d.BLACK:
            return f.BLACK;
        case d.ORANGE:
            return f.ORANGE;
        case d.GREY:
            return f.GREY;
        default:
            throw "invalid color"
        }
    }
    function L(z, D) {
        switch (z) {
        case o.EUROPE:
            switch (D) {
            case u.NOVICE:
                return d.GREEN;
            case u.EASY:
                return d.BLUE;
            case u.INTERMEDIATE:
                return d.RED;
            case u.ADVANCED:
            case u.EXPERT:
                return d.BLACK;
            case u.FREERIDE:
            case u.EXTREME:
                return d.ORANGE;
            default:
                return d.GREY
            }
        case o.JAPAN:
            switch (D) {
            case u.NOVICE:
            case u.EASY:
                return d.GREEN;
            case u.INTERMEDIATE:
                return d.RED;
            case u.ADVANCED:
            case u.EXPERT:
                return d.BLACK;
            case u.FREERIDE:
            case u.EXTREME:
                return d.ORANGE;
            default:
                return d.GREY
            }
        case o.NORTH_AMERICA:
            switch (D) {
            case u.NOVICE:
            case u.EASY:
                return d.GREEN;
            case u.INTERMEDIATE:
                return d.BLUE;
            case u.ADVANCED:
            case u.EXPERT:
                return d.BLACK;
            case u.FREERIDE:
            case u.EXTREME:
                return d.ORANGE;
            default:
                return d.GREY
            }
        default:
            return (0,
            t.exhaustiveMatchingGuard)(z)
        }
    }
    return ko
}
var ng = {}, mS;
function cB() {
    if (mS)
        return ng;
    mS = 1,
    Object.defineProperty(ng, "__esModule", {
        value: !0
    }),
    ng.SkiAreaActivity = void 0;
    var e;
    return function(t) {
        t.Downhill = "downhill",
        t.Nordic = "nordic"
    }(e || (ng.SkiAreaActivity = e = {})),
    ng
}
var Yd = {}, gS;
function uB() {
    if (gS)
        return Yd;
    gS = 1,
    Object.defineProperty(Yd, "__esModule", {
        value: !0
    }),
    Yd.SourceType = void 0,
    Yd.getSourceURL = i,
    Yd.getSourceName = s;
    const e = lb();
    var t;
    (function(u) {
        u.SKIMAP_ORG = "skimap.org",
        u.OPENSTREETMAP = "openstreetmap"
    }
    )(t || (Yd.SourceType = t = {}));
    function i(u) {
        switch (u.type) {
        case t.OPENSTREETMAP:
            return "https://www.openstreetmap.org/" + u.id;
        case t.SKIMAP_ORG:
            return "https://www.skimap.org/SkiAreas/view/" + u.id;
        default:
            return (0,
            e.exhaustiveMatchingGuard)(u.type)
        }
    }
    function s(u) {
        switch (u) {
        case t.OPENSTREETMAP:
            return "OpenStreetMap";
        case t.SKIMAP_ORG:
            return "Skimap.org";
        default:
            return (0,
            e.exhaustiveMatchingGuard)(u)
        }
    }
    return Yd
}
var yS;
function hB() {
    return yS || (yS = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        const t = sP;
        t.__exportStar(ab(), e),
        t.__exportStar(oB(), e),
        t.__exportStar(dP(), e),
        t.__exportStar(sB(), e),
        t.__exportStar(aB(), e),
        t.__exportStar(lB(), e),
        t.__exportStar(cB(), e),
        t.__exportStar(uB(), e),
        t.__exportStar(hP(), e)
    }(E0)),
    E0
}
var Et = hB();
const _S = qC("span")({
    maxWidth: "250px",
    whiteSpace: "nowrap",
    display: "inline-block",
    textOverflow: "ellipsis",
    overflow: "hidden",
    verticalAlign: "bottom"
})
  , dB = e => {
    const t = e.feature.properties
      , i = fB(t, e.eventBus);
    return i.length === 0 ? null : G.jsx(G.Fragment, {
        children: G.jsx(hL, {
            separator: "›",
            "aria-label": "breadcrumb",
            children: i.map( (s, u) => G.jsx("span", {
                children: s.map(d => d.onClick ? G.jsx(_S, {
                    children: G.jsx(Hr, {
                        color: "inherit",
                        href: "#",
                        onClick: d.onClick,
                        children: d.text
                    })
                }, d.id) : G.jsx(_S, {
                    color: "inherit",
                    children: d.text
                }, d.id)).reduce( (d, f, o, w) => (d.push(f),
                o < w.length - 1 && d.push(" / "),
                d), [])
            }, u))
        })
    })
}
;
function fB(e, t) {
    let i = [];
    (e.type === Et.FeatureType.Lift || e.type === Et.FeatureType.Run) && (i = e.skiAreas);
    let s;
    e.type === Et.FeatureType.SkiArea && e.location ? s = [e.location] : s = i.flatMap(o => o.properties.location ? [o.properties.location] : []);
    const u = R0(s.flatMap(o => o ? [{
        id: "country-" + o.iso3166_1Alpha2,
        text: o.localized.en.country
    }] : []))
      , d = R0(s.flatMap(o => {
        const w = o?.localized.en.region
          , T = o?.iso3166_2;
        return !w || !T ? [] : [{
            id: "region-" + T,
            text: w
        }]
    }
    ))
      , f = R0(i.flatMap(o => [{
        id: "skiArea-" + o.properties.id,
        text: o.properties.name ?? "Ski Area",
        onClick: () => {
            t.showInfo({
                id: o.properties.id,
                panToPosition: null
            })
        }
    }]));
    return [u, d, f].filter(o => o.length > 0)
}
function R0(e) {
    const t = new Set;
    return e.filter(i => t.has(i.id) ? !1 : (t.add(i.id),
    !0))
}
const pB = Jt("div")({
    position: "sticky",
    top: 0,
    display: "flex",
    justifyContent: "space-between",
    alignItems: "flex-start",
    background: "white",
    zIndex: 1
})
  , mB = Jt("div")( ({theme: e}) => ({
    marginTop: e.spacing(1),
    marginLeft: e.spacing(2)
}))
  , Pv = e => G.jsxs(pB, {
    children: [G.jsxs(mB, {
        children: [e.breadcrumbs && G.jsx(dB, {
            ...e.breadcrumbs
        }), e.children]
    }), G.jsx(kT, {
        onClick: e.onClose
    })]
})
  , vS = "#3085FE"
  , xS = "#20B200"
  , gB = Jt(e => G.jsx(yT, {
    ...e
}))({
    color: xS,
    "&.Mui-checked": {
        color: xS
    }
})
  , yB = Jt(e => G.jsx(yT, {
    ...e
}))({
    color: vS,
    "&.Mui-checked": {
        color: vS
    }
})
  , Mv = e => {
    const [t,i] = Pe.useState(!1)
      , [s,u] = Pe.useState(!1)
      , d = Pe.useRef(null)
      , f = Pe.useRef(null)
      , o = () => {
        const w = d.current
          , T = f.current;
        if (!w || !T)
            return;
        i(w.scrollTop > 0);
        const k = T.offsetTop + T.scrollHeight
          , L = w.scrollTop + w.clientHeight;
        u(k > L)
    }
    ;
    return Pe.useEffect( () => {
        const w = d.current;
        if (w)
            return w.addEventListener("scroll", o),
            o(),
            () => {
                w.removeEventListener("scroll", o)
            }
    }
    , []),
    Pe.useEffect( () => {
        const w = f.current;
        if (!w)
            return;
        const T = new ResizeObserver( () => {
            o()
        }
        );
        return T.observe(w),
        () => {
            T.disconnect()
        }
    }
    , [e.children]),
    G.jsxs(CL, {
        ref: d,
        style: {
            overflowY: "auto",
            maxHeight: "calc(100dvh - 78px)",
            width: e.width,
            WebkitOverflowScrolling: "touch",
            position: "relative"
        },
        children: [G.jsx("div", {
            style: {
                position: "sticky",
                top: 0,
                backgroundColor: "white",
                zIndex: 2,
                borderBottom: t ? "1px solid rgba(0, 0, 0, 0.12)" : "none"
            },
            children: e.header
        }), G.jsx("div", {
            ref: f,
            children: G.jsx(zL, {
                style: {
                    paddingTop: "0px"
                },
                children: e.children
            })
        }), e.footer && G.jsx("div", {
            style: {
                position: "sticky",
                bottom: 0,
                backgroundColor: "white",
                zIndex: 2,
                borderTop: s ? "1px solid rgba(0, 0, 0, 0.12)" : "none"
            },
            children: e.footer
        })]
    })
}
;
function _B(e) {
    switch (e) {
    case "imperial":
    case "metric":
        return e;
    default:
        return "metric"
    }
}
function A0(e, t) {
    switch (t) {
    case "metric":
        switch (e) {
        case "meters":
            return "meters";
        case "kilometers":
            return "kilometers"
        }
    case "imperial":
        switch (e) {
        case "meters":
            return "feet";
        case "kilometers":
            return "miles"
        }
    }
}
function j_(e) {
    switch (e) {
    case "feet":
        return "ft";
    case "meters":
        return "m";
    case "kilometers":
        return "km";
    case "miles":
        return "mi"
    }
}
function kp(e, t) {
    const i = e.lengthUnit;
    return `${`${e.length}${t ? " " : ""}`}${j_(i)}`
}
function Ep(e, t, i=!1) {
    let s;
    const d = 10 ** (i ? 0 : 2);
    switch (t) {
    case "feet":
        s = Math.round(e * 3.28084);
        break;
    case "meters":
        s = Math.round(e * 1);
        break;
    case "kilometers":
        s = Math.round(e * .001 * d) / d;
        break;
    case "miles":
        s = Math.round(e * 621371e-9 * d) / d;
        break
    }
    return {
        length: s,
        lengthUnit: t
    }
}
function ec(e, t, i=!1) {
    switch (t) {
    case "metric":
        return kp(Ep(e, "meters"), i);
    case "imperial":
        return kp(Ep(e, "feet"), i)
    }
}
function Jp({distanceInMeters: e, unitSystem: t, forceLongestUnit: i=!1, roundToNearestDecimal: s=!1, withSpace: u=!1}) {
    switch (t) {
    case "metric":
        const d = Ep(e, "kilometers", s);
        return i || d.length > 1 ? kp(d, u) : kp(Ep(e, "meters"), u);
    case "imperial":
        const f = Ep(e, "miles", s);
        return i || f.length >= .1 ? kp(f, u) : kp(Ep(e, "feet"), u)
    }
}
function vB(e, t) {
    if (t === "metric")
        return `${e.toFixed(1)} m/s`;
    {
        const i = e * 3.28084 * 60;
        return `${Math.round(i)} ft/min`
    }
}
function xB(e, t) {
    if (t === "metric") {
        const i = e * 60;
        return `${Math.round(i)} m/min`
    } else {
        const i = e * 3.28084 * 60;
        return `${Math.round(i)} ft/min`
    }
}
const bB = e => {
    const t = !e.filters.hiddenActivities.includes(Et.SkiAreaActivity.Downhill)
      , i = !e.filters.hiddenActivities.includes(Et.SkiAreaActivity.Nordic)
      , s = {
        marginLeft: "8px",
        marginRight: "8px"
    }
      , u = {
        marginBottom: "16px"
    }
      , d = Pe.useState(e.filters.minElevation || 0)[0]
      , f = Pe.useState(e.filters.minVertical || 0)[0]
      , o = Pe.useState(e.filters.minRunLength || 0)[0];
    return G.jsxs(Mv, {
        width: e.width,
        header: G.jsx(Pv, {
            onClose: () => e.eventBus.hideFilters(),
            children: G.jsx(qt, {
                gutterBottom: !0,
                variant: "h6",
                children: "Filters"
            })
        }),
        children: [G.jsxs("div", {
            style: u,
            children: [G.jsx(kg, {
                component: "legend",
                children: "Activities"
            }), G.jsxs(Mg, {
                children: [G.jsx(mf, {
                    control: G.jsx(yB, {
                        checked: t,
                        onChange: () => e.eventBus.toggleActivity(Et.SkiAreaActivity.Downhill)
                    }),
                    label: "Downhill & Backcountry"
                }), G.jsx(mf, {
                    control: G.jsx(gB, {
                        checked: i,
                        onChange: () => e.eventBus.toggleActivity(Et.SkiAreaActivity.Nordic)
                    }),
                    label: "Nordic"
                })]
            })]
        }), G.jsxs("div", {
            style: u,
            children: [G.jsxs(kg, {
                component: "legend",
                children: ["Minimum Elevation (", j_(A0("meters", e.unitSystem)), ")"]
            }), G.jsx(Mg, {
                style: s,
                children: G.jsx(P0, {
                    defaultValue: d,
                    min: 0,
                    max: 5e3,
                    valueLabelDisplay: "auto",
                    valueLabelFormat: w => ec(w, e.unitSystem, !0),
                    onChange: (w, T) => e.eventBus.setMinimumElevation(T)
                })
            })]
        }), G.jsxs("div", {
            style: u,
            children: [G.jsxs(kg, {
                component: "legend",
                children: ["Minimum Vertical (", j_(A0("meters", e.unitSystem)), ")"]
            }), G.jsx(Mg, {
                style: s,
                children: G.jsx(P0, {
                    defaultValue: f,
                    min: 0,
                    max: 2e3,
                    valueLabelDisplay: "auto",
                    valueLabelFormat: w => ec(w, e.unitSystem, !0),
                    onChange: (w, T) => e.eventBus.setMinimumVertical(T)
                })
            })]
        }), G.jsxs("div", {
            style: u,
            children: [G.jsxs(kg, {
                component: "legend",
                children: ["Run Length (", j_(A0("kilometers", e.unitSystem)), ")"]
            }), G.jsx(Mg, {
                style: s,
                children: G.jsx(P0, {
                    defaultValue: o,
                    min: 0,
                    max: 500,
                    valueLabelDisplay: "auto",
                    valueLabelFormat: w => Jp({
                        distanceInMeters: w * 1e3,
                        unitSystem: e.unitSystem,
                        forceLongestUnit: !0,
                        withSpace: !0,
                        roundToNearestDecimal: !0
                    }),
                    onChange: (w, T) => e.eventBus.setMinimumRunLength(T)
                })
            })]
        }), G.jsxs(qt, {
            variant: "subtitle2",
            children: [e.visibleSkiAreasCount, " visible ski areas"]
        })]
    })
}
  , wB = JC({
    palette: {
        mode: "light"
    }
})
  , qh = e => G.jsx(AC, {
    injectFirst: !0,
    children: G.jsx(tA, {
        theme: wB,
        children: e.children
    })
});
class ah extends CustomEvent {
    static EVENT_TYPE = "settings_update";
    static UNIT_SYSTEM_SETTINGS_PROPERTY = "unitSystem";
    constructor(t) {
        super(ah.EVENT_TYPE, {
            detail: t
        })
    }
}
const fP = "setting.unitSystem"
  , pP = e => {
    const [t,i] = Pe.useState(Wp());
    return Pe.useEffect( () => {
        const s = u => {
            u.detail.settingsProperty === ah.UNIT_SYSTEM_SETTINGS_PROPERTY && i(Wp())
        }
        ;
        return window.addEventListener(ah.EVENT_TYPE, s),
        () => {
            window.removeEventListener(ah.EVENT_TYPE, s)
        }
    }
    , []),
    e.render(t)
}
;
function SB(e) {
    const t = new ah({
        settingsProperty: ah.UNIT_SYSTEM_SETTINGS_PROPERTY
    });
    localStorage.setItem(fP, e),
    window.dispatchEvent(t)
}
function Wp() {
    return _B(localStorage.getItem(fP))
}
function CB({onUnitSystemChange: e, triggerWhenInitialized: t}) {
    const i = s => {
        s.detail.settingsProperty === ah.UNIT_SYSTEM_SETTINGS_PROPERTY && e(Wp())
    }
    ;
    window.addEventListener(ah.EVENT_TYPE, i),
    e(Wp())
}
class TB {
    _container;
    _map = null;
    _eventBus;
    _filters = AT;
    _visibleSkiAreasCount = 0;
    _root = null;
    constructor(t) {
        this._eventBus = t,
        this._container = document.createElement("div"),
        this._container.className = "maplibregl-ctrl"
    }
    onAdd = t => (this._root = Wh.createRoot(this._container),
    this._map = t,
    this.render(),
    this._map.on("resize", this.render),
    this._container);
    onRemove = () => {
        this._root?.unmount(),
        this._root = null,
        this._map && this._map.off("resize", this.render);
        const t = this._container.parentNode;
        t && t.removeChild(this._container),
        this._map = null
    }
    ;
    setFilters = t => {
        this._filters = t
    }
    ;
    setVisibleSkiAreasCount = t => {
        this._visibleSkiAreasCount = t,
        this.render()
    }
    ;
    render = () => {
        this._root?.render(G.jsx(qh, {
            children: G.jsx(pP, {
                render: t => G.jsx(bB, {
                    eventBus: this._eventBus,
                    filters: this._filters,
                    width: ib(this._map),
                    visibleSkiAreasCount: this._visibleSkiAreasCount,
                    unitSystem: t
                })
            })
        }))
    }
    ;
    getDefaultPosition = () => "top-left"
}
var as = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof global < "u" && global || {}
  , Fs = {
    searchParams: "URLSearchParams"in as,
    iterable: "Symbol"in as && "iterator"in Symbol,
    blob: "FileReader"in as && "Blob"in as && function() {
        try {
            return new Blob,
            !0
        } catch {
            return !1
        }
    }(),
    formData: "FormData"in as,
    arrayBuffer: "ArrayBuffer"in as
};
function PB(e) {
    return e && DataView.prototype.isPrototypeOf(e)
}
if (Fs.arrayBuffer)
    var MB = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"]
      , kB = ArrayBuffer.isView || function(e) {
        return e && MB.indexOf(Object.prototype.toString.call(e)) > -1
    }
    ;
function em(e) {
    if (typeof e != "string" && (e = String(e)),
    /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || e === "")
        throw new TypeError('Invalid character in header field name: "' + e + '"');
    return e.toLowerCase()
}
function cb(e) {
    return typeof e != "string" && (e = String(e)),
    e
}
function ub(e) {
    var t = {
        next: function() {
            var i = e.shift();
            return {
                done: i === void 0,
                value: i
            }
        }
    };
    return Fs.iterable && (t[Symbol.iterator] = function() {
        return t
    }
    ),
    t
}
function Eo(e) {
    this.map = {},
    e instanceof Eo ? e.forEach(function(t, i) {
        this.append(i, t)
    }, this) : Array.isArray(e) ? e.forEach(function(t) {
        if (t.length != 2)
            throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + t.length);
        this.append(t[0], t[1])
    }, this) : e && Object.getOwnPropertyNames(e).forEach(function(t) {
        this.append(t, e[t])
    }, this)
}
Eo.prototype.append = function(e, t) {
    e = em(e),
    t = cb(t);
    var i = this.map[e];
    this.map[e] = i ? i + ", " + t : t
}
;
Eo.prototype.delete = function(e) {
    delete this.map[em(e)]
}
;
Eo.prototype.get = function(e) {
    return e = em(e),
    this.has(e) ? this.map[e] : null
}
;
Eo.prototype.has = function(e) {
    return this.map.hasOwnProperty(em(e))
}
;
Eo.prototype.set = function(e, t) {
    this.map[em(e)] = cb(t)
}
;
Eo.prototype.forEach = function(e, t) {
    for (var i in this.map)
        this.map.hasOwnProperty(i) && e.call(t, this.map[i], i, this)
}
;
Eo.prototype.keys = function() {
    var e = [];
    return this.forEach(function(t, i) {
        e.push(i)
    }),
    ub(e)
}
;
Eo.prototype.values = function() {
    var e = [];
    return this.forEach(function(t) {
        e.push(t)
    }),
    ub(e)
}
;
Eo.prototype.entries = function() {
    var e = [];
    return this.forEach(function(t, i) {
        e.push([i, t])
    }),
    ub(e)
}
;
Fs.iterable && (Eo.prototype[Symbol.iterator] = Eo.prototype.entries);
function z0(e) {
    if (!e._noBody) {
        if (e.bodyUsed)
            return Promise.reject(new TypeError("Already read"));
        e.bodyUsed = !0
    }
}
function mP(e) {
    return new Promise(function(t, i) {
        e.onload = function() {
            t(e.result)
        }
        ,
        e.onerror = function() {
            i(e.error)
        }
    }
    )
}
function EB(e) {
    var t = new FileReader
      , i = mP(t);
    return t.readAsArrayBuffer(e),
    i
}
function IB(e) {
    var t = new FileReader
      , i = mP(t)
      , s = /charset=([A-Za-z0-9_-]+)/.exec(e.type)
      , u = s ? s[1] : "utf-8";
    return t.readAsText(e, u),
    i
}
function RB(e) {
    for (var t = new Uint8Array(e), i = new Array(t.length), s = 0; s < t.length; s++)
        i[s] = String.fromCharCode(t[s]);
    return i.join("")
}
function bS(e) {
    if (e.slice)
        return e.slice(0);
    var t = new Uint8Array(e.byteLength);
    return t.set(new Uint8Array(e)),
    t.buffer
}
function gP() {
    return this.bodyUsed = !1,
    this._initBody = function(e) {
        this.bodyUsed = this.bodyUsed,
        this._bodyInit = e,
        e ? typeof e == "string" ? this._bodyText = e : Fs.blob && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : Fs.formData && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : Fs.searchParams && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : Fs.arrayBuffer && Fs.blob && PB(e) ? (this._bodyArrayBuffer = bS(e.buffer),
        this._bodyInit = new Blob([this._bodyArrayBuffer])) : Fs.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(e) || kB(e)) ? this._bodyArrayBuffer = bS(e) : this._bodyText = e = Object.prototype.toString.call(e) : (this._noBody = !0,
        this._bodyText = ""),
        this.headers.get("content-type") || (typeof e == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : Fs.searchParams && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
    }
    ,
    Fs.blob && (this.blob = function() {
        var e = z0(this);
        if (e)
            return e;
        if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
        if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
        if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
        return Promise.resolve(new Blob([this._bodyText]))
    }
    ),
    this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
            var e = z0(this);
            return e || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
        } else {
            if (Fs.blob)
                return this.blob().then(EB);
            throw new Error("could not read as ArrayBuffer")
        }
    }
    ,
    this.text = function() {
        var e = z0(this);
        if (e)
            return e;
        if (this._bodyBlob)
            return IB(this._bodyBlob);
        if (this._bodyArrayBuffer)
            return Promise.resolve(RB(this._bodyArrayBuffer));
        if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
        return Promise.resolve(this._bodyText)
    }
    ,
    Fs.formData && (this.formData = function() {
        return this.text().then(DB)
    }
    ),
    this.json = function() {
        return this.text().then(JSON.parse)
    }
    ,
    this
}
var AB = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function zB(e) {
    var t = e.toUpperCase();
    return AB.indexOf(t) > -1 ? t : e
}
function vf(e, t) {
    if (!(this instanceof vf))
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    t = t || {};
    var i = t.body;
    if (e instanceof vf) {
        if (e.bodyUsed)
            throw new TypeError("Already read");
        this.url = e.url,
        this.credentials = e.credentials,
        t.headers || (this.headers = new Eo(e.headers)),
        this.method = e.method,
        this.mode = e.mode,
        this.signal = e.signal,
        !i && e._bodyInit != null && (i = e._bodyInit,
        e.bodyUsed = !0)
    } else
        this.url = String(e);
    if (this.credentials = t.credentials || this.credentials || "same-origin",
    (t.headers || !this.headers) && (this.headers = new Eo(t.headers)),
    this.method = zB(t.method || this.method || "GET"),
    this.mode = t.mode || this.mode || null,
    this.signal = t.signal || this.signal || function() {
        if ("AbortController"in as) {
            var d = new AbortController;
            return d.signal
        }
    }(),
    this.referrer = null,
    (this.method === "GET" || this.method === "HEAD") && i)
        throw new TypeError("Body not allowed for GET or HEAD requests");
    if (this._initBody(i),
    (this.method === "GET" || this.method === "HEAD") && (t.cache === "no-store" || t.cache === "no-cache")) {
        var s = /([?&])_=[^&]*/;
        if (s.test(this.url))
            this.url = this.url.replace(s, "$1_=" + new Date().getTime());
        else {
            var u = /\?/;
            this.url += (u.test(this.url) ? "&" : "?") + "_=" + new Date().getTime()
        }
    }
}
vf.prototype.clone = function() {
    return new vf(this,{
        body: this._bodyInit
    })
}
;
function DB(e) {
    var t = new FormData;
    return e.trim().split("&").forEach(function(i) {
        if (i) {
            var s = i.split("=")
              , u = s.shift().replace(/\+/g, " ")
              , d = s.join("=").replace(/\+/g, " ");
            t.append(decodeURIComponent(u), decodeURIComponent(d))
        }
    }),
    t
}
function LB(e) {
    var t = new Eo
      , i = e.replace(/\r?\n[\t ]+/g, " ");
    return i.split("\r").map(function(s) {
        return s.indexOf(`
`) === 0 ? s.substr(1, s.length) : s
    }).forEach(function(s) {
        var u = s.split(":")
          , d = u.shift().trim();
        if (d) {
            var f = u.join(":").trim();
            try {
                t.append(d, f)
            } catch (o) {
                console.warn("Response " + o.message)
            }
        }
    }),
    t
}
gP.call(vf.prototype);
function iu(e, t) {
    if (!(this instanceof iu))
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    if (t || (t = {}),
    this.type = "default",
    this.status = t.status === void 0 ? 200 : t.status,
    this.status < 200 || this.status > 599)
        throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
    this.ok = this.status >= 200 && this.status < 300,
    this.statusText = t.statusText === void 0 ? "" : "" + t.statusText,
    this.headers = new Eo(t.headers),
    this.url = t.url || "",
    this._initBody(e)
}
gP.call(iu.prototype);
iu.prototype.clone = function() {
    return new iu(this._bodyInit,{
        status: this.status,
        statusText: this.statusText,
        headers: new Eo(this.headers),
        url: this.url
    })
}
;
iu.error = function() {
    var e = new iu(null,{
        status: 200,
        statusText: ""
    });
    return e.ok = !1,
    e.status = 0,
    e.type = "error",
    e
}
;
var OB = [301, 302, 303, 307, 308];
iu.redirect = function(e, t) {
    if (OB.indexOf(t) === -1)
        throw new RangeError("Invalid status code");
    return new iu(null,{
        status: t,
        headers: {
            location: e
        }
    })
}
;
var hf = as.DOMException;
try {
    new hf
} catch {
    hf = function(t, i) {
        this.message = t,
        this.name = i;
        var s = Error(t);
        this.stack = s.stack
    }
    ,
    hf.prototype = Object.create(Error.prototype),
    hf.prototype.constructor = hf
}
function yP(e, t) {
    return new Promise(function(i, s) {
        var u = new vf(e,t);
        if (u.signal && u.signal.aborted)
            return s(new hf("Aborted","AbortError"));
        var d = new XMLHttpRequest;
        function f() {
            d.abort()
        }
        d.onload = function() {
            var T = {
                statusText: d.statusText,
                headers: LB(d.getAllResponseHeaders() || "")
            };
            u.url.indexOf("file://") === 0 && (d.status < 200 || d.status > 599) ? T.status = 200 : T.status = d.status,
            T.url = "responseURL"in d ? d.responseURL : T.headers.get("X-Request-URL");
            var k = "response"in d ? d.response : d.responseText;
            setTimeout(function() {
                i(new iu(k,T))
            }, 0)
        }
        ,
        d.onerror = function() {
            setTimeout(function() {
                s(new TypeError("Network request failed"))
            }, 0)
        }
        ,
        d.ontimeout = function() {
            setTimeout(function() {
                s(new TypeError("Network request timed out"))
            }, 0)
        }
        ,
        d.onabort = function() {
            setTimeout(function() {
                s(new hf("Aborted","AbortError"))
            }, 0)
        }
        ;
        function o(T) {
            try {
                return T === "" && as.location.href ? as.location.href : T
            } catch {
                return T
            }
        }
        if (d.open(u.method, o(u.url), !0),
        u.credentials === "include" ? d.withCredentials = !0 : u.credentials === "omit" && (d.withCredentials = !1),
        "responseType"in d && (Fs.blob ? d.responseType = "blob" : Fs.arrayBuffer && (d.responseType = "arraybuffer")),
        t && typeof t.headers == "object" && !(t.headers instanceof Eo || as.Headers && t.headers instanceof as.Headers)) {
            var w = [];
            Object.getOwnPropertyNames(t.headers).forEach(function(T) {
                w.push(em(T)),
                d.setRequestHeader(T, cb(t.headers[T]))
            }),
            u.headers.forEach(function(T, k) {
                w.indexOf(k) === -1 && d.setRequestHeader(k, T)
            })
        } else
            u.headers.forEach(function(T, k) {
                d.setRequestHeader(k, T)
            });
        u.signal && (u.signal.addEventListener("abort", f),
        d.onreadystatechange = function() {
            d.readyState === 4 && u.signal.removeEventListener("abort", f)
        }
        ),
        d.send(typeof u._bodyInit > "u" ? null : u._bodyInit)
    }
    )
}
yP.polyfill = !0;
as.fetch || (as.fetch = yP,
as.Headers = Eo,
as.Request = vf,
as.Response = iu);
function FB(e) {
    return fetch("https://api.openskimap.org/features/" + e + ".geojson").then(t => t.json())
}
function hb(e) {
    return e.length === 0 ? [] : e.map( (t, i) => G.jsxs(Qx, {
        size: "small",
        color: "primary",
        target: "_blank",
        href: t,
        children: ["Website ", i > 0 ? "(alternate)" : ""]
    }, `website-${i}`))
}
function _P(e, t) {
    return e.map(s => {
        switch (s) {
        case Et.RunUse.Downhill:
            return t !== Et.RunGrooming.Backcountry ? "Downhill ski run" : "Downhill ski route";
        case Et.RunUse.Nordic:
            return t !== Et.RunGrooming.Backcountry ? "Nordic ski trail" : "Nordic ski route";
        case Et.RunUse.Skitour:
            return t !== Et.RunGrooming.Backcountry ? "Ski touring trail" : "Ski touring route";
        case Et.RunUse.Sled:
            return t !== Et.RunGrooming.Backcountry ? "Sledding trail" : "Sledding route";
        case Et.RunUse.Hike:
            return t !== Et.RunGrooming.Backcountry ? "Hiking trail" : "Hiking route";
        case Et.RunUse.Sleigh:
            return "Sleigh route";
        case Et.RunUse.IceSkate:
            return "Ice skating route";
        case Et.RunUse.SnowPark:
            return "Terrain park";
        case Et.RunUse.Playground:
            return "Ski playground";
        case Et.RunUse.Connection:
            return t !== Et.RunGrooming.Backcountry ? "Connector trail" : "Connector route";
        case Et.RunUse.Fatbike:
            return t !== Et.RunGrooming.Backcountry ? "Fatbike trail" : "Fatbike route";
        default:
            return null
        }
    }
    ).filter(s => s !== null).join(", ")
}
function vP(e) {
    return e.charAt(0).toUpperCase() + e.slice(1)
}
function BB(e) {
    return e.charAt(0).toUpperCase() + e.slice(1)
}
function jB(e) {
    return e && e.length > 20 ? e.split("(")[0].trim() : e
}
var ig = {}, wS;
function NB() {
    if (wS)
        return ig;
    wS = 1;
    var e = Io();
    Object.defineProperty(ig, "__esModule", {
        value: !0
    }),
    ig.default = void 0;
    var t = e(ls())
      , i = Uo();
    return ig.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1 15h-2v-6h2zm0-8h-2V7h2z"
    }), "Info"),
    ig
}
var $B = NB();
const xP = Ni($B);
function bP(e, t, i) {
    if (e !== null)
        for (var s, u, d, f, o, w, T, k = 0, L = 0, z, D = e.type, N = D === "FeatureCollection", U = D === "Feature", V = N ? e.features.length : 1, re = 0; re < V; re++) {
            T = N ? e.features[re].geometry : U ? e.geometry : e,
            z = T ? T.type === "GeometryCollection" : !1,
            o = z ? T.geometries.length : 1;
            for (var ie = 0; ie < o; ie++) {
                var ue = 0
                  , ce = 0;
                if (f = z ? T.geometries[ie] : T,
                f !== null) {
                    w = f.coordinates;
                    var X = f.type;
                    switch (k = X === "Polygon" || X === "MultiPolygon" ? 1 : 0,
                    X) {
                    case null:
                        break;
                    case "Point":
                        if (t(w, L, re, ue, ce) === !1)
                            return !1;
                        L++,
                        ue++;
                        break;
                    case "LineString":
                    case "MultiPoint":
                        for (s = 0; s < w.length; s++) {
                            if (t(w[s], L, re, ue, ce) === !1)
                                return !1;
                            L++,
                            X === "MultiPoint" && ue++
                        }
                        X === "LineString" && ue++;
                        break;
                    case "Polygon":
                    case "MultiLineString":
                        for (s = 0; s < w.length; s++) {
                            for (u = 0; u < w[s].length - k; u++) {
                                if (t(w[s][u], L, re, ue, ce) === !1)
                                    return !1;
                                L++
                            }
                            X === "MultiLineString" && ue++,
                            X === "Polygon" && ce++
                        }
                        X === "Polygon" && ue++;
                        break;
                    case "MultiPolygon":
                        for (s = 0; s < w.length; s++) {
                            for (ce = 0,
                            u = 0; u < w[s].length; u++) {
                                for (d = 0; d < w[s][u].length - k; d++) {
                                    if (t(w[s][u][d], L, re, ue, ce) === !1)
                                        return !1;
                                    L++
                                }
                                ce++
                            }
                            ue++
                        }
                        break;
                    case "GeometryCollection":
                        for (s = 0; s < f.geometries.length; s++)
                            if (bP(f.geometries[s], t) === !1)
                                return !1;
                        break;
                    default:
                        throw new Error("Unknown Geometry Type")
                    }
                }
            }
        }
}
function wP(e, t={}) {
    let i = 0
      , s = 0
      , u = 0;
    return bP(e, function(d) {
        i += d[0],
        s += d[1],
        u++
    }),
    Ap([i / u, s / u], t.properties)
}
var VB = wP;
const UB = ({feature: e}) => {
    const t = e.properties.id
      , [i,s] = Ra.useState(!1)
      , u = `https://openskistats.org/ski-areas/roses-openskimap/${t}.svg`
      , f = wP(e).geometry.coordinates[1] >= 0;
    return G.jsxs("div", {
        style: {
            margin: "16px 0",
            display: i ? "block" : "none"
        },
        children: [G.jsxs(qt, {
            variant: "h6",
            gutterBottom: !0,
            style: {
                display: "flex",
                alignItems: "center"
            },
            children: ["Slope Aspect Rose", G.jsx(tb, {
                enterTouchDelay: 0,
                leaveTouchDelay: 15e3,
                title: G.jsxs("div", {
                    children: [G.jsx(qt, {
                        variant: "body2",
                        style: {
                            fontWeight: "bold",
                            marginBottom: "8px"
                        },
                        children: "How to read this rose diagram:"
                    }), G.jsxs(qt, {
                        variant: "body2",
                        style: {
                            marginBottom: "4px"
                        },
                        children: ["• ", G.jsx("strong", {
                            children: "Petals:"
                        }), " Show which compass directions the downhill ski runs face"]
                    }), G.jsxs(qt, {
                        variant: "body2",
                        style: {
                            marginBottom: "4px"
                        },
                        children: ["• ", G.jsx("strong", {
                            children: "Petal length:"
                        }), " Longer petals = more terrain facing that direction"]
                    }), G.jsxs(qt, {
                        variant: "body2",
                        style: {
                            marginBottom: "4px"
                        },
                        children: ["• ", G.jsx("strong", {
                            children: "Snowflake:"
                        }), " Overall average slope aspect"]
                    }), G.jsxs(qt, {
                        variant: "body2",
                        style: {
                            marginBottom: "8px"
                        },
                        children: ["• ", G.jsx("strong", {
                            children: "Sun lines:"
                        }), " Winter sun paths across the sky"]
                    }), G.jsx(qt, {
                        variant: "body2",
                        style: {
                            fontWeight: "bold",
                            marginBottom: "8px",
                            marginTop: "12px"
                        },
                        children: "Why aspect matters:"
                    }), f ? G.jsxs(G.Fragment, {
                        children: [G.jsxs(qt, {
                            variant: "body2",
                            style: {
                                marginBottom: "4px"
                            },
                            children: ["• ", G.jsx("strong", {
                                children: "North (top):"
                            }), " Retains snow longer, often colder"]
                        }), G.jsxs(qt, {
                            variant: "body2",
                            style: {
                                marginBottom: "4px"
                            },
                            children: ["• ", G.jsx("strong", {
                                children: "South (bottom):"
                            }), " More sun exposure, softens faster"]
                        })]
                    }) : G.jsxs(G.Fragment, {
                        children: [G.jsxs(qt, {
                            variant: "body2",
                            style: {
                                marginBottom: "4px"
                            },
                            children: ["• ", G.jsx("strong", {
                                children: "South (bottom):"
                            }), " Retains snow longer, often colder"]
                        }), G.jsxs(qt, {
                            variant: "body2",
                            style: {
                                marginBottom: "4px"
                            },
                            children: ["• ", G.jsx("strong", {
                                children: "North (top):"
                            }), " More sun exposure, softens faster"]
                        })]
                    }), G.jsxs(qt, {
                        variant: "body2",
                        style: {
                            marginBottom: "4px"
                        },
                        children: ["• ", G.jsx("strong", {
                            children: "East (right):"
                        }), " Morning sun, often good morning skiing, typically colder than west-facing slopes"]
                    }), G.jsxs(qt, {
                        variant: "body2",
                        style: {
                            marginBottom: "8px"
                        },
                        children: ["• ", G.jsx("strong", {
                            children: "West (left):"
                        }), " Afternoon sun, softens later in day, typically warmer than east-facing slopes"]
                    }), G.jsxs(qt, {
                        variant: "body2",
                        style: {
                            fontSize: "0.8rem",
                            marginTop: "8px"
                        },
                        children: ["Provided by", " ", G.jsx(Hr, {
                            href: "https://openskistats.org",
                            target: "_blank",
                            rel: "noopener noreferrer",
                            style: {
                                color: "white"
                            },
                            children: "OpenSkiStats"
                        })]
                    })]
                }),
                arrow: !0,
                children: G.jsx(xP, {
                    fontSize: "small",
                    style: {
                        marginLeft: "8px",
                        cursor: "pointer"
                    }
                })
            })]
        }), e.properties.activities.some(o => o !== "downhill") && G.jsx(qt, {
            variant: "body2",
            color: "textSecondary",
            children: "Only downhill runs are included in the analysis."
        }), G.jsx("div", {
            style: {
                textAlign: "center"
            },
            children: G.jsx("img", {
                src: u,
                alt: "Slope aspect rose",
                style: {
                    pointerEvents: "none",
                    maxWidth: "100%",
                    height: "auto",
                    display: i ? "inline-block" : "none"
                },
                onLoad: () => s(!0)
            })
        }), G.jsxs(qt, {
            variant: "caption",
            color: "textSecondary",
            style: {
                display: "block",
                marginTop: "8px"
            },
            children: ["Rose from", " ", G.jsx(Hr, {
                href: "https://openskistats.org",
                target: "_blank",
                rel: "noopener noreferrer",
                children: "OpenSkiStats"
            }), " ", "available under a", " ", G.jsx(Hr, {
                href: "https://creativecommons.org/licenses/by/4.0/",
                target: "_blank",
                rel: "noopener noreferrer",
                children: "CC BY 4.0 license"
            }), " ", "."]
        })]
    })
}
  , db = e => {
    const t = e.sources.some(s => s.type === Et.SourceType.OPENSTREETMAP)
      , i = e.sources.reduce( (s, u) => (s.has(u.type) || s.set(u.type, []),
    s.get(u.type).push(u.id),
    s), new Map);
    return G.jsxs(qt, {
        variant: "subtitle1",
        color: "textSecondary",
        children: ["Source:", " ", [...i.keys()].map( (s, u) => {
            const d = i.get(s);
            return G.jsxs("span", {
                children: [d.length === 1 ? G.jsx(Hr, {
                    href: Et.getSourceURL({
                        type: s,
                        id: d[0]
                    }),
                    target: "_blank",
                    children: Et.getSourceName(s)
                }) : G.jsxs(G.Fragment, {
                    children: [Et.getSourceName(s), " (", d.map( (f, o) => G.jsxs("span", {
                        children: [G.jsx(Hr, {
                            href: Et.getSourceURL({
                                type: s,
                                id: f
                            }),
                            target: "_blank",
                            children: o + 1
                        }), o !== d.length - 1 ? ", " : ""]
                    }, "source-id-" + f)), ")"]
                }), u !== i.size - 1 || !t ? ", " : ""]
            }, "source-" + u)
        }
        ), t ? null : "OpenStreetMap"]
    })
}
;
var og = {}, SS;
function GB() {
    if (SS)
        return og;
    SS = 1;
    var e = Io();
    Object.defineProperty(og, "__esModule", {
        value: !0
    }),
    og.default = void 0;
    var t = e(ls())
      , i = Uo();
    return og.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2m5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12z"
    }), "Cancel"),
    og
}
var WB = GB();
const qB = Ni(WB);
var sg = {}, CS;
function HB() {
    if (CS)
        return sg;
    CS = 1;
    var e = Io();
    Object.defineProperty(sg, "__esModule", {
        value: !0
    }),
    sg.default = void 0;
    var t = e(ls())
      , i = Uo();
    return sg.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"
    }), "CheckCircle"),
    sg
}
var ZB = HB();
const XB = Ni(ZB);
var ag = {}, TS;
function YB() {
    if (TS)
        return ag;
    TS = 1;
    var e = Io();
    Object.defineProperty(ag, "__esModule", {
        value: !0
    }),
    ag.default = void 0;
    var t = e(ls())
      , i = Uo();
    return ag.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1 17h-2v-2h2zm2.07-7.75-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25"
    }), "Help"),
    ag
}
var KB = YB();
const PS = Ni(KB)
  , SP = e => G.jsx("span", {
    style: {
        flexShrink: 0
    },
    children: G.jsx(tb, {
        enterTouchDelay: 0,
        title: JB(e.status, e.entityName),
        placement: "right",
        children: QB(e.status)
    })
});
function QB(e) {
    const t = {
        verticalAlign: "text-top",
        fontSize: "32px"
    };
    switch (e) {
    case Et.Status.Proposed:
    case Et.Status.Planned:
    case Et.Status.Construction:
        return G.jsx(PS, {
            style: {
                ...t,
                color: "purple"
            }
        });
    case Et.Status.Operating:
        return G.jsx(XB, {
            style: {
                ...t,
                color: "green"
            }
        });
    case Et.Status.Abandoned:
    case Et.Status.Disused:
        return G.jsx(qB, {
            style: {
                ...t,
                color: "red"
            }
        });
    case null:
        return G.jsx(PS, {
            style: t
        })
    }
}
function JB(e, t) {
    switch (e) {
    case Et.Status.Proposed:
        return "This " + t + " is proposed to be built.";
    case Et.Status.Planned:
        return "This " + t + " is planned to be built.";
    case Et.Status.Construction:
        return "This " + t + " is under construction.";
    case Et.Status.Operating:
        return "This " + t + " is thought to be operational.";
    case Et.Status.Abandoned:
        return "This " + t + " is abandoned.";
    case Et.Status.Disused:
        return "This " + t + " is not being operated.";
    case null:
        return "The status of this " + t + " is unknown."
    }
}
const CP = 12.5
  , ej = e => {
    const t = e.feature.properties
      , i = tj(t);
    return G.jsxs(Mv, {
        width: e.width,
        header: G.jsx(Pv, {
            breadcrumbs: {
                eventBus: e.eventBus,
                feature: e.feature
            },
            onClose: e.eventBus.hideInfo
        }),
        footer: i.length > 0 ? G.jsx(Jx, {
            children: i
        }) : void 0,
        children: [G.jsxs(qt, {
            variant: "h5",
            component: "h2",
            children: [t.status !== Et.Status.Operating && G.jsx("span", {
                style: {
                    display: "inline-block",
                    marginRight: "8px"
                },
                children: G.jsx(SP, {
                    status: t.status,
                    entityName: "ski area"
                })
            }), G.jsx("span", {
                style: {
                    verticalAlign: "middle"
                },
                children: rj(t)
            })]
        }), t.statistics && G.jsx(ij, {
            activities: t.activities,
            statistics: t.statistics,
            runConvention: t.runConvention,
            unitSystem: e.unitSystem
        }), G.jsx(db, {
            sources: t.sources
        }), t.activities.includes(Et.SkiAreaActivity.Downhill) && G.jsx(UB, {
            feature: e.feature
        })]
    })
}
;
function tj(e) {
    const t = e.sources.find(s => s.type === Et.SourceType.SKIMAP_ORG);
    let i = [];
    return t && i.push(G.jsx(Qx, {
        size: "small",
        color: "primary",
        target: "_blank",
        href: "https://skimap.org/SkiAreas/view/" + t.id,
        children: "See Paper Maps"
    }, "paperMaps")),
    i = i.concat(hb(e.websites)),
    i
}
function rj(e) {
    if (e.name)
        return e.name;
    let t;
    const i = e.activities.includes(Et.SkiAreaActivity.Downhill)
      , s = e.activities.includes(Et.SkiAreaActivity.Nordic);
    i && s ? t = "Downhill & Nordic Ski Area" : i ? t = "Downhill Ski Area" : s ? t = "Nordic Ski Area" : t = "Ski Area";
    const u = e.location?.localized.en.locality;
    return u ? t + " near " + u : t
}
function nj(e, t, i) {
    const s = e.minElevation
      , u = e.maxElevation;
    if (!u || !s)
        return null;
    const d = u - s
      , f = ec(s, i) + " - " + ec(u, i);
    return G.jsx(qt, {
        variant: "subtitle1",
        color: "textSecondary",
        children: t.includes(Et.SkiAreaActivity.Downhill) ? "Vertical: " + ec(d, i) + " (" + f + ")" : "Elevation: " + f
    })
}
const ij = e => {
    const t = [Et.SkiAreaActivity.Downhill, Et.SkiAreaActivity.Nordic]
      , i = [Et.RunDifficulty.NOVICE, Et.RunDifficulty.EASY, Et.RunDifficulty.INTERMEDIATE, Et.RunDifficulty.ADVANCED, Et.RunDifficulty.EXPERT, Et.RunDifficulty.FREERIDE, Et.RunDifficulty.EXTREME, null]
      , s = t.flatMap(u => {
        const d = e.statistics.runs.byActivity[u];
        return d !== void 0 ? [[u, i.flatMap(f => {
            const o = d.byDifficulty[f || "other"];
            return o !== void 0 ? [[f, o.lengthInKm]] : []
        }
        )]] : []
    }
    );
    return G.jsxs(G.Fragment, {
        children: [nj(e.statistics, e.activities, e.unitSystem), s.map(u => {
            const d = u[1].reduce( (o, w) => o + w[1], 0);
            return Math.round(d) === 0 ? null : G.jsxs("div", {
                children: [G.jsxs(qt, {
                    variant: "subtitle1",
                    color: "textSecondary",
                    children: [BB(u[0]), " runs: ", Jp({
                        distanceInMeters: d * 1e3,
                        unitSystem: e.unitSystem,
                        forceLongestUnit: !0,
                        roundToNearestDecimal: !0
                    })]
                }), G.jsx(aj, {
                    activity: u[0],
                    totalRunKm: d,
                    runConvention: e.runConvention,
                    data: u[1],
                    unitSystem: e.unitSystem
                })]
            }, u[0])
        }
        ), oj(e.statistics.lifts)]
    })
}
;
function oj(e) {
    const t = new Map([[Et.LiftType.Funicular, {
        count: 0
    }], [Et.LiftType.CableCar, {
        count: 0
    }], [Et.LiftType.Gondola, {
        count: 0
    }], [Et.LiftType.MixedLift, {
        count: 0
    }], [Et.LiftType.ChairLift, {
        count: 0
    }], ["surface", {
        count: 0
    }]])
      , i = e.byType;
    Object.keys(i).forEach(u => {
        const d = i[u].count;
        switch (u) {
        case Et.LiftType.CableCar:
        case Et.LiftType.Funicular:
        case Et.LiftType.CableCar:
        case Et.LiftType.Gondola:
        case Et.LiftType.MixedLift:
        case Et.LiftType.ChairLift:
            t.get(u).count += d;
            break;
        case Et.LiftType.DragLift:
        case Et.LiftType.JBar:
        case Et.LiftType.MagicCarpet:
        case Et.LiftType.Platter:
        case Et.LiftType.RopeTow:
        case Et.LiftType.TBar:
            t.get("surface").count += d;
            break
        }
    }
    );
    const s = [...t.entries()].flatMap(u => {
        const d = u[0]
          , f = u[1];
        return f.count === 0 ? [] : [f.count + " " + sj(d) + (f.count === 1 ? "" : "s")]
    }
    );
    return s.length === 0 ? null : G.jsxs(qt, {
        variant: "subtitle1",
        color: "textSecondary",
        children: ["Lifts: ", s.join(", ")]
    })
}
function sj(e) {
    switch (e) {
    case "surface":
        return "Surface Lift";
    default:
        return Et.getFormattedLiftType(e)
    }
}
const aj = e => {
    const t = e.data.map(i => {
        const s = i[1]
          , u = s / e.totalRunKm * 100
          , d = i[0]
          , f = d ? vP(d) : "Other"
          , o = Jp({
            distanceInMeters: s * 1e3,
            unitSystem: e.unitSystem,
            forceLongestUnit: !0,
            roundToNearestDecimal: !0
        });
        return G.jsx(tb, {
            enterTouchDelay: 0,
            title: f + " (" + o + ")",
            placement: "bottom",
            slotProps: {
                popper: {
                    modifiers: [{
                        name: "offset",
                        options: {
                            offset: [0, -8]
                        }
                    }]
                }
            },
            children: G.jsx("span", {
                style: {
                    width: u + "%",
                    backgroundColor: Et.getRunColor(e.runConvention, d)
                }
            })
        }, d || "other")
    }
    );
    return G.jsx("div", {
        style: {
            display: "flex",
            height: "10px",
            marginBottom: "12px"
        },
        children: t
    })
}
  , lj = Jt(lf)( ({theme: e}) => ({
    "& .MuiChip-label": {
        paddingLeft: e.spacing(1),
        paddingRight: e.spacing(1),
        color: "white",
        fontSize: "1.25rem"
    },
    minWidth: "32px",
    flexShrink: 0
}))
  , TP = e => G.jsx(lj, {
    label: e.text,
    style: {
        backgroundColor: e.color
    }
});
function px(e) {
    const t = Math.round(Math.abs(e * 100)) + "%";
    return Math.round(Math.abs(Math.atan(e) / Math.PI * 180)) + "°" + " (" + t + ")"
}
const cj = e => {
    const t = e.feature.properties
      , i = Pe.useMemo( () => Et.getLiftElevationData(e.feature), [e.feature])
      , s = hb(t.websites);
    return G.jsxs(Mv, {
        width: e.width,
        header: G.jsx(Pv, {
            onClose: e.eventBus.hideInfo,
            breadcrumbs: {
                eventBus: e.eventBus,
                feature: e.feature
            }
        }),
        footer: s.length > 0 ? G.jsx(Jx, {
            children: s
        }) : void 0,
        children: [G.jsxs(qt, {
            gutterBottom: !0,
            variant: "h5",
            component: "h2",
            children: [t.ref && G.jsx("span", {
                style: {
                    display: "inline-block",
                    marginRight: "8px"
                },
                children: G.jsx(TP, {
                    text: t.ref,
                    color: Et.getLiftColor(t.status)
                })
            }), t.status && t.status !== Et.Status.Operating && G.jsx("span", {
                style: {
                    display: "inline-block",
                    marginRight: "8px"
                },
                children: G.jsx(SP, {
                    status: t.status,
                    entityName: "lift"
                })
            }), G.jsx("span", {
                style: {
                    verticalAlign: "middle"
                },
                children: Et.getLiftNameAndType(t)
            })]
        }), G.jsxs(qt, {
            className: "distance-and-elevation-info",
            children: [i && G.jsxs("span", {
                children: ["Distance:", " ", Jp({
                    distanceInMeters: i.inclinedLengthInMeters,
                    unitSystem: e.unitSystem
                })]
            }), i && G.jsxs("span", {
                children: ["Vertical:", " ", ec(i.verticalInMeters, e.unitSystem), " ", "(", ec(i.minElevationInMeters, e.unitSystem), " ", "-", " ", ec(i.maxElevationInMeters, e.unitSystem), ")"]
            })]
        }), G.jsxs(qt, {
            className: "distance-and-elevation-info",
            children: [i && i.speedInMetersPerSecond && G.jsxs("span", {
                children: ["Speed:", " ", vB(i.speedInMetersPerSecond, e.unitSystem)]
            }), t.duration && G.jsxs("span", {
                children: ["Ride time: ", Math.round(t.duration / 60), " min"]
            })]
        }), G.jsxs(qt, {
            className: "distance-and-elevation-info",
            children: [i && i.verticalSpeedInMetersPerSecond && G.jsxs("span", {
                children: ["Vertical speed:", " ", xB(i.verticalSpeedInMetersPerSecond, e.unitSystem)]
            }), G.jsx(qt, {
                className: "distance-and-elevation-info",
                children: i && i.overallPitchInPercent && G.jsxs("span", {
                    children: ["Slope (average):", " ", px(i.overallPitchInPercent)]
                })
            })]
        }), t.description && G.jsx(qt, {
            children: G.jsxs("span", {
                children: ["Notes: ", t.description]
            })
        }), G.jsx(db, {
            sources: t.sources
        })]
    })
}
;
var lg = {}, MS;
function uj() {
    if (MS)
        return lg;
    MS = 1;
    var e = Io();
    Object.defineProperty(lg, "__esModule", {
        value: !0
    }),
    lg.default = void 0;
    var t = e(ls())
      , i = Uo();
    return lg.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "m12 4-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"
    }), "ArrowForward"),
    lg
}
var hj = uj();
const dj = Ni(hj);
var cg = {}, kS;
function fj() {
    if (kS)
        return cg;
    kS = 1;
    var e = Io();
    Object.defineProperty(cg, "__esModule", {
        value: !0
    }),
    cg.default = void 0;
    var t = e(ls())
      , i = Uo();
    return cg.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "m6 14 3 3v5h6v-5l3-3V9H6zm5-12h2v3h-2zM3.5 5.88l1.41-1.41 2.12 2.12L5.62 8zm13.46.71 2.12-2.12 1.41 1.41L18.38 8z"
    }), "Highlight"),
    cg
}
var pj = fj();
const mj = Ni(pj);
var ug = {}, ES;
function gj() {
    if (ES)
        return ug;
    ES = 1;
    var e = Io();
    Object.defineProperty(ug, "__esModule", {
        value: !0
    }),
    ug.default = void 0;
    var t = e(ls())
      , i = Uo();
    return ug.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "M19 3H5c-1.1 0-1.99.9-1.99 2L3 19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-1 11h-4v4h-4v-4H6v-4h4V6h4v4h4z"
    }), "LocalHospital"),
    ug
}
var yj = gj();
const _j = Ni(yj);
var hg = {}, IS;
function vj() {
    if (IS)
        return hg;
    IS = 1;
    var e = Io();
    Object.defineProperty(hg, "__esModule", {
        value: !0
    }),
    hg.default = void 0;
    var t = e(ls())
      , i = Uo();
    return hg.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "M1 21h22L12 2zm12-3h-2v-2h2zm0-4h-2v-4h2z"
    }), "Warning"),
    hg
}
var xj = vj();
const bj = Ni(xj)
  , wj = "modulepreload"
  , Sj = function(e) {
    return "/" + e
}
  , RS = {}
  , Cj = function(t, i, s) {
    let u = Promise.resolve();
    if (i && i.length > 0) {
        let T = function(k) {
            return Promise.all(k.map(L => Promise.resolve(L).then(z => ({
                status: "fulfilled",
                value: z
            }), z => ({
                status: "rejected",
                reason: z
            }))))
        };
        var f = T;
        document.getElementsByTagName("link");
        const o = document.querySelector("meta[property=csp-nonce]")
          , w = o?.nonce || o?.getAttribute("nonce");
        u = T(i.map(k => {
            if (k = Sj(k),
            k in RS)
                return;
            RS[k] = !0;
            const L = k.endsWith(".css")
              , z = L ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${k}"]${z}`))
                return;
            const D = document.createElement("link");
            if (D.rel = L ? "stylesheet" : wj,
            L || (D.as = "script"),
            D.crossOrigin = "",
            D.href = k,
            w && D.setAttribute("nonce", w),
            document.head.appendChild(D),
            L)
                return new Promise( (N, U) => {
                    D.addEventListener("load", N),
                    D.addEventListener("error", () => U(new Error(`Unable to preload CSS for ${k}`)))
                }
                )
        }
        ))
    }
    function d(o) {
        const w = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (w.payload = o,
        window.dispatchEvent(w),
        !w.defaultPrevented)
            throw o
    }
    return u.then(o => {
        for (const w of o || [])
            w.status === "rejected" && d(w.reason);
        return t().catch(d)
    }
    )
};
function J_(e, t, i={}) {
    if (i.final === !0)
        return Tj(e, t);
    const s = Kg(e)
      , u = Kg(t)
      , d = Jl(s[0])
      , f = Jl(u[0])
      , o = Jl(s[1])
      , w = Jl(u[1])
      , T = Math.sin(f - d) * Math.cos(w)
      , k = Math.cos(o) * Math.sin(w) - Math.sin(o) * Math.cos(w) * Math.cos(f - d);
    return ux(Math.atan2(T, k))
}
function Tj(e, t) {
    let i = J_(t, e);
    return i = (i + 180) % 360,
    i
}
function ev(e, t, i, s={}) {
    const u = Kg(e)
      , d = Jl(u[0])
      , f = Jl(u[1])
      , o = Jl(i)
      , w = L5(t, s.units)
      , T = Math.asin(Math.sin(f) * Math.cos(w) + Math.cos(f) * Math.sin(w) * Math.cos(o))
      , k = d + Math.atan2(Math.sin(o) * Math.sin(w) * Math.cos(f), Math.cos(w) - Math.sin(f) * Math.sin(T))
      , L = ux(k)
      , z = ux(T);
    return Ap([L, z], s.properties)
}
function Pj(e, t, i, s) {
    if (s = s || {},
    !O5(s))
        throw new Error("options is invalid");
    var u, d = [];
    if (e.type === "Feature")
        u = e.geometry.coordinates;
    else if (e.type === "LineString")
        u = e.coordinates;
    else
        throw new Error("input must be a LineString Feature or Geometry");
    for (var f = u.length, o = 0, w, T, k, L = 0; L < u.length && !(t >= o && L === u.length - 1); L++) {
        if (o > t && d.length === 0) {
            if (w = t - o,
            !w)
                return d.push(u[L]),
                cf(d);
            T = J_(u[L], u[L - 1]) - 180,
            k = ev(u[L], w, T, s),
            d.push(k.geometry.coordinates)
        }
        if (o >= i)
            return w = i - o,
            w ? (T = J_(u[L], u[L - 1]) - 180,
            k = ev(u[L], w, T, s),
            d.push(k.geometry.coordinates),
            cf(d)) : (d.push(u[L]),
            cf(d));
        if (o >= t && d.push(u[L]),
        L === u.length - 1)
            return cf(d);
        o += uf(u[L], u[L + 1], s)
    }
    if (o < t && u.length === f)
        throw new Error("Start position is beyond line");
    var z = u[u.length - 1];
    return cf([z, z])
}
var Mj = Pj;
class PP {
    constructor(t=[], i=kj) {
        if (this.data = t,
        this.length = this.data.length,
        this.compare = i,
        this.length > 0)
            for (let s = (this.length >> 1) - 1; s >= 0; s--)
                this._down(s)
    }
    push(t) {
        this.data.push(t),
        this.length++,
        this._up(this.length - 1)
    }
    pop() {
        if (this.length === 0)
            return;
        const t = this.data[0]
          , i = this.data.pop();
        return this.length--,
        this.length > 0 && (this.data[0] = i,
        this._down(0)),
        t
    }
    peek() {
        return this.data[0]
    }
    _up(t) {
        const {data: i, compare: s} = this
          , u = i[t];
        for (; t > 0; ) {
            const d = t - 1 >> 1
              , f = i[d];
            if (s(u, f) >= 0)
                break;
            i[t] = f,
            t = d
        }
        i[t] = u
    }
    _down(t) {
        const {data: i, compare: s} = this
          , u = this.length >> 1
          , d = i[t];
        for (; t < u; ) {
            let f = (t << 1) + 1
              , o = i[f];
            const w = f + 1;
            if (w < this.length && s(i[w], o) < 0 && (f = w,
            o = i[w]),
            s(o, d) >= 0)
                break;
            i[t] = o,
            t = f
        }
        i[t] = d
    }
}
function kj(e, t) {
    return e < t ? -1 : e > t ? 1 : 0
}
function MP(e, t) {
    return e.p.x > t.p.x ? 1 : e.p.x < t.p.x ? -1 : e.p.y !== t.p.y ? e.p.y > t.p.y ? 1 : -1 : 1
}
function Ej(e, t) {
    return e.rightSweepEvent.p.x > t.rightSweepEvent.p.x ? 1 : e.rightSweepEvent.p.x < t.rightSweepEvent.p.x ? -1 : e.rightSweepEvent.p.y !== t.rightSweepEvent.p.y ? e.rightSweepEvent.p.y < t.rightSweepEvent.p.y ? 1 : -1 : 1
}
let AS = class {
    constructor(t, i, s, u) {
        this.p = {
            x: t[0],
            y: t[1]
        },
        this.featureId = i,
        this.ringId = s,
        this.eventId = u,
        this.otherEvent = null,
        this.isLeftEndpoint = null
    }
    isSamePoint(t) {
        return this.p.x === t.p.x && this.p.y === t.p.y
    }
}
;
function Ij(e, t) {
    if (e.type === "FeatureCollection") {
        const i = e.features;
        for (let s = 0; s < i.length; s++)
            zS(i[s], t)
    } else
        zS(e, t)
}
let f_ = 0
  , p_ = 0
  , m_ = 0;
function zS(e, t) {
    const i = e.type === "Feature" ? e.geometry : e;
    let s = i.coordinates;
    (i.type === "Polygon" || i.type === "MultiLineString") && (s = [s]),
    i.type === "LineString" && (s = [[s]]);
    for (let u = 0; u < s.length; u++)
        for (let d = 0; d < s[u].length; d++) {
            let f = s[u][d][0]
              , o = null;
            p_ = p_ + 1;
            for (let w = 0; w < s[u][d].length - 1; w++) {
                o = s[u][d][w + 1];
                const T = new AS(f,f_,p_,m_)
                  , k = new AS(o,f_,p_,m_ + 1);
                T.otherEvent = k,
                k.otherEvent = T,
                MP(T, k) > 0 ? (k.isLeftEndpoint = !0,
                T.isLeftEndpoint = !1) : (T.isLeftEndpoint = !0,
                k.isLeftEndpoint = !1),
                t.push(T),
                t.push(k),
                f = o,
                m_ = m_ + 1
            }
        }
    f_ = f_ + 1
}
class Rj {
    constructor(t) {
        this.leftSweepEvent = t,
        this.rightSweepEvent = t.otherEvent
    }
}
function Aj(e, t) {
    if (e === null || t === null || e.leftSweepEvent.ringId === t.leftSweepEvent.ringId && (e.rightSweepEvent.isSamePoint(t.leftSweepEvent) || e.rightSweepEvent.isSamePoint(t.leftSweepEvent) || e.rightSweepEvent.isSamePoint(t.rightSweepEvent) || e.leftSweepEvent.isSamePoint(t.leftSweepEvent) || e.leftSweepEvent.isSamePoint(t.rightSweepEvent)))
        return !1;
    const i = e.leftSweepEvent.p.x
      , s = e.leftSweepEvent.p.y
      , u = e.rightSweepEvent.p.x
      , d = e.rightSweepEvent.p.y
      , f = t.leftSweepEvent.p.x
      , o = t.leftSweepEvent.p.y
      , w = t.rightSweepEvent.p.x
      , T = t.rightSweepEvent.p.y
      , k = (T - o) * (u - i) - (w - f) * (d - s)
      , L = (w - f) * (s - o) - (T - o) * (i - f)
      , z = (u - i) * (s - o) - (d - s) * (i - f);
    if (k === 0)
        return !1;
    const D = L / k
      , N = z / k;
    if (D >= 0 && D <= 1 && N >= 0 && N <= 1) {
        const U = i + D * (u - i)
          , V = s + D * (d - s);
        return [U, V]
    }
    return !1
}
function zj(e, t) {
    t = t || !1;
    const i = []
      , s = new PP([],Ej);
    for (; e.length; ) {
        const u = e.pop();
        if (u.isLeftEndpoint) {
            const d = new Rj(u);
            for (let f = 0; f < s.data.length; f++) {
                const o = s.data[f];
                if (t && o.leftSweepEvent.featureId === u.featureId)
                    continue;
                const w = Aj(d, o);
                w !== !1 && i.push(w)
            }
            s.push(d)
        } else
            u.isLeftEndpoint === !1 && s.pop()
    }
    return i
}
function Dj(e, t) {
    const i = new PP([],MP);
    return Ij(e, i),
    zj(i, t)
}
var Lj = Dj;
function Oj(e, t, i={}) {
    const {removeDuplicates: s=!0, ignoreSelfIntersections: u=!1} = i;
    let d = [];
    e.type === "FeatureCollection" ? d = d.concat(e.features) : e.type === "Feature" ? d.push(e) : (e.type === "LineString" || e.type === "Polygon" || e.type === "MultiLineString" || e.type === "MultiPolygon") && d.push(Up(e)),
    t.type === "FeatureCollection" ? d = d.concat(t.features) : t.type === "Feature" ? d.push(t) : (t.type === "LineString" || t.type === "Polygon" || t.type === "MultiLineString" || t.type === "MultiPolygon") && d.push(Up(t));
    const f = Lj(Uw(d), u);
    let o = [];
    if (s) {
        const w = {};
        f.forEach(T => {
            const k = T.join(",");
            w[k] || (w[k] = !0,
            o.push(T))
        }
        )
    } else
        o = f;
    return Uw(o.map(w => Ap(w)))
}
function Fj(e, t) {
    var i, s, u, d, f, o, w, T, k, L, z = 0, D = e.type === "FeatureCollection", N = e.type === "Feature", U = D ? e.features.length : 1;
    for (i = 0; i < U; i++) {
        for (o = D ? e.features[i].geometry : N ? e.geometry : e,
        T = D ? e.features[i].properties : N ? e.properties : {},
        k = D ? e.features[i].bbox : N ? e.bbox : void 0,
        L = D ? e.features[i].id : N ? e.id : void 0,
        w = o ? o.type === "GeometryCollection" : !1,
        f = w ? o.geometries.length : 1,
        u = 0; u < f; u++) {
            if (d = w ? o.geometries[u] : o,
            d === null) {
                if (t(null, z, T, k, L) === !1)
                    return !1;
                continue
            }
            switch (d.type) {
            case "Point":
            case "LineString":
            case "MultiPoint":
            case "Polygon":
            case "MultiLineString":
            case "MultiPolygon":
                {
                    if (t(d, z, T, k, L) === !1)
                        return !1;
                    break
                }
            case "GeometryCollection":
                {
                    for (s = 0; s < d.geometries.length; s++)
                        if (t(d.geometries[s], z, T, k, L) === !1)
                            return !1;
                    break
                }
            default:
                throw new Error("Unknown Geometry Type")
            }
        }
        z++
    }
}
function Bj(e, t) {
    Fj(e, function(i, s, u, d, f) {
        var o = i === null ? null : i.type;
        switch (o) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
            return t(Up(i, u, {
                bbox: d,
                id: f
            }), s, 0) === !1 ? !1 : void 0
        }
        var w;
        switch (o) {
        case "MultiPoint":
            w = "Point";
            break;
        case "MultiLineString":
            w = "LineString";
            break;
        case "MultiPolygon":
            w = "Polygon";
            break
        }
        for (var T = 0; T < i.coordinates.length; T++) {
            var k = i.coordinates[T]
              , L = {
                type: w,
                coordinates: k
            };
            if (t(Up(L, u), s, T) === !1)
                return !1
        }
    })
}
var jj = Object.defineProperty
  , Nj = Object.defineProperties
  , $j = Object.getOwnPropertyDescriptors
  , DS = Object.getOwnPropertySymbols
  , Vj = Object.prototype.hasOwnProperty
  , Uj = Object.prototype.propertyIsEnumerable
  , LS = (e, t, i) => t in e ? jj(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: i
}) : e[t] = i
  , Kd = (e, t) => {
    for (var i in t || (t = {}))
        Vj.call(t, i) && LS(e, i, t[i]);
    if (DS)
        for (var i of DS(t))
            Uj.call(t, i) && LS(e, i, t[i]);
    return e
}
  , Qd = (e, t) => Nj(e, $j(t));
function Gj(e, t, i={}) {
    if (!e || !t)
        throw new Error("lines and pt are required arguments");
    let s = Ap([1 / 0, 1 / 0], {
        dist: 1 / 0,
        index: -1,
        multiFeatureIndex: -1,
        location: -1
    })
      , u = 0;
    return Bj(e, function(d, f, o) {
        const w = F5(d);
        for (let T = 0; T < w.length - 1; T++) {
            const k = Ap(w[T]);
            k.properties.dist = uf(t, k, i);
            const L = Ap(w[T + 1]);
            L.properties.dist = uf(t, L, i);
            const z = uf(k, L, i)
              , D = Math.max(k.properties.dist, L.properties.dist)
              , N = J_(k, L)
              , U = ev(t, D, N + 90, i)
              , V = ev(t, D, N - 90, i)
              , re = Oj(cf([U.geometry.coordinates, V.geometry.coordinates]), cf([k.geometry.coordinates, L.geometry.coordinates]));
            let ie;
            re.features.length > 0 && re.features[0] && (ie = Qd(Kd({}, re.features[0]), {
                properties: {
                    dist: uf(t, re.features[0], i),
                    multiFeatureIndex: o,
                    location: u + uf(k, re.features[0], i)
                }
            })),
            k.properties.dist < s.properties.dist && (s = Qd(Kd({}, k), {
                properties: Qd(Kd({}, k.properties), {
                    index: T,
                    multiFeatureIndex: o,
                    location: u
                })
            })),
            L.properties.dist < s.properties.dist && (s = Qd(Kd({}, L), {
                properties: Qd(Kd({}, L.properties), {
                    index: T + 1,
                    multiFeatureIndex: o,
                    location: u + z
                })
            })),
            ie && ie.properties.dist < s.properties.dist && (s = Qd(Kd({}, ie), {
                properties: Qd(Kd({}, ie.properties), {
                    index: T
                })
            })),
            u += z
        }
    }),
    s
}
var Wj = Gj;
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
function yy(e) {
    return e + .5 | 0
}
const Zh = (e, t, i) => Math.max(Math.min(e, i), t);
function Eg(e) {
    return Zh(yy(e * 2.55), 0, 255)
}
function Xh(e) {
    return Zh(yy(e * 255), 0, 255)
}
function rh(e) {
    return Zh(yy(e / 2.55) / 100, 0, 1)
}
function OS(e) {
    return Zh(yy(e * 100), 0, 100)
}
const ll = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
}
  , mx = [..."0123456789ABCDEF"]
  , qj = e => mx[e & 15]
  , Hj = e => mx[(e & 240) >> 4] + mx[e & 15]
  , g_ = e => (e & 240) >> 4 === (e & 15)
  , Zj = e => g_(e.r) && g_(e.g) && g_(e.b) && g_(e.a);
function Xj(e) {
    var t = e.length, i;
    return e[0] === "#" && (t === 4 || t === 5 ? i = {
        r: 255 & ll[e[1]] * 17,
        g: 255 & ll[e[2]] * 17,
        b: 255 & ll[e[3]] * 17,
        a: t === 5 ? ll[e[4]] * 17 : 255
    } : (t === 7 || t === 9) && (i = {
        r: ll[e[1]] << 4 | ll[e[2]],
        g: ll[e[3]] << 4 | ll[e[4]],
        b: ll[e[5]] << 4 | ll[e[6]],
        a: t === 9 ? ll[e[7]] << 4 | ll[e[8]] : 255
    })),
    i
}
const Yj = (e, t) => e < 255 ? t(e) : "";
function Kj(e) {
    var t = Zj(e) ? qj : Hj;
    return e ? "#" + t(e.r) + t(e.g) + t(e.b) + Yj(e.a, t) : void 0
}
const Qj = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function kP(e, t, i) {
    const s = t * Math.min(i, 1 - i)
      , u = (d, f=(d + e / 30) % 12) => i - s * Math.max(Math.min(f - 3, 9 - f, 1), -1);
    return [u(0), u(8), u(4)]
}
function Jj(e, t, i) {
    const s = (u, d=(u + e / 60) % 6) => i - i * t * Math.max(Math.min(d, 4 - d, 1), 0);
    return [s(5), s(3), s(1)]
}
function e4(e, t, i) {
    const s = kP(e, 1, .5);
    let u;
    for (t + i > 1 && (u = 1 / (t + i),
    t *= u,
    i *= u),
    u = 0; u < 3; u++)
        s[u] *= 1 - t - i,
        s[u] += t;
    return s
}
function t4(e, t, i, s, u) {
    return e === u ? (t - i) / s + (t < i ? 6 : 0) : t === u ? (i - e) / s + 2 : (e - t) / s + 4
}
function fb(e) {
    const i = e.r / 255
      , s = e.g / 255
      , u = e.b / 255
      , d = Math.max(i, s, u)
      , f = Math.min(i, s, u)
      , o = (d + f) / 2;
    let w, T, k;
    return d !== f && (k = d - f,
    T = o > .5 ? k / (2 - d - f) : k / (d + f),
    w = t4(i, s, u, k, d),
    w = w * 60 + .5),
    [w | 0, T || 0, o]
}
function pb(e, t, i, s) {
    return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, i, s)).map(Xh)
}
function mb(e, t, i) {
    return pb(kP, e, t, i)
}
function r4(e, t, i) {
    return pb(e4, e, t, i)
}
function n4(e, t, i) {
    return pb(Jj, e, t, i)
}
function EP(e) {
    return (e % 360 + 360) % 360
}
function i4(e) {
    const t = Qj.exec(e);
    let i = 255, s;
    if (!t)
        return;
    t[5] !== s && (i = t[6] ? Eg(+t[5]) : Xh(+t[5]));
    const u = EP(+t[2])
      , d = +t[3] / 100
      , f = +t[4] / 100;
    return t[1] === "hwb" ? s = r4(u, d, f) : t[1] === "hsv" ? s = n4(u, d, f) : s = mb(u, d, f),
    {
        r: s[0],
        g: s[1],
        b: s[2],
        a: i
    }
}
function o4(e, t) {
    var i = fb(e);
    i[0] = EP(i[0] + t),
    i = mb(i),
    e.r = i[0],
    e.g = i[1],
    e.b = i[2]
}
function s4(e) {
    if (!e)
        return;
    const t = fb(e)
      , i = t[0]
      , s = OS(t[1])
      , u = OS(t[2]);
    return e.a < 255 ? `hsla(${i}, ${s}%, ${u}%, ${rh(e.a)})` : `hsl(${i}, ${s}%, ${u}%)`
}
const FS = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
}
  , BS = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
};
function a4() {
    const e = {}
      , t = Object.keys(BS)
      , i = Object.keys(FS);
    let s, u, d, f, o;
    for (s = 0; s < t.length; s++) {
        for (f = o = t[s],
        u = 0; u < i.length; u++)
            d = i[u],
            o = o.replace(d, FS[d]);
        d = parseInt(BS[f], 16),
        e[o] = [d >> 16 & 255, d >> 8 & 255, d & 255]
    }
    return e
}
let y_;
function l4(e) {
    y_ || (y_ = a4(),
    y_.transparent = [0, 0, 0, 0]);
    const t = y_[e.toLowerCase()];
    return t && {
        r: t[0],
        g: t[1],
        b: t[2],
        a: t.length === 4 ? t[3] : 255
    }
}
const c4 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function u4(e) {
    const t = c4.exec(e);
    let i = 255, s, u, d;
    if (t) {
        if (t[7] !== s) {
            const f = +t[7];
            i = t[8] ? Eg(f) : Zh(f * 255, 0, 255)
        }
        return s = +t[1],
        u = +t[3],
        d = +t[5],
        s = 255 & (t[2] ? Eg(s) : Zh(s, 0, 255)),
        u = 255 & (t[4] ? Eg(u) : Zh(u, 0, 255)),
        d = 255 & (t[6] ? Eg(d) : Zh(d, 0, 255)),
        {
            r: s,
            g: u,
            b: d,
            a: i
        }
    }
}
function h4(e) {
    return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${rh(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`)
}
const D0 = e => e <= .0031308 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - .055
  , bp = e => e <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);
function d4(e, t, i) {
    const s = bp(rh(e.r))
      , u = bp(rh(e.g))
      , d = bp(rh(e.b));
    return {
        r: Xh(D0(s + i * (bp(rh(t.r)) - s))),
        g: Xh(D0(u + i * (bp(rh(t.g)) - u))),
        b: Xh(D0(d + i * (bp(rh(t.b)) - d))),
        a: e.a + i * (t.a - e.a)
    }
}
function __(e, t, i) {
    if (e) {
        let s = fb(e);
        s[t] = Math.max(0, Math.min(s[t] + s[t] * i, t === 0 ? 360 : 1)),
        s = mb(s),
        e.r = s[0],
        e.g = s[1],
        e.b = s[2]
    }
}
function IP(e, t) {
    return e && Object.assign(t || {}, e)
}
function jS(e) {
    var t = {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    return Array.isArray(e) ? e.length >= 3 && (t = {
        r: e[0],
        g: e[1],
        b: e[2],
        a: 255
    },
    e.length > 3 && (t.a = Xh(e[3]))) : (t = IP(e, {
        r: 0,
        g: 0,
        b: 0,
        a: 1
    }),
    t.a = Xh(t.a)),
    t
}
function f4(e) {
    return e.charAt(0) === "r" ? u4(e) : i4(e)
}
class Qg {
    constructor(t) {
        if (t instanceof Qg)
            return t;
        const i = typeof t;
        let s;
        i === "object" ? s = jS(t) : i === "string" && (s = Xj(t) || l4(t) || f4(t)),
        this._rgb = s,
        this._valid = !!s
    }
    get valid() {
        return this._valid
    }
    get rgb() {
        var t = IP(this._rgb);
        return t && (t.a = rh(t.a)),
        t
    }
    set rgb(t) {
        this._rgb = jS(t)
    }
    rgbString() {
        return this._valid ? h4(this._rgb) : void 0
    }
    hexString() {
        return this._valid ? Kj(this._rgb) : void 0
    }
    hslString() {
        return this._valid ? s4(this._rgb) : void 0
    }
    mix(t, i) {
        if (t) {
            const s = this.rgb
              , u = t.rgb;
            let d;
            const f = i === d ? .5 : i
              , o = 2 * f - 1
              , w = s.a - u.a
              , T = ((o * w === -1 ? o : (o + w) / (1 + o * w)) + 1) / 2;
            d = 1 - T,
            s.r = 255 & T * s.r + d * u.r + .5,
            s.g = 255 & T * s.g + d * u.g + .5,
            s.b = 255 & T * s.b + d * u.b + .5,
            s.a = f * s.a + (1 - f) * u.a,
            this.rgb = s
        }
        return this
    }
    interpolate(t, i) {
        return t && (this._rgb = d4(this._rgb, t._rgb, i)),
        this
    }
    clone() {
        return new Qg(this.rgb)
    }
    alpha(t) {
        return this._rgb.a = Xh(t),
        this
    }
    clearer(t) {
        const i = this._rgb;
        return i.a *= 1 - t,
        this
    }
    greyscale() {
        const t = this._rgb
          , i = yy(t.r * .3 + t.g * .59 + t.b * .11);
        return t.r = t.g = t.b = i,
        this
    }
    opaquer(t) {
        const i = this._rgb;
        return i.a *= 1 + t,
        this
    }
    negate() {
        const t = this._rgb;
        return t.r = 255 - t.r,
        t.g = 255 - t.g,
        t.b = 255 - t.b,
        this
    }
    lighten(t) {
        return __(this._rgb, 2, t),
        this
    }
    darken(t) {
        return __(this._rgb, 2, -t),
        this
    }
    saturate(t) {
        return __(this._rgb, 1, t),
        this
    }
    desaturate(t) {
        return __(this._rgb, 1, -t),
        this
    }
    rotate(t) {
        return o4(this._rgb, t),
        this
    }
}
/*!
 * Chart.js v4.4.6
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
const p4 = ( () => {
    let e = 0;
    return () => e++
}
)();
function li(e) {
    return e === null || typeof e > "u"
}
function Vo(e) {
    if (Array.isArray && Array.isArray(e))
        return !0;
    const t = Object.prototype.toString.call(e);
    return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]"
}
function Cn(e) {
    return e !== null && Object.prototype.toString.call(e) === "[object Object]"
}
function _s(e) {
    return (typeof e == "number" || e instanceof Number) && isFinite(+e)
}
function Wc(e, t) {
    return _s(e) ? e : t
}
function zn(e, t) {
    return typeof e > "u" ? t : e
}
const m4 = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 : +e / t
  , RP = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function Xi(e, t, i) {
    if (e && typeof e.call == "function")
        return e.apply(i, t)
}
function ys(e, t, i, s) {
    let u, d, f;
    if (Vo(e))
        for (d = e.length,
        u = 0; u < d; u++)
            t.call(i, e[u], u);
    else if (Cn(e))
        for (f = Object.keys(e),
        d = f.length,
        u = 0; u < d; u++)
            t.call(i, e[f[u]], f[u])
}
function NS(e, t) {
    let i, s, u, d;
    if (!e || !t || e.length !== t.length)
        return !1;
    for (i = 0,
    s = e.length; i < s; ++i)
        if (u = e[i],
        d = t[i],
        u.datasetIndex !== d.datasetIndex || u.index !== d.index)
            return !1;
    return !0
}
function tv(e) {
    if (Vo(e))
        return e.map(tv);
    if (Cn(e)) {
        const t = Object.create(null)
          , i = Object.keys(e)
          , s = i.length;
        let u = 0;
        for (; u < s; ++u)
            t[i[u]] = tv(e[i[u]]);
        return t
    }
    return e
}
function AP(e) {
    return ["__proto__", "prototype", "constructor"].indexOf(e) === -1
}
function g4(e, t, i, s) {
    if (!AP(e))
        return;
    const u = t[e]
      , d = i[e];
    Cn(u) && Cn(d) ? Jg(u, d, s) : t[e] = tv(d)
}
function Jg(e, t, i) {
    const s = Vo(t) ? t : [t]
      , u = s.length;
    if (!Cn(e))
        return e;
    i = i || {};
    const d = i.merger || g4;
    let f;
    for (let o = 0; o < u; ++o) {
        if (f = s[o],
        !Cn(f))
            continue;
        const w = Object.keys(f);
        for (let T = 0, k = w.length; T < k; ++T)
            d(w[T], e, f, i)
    }
    return e
}
function jg(e, t) {
    return Jg(e, t, {
        merger: y4
    })
}
function y4(e, t, i) {
    if (!AP(e))
        return;
    const s = t[e]
      , u = i[e];
    Cn(s) && Cn(u) ? jg(s, u) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = tv(u))
}
const $S = {
    "": e => e,
    x: e => e.x,
    y: e => e.y
};
function _4(e) {
    const t = e.split(".")
      , i = [];
    let s = "";
    for (const u of t)
        s += u,
        s.endsWith("\\") ? s = s.slice(0, -1) + "." : (i.push(s),
        s = "");
    return i
}
function v4(e) {
    const t = _4(e);
    return i => {
        for (const s of t) {
            if (s === "")
                break;
            i = i && i[s]
        }
        return i
    }
}
function Qh(e, t) {
    return ($S[t] || ($S[t] = v4(t)))(e)
}
function gb(e) {
    return e.charAt(0).toUpperCase() + e.slice(1)
}
const ey = e => typeof e < "u"
  , Jh = e => typeof e == "function"
  , VS = (e, t) => {
    if (e.size !== t.size)
        return !1;
    for (const i of e)
        if (!t.has(i))
            return !1;
    return !0
}
;
function x4(e) {
    return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu"
}
const vs = Math.PI
  , Bs = 2 * vs
  , b4 = Bs + vs
  , rv = Number.POSITIVE_INFINITY
  , w4 = vs / 180
  , Kc = vs / 2
  , Jd = vs / 4
  , US = vs * 2 / 3
  , zP = Math.log10
  , ru = Math.sign;
function Ng(e, t, i) {
    return Math.abs(e - t) < i
}
function GS(e) {
    const t = Math.round(e);
    e = Ng(e, t, e / 1e3) ? t : e;
    const i = Math.pow(10, Math.floor(zP(e)))
      , s = e / i;
    return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * i
}
function S4(e) {
    const t = []
      , i = Math.sqrt(e);
    let s;
    for (s = 1; s < i; s++)
        e % s === 0 && (t.push(s),
        t.push(e / s));
    return i === (i | 0) && t.push(i),
    t.sort( (u, d) => u - d).pop(),
    t
}
function qp(e) {
    return !isNaN(parseFloat(e)) && isFinite(e)
}
function C4(e, t) {
    const i = Math.round(e);
    return i - t <= e && i + t >= e
}
function T4(e, t, i) {
    let s, u, d;
    for (s = 0,
    u = e.length; s < u; s++)
        d = e[s][i],
        isNaN(d) || (t.min = Math.min(t.min, d),
        t.max = Math.max(t.max, d))
}
function Qc(e) {
    return e * (vs / 180)
}
function P4(e) {
    return e * (180 / vs)
}
function WS(e) {
    if (!_s(e))
        return;
    let t = 1
      , i = 0;
    for (; Math.round(e * t) / t !== e; )
        t *= 10,
        i++;
    return i
}
function M4(e, t) {
    const i = t.x - e.x
      , s = t.y - e.y
      , u = Math.sqrt(i * i + s * s);
    let d = Math.atan2(s, i);
    return d < -.5 * vs && (d += Bs),
    {
        angle: d,
        distance: u
    }
}
function qS(e, t) {
    return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
}
function k4(e, t) {
    return (e - t + b4) % Bs - vs
}
function Hc(e) {
    return (e % Bs + Bs) % Bs
}
function nv(e, t, i, s) {
    const u = Hc(e)
      , d = Hc(t)
      , f = Hc(i)
      , o = Hc(d - u)
      , w = Hc(f - u)
      , T = Hc(u - d)
      , k = Hc(u - f);
    return u === d || u === f || s && d === f || o > w && T < k
}
function Jc(e, t, i) {
    return Math.max(t, Math.min(i, e))
}
function E4(e) {
    return Jc(e, -32768, 32767)
}
function DP(e, t, i, s=1e-6) {
    return e >= Math.min(t, i) - s && e <= Math.max(t, i) + s
}
function yb(e, t, i) {
    i = i || (f => e[f] < t);
    let s = e.length - 1, u = 0, d;
    for (; s - u > 1; )
        d = u + s >> 1,
        i(d) ? u = d : s = d;
    return {
        lo: u,
        hi: s
    }
}
const ff = (e, t, i, s) => yb(e, i, s ? u => {
    const d = e[u][t];
    return d < i || d === i && e[u + 1][t] === i
}
: u => e[u][t] < i)
  , I4 = (e, t, i) => yb(e, i, s => e[s][t] >= i);
function R4(e, t, i) {
    let s = 0
      , u = e.length;
    for (; s < u && e[s] < t; )
        s++;
    for (; u > s && e[u - 1] > i; )
        u--;
    return s > 0 || u < e.length ? e.slice(s, u) : e
}
const LP = ["push", "pop", "shift", "splice", "unshift"];
function A4(e, t) {
    if (e._chartjs) {
        e._chartjs.listeners.push(t);
        return
    }
    Object.defineProperty(e, "_chartjs", {
        configurable: !0,
        enumerable: !1,
        value: {
            listeners: [t]
        }
    }),
    LP.forEach(i => {
        const s = "_onData" + gb(i)
          , u = e[i];
        Object.defineProperty(e, i, {
            configurable: !0,
            enumerable: !1,
            value(...d) {
                const f = u.apply(this, d);
                return e._chartjs.listeners.forEach(o => {
                    typeof o[s] == "function" && o[s](...d)
                }
                ),
                f
            }
        })
    }
    )
}
function HS(e, t) {
    const i = e._chartjs;
    if (!i)
        return;
    const s = i.listeners
      , u = s.indexOf(t);
    u !== -1 && s.splice(u, 1),
    !(s.length > 0) && (LP.forEach(d => {
        delete e[d]
    }
    ),
    delete e._chartjs)
}
function OP(e) {
    const t = new Set(e);
    return t.size === e.length ? e : Array.from(t)
}
const FP = function() {
    return typeof window > "u" ? function(e) {
        return e()
    }
    : window.requestAnimationFrame
}();
function BP(e, t) {
    let i = []
      , s = !1;
    return function(...u) {
        i = u,
        s || (s = !0,
        FP.call(window, () => {
            s = !1,
            e.apply(t, i)
        }
        ))
    }
}
function z4(e, t) {
    let i;
    return function(...s) {
        return t ? (clearTimeout(i),
        i = setTimeout(e, t, s)) : e.apply(this, s),
        t
    }
}
const D4 = e => e === "start" ? "left" : e === "end" ? "right" : "center"
  , ZS = (e, t, i) => e === "start" ? t : e === "end" ? i : (t + i) / 2;
function jP(e, t, i) {
    const s = t.length;
    let u = 0
      , d = s;
    if (e._sorted) {
        const {iScale: f, _parsed: o} = e
          , w = f.axis
          , {min: T, max: k, minDefined: L, maxDefined: z} = f.getUserBounds();
        L && (u = Jc(Math.min(ff(o, w, T).lo, i ? s : ff(t, w, f.getPixelForValue(T)).lo), 0, s - 1)),
        z ? d = Jc(Math.max(ff(o, f.axis, k, !0).hi + 1, i ? 0 : ff(t, w, f.getPixelForValue(k), !0).hi + 1), u, s) - u : d = s - u
    }
    return {
        start: u,
        count: d
    }
}
function NP(e) {
    const {xScale: t, yScale: i, _scaleRanges: s} = e
      , u = {
        xmin: t.min,
        xmax: t.max,
        ymin: i.min,
        ymax: i.max
    };
    if (!s)
        return e._scaleRanges = u,
        !0;
    const d = s.xmin !== t.min || s.xmax !== t.max || s.ymin !== i.min || s.ymax !== i.max;
    return Object.assign(s, u),
    d
}
const v_ = e => e === 0 || e === 1
  , XS = (e, t, i) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * Bs / i))
  , YS = (e, t, i) => Math.pow(2, -10 * e) * Math.sin((e - t) * Bs / i) + 1
  , $g = {
    linear: e => e,
    easeInQuad: e => e * e,
    easeOutQuad: e => -e * (e - 2),
    easeInOutQuad: e => (e /= .5) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1),
    easeInCubic: e => e * e * e,
    easeOutCubic: e => (e -= 1) * e * e + 1,
    easeInOutCubic: e => (e /= .5) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2),
    easeInQuart: e => e * e * e * e,
    easeOutQuart: e => -((e -= 1) * e * e * e - 1),
    easeInOutQuart: e => (e /= .5) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2),
    easeInQuint: e => e * e * e * e * e,
    easeOutQuint: e => (e -= 1) * e * e * e * e + 1,
    easeInOutQuint: e => (e /= .5) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2),
    easeInSine: e => -Math.cos(e * Kc) + 1,
    easeOutSine: e => Math.sin(e * Kc),
    easeInOutSine: e => -.5 * (Math.cos(vs * e) - 1),
    easeInExpo: e => e === 0 ? 0 : Math.pow(2, 10 * (e - 1)),
    easeOutExpo: e => e === 1 ? 1 : -Math.pow(2, -10 * e) + 1,
    easeInOutExpo: e => v_(e) ? e : e < .5 ? .5 * Math.pow(2, 10 * (e * 2 - 1)) : .5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
    easeInCirc: e => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
    easeOutCirc: e => Math.sqrt(1 - (e -= 1) * e),
    easeInOutCirc: e => (e /= .5) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
    easeInElastic: e => v_(e) ? e : XS(e, .075, .3),
    easeOutElastic: e => v_(e) ? e : YS(e, .075, .3),
    easeInOutElastic(e) {
        return v_(e) ? e : e < .5 ? .5 * XS(e * 2, .1125, .45) : .5 + .5 * YS(e * 2 - 1, .1125, .45)
    },
    easeInBack(e) {
        return e * e * ((1.70158 + 1) * e - 1.70158)
    },
    easeOutBack(e) {
        return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1
    },
    easeInOutBack(e) {
        let t = 1.70158;
        return (e /= .5) < 1 ? .5 * (e * e * (((t *= 1.525) + 1) * e - t)) : .5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2)
    },
    easeInBounce: e => 1 - $g.easeOutBounce(1 - e),
    easeOutBounce(e) {
        return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
    },
    easeInOutBounce: e => e < .5 ? $g.easeInBounce(e * 2) * .5 : $g.easeOutBounce(e * 2 - 1) * .5 + .5
};
function _b(e) {
    if (e && typeof e == "object") {
        const t = e.toString();
        return t === "[object CanvasPattern]" || t === "[object CanvasGradient]"
    }
    return !1
}
function KS(e) {
    return _b(e) ? e : new Qg(e)
}
function L0(e) {
    return _b(e) ? e : new Qg(e).saturate(.5).darken(.1).hexString()
}
const L4 = ["x", "y", "borderWidth", "radius", "tension"]
  , O4 = ["color", "borderColor", "backgroundColor"];
function F4(e) {
    e.set("animation", {
        delay: void 0,
        duration: 1e3,
        easing: "easeOutQuart",
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0
    }),
    e.describe("animation", {
        _fallback: !1,
        _indexable: !1,
        _scriptable: t => t !== "onProgress" && t !== "onComplete" && t !== "fn"
    }),
    e.set("animations", {
        colors: {
            type: "color",
            properties: O4
        },
        numbers: {
            type: "number",
            properties: L4
        }
    }),
    e.describe("animations", {
        _fallback: "animation"
    }),
    e.set("transitions", {
        active: {
            animation: {
                duration: 400
            }
        },
        resize: {
            animation: {
                duration: 0
            }
        },
        show: {
            animations: {
                colors: {
                    from: "transparent"
                },
                visible: {
                    type: "boolean",
                    duration: 0
                }
            }
        },
        hide: {
            animations: {
                colors: {
                    to: "transparent"
                },
                visible: {
                    type: "boolean",
                    easing: "linear",
                    fn: t => t | 0
                }
            }
        }
    })
}
function B4(e) {
    e.set("layout", {
        autoPadding: !0,
        padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }
    })
}
const QS = new Map;
function j4(e, t) {
    t = t || {};
    const i = e + JSON.stringify(t);
    let s = QS.get(i);
    return s || (s = new Intl.NumberFormat(e,t),
    QS.set(i, s)),
    s
}
function kv(e, t, i) {
    return j4(t, i).format(e)
}
const N4 = {
    values(e) {
        return Vo(e) ? e : "" + e
    },
    numeric(e, t, i) {
        if (e === 0)
            return "0";
        const s = this.chart.options.locale;
        let u, d = e;
        if (i.length > 1) {
            const T = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
            (T < 1e-4 || T > 1e15) && (u = "scientific"),
            d = $4(e, i)
        }
        const f = zP(Math.abs(d))
          , o = isNaN(f) ? 1 : Math.max(Math.min(-1 * Math.floor(f), 20), 0)
          , w = {
            notation: u,
            minimumFractionDigits: o,
            maximumFractionDigits: o
        };
        return Object.assign(w, this.options.ticks.format),
        kv(e, s, w)
    }
};
function $4(e, t) {
    let i = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
    return Math.abs(i) >= 1 && e !== Math.floor(e) && (i = e - Math.floor(e)),
    i
}
var $P = {
    formatters: N4
};
function V4(e) {
    e.set("scale", {
        display: !0,
        offset: !1,
        reverse: !1,
        beginAtZero: !1,
        bounds: "ticks",
        clip: !0,
        grace: 0,
        grid: {
            display: !0,
            lineWidth: 1,
            drawOnChartArea: !0,
            drawTicks: !0,
            tickLength: 8,
            tickWidth: (t, i) => i.lineWidth,
            tickColor: (t, i) => i.color,
            offset: !1
        },
        border: {
            display: !0,
            dash: [],
            dashOffset: 0,
            width: 1
        },
        title: {
            display: !1,
            text: "",
            padding: {
                top: 4,
                bottom: 4
            }
        },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: !1,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: !0,
            autoSkip: !0,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: $P.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: !1,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
        }
    }),
    e.route("scale.ticks", "color", "", "color"),
    e.route("scale.grid", "color", "", "borderColor"),
    e.route("scale.border", "color", "", "borderColor"),
    e.route("scale.title", "color", "", "color"),
    e.describe("scale", {
        _fallback: !1,
        _scriptable: t => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
        _indexable: t => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
    }),
    e.describe("scales", {
        _fallback: "scale"
    }),
    e.describe("scale.ticks", {
        _scriptable: t => t !== "backdropPadding" && t !== "callback",
        _indexable: t => t !== "backdropPadding"
    })
}
const xf = Object.create(null)
  , gx = Object.create(null);
function Vg(e, t) {
    if (!t)
        return e;
    const i = t.split(".");
    for (let s = 0, u = i.length; s < u; ++s) {
        const d = i[s];
        e = e[d] || (e[d] = Object.create(null))
    }
    return e
}
function O0(e, t, i) {
    return typeof t == "string" ? Jg(Vg(e, t), i) : Jg(Vg(e, ""), t)
}
class U4 {
    constructor(t, i) {
        this.animation = void 0,
        this.backgroundColor = "rgba(0,0,0,0.1)",
        this.borderColor = "rgba(0,0,0,0.1)",
        this.color = "#666",
        this.datasets = {},
        this.devicePixelRatio = s => s.chart.platform.getDevicePixelRatio(),
        this.elements = {},
        this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
        this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: "normal",
            lineHeight: 1.2,
            weight: null
        },
        this.hover = {},
        this.hoverBackgroundColor = (s, u) => L0(u.backgroundColor),
        this.hoverBorderColor = (s, u) => L0(u.borderColor),
        this.hoverColor = (s, u) => L0(u.color),
        this.indexAxis = "x",
        this.interaction = {
            mode: "nearest",
            intersect: !0,
            includeInvisible: !1
        },
        this.maintainAspectRatio = !0,
        this.onHover = null,
        this.onClick = null,
        this.parsing = !0,
        this.plugins = {},
        this.responsive = !0,
        this.scale = void 0,
        this.scales = {},
        this.showLine = !0,
        this.drawActiveElementsOnTop = !0,
        this.describe(t),
        this.apply(i)
    }
    set(t, i) {
        return O0(this, t, i)
    }
    get(t) {
        return Vg(this, t)
    }
    describe(t, i) {
        return O0(gx, t, i)
    }
    override(t, i) {
        return O0(xf, t, i)
    }
    route(t, i, s, u) {
        const d = Vg(this, t)
          , f = Vg(this, s)
          , o = "_" + i;
        Object.defineProperties(d, {
            [o]: {
                value: d[i],
                writable: !0
            },
            [i]: {
                enumerable: !0,
                get() {
                    const w = this[o]
                      , T = f[u];
                    return Cn(w) ? Object.assign({}, T, w) : zn(w, T)
                },
                set(w) {
                    this[o] = w
                }
            }
        })
    }
    apply(t) {
        t.forEach(i => i(this))
    }
}
var fo = new U4({
    _scriptable: e => !e.startsWith("on"),
    _indexable: e => e !== "events",
    hover: {
        _fallback: "interaction"
    },
    interaction: {
        _scriptable: !1,
        _indexable: !1
    }
},[F4, B4, V4]);
function G4(e) {
    return !e || li(e.size) || li(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family
}
function JS(e, t, i, s, u) {
    let d = t[u];
    return d || (d = t[u] = e.measureText(u).width,
    i.push(u)),
    d > s && (s = d),
    s
}
function ef(e, t, i) {
    const s = e.currentDevicePixelRatio
      , u = i !== 0 ? Math.max(i / 2, .5) : 0;
    return Math.round((t - u) * s) / s + u
}
function e2(e, t) {
    !t && !e || (t = t || e.getContext("2d"),
    t.save(),
    t.resetTransform(),
    t.clearRect(0, 0, e.width, e.height),
    t.restore())
}
function W4(e, t, i, s) {
    q4(e, t, i, s)
}
function q4(e, t, i, s, u) {
    let d, f, o, w, T, k, L, z;
    const D = t.pointStyle
      , N = t.rotation
      , U = t.radius;
    let V = (N || 0) * w4;
    if (D && typeof D == "object" && (d = D.toString(),
    d === "[object HTMLImageElement]" || d === "[object HTMLCanvasElement]")) {
        e.save(),
        e.translate(i, s),
        e.rotate(V),
        e.drawImage(D, -D.width / 2, -D.height / 2, D.width, D.height),
        e.restore();
        return
    }
    if (!(isNaN(U) || U <= 0)) {
        switch (e.beginPath(),
        D) {
        default:
            e.arc(i, s, U, 0, Bs),
            e.closePath();
            break;
        case "triangle":
            k = U,
            e.moveTo(i + Math.sin(V) * k, s - Math.cos(V) * U),
            V += US,
            e.lineTo(i + Math.sin(V) * k, s - Math.cos(V) * U),
            V += US,
            e.lineTo(i + Math.sin(V) * k, s - Math.cos(V) * U),
            e.closePath();
            break;
        case "rectRounded":
            T = U * .516,
            w = U - T,
            f = Math.cos(V + Jd) * w,
            L = Math.cos(V + Jd) * w,
            o = Math.sin(V + Jd) * w,
            z = Math.sin(V + Jd) * w,
            e.arc(i - L, s - o, T, V - vs, V - Kc),
            e.arc(i + z, s - f, T, V - Kc, V),
            e.arc(i + L, s + o, T, V, V + Kc),
            e.arc(i - z, s + f, T, V + Kc, V + vs),
            e.closePath();
            break;
        case "rect":
            if (!N) {
                w = Math.SQRT1_2 * U,
                k = w,
                e.rect(i - k, s - w, 2 * k, 2 * w);
                break
            }
            V += Jd;
        case "rectRot":
            L = Math.cos(V) * U,
            f = Math.cos(V) * U,
            o = Math.sin(V) * U,
            z = Math.sin(V) * U,
            e.moveTo(i - L, s - o),
            e.lineTo(i + z, s - f),
            e.lineTo(i + L, s + o),
            e.lineTo(i - z, s + f),
            e.closePath();
            break;
        case "crossRot":
            V += Jd;
        case "cross":
            L = Math.cos(V) * U,
            f = Math.cos(V) * U,
            o = Math.sin(V) * U,
            z = Math.sin(V) * U,
            e.moveTo(i - L, s - o),
            e.lineTo(i + L, s + o),
            e.moveTo(i + z, s - f),
            e.lineTo(i - z, s + f);
            break;
        case "star":
            L = Math.cos(V) * U,
            f = Math.cos(V) * U,
            o = Math.sin(V) * U,
            z = Math.sin(V) * U,
            e.moveTo(i - L, s - o),
            e.lineTo(i + L, s + o),
            e.moveTo(i + z, s - f),
            e.lineTo(i - z, s + f),
            V += Jd,
            L = Math.cos(V) * U,
            f = Math.cos(V) * U,
            o = Math.sin(V) * U,
            z = Math.sin(V) * U,
            e.moveTo(i - L, s - o),
            e.lineTo(i + L, s + o),
            e.moveTo(i + z, s - f),
            e.lineTo(i - z, s + f);
            break;
        case "line":
            f = Math.cos(V) * U,
            o = Math.sin(V) * U,
            e.moveTo(i - f, s - o),
            e.lineTo(i + f, s + o);
            break;
        case "dash":
            e.moveTo(i, s),
            e.lineTo(i + Math.cos(V) * U, s + Math.sin(V) * U);
            break;
        case !1:
            e.closePath();
            break
        }
        e.fill(),
        t.borderWidth > 0 && e.stroke()
    }
}
function ty(e, t, i) {
    return i = i || .5,
    !t || e && e.x > t.left - i && e.x < t.right + i && e.y > t.top - i && e.y < t.bottom + i
}
function vb(e, t) {
    e.save(),
    e.beginPath(),
    e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top),
    e.clip()
}
function xb(e) {
    e.restore()
}
function H4(e, t, i, s, u) {
    if (!t)
        return e.lineTo(i.x, i.y);
    if (u === "middle") {
        const d = (t.x + i.x) / 2;
        e.lineTo(d, t.y),
        e.lineTo(d, i.y)
    } else
        u === "after" != !!s ? e.lineTo(t.x, i.y) : e.lineTo(i.x, t.y);
    e.lineTo(i.x, i.y)
}
function Z4(e, t, i, s) {
    if (!t)
        return e.lineTo(i.x, i.y);
    e.bezierCurveTo(s ? t.cp1x : t.cp2x, s ? t.cp1y : t.cp2y, s ? i.cp2x : i.cp1x, s ? i.cp2y : i.cp1y, i.x, i.y)
}
function X4(e, t) {
    t.translation && e.translate(t.translation[0], t.translation[1]),
    li(t.rotation) || e.rotate(t.rotation),
    t.color && (e.fillStyle = t.color),
    t.textAlign && (e.textAlign = t.textAlign),
    t.textBaseline && (e.textBaseline = t.textBaseline)
}
function Y4(e, t, i, s, u) {
    if (u.strikethrough || u.underline) {
        const d = e.measureText(s)
          , f = t - d.actualBoundingBoxLeft
          , o = t + d.actualBoundingBoxRight
          , w = i - d.actualBoundingBoxAscent
          , T = i + d.actualBoundingBoxDescent
          , k = u.strikethrough ? (w + T) / 2 : T;
        e.strokeStyle = e.fillStyle,
        e.beginPath(),
        e.lineWidth = u.decorationWidth || 2,
        e.moveTo(f, k),
        e.lineTo(o, k),
        e.stroke()
    }
}
function K4(e, t) {
    const i = e.fillStyle;
    e.fillStyle = t.color,
    e.fillRect(t.left, t.top, t.width, t.height),
    e.fillStyle = i
}
function t2(e, t, i, s, u, d={}) {
    const f = Vo(t) ? t : [t]
      , o = d.strokeWidth > 0 && d.strokeColor !== "";
    let w, T;
    for (e.save(),
    e.font = u.string,
    X4(e, d),
    w = 0; w < f.length; ++w)
        T = f[w],
        d.backdrop && K4(e, d.backdrop),
        o && (d.strokeColor && (e.strokeStyle = d.strokeColor),
        li(d.strokeWidth) || (e.lineWidth = d.strokeWidth),
        e.strokeText(T, i, s, d.maxWidth)),
        e.fillText(T, i, s, d.maxWidth),
        Y4(e, i, s, T, d),
        s += Number(u.lineHeight);
    e.restore()
}
const Q4 = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/
  , J4 = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function eN(e, t) {
    const i = ("" + e).match(Q4);
    if (!i || i[1] === "normal")
        return t * 1.2;
    switch (e = +i[2],
    i[3]) {
    case "px":
        return e;
    case "%":
        e /= 100;
        break
    }
    return t * e
}
const tN = e => +e || 0;
function rN(e, t) {
    const i = {}
      , s = Cn(t)
      , u = s ? Object.keys(t) : t
      , d = Cn(e) ? s ? f => zn(e[f], e[t[f]]) : f => e[f] : () => e;
    for (const f of u)
        i[f] = tN(d(f));
    return i
}
function nN(e) {
    return rN(e, {
        top: "y",
        right: "x",
        bottom: "y",
        left: "x"
    })
}
function ry(e) {
    const t = nN(e);
    return t.width = t.left + t.right,
    t.height = t.top + t.bottom,
    t
}
function yx(e, t) {
    e = e || {},
    t = t || fo.font;
    let i = zn(e.size, t.size);
    typeof i == "string" && (i = parseInt(i, 10));
    let s = zn(e.style, t.style);
    s && !("" + s).match(J4) && (console.warn('Invalid font style specified: "' + s + '"'),
    s = void 0);
    const u = {
        family: zn(e.family, t.family),
        lineHeight: eN(zn(e.lineHeight, t.lineHeight), i),
        size: i,
        style: s,
        weight: zn(e.weight, t.weight),
        string: ""
    };
    return u.string = G4(u),
    u
}
function x_(e, t, i, s) {
    let u, d, f;
    for (u = 0,
    d = e.length; u < d; ++u)
        if (f = e[u],
        f !== void 0 && f !== void 0)
            return f
}
function iN(e, t, i) {
    const {min: s, max: u} = e
      , d = RP(t, (u - s) / 2)
      , f = (o, w) => i && o === 0 ? 0 : o + w;
    return {
        min: f(s, -Math.abs(d)),
        max: f(u, d)
    }
}
function tm(e, t) {
    return Object.assign(Object.create(e), t)
}
function bb(e, t=[""], i, s, u= () => e[0]) {
    const d = i || e;
    typeof s > "u" && (s = WP("_fallback", e));
    const f = {
        [Symbol.toStringTag]: "Object",
        _cacheable: !0,
        _scopes: e,
        _rootScopes: d,
        _fallback: s,
        _getTarget: u,
        override: o => bb([o, ...e], t, d, s)
    };
    return new Proxy(f,{
        deleteProperty(o, w) {
            return delete o[w],
            delete o._keys,
            delete e[0][w],
            !0
        },
        get(o, w) {
            return UP(o, w, () => dN(w, t, e, o))
        },
        getOwnPropertyDescriptor(o, w) {
            return Reflect.getOwnPropertyDescriptor(o._scopes[0], w)
        },
        getPrototypeOf() {
            return Reflect.getPrototypeOf(e[0])
        },
        has(o, w) {
            return n2(o).includes(w)
        },
        ownKeys(o) {
            return n2(o)
        },
        set(o, w, T) {
            const k = o._storage || (o._storage = u());
            return o[w] = k[w] = T,
            delete o._keys,
            !0
        }
    })
}
function Hp(e, t, i, s) {
    const u = {
        _cacheable: !1,
        _proxy: e,
        _context: t,
        _subProxy: i,
        _stack: new Set,
        _descriptors: VP(e, s),
        setContext: d => Hp(e, d, i, s),
        override: d => Hp(e.override(d), t, i, s)
    };
    return new Proxy(u,{
        deleteProperty(d, f) {
            return delete d[f],
            delete e[f],
            !0
        },
        get(d, f, o) {
            return UP(d, f, () => sN(d, f, o))
        },
        getOwnPropertyDescriptor(d, f) {
            return d._descriptors.allKeys ? Reflect.has(e, f) ? {
                enumerable: !0,
                configurable: !0
            } : void 0 : Reflect.getOwnPropertyDescriptor(e, f)
        },
        getPrototypeOf() {
            return Reflect.getPrototypeOf(e)
        },
        has(d, f) {
            return Reflect.has(e, f)
        },
        ownKeys() {
            return Reflect.ownKeys(e)
        },
        set(d, f, o) {
            return e[f] = o,
            delete d[f],
            !0
        }
    })
}
function VP(e, t={
    scriptable: !0,
    indexable: !0
}) {
    const {_scriptable: i=t.scriptable, _indexable: s=t.indexable, _allKeys: u=t.allKeys} = e;
    return {
        allKeys: u,
        scriptable: i,
        indexable: s,
        isScriptable: Jh(i) ? i : () => i,
        isIndexable: Jh(s) ? s : () => s
    }
}
const oN = (e, t) => e ? e + gb(t) : t
  , wb = (e, t) => Cn(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function UP(e, t, i) {
    if (Object.prototype.hasOwnProperty.call(e, t) || t === "constructor")
        return e[t];
    const s = i();
    return e[t] = s,
    s
}
function sN(e, t, i) {
    const {_proxy: s, _context: u, _subProxy: d, _descriptors: f} = e;
    let o = s[t];
    return Jh(o) && f.isScriptable(t) && (o = aN(t, o, e, i)),
    Vo(o) && o.length && (o = lN(t, o, e, f.isIndexable)),
    wb(t, o) && (o = Hp(o, u, d && d[t], f)),
    o
}
function aN(e, t, i, s) {
    const {_proxy: u, _context: d, _subProxy: f, _stack: o} = i;
    if (o.has(e))
        throw new Error("Recursion detected: " + Array.from(o).join("->") + "->" + e);
    o.add(e);
    let w = t(d, f || s);
    return o.delete(e),
    wb(e, w) && (w = Sb(u._scopes, u, e, w)),
    w
}
function lN(e, t, i, s) {
    const {_proxy: u, _context: d, _subProxy: f, _descriptors: o} = i;
    if (typeof d.index < "u" && s(e))
        return t[d.index % t.length];
    if (Cn(t[0])) {
        const w = t
          , T = u._scopes.filter(k => k !== w);
        t = [];
        for (const k of w) {
            const L = Sb(T, u, e, k);
            t.push(Hp(L, d, f && f[e], o))
        }
    }
    return t
}
function GP(e, t, i) {
    return Jh(e) ? e(t, i) : e
}
const cN = (e, t) => e === !0 ? t : typeof e == "string" ? Qh(t, e) : void 0;
function uN(e, t, i, s, u) {
    for (const d of t) {
        const f = cN(i, d);
        if (f) {
            e.add(f);
            const o = GP(f._fallback, i, u);
            if (typeof o < "u" && o !== i && o !== s)
                return o
        } else if (f === !1 && typeof s < "u" && i !== s)
            return null
    }
    return !1
}
function Sb(e, t, i, s) {
    const u = t._rootScopes
      , d = GP(t._fallback, i, s)
      , f = [...e, ...u]
      , o = new Set;
    o.add(s);
    let w = r2(o, f, i, d || i, s);
    return w === null || typeof d < "u" && d !== i && (w = r2(o, f, d, w, s),
    w === null) ? !1 : bb(Array.from(o), [""], u, d, () => hN(t, i, s))
}
function r2(e, t, i, s, u) {
    for (; i; )
        i = uN(e, t, i, s, u);
    return i
}
function hN(e, t, i) {
    const s = e._getTarget();
    t in s || (s[t] = {});
    const u = s[t];
    return Vo(u) && Cn(i) ? i : u || {}
}
function dN(e, t, i, s) {
    let u;
    for (const d of t)
        if (u = WP(oN(d, e), i),
        typeof u < "u")
            return wb(e, u) ? Sb(i, s, e, u) : u
}
function WP(e, t) {
    for (const i of t) {
        if (!i)
            continue;
        const s = i[e];
        if (typeof s < "u")
            return s
    }
}
function n2(e) {
    let t = e._keys;
    return t || (t = e._keys = fN(e._scopes)),
    t
}
function fN(e) {
    const t = new Set;
    for (const i of e)
        for (const s of Object.keys(i).filter(u => !u.startsWith("_")))
            t.add(s);
    return Array.from(t)
}
function qP(e, t, i, s) {
    const {iScale: u} = e
      , {key: d="r"} = this._parsing
      , f = new Array(s);
    let o, w, T, k;
    for (o = 0,
    w = s; o < w; ++o)
        T = o + i,
        k = t[T],
        f[o] = {
            r: u.parse(Qh(k, d), T)
        };
    return f
}
const pN = Number.EPSILON || 1e-14
  , Zp = (e, t) => t < e.length && !e[t].skip && e[t]
  , HP = e => e === "x" ? "y" : "x";
function mN(e, t, i, s) {
    const u = e.skip ? t : e
      , d = t
      , f = i.skip ? t : i
      , o = qS(d, u)
      , w = qS(f, d);
    let T = o / (o + w)
      , k = w / (o + w);
    T = isNaN(T) ? 0 : T,
    k = isNaN(k) ? 0 : k;
    const L = s * T
      , z = s * k;
    return {
        previous: {
            x: d.x - L * (f.x - u.x),
            y: d.y - L * (f.y - u.y)
        },
        next: {
            x: d.x + z * (f.x - u.x),
            y: d.y + z * (f.y - u.y)
        }
    }
}
function gN(e, t, i) {
    const s = e.length;
    let u, d, f, o, w, T = Zp(e, 0);
    for (let k = 0; k < s - 1; ++k)
        if (w = T,
        T = Zp(e, k + 1),
        !(!w || !T)) {
            if (Ng(t[k], 0, pN)) {
                i[k] = i[k + 1] = 0;
                continue
            }
            u = i[k] / t[k],
            d = i[k + 1] / t[k],
            o = Math.pow(u, 2) + Math.pow(d, 2),
            !(o <= 9) && (f = 3 / Math.sqrt(o),
            i[k] = u * f * t[k],
            i[k + 1] = d * f * t[k])
        }
}
function yN(e, t, i="x") {
    const s = HP(i)
      , u = e.length;
    let d, f, o, w = Zp(e, 0);
    for (let T = 0; T < u; ++T) {
        if (f = o,
        o = w,
        w = Zp(e, T + 1),
        !o)
            continue;
        const k = o[i]
          , L = o[s];
        f && (d = (k - f[i]) / 3,
        o[`cp1${i}`] = k - d,
        o[`cp1${s}`] = L - d * t[T]),
        w && (d = (w[i] - k) / 3,
        o[`cp2${i}`] = k + d,
        o[`cp2${s}`] = L + d * t[T])
    }
}
function _N(e, t="x") {
    const i = HP(t)
      , s = e.length
      , u = Array(s).fill(0)
      , d = Array(s);
    let f, o, w, T = Zp(e, 0);
    for (f = 0; f < s; ++f)
        if (o = w,
        w = T,
        T = Zp(e, f + 1),
        !!w) {
            if (T) {
                const k = T[t] - w[t];
                u[f] = k !== 0 ? (T[i] - w[i]) / k : 0
            }
            d[f] = o ? T ? ru(u[f - 1]) !== ru(u[f]) ? 0 : (u[f - 1] + u[f]) / 2 : u[f - 1] : u[f]
        }
    gN(e, u, d),
    yN(e, d, t)
}
function b_(e, t, i) {
    return Math.max(Math.min(e, i), t)
}
function vN(e, t) {
    let i, s, u, d, f, o = ty(e[0], t);
    for (i = 0,
    s = e.length; i < s; ++i)
        f = d,
        d = o,
        o = i < s - 1 && ty(e[i + 1], t),
        d && (u = e[i],
        f && (u.cp1x = b_(u.cp1x, t.left, t.right),
        u.cp1y = b_(u.cp1y, t.top, t.bottom)),
        o && (u.cp2x = b_(u.cp2x, t.left, t.right),
        u.cp2y = b_(u.cp2y, t.top, t.bottom)))
}
function xN(e, t, i, s, u) {
    let d, f, o, w;
    if (t.spanGaps && (e = e.filter(T => !T.skip)),
    t.cubicInterpolationMode === "monotone")
        _N(e, u);
    else {
        let T = s ? e[e.length - 1] : e[0];
        for (d = 0,
        f = e.length; d < f; ++d)
            o = e[d],
            w = mN(T, o, e[Math.min(d + 1, f - (s ? 0 : 1)) % f], t.tension),
            o.cp1x = w.previous.x,
            o.cp1y = w.previous.y,
            o.cp2x = w.next.x,
            o.cp2y = w.next.y,
            T = o
    }
    t.capBezierPoints && vN(e, i)
}
function Cb() {
    return typeof window < "u" && typeof document < "u"
}
function Tb(e) {
    let t = e.parentNode;
    return t && t.toString() === "[object ShadowRoot]" && (t = t.host),
    t
}
function iv(e, t, i) {
    let s;
    return typeof e == "string" ? (s = parseInt(e, 10),
    e.indexOf("%") !== -1 && (s = s / 100 * t.parentNode[i])) : s = e,
    s
}
const Ev = e => e.ownerDocument.defaultView.getComputedStyle(e, null);
function bN(e, t) {
    return Ev(e).getPropertyValue(t)
}
const wN = ["top", "right", "bottom", "left"];
function gf(e, t, i) {
    const s = {};
    i = i ? "-" + i : "";
    for (let u = 0; u < 4; u++) {
        const d = wN[u];
        s[d] = parseFloat(e[t + "-" + d + i]) || 0
    }
    return s.width = s.left + s.right,
    s.height = s.top + s.bottom,
    s
}
const SN = (e, t, i) => (e > 0 || t > 0) && (!i || !i.shadowRoot);
function CN(e, t) {
    const i = e.touches
      , s = i && i.length ? i[0] : e
      , {offsetX: u, offsetY: d} = s;
    let f = !1, o, w;
    if (SN(u, d, e.target))
        o = u,
        w = d;
    else {
        const T = t.getBoundingClientRect();
        o = s.clientX - T.left,
        w = s.clientY - T.top,
        f = !0
    }
    return {
        x: o,
        y: w,
        box: f
    }
}
function sf(e, t) {
    if ("native"in e)
        return e;
    const {canvas: i, currentDevicePixelRatio: s} = t
      , u = Ev(i)
      , d = u.boxSizing === "border-box"
      , f = gf(u, "padding")
      , o = gf(u, "border", "width")
      , {x: w, y: T, box: k} = CN(e, i)
      , L = f.left + (k && o.left)
      , z = f.top + (k && o.top);
    let {width: D, height: N} = t;
    return d && (D -= f.width + o.width,
    N -= f.height + o.height),
    {
        x: Math.round((w - L) / D * i.width / s),
        y: Math.round((T - z) / N * i.height / s)
    }
}
function TN(e, t, i) {
    let s, u;
    if (t === void 0 || i === void 0) {
        const d = e && Tb(e);
        if (!d)
            t = e.clientWidth,
            i = e.clientHeight;
        else {
            const f = d.getBoundingClientRect()
              , o = Ev(d)
              , w = gf(o, "border", "width")
              , T = gf(o, "padding");
            t = f.width - T.width - w.width,
            i = f.height - T.height - w.height,
            s = iv(o.maxWidth, d, "clientWidth"),
            u = iv(o.maxHeight, d, "clientHeight")
        }
    }
    return {
        width: t,
        height: i,
        maxWidth: s || rv,
        maxHeight: u || rv
    }
}
const w_ = e => Math.round(e * 10) / 10;
function PN(e, t, i, s) {
    const u = Ev(e)
      , d = gf(u, "margin")
      , f = iv(u.maxWidth, e, "clientWidth") || rv
      , o = iv(u.maxHeight, e, "clientHeight") || rv
      , w = TN(e, t, i);
    let {width: T, height: k} = w;
    if (u.boxSizing === "content-box") {
        const z = gf(u, "border", "width")
          , D = gf(u, "padding");
        T -= D.width + z.width,
        k -= D.height + z.height
    }
    return T = Math.max(0, T - d.width),
    k = Math.max(0, s ? T / s : k - d.height),
    T = w_(Math.min(T, f, w.maxWidth)),
    k = w_(Math.min(k, o, w.maxHeight)),
    T && !k && (k = w_(T / 2)),
    (t !== void 0 || i !== void 0) && s && w.height && k > w.height && (k = w.height,
    T = w_(Math.floor(k * s))),
    {
        width: T,
        height: k
    }
}
function i2(e, t, i) {
    const s = t || 1
      , u = Math.floor(e.height * s)
      , d = Math.floor(e.width * s);
    e.height = Math.floor(e.height),
    e.width = Math.floor(e.width);
    const f = e.canvas;
    return f.style && (i || !f.style.height && !f.style.width) && (f.style.height = `${e.height}px`,
    f.style.width = `${e.width}px`),
    e.currentDevicePixelRatio !== s || f.height !== u || f.width !== d ? (e.currentDevicePixelRatio = s,
    f.height = u,
    f.width = d,
    e.ctx.setTransform(s, 0, 0, s, 0, 0),
    !0) : !1
}
const MN = function() {
    let e = !1;
    try {
        const t = {
            get passive() {
                return e = !0,
                !1
            }
        };
        Cb() && (window.addEventListener("test", null, t),
        window.removeEventListener("test", null, t))
    } catch {}
    return e
}();
function o2(e, t) {
    const i = bN(e, t)
      , s = i && i.match(/^(\d+)(\.\d+)?px$/);
    return s ? +s[1] : void 0
}
function af(e, t, i, s) {
    return {
        x: e.x + i * (t.x - e.x),
        y: e.y + i * (t.y - e.y)
    }
}
function kN(e, t, i, s) {
    return {
        x: e.x + i * (t.x - e.x),
        y: s === "middle" ? i < .5 ? e.y : t.y : s === "after" ? i < 1 ? e.y : t.y : i > 0 ? t.y : e.y
    }
}
function EN(e, t, i, s) {
    const u = {
        x: e.cp2x,
        y: e.cp2y
    }
      , d = {
        x: t.cp1x,
        y: t.cp1y
    }
      , f = af(e, u, i)
      , o = af(u, d, i)
      , w = af(d, t, i)
      , T = af(f, o, i)
      , k = af(o, w, i);
    return af(T, k, i)
}
function ZP(e) {
    return e === "angle" ? {
        between: nv,
        compare: k4,
        normalize: Hc
    } : {
        between: DP,
        compare: (t, i) => t - i,
        normalize: t => t
    }
}
function s2({start: e, end: t, count: i, loop: s, style: u}) {
    return {
        start: e % i,
        end: t % i,
        loop: s && (t - e + 1) % i === 0,
        style: u
    }
}
function IN(e, t, i) {
    const {property: s, start: u, end: d} = i
      , {between: f, normalize: o} = ZP(s)
      , w = t.length;
    let {start: T, end: k, loop: L} = e, z, D;
    if (L) {
        for (T += w,
        k += w,
        z = 0,
        D = w; z < D && f(o(t[T % w][s]), u, d); ++z)
            T--,
            k--;
        T %= w,
        k %= w
    }
    return k < T && (k += w),
    {
        start: T,
        end: k,
        loop: L,
        style: e.style
    }
}
function XP(e, t, i) {
    if (!i)
        return [e];
    const {property: s, start: u, end: d} = i
      , f = t.length
      , {compare: o, between: w, normalize: T} = ZP(s)
      , {start: k, end: L, loop: z, style: D} = IN(e, t, i)
      , N = [];
    let U = !1, V = null, re, ie, ue;
    const ce = () => w(u, ue, re) && o(u, ue) !== 0
      , X = () => o(d, re) === 0 || w(d, ue, re)
      , me = () => U || ce()
      , K = () => !U || X();
    for (let be = k, Ee = k; be <= L; ++be)
        ie = t[be % f],
        !ie.skip && (re = T(ie[s]),
        re !== ue && (U = w(re, u, d),
        V === null && me() && (V = o(re, u) === 0 ? be : Ee),
        V !== null && K() && (N.push(s2({
            start: V,
            end: be,
            loop: z,
            count: f,
            style: D
        })),
        V = null),
        Ee = be,
        ue = re));
    return V !== null && N.push(s2({
        start: V,
        end: L,
        loop: z,
        count: f,
        style: D
    })),
    N
}
function YP(e, t) {
    const i = []
      , s = e.segments;
    for (let u = 0; u < s.length; u++) {
        const d = XP(s[u], e.points, t);
        d.length && i.push(...d)
    }
    return i
}
function RN(e, t, i, s) {
    let u = 0
      , d = t - 1;
    if (i && !s)
        for (; u < t && !e[u].skip; )
            u++;
    for (; u < t && e[u].skip; )
        u++;
    for (u %= t,
    i && (d += u); d > u && e[d % t].skip; )
        d--;
    return d %= t,
    {
        start: u,
        end: d
    }
}
function AN(e, t, i, s) {
    const u = e.length
      , d = [];
    let f = t, o = e[t], w;
    for (w = t + 1; w <= i; ++w) {
        const T = e[w % u];
        T.skip || T.stop ? o.skip || (s = !1,
        d.push({
            start: t % u,
            end: (w - 1) % u,
            loop: s
        }),
        t = f = T.stop ? w : null) : (f = w,
        o.skip && (t = w)),
        o = T
    }
    return f !== null && d.push({
        start: t % u,
        end: f % u,
        loop: s
    }),
    d
}
function zN(e, t) {
    const i = e.points
      , s = e.options.spanGaps
      , u = i.length;
    if (!u)
        return [];
    const d = !!e._loop
      , {start: f, end: o} = RN(i, u, d, s);
    if (s === !0)
        return a2(e, [{
            start: f,
            end: o,
            loop: d
        }], i, t);
    const w = o < f ? o + u : o
      , T = !!e._fullLoop && f === 0 && o === u - 1;
    return a2(e, AN(i, f, w, T), i, t)
}
function a2(e, t, i, s) {
    return !s || !s.setContext || !i ? t : DN(e, t, i, s)
}
function DN(e, t, i, s) {
    const u = e._chart.getContext()
      , d = l2(e.options)
      , {_datasetIndex: f, options: {spanGaps: o}} = e
      , w = i.length
      , T = [];
    let k = d
      , L = t[0].start
      , z = L;
    function D(N, U, V, re) {
        const ie = o ? -1 : 1;
        if (N !== U) {
            for (N += w; i[N % w].skip; )
                N -= ie;
            for (; i[U % w].skip; )
                U += ie;
            N % w !== U % w && (T.push({
                start: N % w,
                end: U % w,
                loop: V,
                style: re
            }),
            k = re,
            L = U % w)
        }
    }
    for (const N of t) {
        L = o ? L : N.start;
        let U = i[L % w], V;
        for (z = L + 1; z <= N.end; z++) {
            const re = i[z % w];
            V = l2(s.setContext(tm(u, {
                type: "segment",
                p0: U,
                p1: re,
                p0DataIndex: (z - 1) % w,
                p1DataIndex: z % w,
                datasetIndex: f
            }))),
            LN(V, k) && D(L, z - 1, N.loop, k),
            U = re,
            k = V
        }
        L < z - 1 && D(L, z - 1, N.loop, k)
    }
    return T
}
function l2(e) {
    return {
        backgroundColor: e.backgroundColor,
        borderCapStyle: e.borderCapStyle,
        borderDash: e.borderDash,
        borderDashOffset: e.borderDashOffset,
        borderJoinStyle: e.borderJoinStyle,
        borderWidth: e.borderWidth,
        borderColor: e.borderColor
    }
}
function LN(e, t) {
    if (!t)
        return !1;
    const i = []
      , s = function(u, d) {
        return _b(d) ? (i.includes(d) || i.push(d),
        i.indexOf(d)) : d
    };
    return JSON.stringify(e, s) !== JSON.stringify(t, s)
}
/*!
 * Chart.js v4.4.6
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
class ON {
    constructor() {
        this._request = null,
        this._charts = new Map,
        this._running = !1,
        this._lastDate = void 0
    }
    _notify(t, i, s, u) {
        const d = i.listeners[u]
          , f = i.duration;
        d.forEach(o => o({
            chart: t,
            initial: i.initial,
            numSteps: f,
            currentStep: Math.min(s - i.start, f)
        }))
    }
    _refresh() {
        this._request || (this._running = !0,
        this._request = FP.call(window, () => {
            this._update(),
            this._request = null,
            this._running && this._refresh()
        }
        ))
    }
    _update(t=Date.now()) {
        let i = 0;
        this._charts.forEach( (s, u) => {
            if (!s.running || !s.items.length)
                return;
            const d = s.items;
            let f = d.length - 1, o = !1, w;
            for (; f >= 0; --f)
                w = d[f],
                w._active ? (w._total > s.duration && (s.duration = w._total),
                w.tick(t),
                o = !0) : (d[f] = d[d.length - 1],
                d.pop());
            o && (u.draw(),
            this._notify(u, s, t, "progress")),
            d.length || (s.running = !1,
            this._notify(u, s, t, "complete"),
            s.initial = !1),
            i += d.length
        }
        ),
        this._lastDate = t,
        i === 0 && (this._running = !1)
    }
    _getAnims(t) {
        const i = this._charts;
        let s = i.get(t);
        return s || (s = {
            running: !1,
            initial: !0,
            items: [],
            listeners: {
                complete: [],
                progress: []
            }
        },
        i.set(t, s)),
        s
    }
    listen(t, i, s) {
        this._getAnims(t).listeners[i].push(s)
    }
    add(t, i) {
        !i || !i.length || this._getAnims(t).items.push(...i)
    }
    has(t) {
        return this._getAnims(t).items.length > 0
    }
    start(t) {
        const i = this._charts.get(t);
        i && (i.running = !0,
        i.start = Date.now(),
        i.duration = i.items.reduce( (s, u) => Math.max(s, u._duration), 0),
        this._refresh())
    }
    running(t) {
        if (!this._running)
            return !1;
        const i = this._charts.get(t);
        return !(!i || !i.running || !i.items.length)
    }
    stop(t) {
        const i = this._charts.get(t);
        if (!i || !i.items.length)
            return;
        const s = i.items;
        let u = s.length - 1;
        for (; u >= 0; --u)
            s[u].cancel();
        i.items = [],
        this._notify(t, i, Date.now(), "complete")
    }
    remove(t) {
        return this._charts.delete(t)
    }
}
var th = new ON;
const c2 = "transparent"
  , FN = {
    boolean(e, t, i) {
        return i > .5 ? t : e
    },
    color(e, t, i) {
        const s = KS(e || c2)
          , u = s.valid && KS(t || c2);
        return u && u.valid ? u.mix(s, i).hexString() : t
    },
    number(e, t, i) {
        return e + (t - e) * i
    }
};
class BN {
    constructor(t, i, s, u) {
        const d = i[s];
        u = x_([t.to, u, d, t.from]);
        const f = x_([t.from, d, u]);
        this._active = !0,
        this._fn = t.fn || FN[t.type || typeof f],
        this._easing = $g[t.easing] || $g.linear,
        this._start = Math.floor(Date.now() + (t.delay || 0)),
        this._duration = this._total = Math.floor(t.duration),
        this._loop = !!t.loop,
        this._target = i,
        this._prop = s,
        this._from = f,
        this._to = u,
        this._promises = void 0
    }
    active() {
        return this._active
    }
    update(t, i, s) {
        if (this._active) {
            this._notify(!1);
            const u = this._target[this._prop]
              , d = s - this._start
              , f = this._duration - d;
            this._start = s,
            this._duration = Math.floor(Math.max(f, t.duration)),
            this._total += d,
            this._loop = !!t.loop,
            this._to = x_([t.to, i, u, t.from]),
            this._from = x_([t.from, u, i])
        }
    }
    cancel() {
        this._active && (this.tick(Date.now()),
        this._active = !1,
        this._notify(!1))
    }
    tick(t) {
        const i = t - this._start
          , s = this._duration
          , u = this._prop
          , d = this._from
          , f = this._loop
          , o = this._to;
        let w;
        if (this._active = d !== o && (f || i < s),
        !this._active) {
            this._target[u] = o,
            this._notify(!0);
            return
        }
        if (i < 0) {
            this._target[u] = d;
            return
        }
        w = i / s % 2,
        w = f && w > 1 ? 2 - w : w,
        w = this._easing(Math.min(1, Math.max(0, w))),
        this._target[u] = this._fn(d, o, w)
    }
    wait() {
        const t = this._promises || (this._promises = []);
        return new Promise( (i, s) => {
            t.push({
                res: i,
                rej: s
            })
        }
        )
    }
    _notify(t) {
        const i = t ? "res" : "rej"
          , s = this._promises || [];
        for (let u = 0; u < s.length; u++)
            s[u][i]()
    }
}
class jN {
    constructor(t, i) {
        this._chart = t,
        this._properties = new Map,
        this.configure(i)
    }
    configure(t) {
        if (!Cn(t))
            return;
        const i = Object.keys(fo.animation)
          , s = this._properties;
        Object.getOwnPropertyNames(t).forEach(u => {
            const d = t[u];
            if (!Cn(d))
                return;
            const f = {};
            for (const o of i)
                f[o] = d[o];
            (Vo(d.properties) && d.properties || [u]).forEach(o => {
                (o === u || !s.has(o)) && s.set(o, f)
            }
            )
        }
        )
    }
    _animateOptions(t, i) {
        const s = i.options
          , u = $N(t, s);
        if (!u)
            return [];
        const d = this._createAnimations(u, s);
        return s.$shared && NN(t.options.$animations, s).then( () => {
            t.options = s
        }
        , () => {}
        ),
        d
    }
    _createAnimations(t, i) {
        const s = this._properties
          , u = []
          , d = t.$animations || (t.$animations = {})
          , f = Object.keys(i)
          , o = Date.now();
        let w;
        for (w = f.length - 1; w >= 0; --w) {
            const T = f[w];
            if (T.charAt(0) === "$")
                continue;
            if (T === "options") {
                u.push(...this._animateOptions(t, i));
                continue
            }
            const k = i[T];
            let L = d[T];
            const z = s.get(T);
            if (L)
                if (z && L.active()) {
                    L.update(z, k, o);
                    continue
                } else
                    L.cancel();
            if (!z || !z.duration) {
                t[T] = k;
                continue
            }
            d[T] = L = new BN(z,t,T,k),
            u.push(L)
        }
        return u
    }
    update(t, i) {
        if (this._properties.size === 0) {
            Object.assign(t, i);
            return
        }
        const s = this._createAnimations(t, i);
        if (s.length)
            return th.add(this._chart, s),
            !0
    }
}
function NN(e, t) {
    const i = []
      , s = Object.keys(t);
    for (let u = 0; u < s.length; u++) {
        const d = e[s[u]];
        d && d.active() && i.push(d.wait())
    }
    return Promise.all(i)
}
function $N(e, t) {
    if (!t)
        return;
    let i = e.options;
    if (!i) {
        e.options = t;
        return
    }
    return i.$shared && (e.options = i = Object.assign({}, i, {
        $shared: !1,
        $animations: {}
    })),
    i
}
function u2(e, t) {
    const i = e && e.options || {}
      , s = i.reverse
      , u = i.min === void 0 ? t : 0
      , d = i.max === void 0 ? t : 0;
    return {
        start: s ? d : u,
        end: s ? u : d
    }
}
function VN(e, t, i) {
    if (i === !1)
        return !1;
    const s = u2(e, i)
      , u = u2(t, i);
    return {
        top: u.end,
        right: s.end,
        bottom: u.start,
        left: s.start
    }
}
function UN(e) {
    let t, i, s, u;
    return Cn(e) ? (t = e.top,
    i = e.right,
    s = e.bottom,
    u = e.left) : t = i = s = u = e,
    {
        top: t,
        right: i,
        bottom: s,
        left: u,
        disabled: e === !1
    }
}
function KP(e, t) {
    const i = []
      , s = e._getSortedDatasetMetas(t);
    let u, d;
    for (u = 0,
    d = s.length; u < d; ++u)
        i.push(s[u].index);
    return i
}
function h2(e, t, i, s={}) {
    const u = e.keys
      , d = s.mode === "single";
    let f, o, w, T;
    if (t === null)
        return;
    let k = !1;
    for (f = 0,
    o = u.length; f < o; ++f) {
        if (w = +u[f],
        w === i) {
            if (k = !0,
            s.all)
                continue;
            break
        }
        T = e.values[w],
        _s(T) && (d || t === 0 || ru(t) === ru(T)) && (t += T)
    }
    return !k && !s.all ? 0 : t
}
function GN(e, t) {
    const {iScale: i, vScale: s} = t
      , u = i.axis === "x" ? "x" : "y"
      , d = s.axis === "x" ? "x" : "y"
      , f = Object.keys(e)
      , o = new Array(f.length);
    let w, T, k;
    for (w = 0,
    T = f.length; w < T; ++w)
        k = f[w],
        o[w] = {
            [u]: k,
            [d]: e[k]
        };
    return o
}
function F0(e, t) {
    const i = e && e.options.stacked;
    return i || i === void 0 && t.stack !== void 0
}
function WN(e, t, i) {
    return `${e.id}.${t.id}.${i.stack || i.type}`
}
function qN(e) {
    const {min: t, max: i, minDefined: s, maxDefined: u} = e.getUserBounds();
    return {
        min: s ? t : Number.NEGATIVE_INFINITY,
        max: u ? i : Number.POSITIVE_INFINITY
    }
}
function HN(e, t, i) {
    const s = e[t] || (e[t] = {});
    return s[i] || (s[i] = {})
}
function d2(e, t, i, s) {
    for (const u of t.getMatchingVisibleMetas(s).reverse()) {
        const d = e[u.index];
        if (i && d > 0 || !i && d < 0)
            return u.index
    }
    return null
}
function f2(e, t) {
    const {chart: i, _cachedMeta: s} = e
      , u = i._stacks || (i._stacks = {})
      , {iScale: d, vScale: f, index: o} = s
      , w = d.axis
      , T = f.axis
      , k = WN(d, f, s)
      , L = t.length;
    let z;
    for (let D = 0; D < L; ++D) {
        const N = t[D]
          , {[w]: U, [T]: V} = N
          , re = N._stacks || (N._stacks = {});
        z = re[T] = HN(u, k, U),
        z[o] = V,
        z._top = d2(z, f, !0, s.type),
        z._bottom = d2(z, f, !1, s.type);
        const ie = z._visualValues || (z._visualValues = {});
        ie[o] = V
    }
}
function B0(e, t) {
    const i = e.scales;
    return Object.keys(i).filter(s => i[s].axis === t).shift()
}
function ZN(e, t) {
    return tm(e, {
        active: !1,
        dataset: void 0,
        datasetIndex: t,
        index: t,
        mode: "default",
        type: "dataset"
    })
}
function XN(e, t, i) {
    return tm(e, {
        active: !1,
        dataIndex: t,
        parsed: void 0,
        raw: void 0,
        element: i,
        index: t,
        mode: "default",
        type: "data"
    })
}
function dg(e, t) {
    const i = e.controller.index
      , s = e.vScale && e.vScale.axis;
    if (s) {
        t = t || e._parsed;
        for (const u of t) {
            const d = u._stacks;
            if (!d || d[s] === void 0 || d[s][i] === void 0)
                return;
            delete d[s][i],
            d[s]._visualValues !== void 0 && d[s]._visualValues[i] !== void 0 && delete d[s]._visualValues[i]
        }
    }
}
const j0 = e => e === "reset" || e === "none"
  , p2 = (e, t) => t ? e : Object.assign({}, e)
  , YN = (e, t, i) => e && !t.hidden && t._stacked && {
    keys: KP(i, !0),
    values: null
};
class rd {
    static defaults = {};
    static datasetElementType = null;
    static dataElementType = null;
    constructor(t, i) {
        this.chart = t,
        this._ctx = t.ctx,
        this.index = i,
        this._cachedDataOpts = {},
        this._cachedMeta = this.getMeta(),
        this._type = this._cachedMeta.type,
        this.options = void 0,
        this._parsing = !1,
        this._data = void 0,
        this._objectData = void 0,
        this._sharedOptions = void 0,
        this._drawStart = void 0,
        this._drawCount = void 0,
        this.enableOptionSharing = !1,
        this.supportsDecimation = !1,
        this.$context = void 0,
        this._syncList = [],
        this.datasetElementType = new.target.datasetElementType,
        this.dataElementType = new.target.dataElementType,
        this.initialize()
    }
    initialize() {
        const t = this._cachedMeta;
        this.configure(),
        this.linkScales(),
        t._stacked = F0(t.vScale, t),
        this.addElements(),
        this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")
    }
    updateIndex(t) {
        this.index !== t && dg(this._cachedMeta),
        this.index = t
    }
    linkScales() {
        const t = this.chart
          , i = this._cachedMeta
          , s = this.getDataset()
          , u = (L, z, D, N) => L === "x" ? z : L === "r" ? N : D
          , d = i.xAxisID = zn(s.xAxisID, B0(t, "x"))
          , f = i.yAxisID = zn(s.yAxisID, B0(t, "y"))
          , o = i.rAxisID = zn(s.rAxisID, B0(t, "r"))
          , w = i.indexAxis
          , T = i.iAxisID = u(w, d, f, o)
          , k = i.vAxisID = u(w, f, d, o);
        i.xScale = this.getScaleForId(d),
        i.yScale = this.getScaleForId(f),
        i.rScale = this.getScaleForId(o),
        i.iScale = this.getScaleForId(T),
        i.vScale = this.getScaleForId(k)
    }
    getDataset() {
        return this.chart.data.datasets[this.index]
    }
    getMeta() {
        return this.chart.getDatasetMeta(this.index)
    }
    getScaleForId(t) {
        return this.chart.scales[t]
    }
    _getOtherScale(t) {
        const i = this._cachedMeta;
        return t === i.iScale ? i.vScale : i.iScale
    }
    reset() {
        this._update("reset")
    }
    _destroy() {
        const t = this._cachedMeta;
        this._data && HS(this._data, this),
        t._stacked && dg(t)
    }
    _dataCheck() {
        const t = this.getDataset()
          , i = t.data || (t.data = [])
          , s = this._data;
        if (Cn(i)) {
            const u = this._cachedMeta;
            this._data = GN(i, u)
        } else if (s !== i) {
            if (s) {
                HS(s, this);
                const u = this._cachedMeta;
                dg(u),
                u._parsed = []
            }
            i && Object.isExtensible(i) && A4(i, this),
            this._syncList = [],
            this._data = i
        }
    }
    addElements() {
        const t = this._cachedMeta;
        this._dataCheck(),
        this.datasetElementType && (t.dataset = new this.datasetElementType)
    }
    buildOrUpdateElements(t) {
        const i = this._cachedMeta
          , s = this.getDataset();
        let u = !1;
        this._dataCheck();
        const d = i._stacked;
        i._stacked = F0(i.vScale, i),
        i.stack !== s.stack && (u = !0,
        dg(i),
        i.stack = s.stack),
        this._resyncElements(t),
        (u || d !== i._stacked) && (f2(this, i._parsed),
        i._stacked = F0(i.vScale, i))
    }
    configure() {
        const t = this.chart.config
          , i = t.datasetScopeKeys(this._type)
          , s = t.getOptionScopes(this.getDataset(), i, !0);
        this.options = t.createResolver(s, this.getContext()),
        this._parsing = this.options.parsing,
        this._cachedDataOpts = {}
    }
    parse(t, i) {
        const {_cachedMeta: s, _data: u} = this
          , {iScale: d, _stacked: f} = s
          , o = d.axis;
        let w = t === 0 && i === u.length ? !0 : s._sorted, T = t > 0 && s._parsed[t - 1], k, L, z;
        if (this._parsing === !1)
            s._parsed = u,
            s._sorted = !0,
            z = u;
        else {
            Vo(u[t]) ? z = this.parseArrayData(s, u, t, i) : Cn(u[t]) ? z = this.parseObjectData(s, u, t, i) : z = this.parsePrimitiveData(s, u, t, i);
            const D = () => L[o] === null || T && L[o] < T[o];
            for (k = 0; k < i; ++k)
                s._parsed[k + t] = L = z[k],
                w && (D() && (w = !1),
                T = L);
            s._sorted = w
        }
        f && f2(this, z)
    }
    parsePrimitiveData(t, i, s, u) {
        const {iScale: d, vScale: f} = t
          , o = d.axis
          , w = f.axis
          , T = d.getLabels()
          , k = d === f
          , L = new Array(u);
        let z, D, N;
        for (z = 0,
        D = u; z < D; ++z)
            N = z + s,
            L[z] = {
                [o]: k || d.parse(T[N], N),
                [w]: f.parse(i[N], N)
            };
        return L
    }
    parseArrayData(t, i, s, u) {
        const {xScale: d, yScale: f} = t
          , o = new Array(u);
        let w, T, k, L;
        for (w = 0,
        T = u; w < T; ++w)
            k = w + s,
            L = i[k],
            o[w] = {
                x: d.parse(L[0], k),
                y: f.parse(L[1], k)
            };
        return o
    }
    parseObjectData(t, i, s, u) {
        const {xScale: d, yScale: f} = t
          , {xAxisKey: o="x", yAxisKey: w="y"} = this._parsing
          , T = new Array(u);
        let k, L, z, D;
        for (k = 0,
        L = u; k < L; ++k)
            z = k + s,
            D = i[z],
            T[k] = {
                x: d.parse(Qh(D, o), z),
                y: f.parse(Qh(D, w), z)
            };
        return T
    }
    getParsed(t) {
        return this._cachedMeta._parsed[t]
    }
    getDataElement(t) {
        return this._cachedMeta.data[t]
    }
    applyStack(t, i, s) {
        const u = this.chart
          , d = this._cachedMeta
          , f = i[t.axis]
          , o = {
            keys: KP(u, !0),
            values: i._stacks[t.axis]._visualValues
        };
        return h2(o, f, d.index, {
            mode: s
        })
    }
    updateRangeFromParsed(t, i, s, u) {
        const d = s[i.axis];
        let f = d === null ? NaN : d;
        const o = u && s._stacks[i.axis];
        u && o && (u.values = o,
        f = h2(u, d, this._cachedMeta.index)),
        t.min = Math.min(t.min, f),
        t.max = Math.max(t.max, f)
    }
    getMinMax(t, i) {
        const s = this._cachedMeta
          , u = s._parsed
          , d = s._sorted && t === s.iScale
          , f = u.length
          , o = this._getOtherScale(t)
          , w = YN(i, s, this.chart)
          , T = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        }
          , {min: k, max: L} = qN(o);
        let z, D;
        function N() {
            D = u[z];
            const U = D[o.axis];
            return !_s(D[t.axis]) || k > U || L < U
        }
        for (z = 0; z < f && !(!N() && (this.updateRangeFromParsed(T, t, D, w),
        d)); ++z)
            ;
        if (d) {
            for (z = f - 1; z >= 0; --z)
                if (!N()) {
                    this.updateRangeFromParsed(T, t, D, w);
                    break
                }
        }
        return T
    }
    getAllParsedValues(t) {
        const i = this._cachedMeta._parsed
          , s = [];
        let u, d, f;
        for (u = 0,
        d = i.length; u < d; ++u)
            f = i[u][t.axis],
            _s(f) && s.push(f);
        return s
    }
    getMaxOverflow() {
        return !1
    }
    getLabelAndValue(t) {
        const i = this._cachedMeta
          , s = i.iScale
          , u = i.vScale
          , d = this.getParsed(t);
        return {
            label: s ? "" + s.getLabelForValue(d[s.axis]) : "",
            value: u ? "" + u.getLabelForValue(d[u.axis]) : ""
        }
    }
    _update(t) {
        const i = this._cachedMeta;
        this.update(t || "default"),
        i._clip = UN(zn(this.options.clip, VN(i.xScale, i.yScale, this.getMaxOverflow())))
    }
    update(t) {}
    draw() {
        const t = this._ctx
          , i = this.chart
          , s = this._cachedMeta
          , u = s.data || []
          , d = i.chartArea
          , f = []
          , o = this._drawStart || 0
          , w = this._drawCount || u.length - o
          , T = this.options.drawActiveElementsOnTop;
        let k;
        for (s.dataset && s.dataset.draw(t, d, o, w),
        k = o; k < o + w; ++k) {
            const L = u[k];
            L.hidden || (L.active && T ? f.push(L) : L.draw(t, d))
        }
        for (k = 0; k < f.length; ++k)
            f[k].draw(t, d)
    }
    getStyle(t, i) {
        const s = i ? "active" : "default";
        return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s) : this.resolveDataElementOptions(t || 0, s)
    }
    getContext(t, i, s) {
        const u = this.getDataset();
        let d;
        if (t >= 0 && t < this._cachedMeta.data.length) {
            const f = this._cachedMeta.data[t];
            d = f.$context || (f.$context = XN(this.getContext(), t, f)),
            d.parsed = this.getParsed(t),
            d.raw = u.data[t],
            d.index = d.dataIndex = t
        } else
            d = this.$context || (this.$context = ZN(this.chart.getContext(), this.index)),
            d.dataset = u,
            d.index = d.datasetIndex = this.index;
        return d.active = !!i,
        d.mode = s,
        d
    }
    resolveDatasetElementOptions(t) {
        return this._resolveElementOptions(this.datasetElementType.id, t)
    }
    resolveDataElementOptions(t, i) {
        return this._resolveElementOptions(this.dataElementType.id, i, t)
    }
    _resolveElementOptions(t, i="default", s) {
        const u = i === "active"
          , d = this._cachedDataOpts
          , f = t + "-" + i
          , o = d[f]
          , w = this.enableOptionSharing && ey(s);
        if (o)
            return p2(o, w);
        const T = this.chart.config
          , k = T.datasetElementScopeKeys(this._type, t)
          , L = u ? [`${t}Hover`, "hover", t, ""] : [t, ""]
          , z = T.getOptionScopes(this.getDataset(), k)
          , D = Object.keys(fo.elements[t])
          , N = () => this.getContext(s, u, i)
          , U = T.resolveNamedOptions(z, D, N, L);
        return U.$shared && (U.$shared = w,
        d[f] = Object.freeze(p2(U, w))),
        U
    }
    _resolveAnimations(t, i, s) {
        const u = this.chart
          , d = this._cachedDataOpts
          , f = `animation-${i}`
          , o = d[f];
        if (o)
            return o;
        let w;
        if (u.options.animation !== !1) {
            const k = this.chart.config
              , L = k.datasetAnimationScopeKeys(this._type, i)
              , z = k.getOptionScopes(this.getDataset(), L);
            w = k.createResolver(z, this.getContext(t, s, i))
        }
        const T = new jN(u,w && w.animations);
        return w && w._cacheable && (d[f] = Object.freeze(T)),
        T
    }
    getSharedOptions(t) {
        if (t.$shared)
            return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))
    }
    includeOptions(t, i) {
        return !i || j0(t) || this.chart._animationsDisabled
    }
    _getSharedOptions(t, i) {
        const s = this.resolveDataElementOptions(t, i)
          , u = this._sharedOptions
          , d = this.getSharedOptions(s)
          , f = this.includeOptions(i, d) || d !== u;
        return this.updateSharedOptions(d, i, s),
        {
            sharedOptions: d,
            includeOptions: f
        }
    }
    updateElement(t, i, s, u) {
        j0(u) ? Object.assign(t, s) : this._resolveAnimations(i, u).update(t, s)
    }
    updateSharedOptions(t, i, s) {
        t && !j0(i) && this._resolveAnimations(void 0, i).update(t, s)
    }
    _setStyle(t, i, s, u) {
        t.active = u;
        const d = this.getStyle(i, u);
        this._resolveAnimations(i, s, u).update(t, {
            options: !u && this.getSharedOptions(d) || d
        })
    }
    removeHoverStyle(t, i, s) {
        this._setStyle(t, s, "active", !1)
    }
    setHoverStyle(t, i, s) {
        this._setStyle(t, s, "active", !0)
    }
    _removeDatasetHoverStyle() {
        const t = this._cachedMeta.dataset;
        t && this._setStyle(t, void 0, "active", !1)
    }
    _setDatasetHoverStyle() {
        const t = this._cachedMeta.dataset;
        t && this._setStyle(t, void 0, "active", !0)
    }
    _resyncElements(t) {
        const i = this._data
          , s = this._cachedMeta.data;
        for (const [o,w,T] of this._syncList)
            this[o](w, T);
        this._syncList = [];
        const u = s.length
          , d = i.length
          , f = Math.min(d, u);
        f && this.parse(0, f),
        d > u ? this._insertElements(u, d - u, t) : d < u && this._removeElements(d, u - d)
    }
    _insertElements(t, i, s=!0) {
        const u = this._cachedMeta
          , d = u.data
          , f = t + i;
        let o;
        const w = T => {
            for (T.length += i,
            o = T.length - 1; o >= f; o--)
                T[o] = T[o - i]
        }
        ;
        for (w(d),
        o = t; o < f; ++o)
            d[o] = new this.dataElementType;
        this._parsing && w(u._parsed),
        this.parse(t, i),
        s && this.updateElements(d, t, i, "reset")
    }
    updateElements(t, i, s, u) {}
    _removeElements(t, i) {
        const s = this._cachedMeta;
        if (this._parsing) {
            const u = s._parsed.splice(t, i);
            s._stacked && dg(s, u)
        }
        s.data.splice(t, i)
    }
    _sync(t) {
        if (this._parsing)
            this._syncList.push(t);
        else {
            const [i,s,u] = t;
            this[i](s, u)
        }
        this.chart._dataChanges.push([this.index, ...t])
    }
    _onDataPush() {
        const t = arguments.length;
        this._sync(["_insertElements", this.getDataset().data.length - t, t])
    }
    _onDataPop() {
        this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
    }
    _onDataShift() {
        this._sync(["_removeElements", 0, 1])
    }
    _onDataSplice(t, i) {
        i && this._sync(["_removeElements", t, i]);
        const s = arguments.length - 2;
        s && this._sync(["_insertElements", t, s])
    }
    _onDataUnshift() {
        this._sync(["_insertElements", 0, arguments.length])
    }
}
function KN(e, t) {
    if (!e._cache.$bar) {
        const i = e.getMatchingVisibleMetas(t);
        let s = [];
        for (let u = 0, d = i.length; u < d; u++)
            s = s.concat(i[u].controller.getAllParsedValues(e));
        e._cache.$bar = OP(s.sort( (u, d) => u - d))
    }
    return e._cache.$bar
}
function QN(e) {
    const t = e.iScale
      , i = KN(t, e.type);
    let s = t._length, u, d, f, o;
    const w = () => {
        f === 32767 || f === -32768 || (ey(o) && (s = Math.min(s, Math.abs(f - o) || s)),
        o = f)
    }
    ;
    for (u = 0,
    d = i.length; u < d; ++u)
        f = t.getPixelForValue(i[u]),
        w();
    for (o = void 0,
    u = 0,
    d = t.ticks.length; u < d; ++u)
        f = t.getPixelForTick(u),
        w();
    return s
}
function JN(e, t, i, s) {
    const u = i.barThickness;
    let d, f;
    return li(u) ? (d = t.min * i.categoryPercentage,
    f = i.barPercentage) : (d = u * s,
    f = 1),
    {
        chunk: d / s,
        ratio: f,
        start: t.pixels[e] - d / 2
    }
}
function e$(e, t, i, s) {
    const u = t.pixels
      , d = u[e];
    let f = e > 0 ? u[e - 1] : null
      , o = e < u.length - 1 ? u[e + 1] : null;
    const w = i.categoryPercentage;
    f === null && (f = d - (o === null ? t.end - t.start : o - d)),
    o === null && (o = d + d - f);
    const T = d - (d - Math.min(f, o)) / 2 * w;
    return {
        chunk: Math.abs(o - f) / 2 * w / s,
        ratio: i.barPercentage,
        start: T
    }
}
function t$(e, t, i, s) {
    const u = i.parse(e[0], s)
      , d = i.parse(e[1], s)
      , f = Math.min(u, d)
      , o = Math.max(u, d);
    let w = f
      , T = o;
    Math.abs(f) > Math.abs(o) && (w = o,
    T = f),
    t[i.axis] = T,
    t._custom = {
        barStart: w,
        barEnd: T,
        start: u,
        end: d,
        min: f,
        max: o
    }
}
function QP(e, t, i, s) {
    return Vo(e) ? t$(e, t, i, s) : t[i.axis] = i.parse(e, s),
    t
}
function m2(e, t, i, s) {
    const u = e.iScale
      , d = e.vScale
      , f = u.getLabels()
      , o = u === d
      , w = [];
    let T, k, L, z;
    for (T = i,
    k = i + s; T < k; ++T)
        z = t[T],
        L = {},
        L[u.axis] = o || u.parse(f[T], T),
        w.push(QP(z, L, d, T));
    return w
}
function N0(e) {
    return e && e.barStart !== void 0 && e.barEnd !== void 0
}
function r$(e, t, i) {
    return e !== 0 ? ru(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= i ? 1 : -1)
}
function n$(e) {
    let t, i, s, u, d;
    return e.horizontal ? (t = e.base > e.x,
    i = "left",
    s = "right") : (t = e.base < e.y,
    i = "bottom",
    s = "top"),
    t ? (u = "end",
    d = "start") : (u = "start",
    d = "end"),
    {
        start: i,
        end: s,
        reverse: t,
        top: u,
        bottom: d
    }
}
function i$(e, t, i, s) {
    let u = t.borderSkipped;
    const d = {};
    if (!u) {
        e.borderSkipped = d;
        return
    }
    if (u === !0) {
        e.borderSkipped = {
            top: !0,
            right: !0,
            bottom: !0,
            left: !0
        };
        return
    }
    const {start: f, end: o, reverse: w, top: T, bottom: k} = n$(e);
    u === "middle" && i && (e.enableBorderRadius = !0,
    (i._top || 0) === s ? u = T : (i._bottom || 0) === s ? u = k : (d[g2(k, f, o, w)] = !0,
    u = T)),
    d[g2(u, f, o, w)] = !0,
    e.borderSkipped = d
}
function g2(e, t, i, s) {
    return s ? (e = o$(e, t, i),
    e = y2(e, i, t)) : e = y2(e, t, i),
    e
}
function o$(e, t, i) {
    return e === t ? i : e === i ? t : e
}
function y2(e, t, i) {
    return e === "start" ? t : e === "end" ? i : e
}
function s$(e, {inflateAmount: t}, i) {
    e.inflateAmount = t === "auto" ? i === 1 ? .33 : 0 : t
}
class a$ extends rd {
    static id = "bar";
    static defaults = {
        datasetElementType: !1,
        dataElementType: "bar",
        categoryPercentage: .8,
        barPercentage: .9,
        grouped: !0,
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "base", "width", "height"]
            }
        }
    };
    static overrides = {
        scales: {
            _index_: {
                type: "category",
                offset: !0,
                grid: {
                    offset: !0
                }
            },
            _value_: {
                type: "linear",
                beginAtZero: !0
            }
        }
    };
    parsePrimitiveData(t, i, s, u) {
        return m2(t, i, s, u)
    }
    parseArrayData(t, i, s, u) {
        return m2(t, i, s, u)
    }
    parseObjectData(t, i, s, u) {
        const {iScale: d, vScale: f} = t
          , {xAxisKey: o="x", yAxisKey: w="y"} = this._parsing
          , T = d.axis === "x" ? o : w
          , k = f.axis === "x" ? o : w
          , L = [];
        let z, D, N, U;
        for (z = s,
        D = s + u; z < D; ++z)
            U = i[z],
            N = {},
            N[d.axis] = d.parse(Qh(U, T), z),
            L.push(QP(Qh(U, k), N, f, z));
        return L
    }
    updateRangeFromParsed(t, i, s, u) {
        super.updateRangeFromParsed(t, i, s, u);
        const d = s._custom;
        d && i === this._cachedMeta.vScale && (t.min = Math.min(t.min, d.min),
        t.max = Math.max(t.max, d.max))
    }
    getMaxOverflow() {
        return 0
    }
    getLabelAndValue(t) {
        const i = this._cachedMeta
          , {iScale: s, vScale: u} = i
          , d = this.getParsed(t)
          , f = d._custom
          , o = N0(f) ? "[" + f.start + ", " + f.end + "]" : "" + u.getLabelForValue(d[u.axis]);
        return {
            label: "" + s.getLabelForValue(d[s.axis]),
            value: o
        }
    }
    initialize() {
        this.enableOptionSharing = !0,
        super.initialize();
        const t = this._cachedMeta;
        t.stack = this.getDataset().stack
    }
    update(t) {
        const i = this._cachedMeta;
        this.updateElements(i.data, 0, i.data.length, t)
    }
    updateElements(t, i, s, u) {
        const d = u === "reset"
          , {index: f, _cachedMeta: {vScale: o}} = this
          , w = o.getBasePixel()
          , T = o.isHorizontal()
          , k = this._getRuler()
          , {sharedOptions: L, includeOptions: z} = this._getSharedOptions(i, u);
        for (let D = i; D < i + s; D++) {
            const N = this.getParsed(D)
              , U = d || li(N[o.axis]) ? {
                base: w,
                head: w
            } : this._calculateBarValuePixels(D)
              , V = this._calculateBarIndexPixels(D, k)
              , re = (N._stacks || {})[o.axis]
              , ie = {
                horizontal: T,
                base: U.base,
                enableBorderRadius: !re || N0(N._custom) || f === re._top || f === re._bottom,
                x: T ? U.head : V.center,
                y: T ? V.center : U.head,
                height: T ? V.size : Math.abs(U.size),
                width: T ? Math.abs(U.size) : V.size
            };
            z && (ie.options = L || this.resolveDataElementOptions(D, t[D].active ? "active" : u));
            const ue = ie.options || t[D].options;
            i$(ie, ue, re, f),
            s$(ie, ue, k.ratio),
            this.updateElement(t[D], D, ie, u)
        }
    }
    _getStacks(t, i) {
        const {iScale: s} = this._cachedMeta
          , u = s.getMatchingVisibleMetas(this._type).filter(k => k.controller.options.grouped)
          , d = s.options.stacked
          , f = []
          , o = this._cachedMeta.controller.getParsed(i)
          , w = o && o[s.axis]
          , T = k => {
            const L = k._parsed.find(D => D[s.axis] === w)
              , z = L && L[k.vScale.axis];
            if (li(z) || isNaN(z))
                return !0
        }
        ;
        for (const k of u)
            if (!(i !== void 0 && T(k)) && ((d === !1 || f.indexOf(k.stack) === -1 || d === void 0 && k.stack === void 0) && f.push(k.stack),
            k.index === t))
                break;
        return f.length || f.push(void 0),
        f
    }
    _getStackCount(t) {
        return this._getStacks(void 0, t).length
    }
    _getStackIndex(t, i, s) {
        const u = this._getStacks(t, s)
          , d = i !== void 0 ? u.indexOf(i) : -1;
        return d === -1 ? u.length - 1 : d
    }
    _getRuler() {
        const t = this.options
          , i = this._cachedMeta
          , s = i.iScale
          , u = [];
        let d, f;
        for (d = 0,
        f = i.data.length; d < f; ++d)
            u.push(s.getPixelForValue(this.getParsed(d)[s.axis], d));
        const o = t.barThickness;
        return {
            min: o || QN(i),
            pixels: u,
            start: s._startPixel,
            end: s._endPixel,
            stackCount: this._getStackCount(),
            scale: s,
            grouped: t.grouped,
            ratio: o ? 1 : t.categoryPercentage * t.barPercentage
        }
    }
    _calculateBarValuePixels(t) {
        const {_cachedMeta: {vScale: i, _stacked: s, index: u}, options: {base: d, minBarLength: f}} = this
          , o = d || 0
          , w = this.getParsed(t)
          , T = w._custom
          , k = N0(T);
        let L = w[i.axis], z = 0, D = s ? this.applyStack(i, w, s) : L, N, U;
        D !== L && (z = D - L,
        D = L),
        k && (L = T.barStart,
        D = T.barEnd - T.barStart,
        L !== 0 && ru(L) !== ru(T.barEnd) && (z = 0),
        z += L);
        const V = !li(d) && !k ? d : z;
        let re = i.getPixelForValue(V);
        if (this.chart.getDataVisibility(t) ? N = i.getPixelForValue(z + D) : N = re,
        U = N - re,
        Math.abs(U) < f) {
            U = r$(U, i, o) * f,
            L === o && (re -= U / 2);
            const ie = i.getPixelForDecimal(0)
              , ue = i.getPixelForDecimal(1)
              , ce = Math.min(ie, ue)
              , X = Math.max(ie, ue);
            re = Math.max(Math.min(re, X), ce),
            N = re + U,
            s && !k && (w._stacks[i.axis]._visualValues[u] = i.getValueForPixel(N) - i.getValueForPixel(re))
        }
        if (re === i.getPixelForValue(o)) {
            const ie = ru(U) * i.getLineWidthForValue(o) / 2;
            re += ie,
            U -= ie
        }
        return {
            size: U,
            base: re,
            head: N,
            center: N + U / 2
        }
    }
    _calculateBarIndexPixels(t, i) {
        const s = i.scale
          , u = this.options
          , d = u.skipNull
          , f = zn(u.maxBarThickness, 1 / 0);
        let o, w;
        if (i.grouped) {
            const T = d ? this._getStackCount(t) : i.stackCount
              , k = u.barThickness === "flex" ? e$(t, i, u, T) : JN(t, i, u, T)
              , L = this._getStackIndex(this.index, this._cachedMeta.stack, d ? t : void 0);
            o = k.start + k.chunk * L + k.chunk / 2,
            w = Math.min(f, k.chunk * k.ratio)
        } else
            o = s.getPixelForValue(this.getParsed(t)[s.axis], t),
            w = Math.min(f, i.min * i.ratio);
        return {
            base: o - w / 2,
            head: o + w / 2,
            center: o,
            size: w
        }
    }
    draw() {
        const t = this._cachedMeta
          , i = t.vScale
          , s = t.data
          , u = s.length;
        let d = 0;
        for (; d < u; ++d)
            this.getParsed(d)[i.axis] !== null && !s[d].hidden && s[d].draw(this._ctx)
    }
}
class l$ extends rd {
    static id = "bubble";
    static defaults = {
        datasetElementType: !1,
        dataElementType: "point",
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "borderWidth", "radius"]
            }
        }
    };
    static overrides = {
        scales: {
            x: {
                type: "linear"
            },
            y: {
                type: "linear"
            }
        }
    };
    initialize() {
        this.enableOptionSharing = !0,
        super.initialize()
    }
    parsePrimitiveData(t, i, s, u) {
        const d = super.parsePrimitiveData(t, i, s, u);
        for (let f = 0; f < d.length; f++)
            d[f]._custom = this.resolveDataElementOptions(f + s).radius;
        return d
    }
    parseArrayData(t, i, s, u) {
        const d = super.parseArrayData(t, i, s, u);
        for (let f = 0; f < d.length; f++) {
            const o = i[s + f];
            d[f]._custom = zn(o[2], this.resolveDataElementOptions(f + s).radius)
        }
        return d
    }
    parseObjectData(t, i, s, u) {
        const d = super.parseObjectData(t, i, s, u);
        for (let f = 0; f < d.length; f++) {
            const o = i[s + f];
            d[f]._custom = zn(o && o.r && +o.r, this.resolveDataElementOptions(f + s).radius)
        }
        return d
    }
    getMaxOverflow() {
        const t = this._cachedMeta.data;
        let i = 0;
        for (let s = t.length - 1; s >= 0; --s)
            i = Math.max(i, t[s].size(this.resolveDataElementOptions(s)) / 2);
        return i > 0 && i
    }
    getLabelAndValue(t) {
        const i = this._cachedMeta
          , s = this.chart.data.labels || []
          , {xScale: u, yScale: d} = i
          , f = this.getParsed(t)
          , o = u.getLabelForValue(f.x)
          , w = d.getLabelForValue(f.y)
          , T = f._custom;
        return {
            label: s[t] || "",
            value: "(" + o + ", " + w + (T ? ", " + T : "") + ")"
        }
    }
    update(t) {
        const i = this._cachedMeta.data;
        this.updateElements(i, 0, i.length, t)
    }
    updateElements(t, i, s, u) {
        const d = u === "reset"
          , {iScale: f, vScale: o} = this._cachedMeta
          , {sharedOptions: w, includeOptions: T} = this._getSharedOptions(i, u)
          , k = f.axis
          , L = o.axis;
        for (let z = i; z < i + s; z++) {
            const D = t[z]
              , N = !d && this.getParsed(z)
              , U = {}
              , V = U[k] = d ? f.getPixelForDecimal(.5) : f.getPixelForValue(N[k])
              , re = U[L] = d ? o.getBasePixel() : o.getPixelForValue(N[L]);
            U.skip = isNaN(V) || isNaN(re),
            T && (U.options = w || this.resolveDataElementOptions(z, D.active ? "active" : u),
            d && (U.options.radius = 0)),
            this.updateElement(D, z, U, u)
        }
    }
    resolveDataElementOptions(t, i) {
        const s = this.getParsed(t);
        let u = super.resolveDataElementOptions(t, i);
        u.$shared && (u = Object.assign({}, u, {
            $shared: !1
        }));
        const d = u.radius;
        return i !== "active" && (u.radius = 0),
        u.radius += zn(s && s._custom, d),
        u
    }
}
function c$(e, t, i) {
    let s = 1
      , u = 1
      , d = 0
      , f = 0;
    if (t < Bs) {
        const o = e
          , w = o + t
          , T = Math.cos(o)
          , k = Math.sin(o)
          , L = Math.cos(w)
          , z = Math.sin(w)
          , D = (ue, ce, X) => nv(ue, o, w, !0) ? 1 : Math.max(ce, ce * i, X, X * i)
          , N = (ue, ce, X) => nv(ue, o, w, !0) ? -1 : Math.min(ce, ce * i, X, X * i)
          , U = D(0, T, L)
          , V = D(Kc, k, z)
          , re = N(vs, T, L)
          , ie = N(vs + Kc, k, z);
        s = (U - re) / 2,
        u = (V - ie) / 2,
        d = -(U + re) / 2,
        f = -(V + ie) / 2
    }
    return {
        ratioX: s,
        ratioY: u,
        offsetX: d,
        offsetY: f
    }
}
class JP extends rd {
    static id = "doughnut";
    static defaults = {
        datasetElementType: !1,
        dataElementType: "arc",
        animation: {
            animateRotate: !0,
            animateScale: !1
        },
        animations: {
            numbers: {
                type: "number",
                properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
            }
        },
        cutout: "50%",
        rotation: 0,
        circumference: 360,
        radius: "100%",
        spacing: 0,
        indexAxis: "r"
    };
    static descriptors = {
        _scriptable: t => t !== "spacing",
        _indexable: t => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
    };
    static overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels(t) {
                        const i = t.data;
                        if (i.labels.length && i.datasets.length) {
                            const {labels: {pointStyle: s, color: u}} = t.legend.options;
                            return i.labels.map( (d, f) => {
                                const w = t.getDatasetMeta(0).controller.getStyle(f);
                                return {
                                    text: d,
                                    fillStyle: w.backgroundColor,
                                    strokeStyle: w.borderColor,
                                    fontColor: u,
                                    lineWidth: w.borderWidth,
                                    pointStyle: s,
                                    hidden: !t.getDataVisibility(f),
                                    index: f
                                }
                            }
                            )
                        }
                        return []
                    }
                },
                onClick(t, i, s) {
                    s.chart.toggleDataVisibility(i.index),
                    s.chart.update()
                }
            }
        }
    };
    constructor(t, i) {
        super(t, i),
        this.enableOptionSharing = !0,
        this.innerRadius = void 0,
        this.outerRadius = void 0,
        this.offsetX = void 0,
        this.offsetY = void 0
    }
    linkScales() {}
    parse(t, i) {
        const s = this.getDataset().data
          , u = this._cachedMeta;
        if (this._parsing === !1)
            u._parsed = s;
        else {
            let d = w => +s[w];
            if (Cn(s[t])) {
                const {key: w="value"} = this._parsing;
                d = T => +Qh(s[T], w)
            }
            let f, o;
            for (f = t,
            o = t + i; f < o; ++f)
                u._parsed[f] = d(f)
        }
    }
    _getRotation() {
        return Qc(this.options.rotation - 90)
    }
    _getCircumference() {
        return Qc(this.options.circumference)
    }
    _getRotationExtents() {
        let t = Bs
          , i = -Bs;
        for (let s = 0; s < this.chart.data.datasets.length; ++s)
            if (this.chart.isDatasetVisible(s) && this.chart.getDatasetMeta(s).type === this._type) {
                const u = this.chart.getDatasetMeta(s).controller
                  , d = u._getRotation()
                  , f = u._getCircumference();
                t = Math.min(t, d),
                i = Math.max(i, d + f)
            }
        return {
            rotation: t,
            circumference: i - t
        }
    }
    update(t) {
        const i = this.chart
          , {chartArea: s} = i
          , u = this._cachedMeta
          , d = u.data
          , f = this.getMaxBorderWidth() + this.getMaxOffset(d) + this.options.spacing
          , o = Math.max((Math.min(s.width, s.height) - f) / 2, 0)
          , w = Math.min(m4(this.options.cutout, o), 1)
          , T = this._getRingWeight(this.index)
          , {circumference: k, rotation: L} = this._getRotationExtents()
          , {ratioX: z, ratioY: D, offsetX: N, offsetY: U} = c$(L, k, w)
          , V = (s.width - f) / z
          , re = (s.height - f) / D
          , ie = Math.max(Math.min(V, re) / 2, 0)
          , ue = RP(this.options.radius, ie)
          , ce = Math.max(ue * w, 0)
          , X = (ue - ce) / this._getVisibleDatasetWeightTotal();
        this.offsetX = N * ue,
        this.offsetY = U * ue,
        u.total = this.calculateTotal(),
        this.outerRadius = ue - X * this._getRingWeightOffset(this.index),
        this.innerRadius = Math.max(this.outerRadius - X * T, 0),
        this.updateElements(d, 0, d.length, t)
    }
    _circumference(t, i) {
        const s = this.options
          , u = this._cachedMeta
          , d = this._getCircumference();
        return i && s.animation.animateRotate || !this.chart.getDataVisibility(t) || u._parsed[t] === null || u.data[t].hidden ? 0 : this.calculateCircumference(u._parsed[t] * d / Bs)
    }
    updateElements(t, i, s, u) {
        const d = u === "reset"
          , f = this.chart
          , o = f.chartArea
          , T = f.options.animation
          , k = (o.left + o.right) / 2
          , L = (o.top + o.bottom) / 2
          , z = d && T.animateScale
          , D = z ? 0 : this.innerRadius
          , N = z ? 0 : this.outerRadius
          , {sharedOptions: U, includeOptions: V} = this._getSharedOptions(i, u);
        let re = this._getRotation(), ie;
        for (ie = 0; ie < i; ++ie)
            re += this._circumference(ie, d);
        for (ie = i; ie < i + s; ++ie) {
            const ue = this._circumference(ie, d)
              , ce = t[ie]
              , X = {
                x: k + this.offsetX,
                y: L + this.offsetY,
                startAngle: re,
                endAngle: re + ue,
                circumference: ue,
                outerRadius: N,
                innerRadius: D
            };
            V && (X.options = U || this.resolveDataElementOptions(ie, ce.active ? "active" : u)),
            re += ue,
            this.updateElement(ce, ie, X, u)
        }
    }
    calculateTotal() {
        const t = this._cachedMeta
          , i = t.data;
        let s = 0, u;
        for (u = 0; u < i.length; u++) {
            const d = t._parsed[u];
            d !== null && !isNaN(d) && this.chart.getDataVisibility(u) && !i[u].hidden && (s += Math.abs(d))
        }
        return s
    }
    calculateCircumference(t) {
        const i = this._cachedMeta.total;
        return i > 0 && !isNaN(t) ? Bs * (Math.abs(t) / i) : 0
    }
    getLabelAndValue(t) {
        const i = this._cachedMeta
          , s = this.chart
          , u = s.data.labels || []
          , d = kv(i._parsed[t], s.options.locale);
        return {
            label: u[t] || "",
            value: d
        }
    }
    getMaxBorderWidth(t) {
        let i = 0;
        const s = this.chart;
        let u, d, f, o, w;
        if (!t) {
            for (u = 0,
            d = s.data.datasets.length; u < d; ++u)
                if (s.isDatasetVisible(u)) {
                    f = s.getDatasetMeta(u),
                    t = f.data,
                    o = f.controller;
                    break
                }
        }
        if (!t)
            return 0;
        for (u = 0,
        d = t.length; u < d; ++u)
            w = o.resolveDataElementOptions(u),
            w.borderAlign !== "inner" && (i = Math.max(i, w.borderWidth || 0, w.hoverBorderWidth || 0));
        return i
    }
    getMaxOffset(t) {
        let i = 0;
        for (let s = 0, u = t.length; s < u; ++s) {
            const d = this.resolveDataElementOptions(s);
            i = Math.max(i, d.offset || 0, d.hoverOffset || 0)
        }
        return i
    }
    _getRingWeightOffset(t) {
        let i = 0;
        for (let s = 0; s < t; ++s)
            this.chart.isDatasetVisible(s) && (i += this._getRingWeight(s));
        return i
    }
    _getRingWeight(t) {
        return Math.max(zn(this.chart.data.datasets[t].weight, 1), 0)
    }
    _getVisibleDatasetWeightTotal() {
        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
    }
}
class u$ extends rd {
    static id = "line";
    static defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        showLine: !0,
        spanGaps: !1
    };
    static overrides = {
        scales: {
            _index_: {
                type: "category"
            },
            _value_: {
                type: "linear"
            }
        }
    };
    initialize() {
        this.enableOptionSharing = !0,
        this.supportsDecimation = !0,
        super.initialize()
    }
    update(t) {
        const i = this._cachedMeta
          , {dataset: s, data: u=[], _dataset: d} = i
          , f = this.chart._animationsDisabled;
        let {start: o, count: w} = jP(i, u, f);
        this._drawStart = o,
        this._drawCount = w,
        NP(i) && (o = 0,
        w = u.length),
        s._chart = this.chart,
        s._datasetIndex = this.index,
        s._decimated = !!d._decimated,
        s.points = u;
        const T = this.resolveDatasetElementOptions(t);
        this.options.showLine || (T.borderWidth = 0),
        T.segment = this.options.segment,
        this.updateElement(s, void 0, {
            animated: !f,
            options: T
        }, t),
        this.updateElements(u, o, w, t)
    }
    updateElements(t, i, s, u) {
        const d = u === "reset"
          , {iScale: f, vScale: o, _stacked: w, _dataset: T} = this._cachedMeta
          , {sharedOptions: k, includeOptions: L} = this._getSharedOptions(i, u)
          , z = f.axis
          , D = o.axis
          , {spanGaps: N, segment: U} = this.options
          , V = qp(N) ? N : Number.POSITIVE_INFINITY
          , re = this.chart._animationsDisabled || d || u === "none"
          , ie = i + s
          , ue = t.length;
        let ce = i > 0 && this.getParsed(i - 1);
        for (let X = 0; X < ue; ++X) {
            const me = t[X]
              , K = re ? me : {};
            if (X < i || X >= ie) {
                K.skip = !0;
                continue
            }
            const be = this.getParsed(X)
              , Ee = li(be[D])
              , Ce = K[z] = f.getPixelForValue(be[z], X)
              , He = K[D] = d || Ee ? o.getBasePixel() : o.getPixelForValue(w ? this.applyStack(o, be, w) : be[D], X);
            K.skip = isNaN(Ce) || isNaN(He) || Ee,
            K.stop = X > 0 && Math.abs(be[z] - ce[z]) > V,
            U && (K.parsed = be,
            K.raw = T.data[X]),
            L && (K.options = k || this.resolveDataElementOptions(X, me.active ? "active" : u)),
            re || this.updateElement(me, X, K, u),
            ce = be
        }
    }
    getMaxOverflow() {
        const t = this._cachedMeta
          , i = t.dataset
          , s = i.options && i.options.borderWidth || 0
          , u = t.data || [];
        if (!u.length)
            return s;
        const d = u[0].size(this.resolveDataElementOptions(0))
          , f = u[u.length - 1].size(this.resolveDataElementOptions(u.length - 1));
        return Math.max(s, d, f) / 2
    }
    draw() {
        const t = this._cachedMeta;
        t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis),
        super.draw()
    }
}
class h$ extends rd {
    static id = "polarArea";
    static defaults = {
        dataElementType: "arc",
        animation: {
            animateRotate: !0,
            animateScale: !0
        },
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
            }
        },
        indexAxis: "r",
        startAngle: 0
    };
    static overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels(t) {
                        const i = t.data;
                        if (i.labels.length && i.datasets.length) {
                            const {labels: {pointStyle: s, color: u}} = t.legend.options;
                            return i.labels.map( (d, f) => {
                                const w = t.getDatasetMeta(0).controller.getStyle(f);
                                return {
                                    text: d,
                                    fillStyle: w.backgroundColor,
                                    strokeStyle: w.borderColor,
                                    fontColor: u,
                                    lineWidth: w.borderWidth,
                                    pointStyle: s,
                                    hidden: !t.getDataVisibility(f),
                                    index: f
                                }
                            }
                            )
                        }
                        return []
                    }
                },
                onClick(t, i, s) {
                    s.chart.toggleDataVisibility(i.index),
                    s.chart.update()
                }
            }
        },
        scales: {
            r: {
                type: "radialLinear",
                angleLines: {
                    display: !1
                },
                beginAtZero: !0,
                grid: {
                    circular: !0
                },
                pointLabels: {
                    display: !1
                },
                startAngle: 0
            }
        }
    };
    constructor(t, i) {
        super(t, i),
        this.innerRadius = void 0,
        this.outerRadius = void 0
    }
    getLabelAndValue(t) {
        const i = this._cachedMeta
          , s = this.chart
          , u = s.data.labels || []
          , d = kv(i._parsed[t].r, s.options.locale);
        return {
            label: u[t] || "",
            value: d
        }
    }
    parseObjectData(t, i, s, u) {
        return qP.bind(this)(t, i, s, u)
    }
    update(t) {
        const i = this._cachedMeta.data;
        this._updateRadius(),
        this.updateElements(i, 0, i.length, t)
    }
    getMinMax() {
        const t = this._cachedMeta
          , i = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        };
        return t.data.forEach( (s, u) => {
            const d = this.getParsed(u).r;
            !isNaN(d) && this.chart.getDataVisibility(u) && (d < i.min && (i.min = d),
            d > i.max && (i.max = d))
        }
        ),
        i
    }
    _updateRadius() {
        const t = this.chart
          , i = t.chartArea
          , s = t.options
          , u = Math.min(i.right - i.left, i.bottom - i.top)
          , d = Math.max(u / 2, 0)
          , f = Math.max(s.cutoutPercentage ? d / 100 * s.cutoutPercentage : 1, 0)
          , o = (d - f) / t.getVisibleDatasetCount();
        this.outerRadius = d - o * this.index,
        this.innerRadius = this.outerRadius - o
    }
    updateElements(t, i, s, u) {
        const d = u === "reset"
          , f = this.chart
          , w = f.options.animation
          , T = this._cachedMeta.rScale
          , k = T.xCenter
          , L = T.yCenter
          , z = T.getIndexAngle(0) - .5 * vs;
        let D = z, N;
        const U = 360 / this.countVisibleElements();
        for (N = 0; N < i; ++N)
            D += this._computeAngle(N, u, U);
        for (N = i; N < i + s; N++) {
            const V = t[N];
            let re = D
              , ie = D + this._computeAngle(N, u, U)
              , ue = f.getDataVisibility(N) ? T.getDistanceFromCenterForValue(this.getParsed(N).r) : 0;
            D = ie,
            d && (w.animateScale && (ue = 0),
            w.animateRotate && (re = ie = z));
            const ce = {
                x: k,
                y: L,
                innerRadius: 0,
                outerRadius: ue,
                startAngle: re,
                endAngle: ie,
                options: this.resolveDataElementOptions(N, V.active ? "active" : u)
            };
            this.updateElement(V, N, ce, u)
        }
    }
    countVisibleElements() {
        const t = this._cachedMeta;
        let i = 0;
        return t.data.forEach( (s, u) => {
            !isNaN(this.getParsed(u).r) && this.chart.getDataVisibility(u) && i++
        }
        ),
        i
    }
    _computeAngle(t, i, s) {
        return this.chart.getDataVisibility(t) ? Qc(this.resolveDataElementOptions(t, i).angle || s) : 0
    }
}
class d$ extends JP {
    static id = "pie";
    static defaults = {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: "100%"
    }
}
class f$ extends rd {
    static id = "radar";
    static defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        indexAxis: "r",
        showLine: !0,
        elements: {
            line: {
                fill: "start"
            }
        }
    };
    static overrides = {
        aspectRatio: 1,
        scales: {
            r: {
                type: "radialLinear"
            }
        }
    };
    getLabelAndValue(t) {
        const i = this._cachedMeta.vScale
          , s = this.getParsed(t);
        return {
            label: i.getLabels()[t],
            value: "" + i.getLabelForValue(s[i.axis])
        }
    }
    parseObjectData(t, i, s, u) {
        return qP.bind(this)(t, i, s, u)
    }
    update(t) {
        const i = this._cachedMeta
          , s = i.dataset
          , u = i.data || []
          , d = i.iScale.getLabels();
        if (s.points = u,
        t !== "resize") {
            const f = this.resolveDatasetElementOptions(t);
            this.options.showLine || (f.borderWidth = 0);
            const o = {
                _loop: !0,
                _fullLoop: d.length === u.length,
                options: f
            };
            this.updateElement(s, void 0, o, t)
        }
        this.updateElements(u, 0, u.length, t)
    }
    updateElements(t, i, s, u) {
        const d = this._cachedMeta.rScale
          , f = u === "reset";
        for (let o = i; o < i + s; o++) {
            const w = t[o]
              , T = this.resolveDataElementOptions(o, w.active ? "active" : u)
              , k = d.getPointPositionForValue(o, this.getParsed(o).r)
              , L = f ? d.xCenter : k.x
              , z = f ? d.yCenter : k.y
              , D = {
                x: L,
                y: z,
                angle: k.angle,
                skip: isNaN(L) || isNaN(z),
                options: T
            };
            this.updateElement(w, o, D, u)
        }
    }
}
class p$ extends rd {
    static id = "scatter";
    static defaults = {
        datasetElementType: !1,
        dataElementType: "point",
        showLine: !1,
        fill: !1
    };
    static overrides = {
        interaction: {
            mode: "point"
        },
        scales: {
            x: {
                type: "linear"
            },
            y: {
                type: "linear"
            }
        }
    };
    getLabelAndValue(t) {
        const i = this._cachedMeta
          , s = this.chart.data.labels || []
          , {xScale: u, yScale: d} = i
          , f = this.getParsed(t)
          , o = u.getLabelForValue(f.x)
          , w = d.getLabelForValue(f.y);
        return {
            label: s[t] || "",
            value: "(" + o + ", " + w + ")"
        }
    }
    update(t) {
        const i = this._cachedMeta
          , {data: s=[]} = i
          , u = this.chart._animationsDisabled;
        let {start: d, count: f} = jP(i, s, u);
        if (this._drawStart = d,
        this._drawCount = f,
        NP(i) && (d = 0,
        f = s.length),
        this.options.showLine) {
            this.datasetElementType || this.addElements();
            const {dataset: o, _dataset: w} = i;
            o._chart = this.chart,
            o._datasetIndex = this.index,
            o._decimated = !!w._decimated,
            o.points = s;
            const T = this.resolveDatasetElementOptions(t);
            T.segment = this.options.segment,
            this.updateElement(o, void 0, {
                animated: !u,
                options: T
            }, t)
        } else
            this.datasetElementType && (delete i.dataset,
            this.datasetElementType = !1);
        this.updateElements(s, d, f, t)
    }
    addElements() {
        const {showLine: t} = this.options;
        !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement("line")),
        super.addElements()
    }
    updateElements(t, i, s, u) {
        const d = u === "reset"
          , {iScale: f, vScale: o, _stacked: w, _dataset: T} = this._cachedMeta
          , k = this.resolveDataElementOptions(i, u)
          , L = this.getSharedOptions(k)
          , z = this.includeOptions(u, L)
          , D = f.axis
          , N = o.axis
          , {spanGaps: U, segment: V} = this.options
          , re = qp(U) ? U : Number.POSITIVE_INFINITY
          , ie = this.chart._animationsDisabled || d || u === "none";
        let ue = i > 0 && this.getParsed(i - 1);
        for (let ce = i; ce < i + s; ++ce) {
            const X = t[ce]
              , me = this.getParsed(ce)
              , K = ie ? X : {}
              , be = li(me[N])
              , Ee = K[D] = f.getPixelForValue(me[D], ce)
              , Ce = K[N] = d || be ? o.getBasePixel() : o.getPixelForValue(w ? this.applyStack(o, me, w) : me[N], ce);
            K.skip = isNaN(Ee) || isNaN(Ce) || be,
            K.stop = ce > 0 && Math.abs(me[D] - ue[D]) > re,
            V && (K.parsed = me,
            K.raw = T.data[ce]),
            z && (K.options = L || this.resolveDataElementOptions(ce, X.active ? "active" : u)),
            ie || this.updateElement(X, ce, K, u),
            ue = me
        }
        this.updateSharedOptions(L, u, k)
    }
    getMaxOverflow() {
        const t = this._cachedMeta
          , i = t.data || [];
        if (!this.options.showLine) {
            let o = 0;
            for (let w = i.length - 1; w >= 0; --w)
                o = Math.max(o, i[w].size(this.resolveDataElementOptions(w)) / 2);
            return o > 0 && o
        }
        const s = t.dataset
          , u = s.options && s.options.borderWidth || 0;
        if (!i.length)
            return u;
        const d = i[0].size(this.resolveDataElementOptions(0))
          , f = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1));
        return Math.max(u, d, f) / 2
    }
}
function tf() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
}
class Pb {
    static override(t) {
        Object.assign(Pb.prototype, t)
    }
    options;
    constructor(t) {
        this.options = t || {}
    }
    init() {}
    formats() {
        return tf()
    }
    parse() {
        return tf()
    }
    format() {
        return tf()
    }
    add() {
        return tf()
    }
    diff() {
        return tf()
    }
    startOf() {
        return tf()
    }
    endOf() {
        return tf()
    }
}
var m$ = {
    _date: Pb
};
function g$(e, t, i, s) {
    const {controller: u, data: d, _sorted: f} = e
      , o = u._cachedMeta.iScale;
    if (o && t === o.axis && t !== "r" && f && d.length) {
        const w = o._reversePixels ? I4 : ff;
        if (s) {
            if (u._sharedOptions) {
                const T = d[0]
                  , k = typeof T.getRange == "function" && T.getRange(t);
                if (k) {
                    const L = w(d, t, i - k)
                      , z = w(d, t, i + k);
                    return {
                        lo: L.lo,
                        hi: z.hi
                    }
                }
            }
        } else
            return w(d, t, i)
    }
    return {
        lo: 0,
        hi: d.length - 1
    }
}
function Iv(e, t, i, s, u) {
    const d = e.getSortedVisibleDatasetMetas()
      , f = i[t];
    for (let o = 0, w = d.length; o < w; ++o) {
        const {index: T, data: k} = d[o]
          , {lo: L, hi: z} = g$(d[o], t, f, u);
        for (let D = L; D <= z; ++D) {
            const N = k[D];
            N.skip || s(N, T, D)
        }
    }
}
function y$(e) {
    const t = e.indexOf("x") !== -1
      , i = e.indexOf("y") !== -1;
    return function(s, u) {
        const d = t ? Math.abs(s.x - u.x) : 0
          , f = i ? Math.abs(s.y - u.y) : 0;
        return Math.sqrt(Math.pow(d, 2) + Math.pow(f, 2))
    }
}
function $0(e, t, i, s, u) {
    const d = [];
    return !u && !e.isPointInArea(t) || Iv(e, i, t, function(o, w, T) {
        !u && !ty(o, e.chartArea, 0) || o.inRange(t.x, t.y, s) && d.push({
            element: o,
            datasetIndex: w,
            index: T
        })
    }, !0),
    d
}
function _$(e, t, i, s) {
    let u = [];
    function d(f, o, w) {
        const {startAngle: T, endAngle: k} = f.getProps(["startAngle", "endAngle"], s)
          , {angle: L} = M4(f, {
            x: t.x,
            y: t.y
        });
        nv(L, T, k) && u.push({
            element: f,
            datasetIndex: o,
            index: w
        })
    }
    return Iv(e, i, t, d),
    u
}
function v$(e, t, i, s, u, d) {
    let f = [];
    const o = y$(i);
    let w = Number.POSITIVE_INFINITY;
    function T(k, L, z) {
        const D = k.inRange(t.x, t.y, u);
        if (s && !D)
            return;
        const N = k.getCenterPoint(u);
        if (!(!!d || e.isPointInArea(N)) && !D)
            return;
        const V = o(t, N);
        V < w ? (f = [{
            element: k,
            datasetIndex: L,
            index: z
        }],
        w = V) : V === w && f.push({
            element: k,
            datasetIndex: L,
            index: z
        })
    }
    return Iv(e, i, t, T),
    f
}
function V0(e, t, i, s, u, d) {
    return !d && !e.isPointInArea(t) ? [] : i === "r" && !s ? _$(e, t, i, u) : v$(e, t, i, s, u, d)
}
function _2(e, t, i, s, u) {
    const d = []
      , f = i === "x" ? "inXRange" : "inYRange";
    let o = !1;
    return Iv(e, i, t, (w, T, k) => {
        w[f] && w[f](t[i], u) && (d.push({
            element: w,
            datasetIndex: T,
            index: k
        }),
        o = o || w.inRange(t.x, t.y, u))
    }
    ),
    s && !o ? [] : d
}
var x$ = {
    modes: {
        index(e, t, i, s) {
            const u = sf(t, e)
              , d = i.axis || "x"
              , f = i.includeInvisible || !1
              , o = i.intersect ? $0(e, u, d, s, f) : V0(e, u, d, !1, s, f)
              , w = [];
            return o.length ? (e.getSortedVisibleDatasetMetas().forEach(T => {
                const k = o[0].index
                  , L = T.data[k];
                L && !L.skip && w.push({
                    element: L,
                    datasetIndex: T.index,
                    index: k
                })
            }
            ),
            w) : []
        },
        dataset(e, t, i, s) {
            const u = sf(t, e)
              , d = i.axis || "xy"
              , f = i.includeInvisible || !1;
            let o = i.intersect ? $0(e, u, d, s, f) : V0(e, u, d, !1, s, f);
            if (o.length > 0) {
                const w = o[0].datasetIndex
                  , T = e.getDatasetMeta(w).data;
                o = [];
                for (let k = 0; k < T.length; ++k)
                    o.push({
                        element: T[k],
                        datasetIndex: w,
                        index: k
                    })
            }
            return o
        },
        point(e, t, i, s) {
            const u = sf(t, e)
              , d = i.axis || "xy"
              , f = i.includeInvisible || !1;
            return $0(e, u, d, s, f)
        },
        nearest(e, t, i, s) {
            const u = sf(t, e)
              , d = i.axis || "xy"
              , f = i.includeInvisible || !1;
            return V0(e, u, d, i.intersect, s, f)
        },
        x(e, t, i, s) {
            const u = sf(t, e);
            return _2(e, u, "x", i.intersect, s)
        },
        y(e, t, i, s) {
            const u = sf(t, e);
            return _2(e, u, "y", i.intersect, s)
        }
    }
};
const eM = ["left", "top", "right", "bottom"];
function fg(e, t) {
    return e.filter(i => i.pos === t)
}
function v2(e, t) {
    return e.filter(i => eM.indexOf(i.pos) === -1 && i.box.axis === t)
}
function pg(e, t) {
    return e.sort( (i, s) => {
        const u = t ? s : i
          , d = t ? i : s;
        return u.weight === d.weight ? u.index - d.index : u.weight - d.weight
    }
    )
}
function b$(e) {
    const t = [];
    let i, s, u, d, f, o;
    for (i = 0,
    s = (e || []).length; i < s; ++i)
        u = e[i],
        {position: d, options: {stack: f, stackWeight: o=1}} = u,
        t.push({
            index: i,
            box: u,
            pos: d,
            horizontal: u.isHorizontal(),
            weight: u.weight,
            stack: f && d + f,
            stackWeight: o
        });
    return t
}
function w$(e) {
    const t = {};
    for (const i of e) {
        const {stack: s, pos: u, stackWeight: d} = i;
        if (!s || !eM.includes(u))
            continue;
        const f = t[s] || (t[s] = {
            count: 0,
            placed: 0,
            weight: 0,
            size: 0
        });
        f.count++,
        f.weight += d
    }
    return t
}
function S$(e, t) {
    const i = w$(e)
      , {vBoxMaxWidth: s, hBoxMaxHeight: u} = t;
    let d, f, o;
    for (d = 0,
    f = e.length; d < f; ++d) {
        o = e[d];
        const {fullSize: w} = o.box
          , T = i[o.stack]
          , k = T && o.stackWeight / T.weight;
        o.horizontal ? (o.width = k ? k * s : w && t.availableWidth,
        o.height = u) : (o.width = s,
        o.height = k ? k * u : w && t.availableHeight)
    }
    return i
}
function C$(e) {
    const t = b$(e)
      , i = pg(t.filter(T => T.box.fullSize), !0)
      , s = pg(fg(t, "left"), !0)
      , u = pg(fg(t, "right"))
      , d = pg(fg(t, "top"), !0)
      , f = pg(fg(t, "bottom"))
      , o = v2(t, "x")
      , w = v2(t, "y");
    return {
        fullSize: i,
        leftAndTop: s.concat(d),
        rightAndBottom: u.concat(w).concat(f).concat(o),
        chartArea: fg(t, "chartArea"),
        vertical: s.concat(u).concat(w),
        horizontal: d.concat(f).concat(o)
    }
}
function x2(e, t, i, s) {
    return Math.max(e[i], t[i]) + Math.max(e[s], t[s])
}
function tM(e, t) {
    e.top = Math.max(e.top, t.top),
    e.left = Math.max(e.left, t.left),
    e.bottom = Math.max(e.bottom, t.bottom),
    e.right = Math.max(e.right, t.right)
}
function T$(e, t, i, s) {
    const {pos: u, box: d} = i
      , f = e.maxPadding;
    if (!Cn(u)) {
        i.size && (e[u] -= i.size);
        const L = s[i.stack] || {
            size: 0,
            count: 1
        };
        L.size = Math.max(L.size, i.horizontal ? d.height : d.width),
        i.size = L.size / L.count,
        e[u] += i.size
    }
    d.getPadding && tM(f, d.getPadding());
    const o = Math.max(0, t.outerWidth - x2(f, e, "left", "right"))
      , w = Math.max(0, t.outerHeight - x2(f, e, "top", "bottom"))
      , T = o !== e.w
      , k = w !== e.h;
    return e.w = o,
    e.h = w,
    i.horizontal ? {
        same: T,
        other: k
    } : {
        same: k,
        other: T
    }
}
function P$(e) {
    const t = e.maxPadding;
    function i(s) {
        const u = Math.max(t[s] - e[s], 0);
        return e[s] += u,
        u
    }
    e.y += i("top"),
    e.x += i("left"),
    i("right"),
    i("bottom")
}
function M$(e, t) {
    const i = t.maxPadding;
    function s(u) {
        const d = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
        return u.forEach(f => {
            d[f] = Math.max(t[f], i[f])
        }
        ),
        d
    }
    return s(e ? ["left", "right"] : ["top", "bottom"])
}
function Ig(e, t, i, s) {
    const u = [];
    let d, f, o, w, T, k;
    for (d = 0,
    f = e.length,
    T = 0; d < f; ++d) {
        o = e[d],
        w = o.box,
        w.update(o.width || t.w, o.height || t.h, M$(o.horizontal, t));
        const {same: L, other: z} = T$(t, i, o, s);
        T |= L && u.length,
        k = k || z,
        w.fullSize || u.push(o)
    }
    return T && Ig(u, t, i, s) || k
}
function S_(e, t, i, s, u) {
    e.top = i,
    e.left = t,
    e.right = t + s,
    e.bottom = i + u,
    e.width = s,
    e.height = u
}
function b2(e, t, i, s) {
    const u = i.padding;
    let {x: d, y: f} = t;
    for (const o of e) {
        const w = o.box
          , T = s[o.stack] || {
            placed: 0,
            weight: 1
        }
          , k = o.stackWeight / T.weight || 1;
        if (o.horizontal) {
            const L = t.w * k
              , z = T.size || w.height;
            ey(T.start) && (f = T.start),
            w.fullSize ? S_(w, u.left, f, i.outerWidth - u.right - u.left, z) : S_(w, t.left + T.placed, f, L, z),
            T.start = f,
            T.placed += L,
            f = w.bottom
        } else {
            const L = t.h * k
              , z = T.size || w.width;
            ey(T.start) && (d = T.start),
            w.fullSize ? S_(w, d, u.top, z, i.outerHeight - u.bottom - u.top) : S_(w, d, t.top + T.placed, z, L),
            T.start = d,
            T.placed += L,
            d = w.right
        }
    }
    t.x = d,
    t.y = f
}
var C_ = {
    addBox(e, t) {
        e.boxes || (e.boxes = []),
        t.fullSize = t.fullSize || !1,
        t.position = t.position || "top",
        t.weight = t.weight || 0,
        t._layers = t._layers || function() {
            return [{
                z: 0,
                draw(i) {
                    t.draw(i)
                }
            }]
        }
        ,
        e.boxes.push(t)
    },
    removeBox(e, t) {
        const i = e.boxes ? e.boxes.indexOf(t) : -1;
        i !== -1 && e.boxes.splice(i, 1)
    },
    configure(e, t, i) {
        t.fullSize = i.fullSize,
        t.position = i.position,
        t.weight = i.weight
    },
    update(e, t, i, s) {
        if (!e)
            return;
        const u = ry(e.options.layout.padding)
          , d = Math.max(t - u.width, 0)
          , f = Math.max(i - u.height, 0)
          , o = C$(e.boxes)
          , w = o.vertical
          , T = o.horizontal;
        ys(e.boxes, U => {
            typeof U.beforeLayout == "function" && U.beforeLayout()
        }
        );
        const k = w.reduce( (U, V) => V.box.options && V.box.options.display === !1 ? U : U + 1, 0) || 1
          , L = Object.freeze({
            outerWidth: t,
            outerHeight: i,
            padding: u,
            availableWidth: d,
            availableHeight: f,
            vBoxMaxWidth: d / 2 / k,
            hBoxMaxHeight: f / 2
        })
          , z = Object.assign({}, u);
        tM(z, ry(s));
        const D = Object.assign({
            maxPadding: z,
            w: d,
            h: f,
            x: u.left,
            y: u.top
        }, u)
          , N = S$(w.concat(T), L);
        Ig(o.fullSize, D, L, N),
        Ig(w, D, L, N),
        Ig(T, D, L, N) && Ig(w, D, L, N),
        P$(D),
        b2(o.leftAndTop, D, L, N),
        D.x += D.w,
        D.y += D.h,
        b2(o.rightAndBottom, D, L, N),
        e.chartArea = {
            left: D.left,
            top: D.top,
            right: D.left + D.w,
            bottom: D.top + D.h,
            height: D.h,
            width: D.w
        },
        ys(o.chartArea, U => {
            const V = U.box;
            Object.assign(V, e.chartArea),
            V.update(D.w, D.h, {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            })
        }
        )
    }
};
class rM {
    acquireContext(t, i) {}
    releaseContext(t) {
        return !1
    }
    addEventListener(t, i, s) {}
    removeEventListener(t, i, s) {}
    getDevicePixelRatio() {
        return 1
    }
    getMaximumSize(t, i, s, u) {
        return i = Math.max(0, i || t.width),
        s = s || t.height,
        {
            width: i,
            height: Math.max(0, u ? Math.floor(i / u) : s)
        }
    }
    isAttached(t) {
        return !0
    }
    updateConfig(t) {}
}
class k$ extends rM {
    acquireContext(t) {
        return t && t.getContext && t.getContext("2d") || null
    }
    updateConfig(t) {
        t.options.animation = !1
    }
}
const N_ = "$chartjs"
  , E$ = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
}
  , w2 = e => e === null || e === "";
function I$(e, t) {
    const i = e.style
      , s = e.getAttribute("height")
      , u = e.getAttribute("width");
    if (e[N_] = {
        initial: {
            height: s,
            width: u,
            style: {
                display: i.display,
                height: i.height,
                width: i.width
            }
        }
    },
    i.display = i.display || "block",
    i.boxSizing = i.boxSizing || "border-box",
    w2(u)) {
        const d = o2(e, "width");
        d !== void 0 && (e.width = d)
    }
    if (w2(s))
        if (e.style.height === "")
            e.height = e.width / (t || 2);
        else {
            const d = o2(e, "height");
            d !== void 0 && (e.height = d)
        }
    return e
}
const nM = MN ? {
    passive: !0
} : !1;
function R$(e, t, i) {
    e && e.addEventListener(t, i, nM)
}
function A$(e, t, i) {
    e && e.canvas && e.canvas.removeEventListener(t, i, nM)
}
function z$(e, t) {
    const i = E$[e.type] || e.type
      , {x: s, y: u} = sf(e, t);
    return {
        type: i,
        chart: t,
        native: e,
        x: s !== void 0 ? s : null,
        y: u !== void 0 ? u : null
    }
}
function ov(e, t) {
    for (const i of e)
        if (i === t || i.contains(t))
            return !0
}
function D$(e, t, i) {
    const s = e.canvas
      , u = new MutationObserver(d => {
        let f = !1;
        for (const o of d)
            f = f || ov(o.addedNodes, s),
            f = f && !ov(o.removedNodes, s);
        f && i()
    }
    );
    return u.observe(document, {
        childList: !0,
        subtree: !0
    }),
    u
}
function L$(e, t, i) {
    const s = e.canvas
      , u = new MutationObserver(d => {
        let f = !1;
        for (const o of d)
            f = f || ov(o.removedNodes, s),
            f = f && !ov(o.addedNodes, s);
        f && i()
    }
    );
    return u.observe(document, {
        childList: !0,
        subtree: !0
    }),
    u
}
const ny = new Map;
let S2 = 0;
function iM() {
    const e = window.devicePixelRatio;
    e !== S2 && (S2 = e,
    ny.forEach( (t, i) => {
        i.currentDevicePixelRatio !== e && t()
    }
    ))
}
function O$(e, t) {
    ny.size || window.addEventListener("resize", iM),
    ny.set(e, t)
}
function F$(e) {
    ny.delete(e),
    ny.size || window.removeEventListener("resize", iM)
}
function B$(e, t, i) {
    const s = e.canvas
      , u = s && Tb(s);
    if (!u)
        return;
    const d = BP( (o, w) => {
        const T = u.clientWidth;
        i(o, w),
        T < u.clientWidth && i()
    }
    , window)
      , f = new ResizeObserver(o => {
        const w = o[0]
          , T = w.contentRect.width
          , k = w.contentRect.height;
        T === 0 && k === 0 || d(T, k)
    }
    );
    return f.observe(u),
    O$(e, d),
    f
}
function U0(e, t, i) {
    i && i.disconnect(),
    t === "resize" && F$(e)
}
function j$(e, t, i) {
    const s = e.canvas
      , u = BP(d => {
        e.ctx !== null && i(z$(d, e))
    }
    , e);
    return R$(s, t, u),
    u
}
class N$ extends rM {
    acquireContext(t, i) {
        const s = t && t.getContext && t.getContext("2d");
        return s && s.canvas === t ? (I$(t, i),
        s) : null
    }
    releaseContext(t) {
        const i = t.canvas;
        if (!i[N_])
            return !1;
        const s = i[N_].initial;
        ["height", "width"].forEach(d => {
            const f = s[d];
            li(f) ? i.removeAttribute(d) : i.setAttribute(d, f)
        }
        );
        const u = s.style || {};
        return Object.keys(u).forEach(d => {
            i.style[d] = u[d]
        }
        ),
        i.width = i.width,
        delete i[N_],
        !0
    }
    addEventListener(t, i, s) {
        this.removeEventListener(t, i);
        const u = t.$proxies || (t.$proxies = {})
          , f = {
            attach: D$,
            detach: L$,
            resize: B$
        }[i] || j$;
        u[i] = f(t, i, s)
    }
    removeEventListener(t, i) {
        const s = t.$proxies || (t.$proxies = {})
          , u = s[i];
        if (!u)
            return;
        ({
            attach: U0,
            detach: U0,
            resize: U0
        }[i] || A$)(t, i, u),
        s[i] = void 0
    }
    getDevicePixelRatio() {
        return window.devicePixelRatio
    }
    getMaximumSize(t, i, s, u) {
        return PN(t, i, s, u)
    }
    isAttached(t) {
        const i = t && Tb(t);
        return !!(i && i.isConnected)
    }
}
function $$(e) {
    return !Cb() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? k$ : N$
}
let Rv = class {
    static defaults = {};
    static defaultRoutes = void 0;
    x;
    y;
    active = !1;
    options;
    $animations;
    tooltipPosition(t) {
        const {x: i, y: s} = this.getProps(["x", "y"], t);
        return {
            x: i,
            y: s
        }
    }
    hasValue() {
        return qp(this.x) && qp(this.y)
    }
    getProps(t, i) {
        const s = this.$animations;
        if (!i || !s)
            return this;
        const u = {};
        return t.forEach(d => {
            u[d] = s[d] && s[d].active() ? s[d]._to : this[d]
        }
        ),
        u
    }
}
;
function V$(e, t) {
    const i = e.options.ticks
      , s = U$(e)
      , u = Math.min(i.maxTicksLimit || s, s)
      , d = i.major.enabled ? W$(t) : []
      , f = d.length
      , o = d[0]
      , w = d[f - 1]
      , T = [];
    if (f > u)
        return q$(t, T, d, f / u),
        T;
    const k = G$(d, t, u);
    if (f > 0) {
        let L, z;
        const D = f > 1 ? Math.round((w - o) / (f - 1)) : null;
        for (T_(t, T, k, li(D) ? 0 : o - D, o),
        L = 0,
        z = f - 1; L < z; L++)
            T_(t, T, k, d[L], d[L + 1]);
        return T_(t, T, k, w, li(D) ? t.length : w + D),
        T
    }
    return T_(t, T, k),
    T
}
function U$(e) {
    const t = e.options.offset
      , i = e._tickSize()
      , s = e._length / i + (t ? 0 : 1)
      , u = e._maxLength / i;
    return Math.floor(Math.min(s, u))
}
function G$(e, t, i) {
    const s = H$(e)
      , u = t.length / i;
    if (!s)
        return Math.max(u, 1);
    const d = S4(s);
    for (let f = 0, o = d.length - 1; f < o; f++) {
        const w = d[f];
        if (w > u)
            return w
    }
    return Math.max(u, 1)
}
function W$(e) {
    const t = [];
    let i, s;
    for (i = 0,
    s = e.length; i < s; i++)
        e[i].major && t.push(i);
    return t
}
function q$(e, t, i, s) {
    let u = 0, d = i[0], f;
    for (s = Math.ceil(s),
    f = 0; f < e.length; f++)
        f === d && (t.push(e[f]),
        u++,
        d = i[u * s])
}
function T_(e, t, i, s, u) {
    const d = zn(s, 0)
      , f = Math.min(zn(u, e.length), e.length);
    let o = 0, w, T, k;
    for (i = Math.ceil(i),
    u && (w = u - s,
    i = w / Math.floor(w / i)),
    k = d; k < 0; )
        o++,
        k = Math.round(d + o * i);
    for (T = Math.max(d, 0); T < f; T++)
        T === k && (t.push(e[T]),
        o++,
        k = Math.round(d + o * i))
}
function H$(e) {
    const t = e.length;
    let i, s;
    if (t < 2)
        return !1;
    for (s = e[0],
    i = 1; i < t; ++i)
        if (e[i] - e[i - 1] !== s)
            return !1;
    return s
}
const Z$ = e => e === "left" ? "right" : e === "right" ? "left" : e
  , C2 = (e, t, i) => t === "top" || t === "left" ? e[t] + i : e[t] - i
  , T2 = (e, t) => Math.min(t || e, e);
function P2(e, t) {
    const i = []
      , s = e.length / t
      , u = e.length;
    let d = 0;
    for (; d < u; d += s)
        i.push(e[Math.floor(d)]);
    return i
}
function X$(e, t, i) {
    const s = e.ticks.length
      , u = Math.min(t, s - 1)
      , d = e._startPixel
      , f = e._endPixel
      , o = 1e-6;
    let w = e.getPixelForTick(u), T;
    if (!(i && (s === 1 ? T = Math.max(w - d, f - w) : t === 0 ? T = (e.getPixelForTick(1) - w) / 2 : T = (w - e.getPixelForTick(u - 1)) / 2,
    w += u < t ? T : -T,
    w < d - o || w > f + o)))
        return w
}
function Y$(e, t) {
    ys(e, i => {
        const s = i.gc
          , u = s.length / 2;
        let d;
        if (u > t) {
            for (d = 0; d < u; ++d)
                delete i.data[s[d]];
            s.splice(0, u)
        }
    }
    )
}
function mg(e) {
    return e.drawTicks ? e.tickLength : 0
}
function M2(e, t) {
    if (!e.display)
        return 0;
    const i = yx(e.font, t)
      , s = ry(e.padding);
    return (Vo(e.text) ? e.text.length : 1) * i.lineHeight + s.height
}
function K$(e, t) {
    return tm(e, {
        scale: t,
        type: "scale"
    })
}
function Q$(e, t, i) {
    return tm(e, {
        tick: i,
        index: t,
        type: "tick"
    })
}
function J$(e, t, i) {
    let s = D4(e);
    return (i && t !== "right" || !i && t === "right") && (s = Z$(s)),
    s
}
function e6(e, t, i, s) {
    const {top: u, left: d, bottom: f, right: o, chart: w} = e
      , {chartArea: T, scales: k} = w;
    let L = 0, z, D, N;
    const U = f - u
      , V = o - d;
    if (e.isHorizontal()) {
        if (D = ZS(s, d, o),
        Cn(i)) {
            const re = Object.keys(i)[0]
              , ie = i[re];
            N = k[re].getPixelForValue(ie) + U - t
        } else
            i === "center" ? N = (T.bottom + T.top) / 2 + U - t : N = C2(e, i, t);
        z = o - d
    } else {
        if (Cn(i)) {
            const re = Object.keys(i)[0]
              , ie = i[re];
            D = k[re].getPixelForValue(ie) - V + t
        } else
            i === "center" ? D = (T.left + T.right) / 2 - V + t : D = C2(e, i, t);
        N = ZS(s, f, u),
        L = i === "left" ? -Kc : Kc
    }
    return {
        titleX: D,
        titleY: N,
        maxWidth: z,
        rotation: L
    }
}
class rm extends Rv {
    constructor(t) {
        super(),
        this.id = t.id,
        this.type = t.type,
        this.options = void 0,
        this.ctx = t.ctx,
        this.chart = t.chart,
        this.top = void 0,
        this.bottom = void 0,
        this.left = void 0,
        this.right = void 0,
        this.width = void 0,
        this.height = void 0,
        this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        },
        this.maxWidth = void 0,
        this.maxHeight = void 0,
        this.paddingTop = void 0,
        this.paddingBottom = void 0,
        this.paddingLeft = void 0,
        this.paddingRight = void 0,
        this.axis = void 0,
        this.labelRotation = void 0,
        this.min = void 0,
        this.max = void 0,
        this._range = void 0,
        this.ticks = [],
        this._gridLineItems = null,
        this._labelItems = null,
        this._labelSizes = null,
        this._length = 0,
        this._maxLength = 0,
        this._longestTextCache = {},
        this._startPixel = void 0,
        this._endPixel = void 0,
        this._reversePixels = !1,
        this._userMax = void 0,
        this._userMin = void 0,
        this._suggestedMax = void 0,
        this._suggestedMin = void 0,
        this._ticksLength = 0,
        this._borderValue = 0,
        this._cache = {},
        this._dataLimitsCached = !1,
        this.$context = void 0
    }
    init(t) {
        this.options = t.setContext(this.getContext()),
        this.axis = t.axis,
        this._userMin = this.parse(t.min),
        this._userMax = this.parse(t.max),
        this._suggestedMin = this.parse(t.suggestedMin),
        this._suggestedMax = this.parse(t.suggestedMax)
    }
    parse(t, i) {
        return t
    }
    getUserBounds() {
        let {_userMin: t, _userMax: i, _suggestedMin: s, _suggestedMax: u} = this;
        return t = Wc(t, Number.POSITIVE_INFINITY),
        i = Wc(i, Number.NEGATIVE_INFINITY),
        s = Wc(s, Number.POSITIVE_INFINITY),
        u = Wc(u, Number.NEGATIVE_INFINITY),
        {
            min: Wc(t, s),
            max: Wc(i, u),
            minDefined: _s(t),
            maxDefined: _s(i)
        }
    }
    getMinMax(t) {
        let {min: i, max: s, minDefined: u, maxDefined: d} = this.getUserBounds(), f;
        if (u && d)
            return {
                min: i,
                max: s
            };
        const o = this.getMatchingVisibleMetas();
        for (let w = 0, T = o.length; w < T; ++w)
            f = o[w].controller.getMinMax(this, t),
            u || (i = Math.min(i, f.min)),
            d || (s = Math.max(s, f.max));
        return i = d && i > s ? s : i,
        s = u && i > s ? i : s,
        {
            min: Wc(i, Wc(s, i)),
            max: Wc(s, Wc(i, s))
        }
    }
    getPadding() {
        return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0
        }
    }
    getTicks() {
        return this.ticks
    }
    getLabels() {
        const t = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []
    }
    getLabelItems(t=this.chart.chartArea) {
        return this._labelItems || (this._labelItems = this._computeLabelItems(t))
    }
    beforeLayout() {
        this._cache = {},
        this._dataLimitsCached = !1
    }
    beforeUpdate() {
        Xi(this.options.beforeUpdate, [this])
    }
    update(t, i, s) {
        const {beginAtZero: u, grace: d, ticks: f} = this.options
          , o = f.sampleSize;
        this.beforeUpdate(),
        this.maxWidth = t,
        this.maxHeight = i,
        this._margins = s = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        }, s),
        this.ticks = null,
        this._labelSizes = null,
        this._gridLineItems = null,
        this._labelItems = null,
        this.beforeSetDimensions(),
        this.setDimensions(),
        this.afterSetDimensions(),
        this._maxLength = this.isHorizontal() ? this.width + s.left + s.right : this.height + s.top + s.bottom,
        this._dataLimitsCached || (this.beforeDataLimits(),
        this.determineDataLimits(),
        this.afterDataLimits(),
        this._range = iN(this, d, u),
        this._dataLimitsCached = !0),
        this.beforeBuildTicks(),
        this.ticks = this.buildTicks() || [],
        this.afterBuildTicks();
        const w = o < this.ticks.length;
        this._convertTicksToLabels(w ? P2(this.ticks, o) : this.ticks),
        this.configure(),
        this.beforeCalculateLabelRotation(),
        this.calculateLabelRotation(),
        this.afterCalculateLabelRotation(),
        f.display && (f.autoSkip || f.source === "auto") && (this.ticks = V$(this, this.ticks),
        this._labelSizes = null,
        this.afterAutoSkip()),
        w && this._convertTicksToLabels(this.ticks),
        this.beforeFit(),
        this.fit(),
        this.afterFit(),
        this.afterUpdate()
    }
    configure() {
        let t = this.options.reverse, i, s;
        this.isHorizontal() ? (i = this.left,
        s = this.right) : (i = this.top,
        s = this.bottom,
        t = !t),
        this._startPixel = i,
        this._endPixel = s,
        this._reversePixels = t,
        this._length = s - i,
        this._alignToPixels = this.options.alignToPixels
    }
    afterUpdate() {
        Xi(this.options.afterUpdate, [this])
    }
    beforeSetDimensions() {
        Xi(this.options.beforeSetDimensions, [this])
    }
    setDimensions() {
        this.isHorizontal() ? (this.width = this.maxWidth,
        this.left = 0,
        this.right = this.width) : (this.height = this.maxHeight,
        this.top = 0,
        this.bottom = this.height),
        this.paddingLeft = 0,
        this.paddingTop = 0,
        this.paddingRight = 0,
        this.paddingBottom = 0
    }
    afterSetDimensions() {
        Xi(this.options.afterSetDimensions, [this])
    }
    _callHooks(t) {
        this.chart.notifyPlugins(t, this.getContext()),
        Xi(this.options[t], [this])
    }
    beforeDataLimits() {
        this._callHooks("beforeDataLimits")
    }
    determineDataLimits() {}
    afterDataLimits() {
        this._callHooks("afterDataLimits")
    }
    beforeBuildTicks() {
        this._callHooks("beforeBuildTicks")
    }
    buildTicks() {
        return []
    }
    afterBuildTicks() {
        this._callHooks("afterBuildTicks")
    }
    beforeTickToLabelConversion() {
        Xi(this.options.beforeTickToLabelConversion, [this])
    }
    generateTickLabels(t) {
        const i = this.options.ticks;
        let s, u, d;
        for (s = 0,
        u = t.length; s < u; s++)
            d = t[s],
            d.label = Xi(i.callback, [d.value, s, t], this)
    }
    afterTickToLabelConversion() {
        Xi(this.options.afterTickToLabelConversion, [this])
    }
    beforeCalculateLabelRotation() {
        Xi(this.options.beforeCalculateLabelRotation, [this])
    }
    calculateLabelRotation() {
        const t = this.options
          , i = t.ticks
          , s = T2(this.ticks.length, t.ticks.maxTicksLimit)
          , u = i.minRotation || 0
          , d = i.maxRotation;
        let f = u, o, w, T;
        if (!this._isVisible() || !i.display || u >= d || s <= 1 || !this.isHorizontal()) {
            this.labelRotation = u;
            return
        }
        const k = this._getLabelSizes()
          , L = k.widest.width
          , z = k.highest.height
          , D = Jc(this.chart.width - L, 0, this.maxWidth);
        o = t.offset ? this.maxWidth / s : D / (s - 1),
        L + 6 > o && (o = D / (s - (t.offset ? .5 : 1)),
        w = this.maxHeight - mg(t.grid) - i.padding - M2(t.title, this.chart.options.font),
        T = Math.sqrt(L * L + z * z),
        f = P4(Math.min(Math.asin(Jc((k.highest.height + 6) / o, -1, 1)), Math.asin(Jc(w / T, -1, 1)) - Math.asin(Jc(z / T, -1, 1)))),
        f = Math.max(u, Math.min(d, f))),
        this.labelRotation = f
    }
    afterCalculateLabelRotation() {
        Xi(this.options.afterCalculateLabelRotation, [this])
    }
    afterAutoSkip() {}
    beforeFit() {
        Xi(this.options.beforeFit, [this])
    }
    fit() {
        const t = {
            width: 0,
            height: 0
        }
          , {chart: i, options: {ticks: s, title: u, grid: d}} = this
          , f = this._isVisible()
          , o = this.isHorizontal();
        if (f) {
            const w = M2(u, i.options.font);
            if (o ? (t.width = this.maxWidth,
            t.height = mg(d) + w) : (t.height = this.maxHeight,
            t.width = mg(d) + w),
            s.display && this.ticks.length) {
                const {first: T, last: k, widest: L, highest: z} = this._getLabelSizes()
                  , D = s.padding * 2
                  , N = Qc(this.labelRotation)
                  , U = Math.cos(N)
                  , V = Math.sin(N);
                if (o) {
                    const re = s.mirror ? 0 : V * L.width + U * z.height;
                    t.height = Math.min(this.maxHeight, t.height + re + D)
                } else {
                    const re = s.mirror ? 0 : U * L.width + V * z.height;
                    t.width = Math.min(this.maxWidth, t.width + re + D)
                }
                this._calculatePadding(T, k, V, U)
            }
        }
        this._handleMargins(),
        o ? (this.width = this._length = i.width - this._margins.left - this._margins.right,
        this.height = t.height) : (this.width = t.width,
        this.height = this._length = i.height - this._margins.top - this._margins.bottom)
    }
    _calculatePadding(t, i, s, u) {
        const {ticks: {align: d, padding: f}, position: o} = this.options
          , w = this.labelRotation !== 0
          , T = o !== "top" && this.axis === "x";
        if (this.isHorizontal()) {
            const k = this.getPixelForTick(0) - this.left
              , L = this.right - this.getPixelForTick(this.ticks.length - 1);
            let z = 0
              , D = 0;
            w ? T ? (z = u * t.width,
            D = s * i.height) : (z = s * t.height,
            D = u * i.width) : d === "start" ? D = i.width : d === "end" ? z = t.width : d !== "inner" && (z = t.width / 2,
            D = i.width / 2),
            this.paddingLeft = Math.max((z - k + f) * this.width / (this.width - k), 0),
            this.paddingRight = Math.max((D - L + f) * this.width / (this.width - L), 0)
        } else {
            let k = i.height / 2
              , L = t.height / 2;
            d === "start" ? (k = 0,
            L = t.height) : d === "end" && (k = i.height,
            L = 0),
            this.paddingTop = k + f,
            this.paddingBottom = L + f
        }
    }
    _handleMargins() {
        this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left),
        this._margins.top = Math.max(this.paddingTop, this._margins.top),
        this._margins.right = Math.max(this.paddingRight, this._margins.right),
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
    }
    afterFit() {
        Xi(this.options.afterFit, [this])
    }
    isHorizontal() {
        const {axis: t, position: i} = this.options;
        return i === "top" || i === "bottom" || t === "x"
    }
    isFullSize() {
        return this.options.fullSize
    }
    _convertTicksToLabels(t) {
        this.beforeTickToLabelConversion(),
        this.generateTickLabels(t);
        let i, s;
        for (i = 0,
        s = t.length; i < s; i++)
            li(t[i].label) && (t.splice(i, 1),
            s--,
            i--);
        this.afterTickToLabelConversion()
    }
    _getLabelSizes() {
        let t = this._labelSizes;
        if (!t) {
            const i = this.options.ticks.sampleSize;
            let s = this.ticks;
            i < s.length && (s = P2(s, i)),
            this._labelSizes = t = this._computeLabelSizes(s, s.length, this.options.ticks.maxTicksLimit)
        }
        return t
    }
    _computeLabelSizes(t, i, s) {
        const {ctx: u, _longestTextCache: d} = this
          , f = []
          , o = []
          , w = Math.floor(i / T2(i, s));
        let T = 0, k = 0, L, z, D, N, U, V, re, ie, ue, ce, X;
        for (L = 0; L < i; L += w) {
            if (N = t[L].label,
            U = this._resolveTickFontOptions(L),
            u.font = V = U.string,
            re = d[V] = d[V] || {
                data: {},
                gc: []
            },
            ie = U.lineHeight,
            ue = ce = 0,
            !li(N) && !Vo(N))
                ue = JS(u, re.data, re.gc, ue, N),
                ce = ie;
            else if (Vo(N))
                for (z = 0,
                D = N.length; z < D; ++z)
                    X = N[z],
                    !li(X) && !Vo(X) && (ue = JS(u, re.data, re.gc, ue, X),
                    ce += ie);
            f.push(ue),
            o.push(ce),
            T = Math.max(ue, T),
            k = Math.max(ce, k)
        }
        Y$(d, i);
        const me = f.indexOf(T)
          , K = o.indexOf(k)
          , be = Ee => ({
            width: f[Ee] || 0,
            height: o[Ee] || 0
        });
        return {
            first: be(0),
            last: be(i - 1),
            widest: be(me),
            highest: be(K),
            widths: f,
            heights: o
        }
    }
    getLabelForValue(t) {
        return t
    }
    getPixelForValue(t, i) {
        return NaN
    }
    getValueForPixel(t) {}
    getPixelForTick(t) {
        const i = this.ticks;
        return t < 0 || t > i.length - 1 ? null : this.getPixelForValue(i[t].value)
    }
    getPixelForDecimal(t) {
        this._reversePixels && (t = 1 - t);
        const i = this._startPixel + t * this._length;
        return E4(this._alignToPixels ? ef(this.chart, i, 0) : i)
    }
    getDecimalForPixel(t) {
        const i = (t - this._startPixel) / this._length;
        return this._reversePixels ? 1 - i : i
    }
    getBasePixel() {
        return this.getPixelForValue(this.getBaseValue())
    }
    getBaseValue() {
        const {min: t, max: i} = this;
        return t < 0 && i < 0 ? i : t > 0 && i > 0 ? t : 0
    }
    getContext(t) {
        const i = this.ticks || [];
        if (t >= 0 && t < i.length) {
            const s = i[t];
            return s.$context || (s.$context = Q$(this.getContext(), t, s))
        }
        return this.$context || (this.$context = K$(this.chart.getContext(), this))
    }
    _tickSize() {
        const t = this.options.ticks
          , i = Qc(this.labelRotation)
          , s = Math.abs(Math.cos(i))
          , u = Math.abs(Math.sin(i))
          , d = this._getLabelSizes()
          , f = t.autoSkipPadding || 0
          , o = d ? d.widest.width + f : 0
          , w = d ? d.highest.height + f : 0;
        return this.isHorizontal() ? w * s > o * u ? o / s : w / u : w * u < o * s ? w / s : o / u
    }
    _isVisible() {
        const t = this.options.display;
        return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0
    }
    _computeGridLineItems(t) {
        const i = this.axis
          , s = this.chart
          , u = this.options
          , {grid: d, position: f, border: o} = u
          , w = d.offset
          , T = this.isHorizontal()
          , L = this.ticks.length + (w ? 1 : 0)
          , z = mg(d)
          , D = []
          , N = o.setContext(this.getContext())
          , U = N.display ? N.width : 0
          , V = U / 2
          , re = function(ve) {
            return ef(s, ve, U)
        };
        let ie, ue, ce, X, me, K, be, Ee, Ce, He, ct, nt;
        if (f === "top")
            ie = re(this.bottom),
            K = this.bottom - z,
            Ee = ie - V,
            He = re(t.top) + V,
            nt = t.bottom;
        else if (f === "bottom")
            ie = re(this.top),
            He = t.top,
            nt = re(t.bottom) - V,
            K = ie + V,
            Ee = this.top + z;
        else if (f === "left")
            ie = re(this.right),
            me = this.right - z,
            be = ie - V,
            Ce = re(t.left) + V,
            ct = t.right;
        else if (f === "right")
            ie = re(this.left),
            Ce = t.left,
            ct = re(t.right) - V,
            me = ie + V,
            be = this.left + z;
        else if (i === "x") {
            if (f === "center")
                ie = re((t.top + t.bottom) / 2 + .5);
            else if (Cn(f)) {
                const ve = Object.keys(f)[0]
                  , Ne = f[ve];
                ie = re(this.chart.scales[ve].getPixelForValue(Ne))
            }
            He = t.top,
            nt = t.bottom,
            K = ie + V,
            Ee = K + z
        } else if (i === "y") {
            if (f === "center")
                ie = re((t.left + t.right) / 2);
            else if (Cn(f)) {
                const ve = Object.keys(f)[0]
                  , Ne = f[ve];
                ie = re(this.chart.scales[ve].getPixelForValue(Ne))
            }
            me = ie - V,
            be = me - z,
            Ce = t.left,
            ct = t.right
        }
        const J = zn(u.ticks.maxTicksLimit, L)
          , he = Math.max(1, Math.ceil(L / J));
        for (ue = 0; ue < L; ue += he) {
            const ve = this.getContext(ue)
              , Ne = d.setContext(ve)
              , je = o.setContext(ve)
              , lt = Ne.lineWidth
              , Pt = Ne.color
              , We = je.dash || []
              , st = je.dashOffset
              , Nt = Ne.tickWidth
              , zt = Ne.tickColor
              , Qt = Ne.tickBorderDash || []
              , Wt = Ne.tickBorderDashOffset;
            ce = X$(this, ue, w),
            ce !== void 0 && (X = ef(s, ce, lt),
            T ? me = be = Ce = ct = X : K = Ee = He = nt = X,
            D.push({
                tx1: me,
                ty1: K,
                tx2: be,
                ty2: Ee,
                x1: Ce,
                y1: He,
                x2: ct,
                y2: nt,
                width: lt,
                color: Pt,
                borderDash: We,
                borderDashOffset: st,
                tickWidth: Nt,
                tickColor: zt,
                tickBorderDash: Qt,
                tickBorderDashOffset: Wt
            }))
        }
        return this._ticksLength = L,
        this._borderValue = ie,
        D
    }
    _computeLabelItems(t) {
        const i = this.axis
          , s = this.options
          , {position: u, ticks: d} = s
          , f = this.isHorizontal()
          , o = this.ticks
          , {align: w, crossAlign: T, padding: k, mirror: L} = d
          , z = mg(s.grid)
          , D = z + k
          , N = L ? -k : D
          , U = -Qc(this.labelRotation)
          , V = [];
        let re, ie, ue, ce, X, me, K, be, Ee, Ce, He, ct, nt = "middle";
        if (u === "top")
            me = this.bottom - N,
            K = this._getXAxisLabelAlignment();
        else if (u === "bottom")
            me = this.top + N,
            K = this._getXAxisLabelAlignment();
        else if (u === "left") {
            const he = this._getYAxisLabelAlignment(z);
            K = he.textAlign,
            X = he.x
        } else if (u === "right") {
            const he = this._getYAxisLabelAlignment(z);
            K = he.textAlign,
            X = he.x
        } else if (i === "x") {
            if (u === "center")
                me = (t.top + t.bottom) / 2 + D;
            else if (Cn(u)) {
                const he = Object.keys(u)[0]
                  , ve = u[he];
                me = this.chart.scales[he].getPixelForValue(ve) + D
            }
            K = this._getXAxisLabelAlignment()
        } else if (i === "y") {
            if (u === "center")
                X = (t.left + t.right) / 2 - D;
            else if (Cn(u)) {
                const he = Object.keys(u)[0]
                  , ve = u[he];
                X = this.chart.scales[he].getPixelForValue(ve)
            }
            K = this._getYAxisLabelAlignment(z).textAlign
        }
        i === "y" && (w === "start" ? nt = "top" : w === "end" && (nt = "bottom"));
        const J = this._getLabelSizes();
        for (re = 0,
        ie = o.length; re < ie; ++re) {
            ue = o[re],
            ce = ue.label;
            const he = d.setContext(this.getContext(re));
            be = this.getPixelForTick(re) + d.labelOffset,
            Ee = this._resolveTickFontOptions(re),
            Ce = Ee.lineHeight,
            He = Vo(ce) ? ce.length : 1;
            const ve = He / 2
              , Ne = he.color
              , je = he.textStrokeColor
              , lt = he.textStrokeWidth;
            let Pt = K;
            f ? (X = be,
            K === "inner" && (re === ie - 1 ? Pt = this.options.reverse ? "left" : "right" : re === 0 ? Pt = this.options.reverse ? "right" : "left" : Pt = "center"),
            u === "top" ? T === "near" || U !== 0 ? ct = -He * Ce + Ce / 2 : T === "center" ? ct = -J.highest.height / 2 - ve * Ce + Ce : ct = -J.highest.height + Ce / 2 : T === "near" || U !== 0 ? ct = Ce / 2 : T === "center" ? ct = J.highest.height / 2 - ve * Ce : ct = J.highest.height - He * Ce,
            L && (ct *= -1),
            U !== 0 && !he.showLabelBackdrop && (X += Ce / 2 * Math.sin(U))) : (me = be,
            ct = (1 - He) * Ce / 2);
            let We;
            if (he.showLabelBackdrop) {
                const st = ry(he.backdropPadding)
                  , Nt = J.heights[re]
                  , zt = J.widths[re];
                let Qt = ct - st.top
                  , Wt = 0 - st.left;
                switch (nt) {
                case "middle":
                    Qt -= Nt / 2;
                    break;
                case "bottom":
                    Qt -= Nt;
                    break
                }
                switch (K) {
                case "center":
                    Wt -= zt / 2;
                    break;
                case "right":
                    Wt -= zt;
                    break;
                case "inner":
                    re === ie - 1 ? Wt -= zt : re > 0 && (Wt -= zt / 2);
                    break
                }
                We = {
                    left: Wt,
                    top: Qt,
                    width: zt + st.width,
                    height: Nt + st.height,
                    color: he.backdropColor
                }
            }
            V.push({
                label: ce,
                font: Ee,
                textOffset: ct,
                options: {
                    rotation: U,
                    color: Ne,
                    strokeColor: je,
                    strokeWidth: lt,
                    textAlign: Pt,
                    textBaseline: nt,
                    translation: [X, me],
                    backdrop: We
                }
            })
        }
        return V
    }
    _getXAxisLabelAlignment() {
        const {position: t, ticks: i} = this.options;
        if (-Qc(this.labelRotation))
            return t === "top" ? "left" : "right";
        let u = "center";
        return i.align === "start" ? u = "left" : i.align === "end" ? u = "right" : i.align === "inner" && (u = "inner"),
        u
    }
    _getYAxisLabelAlignment(t) {
        const {position: i, ticks: {crossAlign: s, mirror: u, padding: d}} = this.options
          , f = this._getLabelSizes()
          , o = t + d
          , w = f.widest.width;
        let T, k;
        return i === "left" ? u ? (k = this.right + d,
        s === "near" ? T = "left" : s === "center" ? (T = "center",
        k += w / 2) : (T = "right",
        k += w)) : (k = this.right - o,
        s === "near" ? T = "right" : s === "center" ? (T = "center",
        k -= w / 2) : (T = "left",
        k = this.left)) : i === "right" ? u ? (k = this.left + d,
        s === "near" ? T = "right" : s === "center" ? (T = "center",
        k -= w / 2) : (T = "left",
        k -= w)) : (k = this.left + o,
        s === "near" ? T = "left" : s === "center" ? (T = "center",
        k += w / 2) : (T = "right",
        k = this.right)) : T = "right",
        {
            textAlign: T,
            x: k
        }
    }
    _computeLabelArea() {
        if (this.options.ticks.mirror)
            return;
        const t = this.chart
          , i = this.options.position;
        if (i === "left" || i === "right")
            return {
                top: 0,
                left: this.left,
                bottom: t.height,
                right: this.right
            };
        if (i === "top" || i === "bottom")
            return {
                top: this.top,
                left: 0,
                bottom: this.bottom,
                right: t.width
            }
    }
    drawBackground() {
        const {ctx: t, options: {backgroundColor: i}, left: s, top: u, width: d, height: f} = this;
        i && (t.save(),
        t.fillStyle = i,
        t.fillRect(s, u, d, f),
        t.restore())
    }
    getLineWidthForValue(t) {
        const i = this.options.grid;
        if (!this._isVisible() || !i.display)
            return 0;
        const u = this.ticks.findIndex(d => d.value === t);
        return u >= 0 ? i.setContext(this.getContext(u)).lineWidth : 0
    }
    drawGrid(t) {
        const i = this.options.grid
          , s = this.ctx
          , u = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
        let d, f;
        const o = (w, T, k) => {
            !k.width || !k.color || (s.save(),
            s.lineWidth = k.width,
            s.strokeStyle = k.color,
            s.setLineDash(k.borderDash || []),
            s.lineDashOffset = k.borderDashOffset,
            s.beginPath(),
            s.moveTo(w.x, w.y),
            s.lineTo(T.x, T.y),
            s.stroke(),
            s.restore())
        }
        ;
        if (i.display)
            for (d = 0,
            f = u.length; d < f; ++d) {
                const w = u[d];
                i.drawOnChartArea && o({
                    x: w.x1,
                    y: w.y1
                }, {
                    x: w.x2,
                    y: w.y2
                }, w),
                i.drawTicks && o({
                    x: w.tx1,
                    y: w.ty1
                }, {
                    x: w.tx2,
                    y: w.ty2
                }, {
                    color: w.tickColor,
                    width: w.tickWidth,
                    borderDash: w.tickBorderDash,
                    borderDashOffset: w.tickBorderDashOffset
                })
            }
    }
    drawBorder() {
        const {chart: t, ctx: i, options: {border: s, grid: u}} = this
          , d = s.setContext(this.getContext())
          , f = s.display ? d.width : 0;
        if (!f)
            return;
        const o = u.setContext(this.getContext(0)).lineWidth
          , w = this._borderValue;
        let T, k, L, z;
        this.isHorizontal() ? (T = ef(t, this.left, f) - f / 2,
        k = ef(t, this.right, o) + o / 2,
        L = z = w) : (L = ef(t, this.top, f) - f / 2,
        z = ef(t, this.bottom, o) + o / 2,
        T = k = w),
        i.save(),
        i.lineWidth = d.width,
        i.strokeStyle = d.color,
        i.beginPath(),
        i.moveTo(T, L),
        i.lineTo(k, z),
        i.stroke(),
        i.restore()
    }
    drawLabels(t) {
        if (!this.options.ticks.display)
            return;
        const s = this.ctx
          , u = this._computeLabelArea();
        u && vb(s, u);
        const d = this.getLabelItems(t);
        for (const f of d) {
            const o = f.options
              , w = f.font
              , T = f.label
              , k = f.textOffset;
            t2(s, T, 0, k, w, o)
        }
        u && xb(s)
    }
    drawTitle() {
        const {ctx: t, options: {position: i, title: s, reverse: u}} = this;
        if (!s.display)
            return;
        const d = yx(s.font)
          , f = ry(s.padding)
          , o = s.align;
        let w = d.lineHeight / 2;
        i === "bottom" || i === "center" || Cn(i) ? (w += f.bottom,
        Vo(s.text) && (w += d.lineHeight * (s.text.length - 1))) : w += f.top;
        const {titleX: T, titleY: k, maxWidth: L, rotation: z} = e6(this, w, i, o);
        t2(t, s.text, 0, 0, d, {
            color: s.color,
            maxWidth: L,
            rotation: z,
            textAlign: J$(o, i, u),
            textBaseline: "middle",
            translation: [T, k]
        })
    }
    draw(t) {
        this._isVisible() && (this.drawBackground(),
        this.drawGrid(t),
        this.drawBorder(),
        this.drawTitle(),
        this.drawLabels(t))
    }
    _layers() {
        const t = this.options
          , i = t.ticks && t.ticks.z || 0
          , s = zn(t.grid && t.grid.z, -1)
          , u = zn(t.border && t.border.z, 0);
        return !this._isVisible() || this.draw !== rm.prototype.draw ? [{
            z: i,
            draw: d => {
                this.draw(d)
            }
        }] : [{
            z: s,
            draw: d => {
                this.drawBackground(),
                this.drawGrid(d),
                this.drawTitle()
            }
        }, {
            z: u,
            draw: () => {
                this.drawBorder()
            }
        }, {
            z: i,
            draw: d => {
                this.drawLabels(d)
            }
        }]
    }
    getMatchingVisibleMetas(t) {
        const i = this.chart.getSortedVisibleDatasetMetas()
          , s = this.axis + "AxisID"
          , u = [];
        let d, f;
        for (d = 0,
        f = i.length; d < f; ++d) {
            const o = i[d];
            o[s] === this.id && (!t || o.type === t) && u.push(o)
        }
        return u
    }
    _resolveTickFontOptions(t) {
        const i = this.options.ticks.setContext(this.getContext(t));
        return yx(i.font)
    }
    _maxDigits() {
        const t = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / t
    }
}
class P_ {
    constructor(t, i, s) {
        this.type = t,
        this.scope = i,
        this.override = s,
        this.items = Object.create(null)
    }
    isForType(t) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)
    }
    register(t) {
        const i = Object.getPrototypeOf(t);
        let s;
        n6(i) && (s = this.register(i));
        const u = this.items
          , d = t.id
          , f = this.scope + "." + d;
        if (!d)
            throw new Error("class does not have id: " + t);
        return d in u || (u[d] = t,
        t6(t, f, s),
        this.override && fo.override(t.id, t.overrides)),
        f
    }
    get(t) {
        return this.items[t]
    }
    unregister(t) {
        const i = this.items
          , s = t.id
          , u = this.scope;
        s in i && delete i[s],
        u && s in fo[u] && (delete fo[u][s],
        this.override && delete xf[s])
    }
}
function t6(e, t, i) {
    const s = Jg(Object.create(null), [i ? fo.get(i) : {}, fo.get(t), e.defaults]);
    fo.set(t, s),
    e.defaultRoutes && r6(t, e.defaultRoutes),
    e.descriptors && fo.describe(t, e.descriptors)
}
function r6(e, t) {
    Object.keys(t).forEach(i => {
        const s = i.split(".")
          , u = s.pop()
          , d = [e].concat(s).join(".")
          , f = t[i].split(".")
          , o = f.pop()
          , w = f.join(".");
        fo.route(d, u, w, o)
    }
    )
}
function n6(e) {
    return "id"in e && "defaults"in e
}
class i6 {
    constructor() {
        this.controllers = new P_(rd,"datasets",!0),
        this.elements = new P_(Rv,"elements"),
        this.plugins = new P_(Object,"plugins"),
        this.scales = new P_(rm,"scales"),
        this._typedRegistries = [this.controllers, this.scales, this.elements]
    }
    add(...t) {
        this._each("register", t)
    }
    remove(...t) {
        this._each("unregister", t)
    }
    addControllers(...t) {
        this._each("register", t, this.controllers)
    }
    addElements(...t) {
        this._each("register", t, this.elements)
    }
    addPlugins(...t) {
        this._each("register", t, this.plugins)
    }
    addScales(...t) {
        this._each("register", t, this.scales)
    }
    getController(t) {
        return this._get(t, this.controllers, "controller")
    }
    getElement(t) {
        return this._get(t, this.elements, "element")
    }
    getPlugin(t) {
        return this._get(t, this.plugins, "plugin")
    }
    getScale(t) {
        return this._get(t, this.scales, "scale")
    }
    removeControllers(...t) {
        this._each("unregister", t, this.controllers)
    }
    removeElements(...t) {
        this._each("unregister", t, this.elements)
    }
    removePlugins(...t) {
        this._each("unregister", t, this.plugins)
    }
    removeScales(...t) {
        this._each("unregister", t, this.scales)
    }
    _each(t, i, s) {
        [...i].forEach(u => {
            const d = s || this._getRegistryForType(u);
            s || d.isForType(u) || d === this.plugins && u.id ? this._exec(t, d, u) : ys(u, f => {
                const o = s || this._getRegistryForType(f);
                this._exec(t, o, f)
            }
            )
        }
        )
    }
    _exec(t, i, s) {
        const u = gb(t);
        Xi(s["before" + u], [], s),
        i[t](s),
        Xi(s["after" + u], [], s)
    }
    _getRegistryForType(t) {
        for (let i = 0; i < this._typedRegistries.length; i++) {
            const s = this._typedRegistries[i];
            if (s.isForType(t))
                return s
        }
        return this.plugins
    }
    _get(t, i, s) {
        const u = i.get(t);
        if (u === void 0)
            throw new Error('"' + t + '" is not a registered ' + s + ".");
        return u
    }
}
var qc = new i6;
class o6 {
    constructor() {
        this._init = []
    }
    notify(t, i, s, u) {
        i === "beforeInit" && (this._init = this._createDescriptors(t, !0),
        this._notify(this._init, t, "install"));
        const d = u ? this._descriptors(t).filter(u) : this._descriptors(t)
          , f = this._notify(d, t, i, s);
        return i === "afterDestroy" && (this._notify(d, t, "stop"),
        this._notify(this._init, t, "uninstall")),
        f
    }
    _notify(t, i, s, u) {
        u = u || {};
        for (const d of t) {
            const f = d.plugin
              , o = f[s]
              , w = [i, u, d.options];
            if (Xi(o, w, f) === !1 && u.cancelable)
                return !1
        }
        return !0
    }
    invalidate() {
        li(this._cache) || (this._oldCache = this._cache,
        this._cache = void 0)
    }
    _descriptors(t) {
        if (this._cache)
            return this._cache;
        const i = this._cache = this._createDescriptors(t);
        return this._notifyStateChanges(t),
        i
    }
    _createDescriptors(t, i) {
        const s = t && t.config
          , u = zn(s.options && s.options.plugins, {})
          , d = s6(s);
        return u === !1 && !i ? [] : l6(t, d, u, i)
    }
    _notifyStateChanges(t) {
        const i = this._oldCache || []
          , s = this._cache
          , u = (d, f) => d.filter(o => !f.some(w => o.plugin.id === w.plugin.id));
        this._notify(u(i, s), t, "stop"),
        this._notify(u(s, i), t, "start")
    }
}
function s6(e) {
    const t = {}
      , i = []
      , s = Object.keys(qc.plugins.items);
    for (let d = 0; d < s.length; d++)
        i.push(qc.getPlugin(s[d]));
    const u = e.plugins || [];
    for (let d = 0; d < u.length; d++) {
        const f = u[d];
        i.indexOf(f) === -1 && (i.push(f),
        t[f.id] = !0)
    }
    return {
        plugins: i,
        localIds: t
    }
}
function a6(e, t) {
    return !t && e === !1 ? null : e === !0 ? {} : e
}
function l6(e, {plugins: t, localIds: i}, s, u) {
    const d = []
      , f = e.getContext();
    for (const o of t) {
        const w = o.id
          , T = a6(s[w], u);
        T !== null && d.push({
            plugin: o,
            options: c6(e.config, {
                plugin: o,
                local: i[w]
            }, T, f)
        })
    }
    return d
}
function c6(e, {plugin: t, local: i}, s, u) {
    const d = e.pluginScopeKeys(t)
      , f = e.getOptionScopes(s, d);
    return i && t.defaults && f.push(t.defaults),
    e.createResolver(f, u, [""], {
        scriptable: !1,
        indexable: !1,
        allKeys: !0
    })
}
function _x(e, t) {
    const i = fo.datasets[e] || {};
    return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || i.indexAxis || "x"
}
function u6(e, t) {
    let i = e;
    return e === "_index_" ? i = t : e === "_value_" && (i = t === "x" ? "y" : "x"),
    i
}
function h6(e, t) {
    return e === t ? "_index_" : "_value_"
}
function k2(e) {
    if (e === "x" || e === "y" || e === "r")
        return e
}
function d6(e) {
    if (e === "top" || e === "bottom")
        return "x";
    if (e === "left" || e === "right")
        return "y"
}
function vx(e, ...t) {
    if (k2(e))
        return e;
    for (const i of t) {
        const s = i.axis || d6(i.position) || e.length > 1 && k2(e[0].toLowerCase());
        if (s)
            return s
    }
    throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`)
}
function E2(e, t, i) {
    if (i[t + "AxisID"] === e)
        return {
            axis: t
        }
}
function f6(e, t) {
    if (t.data && t.data.datasets) {
        const i = t.data.datasets.filter(s => s.xAxisID === e || s.yAxisID === e);
        if (i.length)
            return E2(e, "x", i[0]) || E2(e, "y", i[0])
    }
    return {}
}
function p6(e, t) {
    const i = xf[e.type] || {
        scales: {}
    }
      , s = t.scales || {}
      , u = _x(e.type, t)
      , d = Object.create(null);
    return Object.keys(s).forEach(f => {
        const o = s[f];
        if (!Cn(o))
            return console.error(`Invalid scale configuration for scale: ${f}`);
        if (o._proxy)
            return console.warn(`Ignoring resolver passed as options for scale: ${f}`);
        const w = vx(f, o, f6(f, e), fo.scales[o.type])
          , T = h6(w, u)
          , k = i.scales || {};
        d[f] = jg(Object.create(null), [{
            axis: w
        }, o, k[w], k[T]])
    }
    ),
    e.data.datasets.forEach(f => {
        const o = f.type || e.type
          , w = f.indexAxis || _x(o, t)
          , k = (xf[o] || {}).scales || {};
        Object.keys(k).forEach(L => {
            const z = u6(L, w)
              , D = f[z + "AxisID"] || z;
            d[D] = d[D] || Object.create(null),
            jg(d[D], [{
                axis: z
            }, s[D], k[L]])
        }
        )
    }
    ),
    Object.keys(d).forEach(f => {
        const o = d[f];
        jg(o, [fo.scales[o.type], fo.scale])
    }
    ),
    d
}
function oM(e) {
    const t = e.options || (e.options = {});
    t.plugins = zn(t.plugins, {}),
    t.scales = p6(e, t)
}
function sM(e) {
    return e = e || {},
    e.datasets = e.datasets || [],
    e.labels = e.labels || [],
    e
}
function m6(e) {
    return e = e || {},
    e.data = sM(e.data),
    oM(e),
    e
}
const I2 = new Map
  , aM = new Set;
function M_(e, t) {
    let i = I2.get(e);
    return i || (i = t(),
    I2.set(e, i),
    aM.add(i)),
    i
}
const gg = (e, t, i) => {
    const s = Qh(t, i);
    s !== void 0 && e.add(s)
}
;
class g6 {
    constructor(t) {
        this._config = m6(t),
        this._scopeCache = new Map,
        this._resolverCache = new Map
    }
    get platform() {
        return this._config.platform
    }
    get type() {
        return this._config.type
    }
    set type(t) {
        this._config.type = t
    }
    get data() {
        return this._config.data
    }
    set data(t) {
        this._config.data = sM(t)
    }
    get options() {
        return this._config.options
    }
    set options(t) {
        this._config.options = t
    }
    get plugins() {
        return this._config.plugins
    }
    update() {
        const t = this._config;
        this.clearCache(),
        oM(t)
    }
    clearCache() {
        this._scopeCache.clear(),
        this._resolverCache.clear()
    }
    datasetScopeKeys(t) {
        return M_(t, () => [[`datasets.${t}`, ""]])
    }
    datasetAnimationScopeKeys(t, i) {
        return M_(`${t}.transition.${i}`, () => [[`datasets.${t}.transitions.${i}`, `transitions.${i}`], [`datasets.${t}`, ""]])
    }
    datasetElementScopeKeys(t, i) {
        return M_(`${t}-${i}`, () => [[`datasets.${t}.elements.${i}`, `datasets.${t}`, `elements.${i}`, ""]])
    }
    pluginScopeKeys(t) {
        const i = t.id
          , s = this.type;
        return M_(`${s}-plugin-${i}`, () => [[`plugins.${i}`, ...t.additionalOptionScopes || []]])
    }
    _cachedScopes(t, i) {
        const s = this._scopeCache;
        let u = s.get(t);
        return (!u || i) && (u = new Map,
        s.set(t, u)),
        u
    }
    getOptionScopes(t, i, s) {
        const {options: u, type: d} = this
          , f = this._cachedScopes(t, s)
          , o = f.get(i);
        if (o)
            return o;
        const w = new Set;
        i.forEach(k => {
            t && (w.add(t),
            k.forEach(L => gg(w, t, L))),
            k.forEach(L => gg(w, u, L)),
            k.forEach(L => gg(w, xf[d] || {}, L)),
            k.forEach(L => gg(w, fo, L)),
            k.forEach(L => gg(w, gx, L))
        }
        );
        const T = Array.from(w);
        return T.length === 0 && T.push(Object.create(null)),
        aM.has(i) && f.set(i, T),
        T
    }
    chartOptionScopes() {
        const {options: t, type: i} = this;
        return [t, xf[i] || {}, fo.datasets[i] || {}, {
            type: i
        }, fo, gx]
    }
    resolveNamedOptions(t, i, s, u=[""]) {
        const d = {
            $shared: !0
        }
          , {resolver: f, subPrefixes: o} = R2(this._resolverCache, t, u);
        let w = f;
        if (_6(f, i)) {
            d.$shared = !1,
            s = Jh(s) ? s() : s;
            const T = this.createResolver(t, s, o);
            w = Hp(f, s, T)
        }
        for (const T of i)
            d[T] = w[T];
        return d
    }
    createResolver(t, i, s=[""], u) {
        const {resolver: d} = R2(this._resolverCache, t, s);
        return Cn(i) ? Hp(d, i, void 0, u) : d
    }
}
function R2(e, t, i) {
    let s = e.get(t);
    s || (s = new Map,
    e.set(t, s));
    const u = i.join();
    let d = s.get(u);
    return d || (d = {
        resolver: bb(t, i),
        subPrefixes: i.filter(o => !o.toLowerCase().includes("hover"))
    },
    s.set(u, d)),
    d
}
const y6 = e => Cn(e) && Object.getOwnPropertyNames(e).some(t => Jh(e[t]));
function _6(e, t) {
    const {isScriptable: i, isIndexable: s} = VP(e);
    for (const u of t) {
        const d = i(u)
          , f = s(u)
          , o = (f || d) && e[u];
        if (d && (Jh(o) || y6(o)) || f && Vo(o))
            return !0
    }
    return !1
}
var v6 = "4.4.6";
const x6 = ["top", "bottom", "left", "right", "chartArea"];
function A2(e, t) {
    return e === "top" || e === "bottom" || x6.indexOf(e) === -1 && t === "x"
}
function z2(e, t) {
    return function(i, s) {
        return i[e] === s[e] ? i[t] - s[t] : i[e] - s[e]
    }
}
function D2(e) {
    const t = e.chart
      , i = t.options.animation;
    t.notifyPlugins("afterRender"),
    Xi(i && i.onComplete, [e], t)
}
function b6(e) {
    const t = e.chart
      , i = t.options.animation;
    Xi(i && i.onProgress, [e], t)
}
function lM(e) {
    return Cb() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]),
    e && e.canvas && (e = e.canvas),
    e
}
const $_ = {}
  , L2 = e => {
    const t = lM(e);
    return Object.values($_).filter(i => i.canvas === t).pop()
}
;
function w6(e, t, i) {
    const s = Object.keys(e);
    for (const u of s) {
        const d = +u;
        if (d >= t) {
            const f = e[u];
            delete e[u],
            (i > 0 || d > t) && (e[d + i] = f)
        }
    }
}
function S6(e, t, i, s) {
    return !i || e.type === "mouseout" ? null : s ? t : e
}
function k_(e, t, i) {
    return e.options.clip ? e[i] : t[i]
}
function C6(e, t) {
    const {xScale: i, yScale: s} = e;
    return i && s ? {
        left: k_(i, t, "left"),
        right: k_(i, t, "right"),
        top: k_(s, t, "top"),
        bottom: k_(s, t, "bottom")
    } : t
}
let nd = class {
    static defaults = fo;
    static instances = $_;
    static overrides = xf;
    static registry = qc;
    static version = v6;
    static getChart = L2;
    static register(...t) {
        qc.add(...t),
        O2()
    }
    static unregister(...t) {
        qc.remove(...t),
        O2()
    }
    constructor(t, i) {
        const s = this.config = new g6(i)
          , u = lM(t)
          , d = L2(u);
        if (d)
            throw new Error("Canvas is already in use. Chart with ID '" + d.id + "' must be destroyed before the canvas with ID '" + d.canvas.id + "' can be reused.");
        const f = s.createResolver(s.chartOptionScopes(), this.getContext());
        this.platform = new (s.platform || $$(u)),
        this.platform.updateConfig(s);
        const o = this.platform.acquireContext(u, f.aspectRatio)
          , w = o && o.canvas
          , T = w && w.height
          , k = w && w.width;
        if (this.id = p4(),
        this.ctx = o,
        this.canvas = w,
        this.width = k,
        this.height = T,
        this._options = f,
        this._aspectRatio = this.aspectRatio,
        this._layers = [],
        this._metasets = [],
        this._stacks = void 0,
        this.boxes = [],
        this.currentDevicePixelRatio = void 0,
        this.chartArea = void 0,
        this._active = [],
        this._lastEvent = void 0,
        this._listeners = {},
        this._responsiveListeners = void 0,
        this._sortedMetasets = [],
        this.scales = {},
        this._plugins = new o6,
        this.$proxies = {},
        this._hiddenIndices = {},
        this.attached = !1,
        this._animationsDisabled = void 0,
        this.$context = void 0,
        this._doResize = z4(L => this.update(L), f.resizeDelay || 0),
        this._dataChanges = [],
        $_[this.id] = this,
        !o || !w) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return
        }
        th.listen(this, "complete", D2),
        th.listen(this, "progress", b6),
        this._initialize(),
        this.attached && this.update()
    }
    get aspectRatio() {
        const {options: {aspectRatio: t, maintainAspectRatio: i}, width: s, height: u, _aspectRatio: d} = this;
        return li(t) ? i && d ? d : u ? s / u : null : t
    }
    get data() {
        return this.config.data
    }
    set data(t) {
        this.config.data = t
    }
    get options() {
        return this._options
    }
    set options(t) {
        this.config.options = t
    }
    get registry() {
        return qc
    }
    _initialize() {
        return this.notifyPlugins("beforeInit"),
        this.options.responsive ? this.resize() : i2(this, this.options.devicePixelRatio),
        this.bindEvents(),
        this.notifyPlugins("afterInit"),
        this
    }
    clear() {
        return e2(this.canvas, this.ctx),
        this
    }
    stop() {
        return th.stop(this),
        this
    }
    resize(t, i) {
        th.running(this) ? this._resizeBeforeDraw = {
            width: t,
            height: i
        } : this._resize(t, i)
    }
    _resize(t, i) {
        const s = this.options
          , u = this.canvas
          , d = s.maintainAspectRatio && this.aspectRatio
          , f = this.platform.getMaximumSize(u, t, i, d)
          , o = s.devicePixelRatio || this.platform.getDevicePixelRatio()
          , w = this.width ? "resize" : "attach";
        this.width = f.width,
        this.height = f.height,
        this._aspectRatio = this.aspectRatio,
        i2(this, o, !0) && (this.notifyPlugins("resize", {
            size: f
        }),
        Xi(s.onResize, [this, f], this),
        this.attached && this._doResize(w) && this.render())
    }
    ensureScalesHaveIDs() {
        const i = this.options.scales || {};
        ys(i, (s, u) => {
            s.id = u
        }
        )
    }
    buildOrUpdateScales() {
        const t = this.options
          , i = t.scales
          , s = this.scales
          , u = Object.keys(s).reduce( (f, o) => (f[o] = !1,
        f), {});
        let d = [];
        i && (d = d.concat(Object.keys(i).map(f => {
            const o = i[f]
              , w = vx(f, o)
              , T = w === "r"
              , k = w === "x";
            return {
                options: o,
                dposition: T ? "chartArea" : k ? "bottom" : "left",
                dtype: T ? "radialLinear" : k ? "category" : "linear"
            }
        }
        ))),
        ys(d, f => {
            const o = f.options
              , w = o.id
              , T = vx(w, o)
              , k = zn(o.type, f.dtype);
            (o.position === void 0 || A2(o.position, T) !== A2(f.dposition)) && (o.position = f.dposition),
            u[w] = !0;
            let L = null;
            if (w in s && s[w].type === k)
                L = s[w];
            else {
                const z = qc.getScale(k);
                L = new z({
                    id: w,
                    type: k,
                    ctx: this.ctx,
                    chart: this
                }),
                s[L.id] = L
            }
            L.init(o, t)
        }
        ),
        ys(u, (f, o) => {
            f || delete s[o]
        }
        ),
        ys(s, f => {
            C_.configure(this, f, f.options),
            C_.addBox(this, f)
        }
        )
    }
    _updateMetasets() {
        const t = this._metasets
          , i = this.data.datasets.length
          , s = t.length;
        if (t.sort( (u, d) => u.index - d.index),
        s > i) {
            for (let u = i; u < s; ++u)
                this._destroyDatasetMeta(u);
            t.splice(i, s - i)
        }
        this._sortedMetasets = t.slice(0).sort(z2("order", "index"))
    }
    _removeUnreferencedMetasets() {
        const {_metasets: t, data: {datasets: i}} = this;
        t.length > i.length && delete this._stacks,
        t.forEach( (s, u) => {
            i.filter(d => d === s._dataset).length === 0 && this._destroyDatasetMeta(u)
        }
        )
    }
    buildOrUpdateControllers() {
        const t = []
          , i = this.data.datasets;
        let s, u;
        for (this._removeUnreferencedMetasets(),
        s = 0,
        u = i.length; s < u; s++) {
            const d = i[s];
            let f = this.getDatasetMeta(s);
            const o = d.type || this.config.type;
            if (f.type && f.type !== o && (this._destroyDatasetMeta(s),
            f = this.getDatasetMeta(s)),
            f.type = o,
            f.indexAxis = d.indexAxis || _x(o, this.options),
            f.order = d.order || 0,
            f.index = s,
            f.label = "" + d.label,
            f.visible = this.isDatasetVisible(s),
            f.controller)
                f.controller.updateIndex(s),
                f.controller.linkScales();
            else {
                const w = qc.getController(o)
                  , {datasetElementType: T, dataElementType: k} = fo.datasets[o];
                Object.assign(w, {
                    dataElementType: qc.getElement(k),
                    datasetElementType: T && qc.getElement(T)
                }),
                f.controller = new w(this,s),
                t.push(f.controller)
            }
        }
        return this._updateMetasets(),
        t
    }
    _resetElements() {
        ys(this.data.datasets, (t, i) => {
            this.getDatasetMeta(i).controller.reset()
        }
        , this)
    }
    reset() {
        this._resetElements(),
        this.notifyPlugins("reset")
    }
    update(t) {
        const i = this.config;
        i.update();
        const s = this._options = i.createResolver(i.chartOptionScopes(), this.getContext())
          , u = this._animationsDisabled = !s.animation;
        if (this._updateScales(),
        this._checkEventBindings(),
        this._updateHiddenIndices(),
        this._plugins.invalidate(),
        this.notifyPlugins("beforeUpdate", {
            mode: t,
            cancelable: !0
        }) === !1)
            return;
        const d = this.buildOrUpdateControllers();
        this.notifyPlugins("beforeElementsUpdate");
        let f = 0;
        for (let T = 0, k = this.data.datasets.length; T < k; T++) {
            const {controller: L} = this.getDatasetMeta(T)
              , z = !u && d.indexOf(L) === -1;
            L.buildOrUpdateElements(z),
            f = Math.max(+L.getMaxOverflow(), f)
        }
        f = this._minPadding = s.layout.autoPadding ? f : 0,
        this._updateLayout(f),
        u || ys(d, T => {
            T.reset()
        }
        ),
        this._updateDatasets(t),
        this.notifyPlugins("afterUpdate", {
            mode: t
        }),
        this._layers.sort(z2("z", "_idx"));
        const {_active: o, _lastEvent: w} = this;
        w ? this._eventHandler(w, !0) : o.length && this._updateHoverStyles(o, o, !0),
        this.render()
    }
    _updateScales() {
        ys(this.scales, t => {
            C_.removeBox(this, t)
        }
        ),
        this.ensureScalesHaveIDs(),
        this.buildOrUpdateScales()
    }
    _checkEventBindings() {
        const t = this.options
          , i = new Set(Object.keys(this._listeners))
          , s = new Set(t.events);
        (!VS(i, s) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(),
        this.bindEvents())
    }
    _updateHiddenIndices() {
        const {_hiddenIndices: t} = this
          , i = this._getUniformDataChanges() || [];
        for (const {method: s, start: u, count: d} of i) {
            const f = s === "_removeElements" ? -d : d;
            w6(t, u, f)
        }
    }
    _getUniformDataChanges() {
        const t = this._dataChanges;
        if (!t || !t.length)
            return;
        this._dataChanges = [];
        const i = this.data.datasets.length
          , s = d => new Set(t.filter(f => f[0] === d).map( (f, o) => o + "," + f.splice(1).join(",")))
          , u = s(0);
        for (let d = 1; d < i; d++)
            if (!VS(u, s(d)))
                return;
        return Array.from(u).map(d => d.split(",")).map(d => ({
            method: d[1],
            start: +d[2],
            count: +d[3]
        }))
    }
    _updateLayout(t) {
        if (this.notifyPlugins("beforeLayout", {
            cancelable: !0
        }) === !1)
            return;
        C_.update(this, this.width, this.height, t);
        const i = this.chartArea
          , s = i.width <= 0 || i.height <= 0;
        this._layers = [],
        ys(this.boxes, u => {
            s && u.position === "chartArea" || (u.configure && u.configure(),
            this._layers.push(...u._layers()))
        }
        , this),
        this._layers.forEach( (u, d) => {
            u._idx = d
        }
        ),
        this.notifyPlugins("afterLayout")
    }
    _updateDatasets(t) {
        if (this.notifyPlugins("beforeDatasetsUpdate", {
            mode: t,
            cancelable: !0
        }) !== !1) {
            for (let i = 0, s = this.data.datasets.length; i < s; ++i)
                this.getDatasetMeta(i).controller.configure();
            for (let i = 0, s = this.data.datasets.length; i < s; ++i)
                this._updateDataset(i, Jh(t) ? t({
                    datasetIndex: i
                }) : t);
            this.notifyPlugins("afterDatasetsUpdate", {
                mode: t
            })
        }
    }
    _updateDataset(t, i) {
        const s = this.getDatasetMeta(t)
          , u = {
            meta: s,
            index: t,
            mode: i,
            cancelable: !0
        };
        this.notifyPlugins("beforeDatasetUpdate", u) !== !1 && (s.controller._update(i),
        u.cancelable = !1,
        this.notifyPlugins("afterDatasetUpdate", u))
    }
    render() {
        this.notifyPlugins("beforeRender", {
            cancelable: !0
        }) !== !1 && (th.has(this) ? this.attached && !th.running(this) && th.start(this) : (this.draw(),
        D2({
            chart: this
        })))
    }
    draw() {
        let t;
        if (this._resizeBeforeDraw) {
            const {width: s, height: u} = this._resizeBeforeDraw;
            this._resizeBeforeDraw = null,
            this._resize(s, u)
        }
        if (this.clear(),
        this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
            cancelable: !0
        }) === !1)
            return;
        const i = this._layers;
        for (t = 0; t < i.length && i[t].z <= 0; ++t)
            i[t].draw(this.chartArea);
        for (this._drawDatasets(); t < i.length; ++t)
            i[t].draw(this.chartArea);
        this.notifyPlugins("afterDraw")
    }
    _getSortedDatasetMetas(t) {
        const i = this._sortedMetasets
          , s = [];
        let u, d;
        for (u = 0,
        d = i.length; u < d; ++u) {
            const f = i[u];
            (!t || f.visible) && s.push(f)
        }
        return s
    }
    getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(!0)
    }
    _drawDatasets() {
        if (this.notifyPlugins("beforeDatasetsDraw", {
            cancelable: !0
        }) === !1)
            return;
        const t = this.getSortedVisibleDatasetMetas();
        for (let i = t.length - 1; i >= 0; --i)
            this._drawDataset(t[i]);
        this.notifyPlugins("afterDatasetsDraw")
    }
    _drawDataset(t) {
        const i = this.ctx
          , s = t._clip
          , u = !s.disabled
          , d = C6(t, this.chartArea)
          , f = {
            meta: t,
            index: t.index,
            cancelable: !0
        };
        this.notifyPlugins("beforeDatasetDraw", f) !== !1 && (u && vb(i, {
            left: s.left === !1 ? 0 : d.left - s.left,
            right: s.right === !1 ? this.width : d.right + s.right,
            top: s.top === !1 ? 0 : d.top - s.top,
            bottom: s.bottom === !1 ? this.height : d.bottom + s.bottom
        }),
        t.controller.draw(),
        u && xb(i),
        f.cancelable = !1,
        this.notifyPlugins("afterDatasetDraw", f))
    }
    isPointInArea(t) {
        return ty(t, this.chartArea, this._minPadding)
    }
    getElementsAtEventForMode(t, i, s, u) {
        const d = x$.modes[i];
        return typeof d == "function" ? d(this, t, s, u) : []
    }
    getDatasetMeta(t) {
        const i = this.data.datasets[t]
          , s = this._metasets;
        let u = s.filter(d => d && d._dataset === i).pop();
        return u || (u = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
            order: i && i.order || 0,
            index: t,
            _dataset: i,
            _parsed: [],
            _sorted: !1
        },
        s.push(u)),
        u
    }
    getContext() {
        return this.$context || (this.$context = tm(null, {
            chart: this,
            type: "chart"
        }))
    }
    getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length
    }
    isDatasetVisible(t) {
        const i = this.data.datasets[t];
        if (!i)
            return !1;
        const s = this.getDatasetMeta(t);
        return typeof s.hidden == "boolean" ? !s.hidden : !i.hidden
    }
    setDatasetVisibility(t, i) {
        const s = this.getDatasetMeta(t);
        s.hidden = !i
    }
    toggleDataVisibility(t) {
        this._hiddenIndices[t] = !this._hiddenIndices[t]
    }
    getDataVisibility(t) {
        return !this._hiddenIndices[t]
    }
    _updateVisibility(t, i, s) {
        const u = s ? "show" : "hide"
          , d = this.getDatasetMeta(t)
          , f = d.controller._resolveAnimations(void 0, u);
        ey(i) ? (d.data[i].hidden = !s,
        this.update()) : (this.setDatasetVisibility(t, s),
        f.update(d, {
            visible: s
        }),
        this.update(o => o.datasetIndex === t ? u : void 0))
    }
    hide(t, i) {
        this._updateVisibility(t, i, !1)
    }
    show(t, i) {
        this._updateVisibility(t, i, !0)
    }
    _destroyDatasetMeta(t) {
        const i = this._metasets[t];
        i && i.controller && i.controller._destroy(),
        delete this._metasets[t]
    }
    _stop() {
        let t, i;
        for (this.stop(),
        th.remove(this),
        t = 0,
        i = this.data.datasets.length; t < i; ++t)
            this._destroyDatasetMeta(t)
    }
    destroy() {
        this.notifyPlugins("beforeDestroy");
        const {canvas: t, ctx: i} = this;
        this._stop(),
        this.config.clearCache(),
        t && (this.unbindEvents(),
        e2(t, i),
        this.platform.releaseContext(i),
        this.canvas = null,
        this.ctx = null),
        delete $_[this.id],
        this.notifyPlugins("afterDestroy")
    }
    toBase64Image(...t) {
        return this.canvas.toDataURL(...t)
    }
    bindEvents() {
        this.bindUserEvents(),
        this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
    }
    bindUserEvents() {
        const t = this._listeners
          , i = this.platform
          , s = (d, f) => {
            i.addEventListener(this, d, f),
            t[d] = f
        }
          , u = (d, f, o) => {
            d.offsetX = f,
            d.offsetY = o,
            this._eventHandler(d)
        }
        ;
        ys(this.options.events, d => s(d, u))
    }
    bindResponsiveEvents() {
        this._responsiveListeners || (this._responsiveListeners = {});
        const t = this._responsiveListeners
          , i = this.platform
          , s = (w, T) => {
            i.addEventListener(this, w, T),
            t[w] = T
        }
          , u = (w, T) => {
            t[w] && (i.removeEventListener(this, w, T),
            delete t[w])
        }
          , d = (w, T) => {
            this.canvas && this.resize(w, T)
        }
        ;
        let f;
        const o = () => {
            u("attach", o),
            this.attached = !0,
            this.resize(),
            s("resize", d),
            s("detach", f)
        }
        ;
        f = () => {
            this.attached = !1,
            u("resize", d),
            this._stop(),
            this._resize(0, 0),
            s("attach", o)
        }
        ,
        i.isAttached(this.canvas) ? o() : f()
    }
    unbindEvents() {
        ys(this._listeners, (t, i) => {
            this.platform.removeEventListener(this, i, t)
        }
        ),
        this._listeners = {},
        ys(this._responsiveListeners, (t, i) => {
            this.platform.removeEventListener(this, i, t)
        }
        ),
        this._responsiveListeners = void 0
    }
    updateHoverStyle(t, i, s) {
        const u = s ? "set" : "remove";
        let d, f, o, w;
        for (i === "dataset" && (d = this.getDatasetMeta(t[0].datasetIndex),
        d.controller["_" + u + "DatasetHoverStyle"]()),
        o = 0,
        w = t.length; o < w; ++o) {
            f = t[o];
            const T = f && this.getDatasetMeta(f.datasetIndex).controller;
            T && T[u + "HoverStyle"](f.element, f.datasetIndex, f.index)
        }
    }
    getActiveElements() {
        return this._active || []
    }
    setActiveElements(t) {
        const i = this._active || []
          , s = t.map( ({datasetIndex: d, index: f}) => {
            const o = this.getDatasetMeta(d);
            if (!o)
                throw new Error("No dataset found at index " + d);
            return {
                datasetIndex: d,
                element: o.data[f],
                index: f
            }
        }
        );
        !NS(s, i) && (this._active = s,
        this._lastEvent = null,
        this._updateHoverStyles(s, i))
    }
    notifyPlugins(t, i, s) {
        return this._plugins.notify(this, t, i, s)
    }
    isPluginEnabled(t) {
        return this._plugins._cache.filter(i => i.plugin.id === t).length === 1
    }
    _updateHoverStyles(t, i, s) {
        const u = this.options.hover
          , d = (w, T) => w.filter(k => !T.some(L => k.datasetIndex === L.datasetIndex && k.index === L.index))
          , f = d(i, t)
          , o = s ? t : d(t, i);
        f.length && this.updateHoverStyle(f, u.mode, !1),
        o.length && u.mode && this.updateHoverStyle(o, u.mode, !0)
    }
    _eventHandler(t, i) {
        const s = {
            event: t,
            replay: i,
            cancelable: !0,
            inChartArea: this.isPointInArea(t)
        }
          , u = f => (f.options.events || this.options.events).includes(t.native.type);
        if (this.notifyPlugins("beforeEvent", s, u) === !1)
            return;
        const d = this._handleEvent(t, i, s.inChartArea);
        return s.cancelable = !1,
        this.notifyPlugins("afterEvent", s, u),
        (d || s.changed) && this.render(),
        this
    }
    _handleEvent(t, i, s) {
        const {_active: u=[], options: d} = this
          , f = i
          , o = this._getActiveElements(t, u, s, f)
          , w = x4(t)
          , T = S6(t, this._lastEvent, s, w);
        s && (this._lastEvent = null,
        Xi(d.onHover, [t, o, this], this),
        w && Xi(d.onClick, [t, o, this], this));
        const k = !NS(o, u);
        return (k || i) && (this._active = o,
        this._updateHoverStyles(o, u, i)),
        this._lastEvent = T,
        k
    }
    _getActiveElements(t, i, s, u) {
        if (t.type === "mouseout")
            return [];
        if (!s)
            return i;
        const d = this.options.hover;
        return this.getElementsAtEventForMode(t, d.mode, d, u)
    }
}
;
function O2() {
    return ys(nd.instances, e => e._plugins.invalidate())
}
function cM(e, t, i=t) {
    e.lineCap = zn(i.borderCapStyle, t.borderCapStyle),
    e.setLineDash(zn(i.borderDash, t.borderDash)),
    e.lineDashOffset = zn(i.borderDashOffset, t.borderDashOffset),
    e.lineJoin = zn(i.borderJoinStyle, t.borderJoinStyle),
    e.lineWidth = zn(i.borderWidth, t.borderWidth),
    e.strokeStyle = zn(i.borderColor, t.borderColor)
}
function T6(e, t, i) {
    e.lineTo(i.x, i.y)
}
function P6(e) {
    return e.stepped ? H4 : e.tension || e.cubicInterpolationMode === "monotone" ? Z4 : T6
}
function uM(e, t, i={}) {
    const s = e.length
      , {start: u=0, end: d=s - 1} = i
      , {start: f, end: o} = t
      , w = Math.max(u, f)
      , T = Math.min(d, o)
      , k = u < f && d < f || u > o && d > o;
    return {
        count: s,
        start: w,
        loop: t.loop,
        ilen: T < w && !k ? s + T - w : T - w
    }
}
function M6(e, t, i, s) {
    const {points: u, options: d} = t
      , {count: f, start: o, loop: w, ilen: T} = uM(u, i, s)
      , k = P6(d);
    let {move: L=!0, reverse: z} = s || {}, D, N, U;
    for (D = 0; D <= T; ++D)
        N = u[(o + (z ? T - D : D)) % f],
        !N.skip && (L ? (e.moveTo(N.x, N.y),
        L = !1) : k(e, U, N, z, d.stepped),
        U = N);
    return w && (N = u[(o + (z ? T : 0)) % f],
    k(e, U, N, z, d.stepped)),
    !!w
}
function k6(e, t, i, s) {
    const u = t.points
      , {count: d, start: f, ilen: o} = uM(u, i, s)
      , {move: w=!0, reverse: T} = s || {};
    let k = 0, L = 0, z, D, N, U, V, re;
    const ie = ce => (f + (T ? o - ce : ce)) % d
      , ue = () => {
        U !== V && (e.lineTo(k, V),
        e.lineTo(k, U),
        e.lineTo(k, re))
    }
    ;
    for (w && (D = u[ie(0)],
    e.moveTo(D.x, D.y)),
    z = 0; z <= o; ++z) {
        if (D = u[ie(z)],
        D.skip)
            continue;
        const ce = D.x
          , X = D.y
          , me = ce | 0;
        me === N ? (X < U ? U = X : X > V && (V = X),
        k = (L * k + ce) / ++L) : (ue(),
        e.lineTo(ce, X),
        N = me,
        L = 0,
        U = V = X),
        re = X
    }
    ue()
}
function xx(e) {
    const t = e.options
      , i = t.borderDash && t.borderDash.length;
    return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !i ? k6 : M6
}
function E6(e) {
    return e.stepped ? kN : e.tension || e.cubicInterpolationMode === "monotone" ? EN : af
}
function I6(e, t, i, s) {
    let u = t._path;
    u || (u = t._path = new Path2D,
    t.path(u, i, s) && u.closePath()),
    cM(e, t.options),
    e.stroke(u)
}
function R6(e, t, i, s) {
    const {segments: u, options: d} = t
      , f = xx(t);
    for (const o of u)
        cM(e, d, o.style),
        e.beginPath(),
        f(e, t, o, {
            start: i,
            end: i + s - 1
        }) && e.closePath(),
        e.stroke()
}
const A6 = typeof Path2D == "function";
function z6(e, t, i, s) {
    A6 && !t.options.segment ? I6(e, t, i, s) : R6(e, t, i, s)
}
class Av extends Rv {
    static id = "line";
    static defaults = {
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderWidth: 3,
        capBezierPoints: !0,
        cubicInterpolationMode: "default",
        fill: !1,
        spanGaps: !1,
        stepped: !1,
        tension: 0
    };
    static defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    static descriptors = {
        _scriptable: !0,
        _indexable: t => t !== "borderDash" && t !== "fill"
    };
    constructor(t) {
        super(),
        this.animated = !0,
        this.options = void 0,
        this._chart = void 0,
        this._loop = void 0,
        this._fullLoop = void 0,
        this._path = void 0,
        this._points = void 0,
        this._segments = void 0,
        this._decimated = !1,
        this._pointsUpdated = !1,
        this._datasetIndex = void 0,
        t && Object.assign(this, t)
    }
    updateControlPoints(t, i) {
        const s = this.options;
        if ((s.tension || s.cubicInterpolationMode === "monotone") && !s.stepped && !this._pointsUpdated) {
            const u = s.spanGaps ? this._loop : this._fullLoop;
            xN(this._points, s, t, u, i),
            this._pointsUpdated = !0
        }
    }
    set points(t) {
        this._points = t,
        delete this._segments,
        delete this._path,
        this._pointsUpdated = !1
    }
    get points() {
        return this._points
    }
    get segments() {
        return this._segments || (this._segments = zN(this, this.options.segment))
    }
    first() {
        const t = this.segments
          , i = this.points;
        return t.length && i[t[0].start]
    }
    last() {
        const t = this.segments
          , i = this.points
          , s = t.length;
        return s && i[t[s - 1].end]
    }
    interpolate(t, i) {
        const s = this.options
          , u = t[i]
          , d = this.points
          , f = YP(this, {
            property: i,
            start: u,
            end: u
        });
        if (!f.length)
            return;
        const o = []
          , w = E6(s);
        let T, k;
        for (T = 0,
        k = f.length; T < k; ++T) {
            const {start: L, end: z} = f[T]
              , D = d[L]
              , N = d[z];
            if (D === N) {
                o.push(D);
                continue
            }
            const U = Math.abs((u - D[i]) / (N[i] - D[i]))
              , V = w(D, N, U, s.stepped);
            V[i] = t[i],
            o.push(V)
        }
        return o.length === 1 ? o[0] : o
    }
    pathSegment(t, i, s) {
        return xx(this)(t, this, i, s)
    }
    path(t, i, s) {
        const u = this.segments
          , d = xx(this);
        let f = this._loop;
        i = i || 0,
        s = s || this.points.length - i;
        for (const o of u)
            f &= d(t, this, o, {
                start: i,
                end: i + s - 1
            });
        return !!f
    }
    draw(t, i, s, u) {
        const d = this.options || {};
        (this.points || []).length && d.borderWidth && (t.save(),
        z6(t, this, s, u),
        t.restore()),
        this.animated && (this._pointsUpdated = !1,
        this._path = void 0)
    }
}
function F2(e, t, i, s) {
    const u = e.options
      , {[i]: d} = e.getProps([i], s);
    return Math.abs(t - d) < u.radius + u.hitRadius
}
class D6 extends Rv {
    static id = "point";
    parsed;
    skip;
    stop;
    static defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: "circle",
        radius: 3,
        rotation: 0
    };
    static defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    constructor(t) {
        super(),
        this.options = void 0,
        this.parsed = void 0,
        this.skip = void 0,
        this.stop = void 0,
        t && Object.assign(this, t)
    }
    inRange(t, i, s) {
        const u = this.options
          , {x: d, y: f} = this.getProps(["x", "y"], s);
        return Math.pow(t - d, 2) + Math.pow(i - f, 2) < Math.pow(u.hitRadius + u.radius, 2)
    }
    inXRange(t, i) {
        return F2(this, t, "x", i)
    }
    inYRange(t, i) {
        return F2(this, t, "y", i)
    }
    getCenterPoint(t) {
        const {x: i, y: s} = this.getProps(["x", "y"], t);
        return {
            x: i,
            y: s
        }
    }
    size(t) {
        t = t || this.options || {};
        let i = t.radius || 0;
        i = Math.max(i, i && t.hoverRadius || 0);
        const s = i && t.borderWidth || 0;
        return (i + s) * 2
    }
    draw(t, i) {
        const s = this.options;
        this.skip || s.radius < .1 || !ty(this, i, this.size(s) / 2) || (t.strokeStyle = s.borderColor,
        t.lineWidth = s.borderWidth,
        t.fillStyle = s.backgroundColor,
        W4(t, s, this.x, this.y))
    }
    getRange() {
        const t = this.options || {};
        return t.radius + t.hitRadius
    }
}
function L6(e, t, i) {
    const s = e.segments
      , u = e.points
      , d = t.points
      , f = [];
    for (const o of s) {
        let {start: w, end: T} = o;
        T = Mb(w, T, u);
        const k = bx(i, u[w], u[T], o.loop);
        if (!t.segments) {
            f.push({
                source: o,
                target: k,
                start: u[w],
                end: u[T]
            });
            continue
        }
        const L = YP(t, k);
        for (const z of L) {
            const D = bx(i, d[z.start], d[z.end], z.loop)
              , N = XP(o, u, D);
            for (const U of N)
                f.push({
                    source: U,
                    target: z,
                    start: {
                        [i]: B2(k, D, "start", Math.max)
                    },
                    end: {
                        [i]: B2(k, D, "end", Math.min)
                    }
                })
        }
    }
    return f
}
function bx(e, t, i, s) {
    if (s)
        return;
    let u = t[e]
      , d = i[e];
    return e === "angle" && (u = Hc(u),
    d = Hc(d)),
    {
        property: e,
        start: u,
        end: d
    }
}
function O6(e, t) {
    const {x: i=null, y: s=null} = e || {}
      , u = t.points
      , d = [];
    return t.segments.forEach( ({start: f, end: o}) => {
        o = Mb(f, o, u);
        const w = u[f]
          , T = u[o];
        s !== null ? (d.push({
            x: w.x,
            y: s
        }),
        d.push({
            x: T.x,
            y: s
        })) : i !== null && (d.push({
            x: i,
            y: w.y
        }),
        d.push({
            x: i,
            y: T.y
        }))
    }
    ),
    d
}
function Mb(e, t, i) {
    for (; t > e; t--) {
        const s = i[t];
        if (!isNaN(s.x) && !isNaN(s.y))
            break
    }
    return t
}
function B2(e, t, i, s) {
    return e && t ? s(e[i], t[i]) : e ? e[i] : t ? t[i] : 0
}
function hM(e, t) {
    let i = []
      , s = !1;
    return Vo(e) ? (s = !0,
    i = e) : i = O6(e, t),
    i.length ? new Av({
        points: i,
        options: {
            tension: 0
        },
        _loop: s,
        _fullLoop: s
    }) : null
}
function j2(e) {
    return e && e.fill !== !1
}
function F6(e, t, i) {
    let u = e[t].fill;
    const d = [t];
    let f;
    if (!i)
        return u;
    for (; u !== !1 && d.indexOf(u) === -1; ) {
        if (!_s(u))
            return u;
        if (f = e[u],
        !f)
            return !1;
        if (f.visible)
            return u;
        d.push(u),
        u = f.fill
    }
    return !1
}
function B6(e, t, i) {
    const s = V6(e);
    if (Cn(s))
        return isNaN(s.value) ? !1 : s;
    let u = parseFloat(s);
    return _s(u) && Math.floor(u) === u ? j6(s[0], t, u, i) : ["origin", "start", "end", "stack", "shape"].indexOf(s) >= 0 && s
}
function j6(e, t, i, s) {
    return (e === "-" || e === "+") && (i = t + i),
    i === t || i < 0 || i >= s ? !1 : i
}
function N6(e, t) {
    let i = null;
    return e === "start" ? i = t.bottom : e === "end" ? i = t.top : Cn(e) ? i = t.getPixelForValue(e.value) : t.getBasePixel && (i = t.getBasePixel()),
    i
}
function $6(e, t, i) {
    let s;
    return e === "start" ? s = i : e === "end" ? s = t.options.reverse ? t.min : t.max : Cn(e) ? s = e.value : s = t.getBaseValue(),
    s
}
function V6(e) {
    const t = e.options
      , i = t.fill;
    let s = zn(i && i.target, i);
    return s === void 0 && (s = !!t.backgroundColor),
    s === !1 || s === null ? !1 : s === !0 ? "origin" : s
}
function U6(e) {
    const {scale: t, index: i, line: s} = e
      , u = []
      , d = s.segments
      , f = s.points
      , o = G6(t, i);
    o.push(hM({
        x: null,
        y: t.bottom
    }, s));
    for (let w = 0; w < d.length; w++) {
        const T = d[w];
        for (let k = T.start; k <= T.end; k++)
            W6(u, f[k], o)
    }
    return new Av({
        points: u,
        options: {}
    })
}
function G6(e, t) {
    const i = []
      , s = e.getMatchingVisibleMetas("line");
    for (let u = 0; u < s.length; u++) {
        const d = s[u];
        if (d.index === t)
            break;
        d.hidden || i.unshift(d.dataset)
    }
    return i
}
function W6(e, t, i) {
    const s = [];
    for (let u = 0; u < i.length; u++) {
        const d = i[u]
          , {first: f, last: o, point: w} = q6(d, t, "x");
        if (!(!w || f && o)) {
            if (f)
                s.unshift(w);
            else if (e.push(w),
            !o)
                break
        }
    }
    e.push(...s)
}
function q6(e, t, i) {
    const s = e.interpolate(t, i);
    if (!s)
        return {};
    const u = s[i]
      , d = e.segments
      , f = e.points;
    let o = !1
      , w = !1;
    for (let T = 0; T < d.length; T++) {
        const k = d[T]
          , L = f[k.start][i]
          , z = f[k.end][i];
        if (DP(u, L, z)) {
            o = u === L,
            w = u === z;
            break
        }
    }
    return {
        first: o,
        last: w,
        point: s
    }
}
class dM {
    constructor(t) {
        this.x = t.x,
        this.y = t.y,
        this.radius = t.radius
    }
    pathSegment(t, i, s) {
        const {x: u, y: d, radius: f} = this;
        return i = i || {
            start: 0,
            end: Bs
        },
        t.arc(u, d, f, i.end, i.start, !0),
        !s.bounds
    }
    interpolate(t) {
        const {x: i, y: s, radius: u} = this
          , d = t.angle;
        return {
            x: i + Math.cos(d) * u,
            y: s + Math.sin(d) * u,
            angle: d
        }
    }
}
function H6(e) {
    const {chart: t, fill: i, line: s} = e;
    if (_s(i))
        return Z6(t, i);
    if (i === "stack")
        return U6(e);
    if (i === "shape")
        return !0;
    const u = X6(e);
    return u instanceof dM ? u : hM(u, s)
}
function Z6(e, t) {
    const i = e.getDatasetMeta(t);
    return i && e.isDatasetVisible(t) ? i.dataset : null
}
function X6(e) {
    return (e.scale || {}).getPointPositionForValue ? K6(e) : Y6(e)
}
function Y6(e) {
    const {scale: t={}, fill: i} = e
      , s = N6(i, t);
    if (_s(s)) {
        const u = t.isHorizontal();
        return {
            x: u ? s : null,
            y: u ? null : s
        }
    }
    return null
}
function K6(e) {
    const {scale: t, fill: i} = e
      , s = t.options
      , u = t.getLabels().length
      , d = s.reverse ? t.max : t.min
      , f = $6(i, t, d)
      , o = [];
    if (s.grid.circular) {
        const w = t.getPointPositionForValue(0, d);
        return new dM({
            x: w.x,
            y: w.y,
            radius: t.getDistanceFromCenterForValue(f)
        })
    }
    for (let w = 0; w < u; ++w)
        o.push(t.getPointPositionForValue(w, f));
    return o
}
function G0(e, t, i) {
    const s = H6(t)
      , {line: u, scale: d, axis: f} = t
      , o = u.options
      , w = o.fill
      , T = o.backgroundColor
      , {above: k=T, below: L=T} = w || {};
    s && u.points.length && (vb(e, i),
    Q6(e, {
        line: u,
        target: s,
        above: k,
        below: L,
        area: i,
        scale: d,
        axis: f
    }),
    xb(e))
}
function Q6(e, t) {
    const {line: i, target: s, above: u, below: d, area: f, scale: o} = t
      , w = i._loop ? "angle" : t.axis;
    e.save(),
    w === "x" && d !== u && (N2(e, s, f.top),
    $2(e, {
        line: i,
        target: s,
        color: u,
        scale: o,
        property: w
    }),
    e.restore(),
    e.save(),
    N2(e, s, f.bottom)),
    $2(e, {
        line: i,
        target: s,
        color: d,
        scale: o,
        property: w
    }),
    e.restore()
}
function N2(e, t, i) {
    const {segments: s, points: u} = t;
    let d = !0
      , f = !1;
    e.beginPath();
    for (const o of s) {
        const {start: w, end: T} = o
          , k = u[w]
          , L = u[Mb(w, T, u)];
        d ? (e.moveTo(k.x, k.y),
        d = !1) : (e.lineTo(k.x, i),
        e.lineTo(k.x, k.y)),
        f = !!t.pathSegment(e, o, {
            move: f
        }),
        f ? e.closePath() : e.lineTo(L.x, i)
    }
    e.lineTo(t.first().x, i),
    e.closePath(),
    e.clip()
}
function $2(e, t) {
    const {line: i, target: s, property: u, color: d, scale: f} = t
      , o = L6(i, s, u);
    for (const {source: w, target: T, start: k, end: L} of o) {
        const {style: {backgroundColor: z=d}={}} = w
          , D = s !== !0;
        e.save(),
        e.fillStyle = z,
        J6(e, f, D && bx(u, k, L)),
        e.beginPath();
        const N = !!i.pathSegment(e, w);
        let U;
        if (D) {
            N ? e.closePath() : V2(e, s, L, u);
            const V = !!s.pathSegment(e, T, {
                move: N,
                reverse: !0
            });
            U = N && V,
            U || V2(e, s, k, u)
        }
        e.closePath(),
        e.fill(U ? "evenodd" : "nonzero"),
        e.restore()
    }
}
function J6(e, t, i) {
    const {top: s, bottom: u} = t.chart.chartArea
      , {property: d, start: f, end: o} = i || {};
    d === "x" && (e.beginPath(),
    e.rect(f, s, o - f, u - s),
    e.clip())
}
function V2(e, t, i, s) {
    const u = t.interpolate(i, s);
    u && e.lineTo(u.x, u.y)
}
var eV = {
    id: "filler",
    afterDatasetsUpdate(e, t, i) {
        const s = (e.data.datasets || []).length
          , u = [];
        let d, f, o, w;
        for (f = 0; f < s; ++f)
            d = e.getDatasetMeta(f),
            o = d.dataset,
            w = null,
            o && o.options && o instanceof Av && (w = {
                visible: e.isDatasetVisible(f),
                index: f,
                fill: B6(o, f, s),
                chart: e,
                axis: d.controller.options.indexAxis,
                scale: d.vScale,
                line: o
            }),
            d.$filler = w,
            u.push(w);
        for (f = 0; f < s; ++f)
            w = u[f],
            !(!w || w.fill === !1) && (w.fill = F6(u, f, i.propagate))
    },
    beforeDraw(e, t, i) {
        const s = i.drawTime === "beforeDraw"
          , u = e.getSortedVisibleDatasetMetas()
          , d = e.chartArea;
        for (let f = u.length - 1; f >= 0; --f) {
            const o = u[f].$filler;
            o && (o.line.updateControlPoints(d, o.axis),
            s && o.fill && G0(e.ctx, o, d))
        }
    },
    beforeDatasetsDraw(e, t, i) {
        if (i.drawTime !== "beforeDatasetsDraw")
            return;
        const s = e.getSortedVisibleDatasetMetas();
        for (let u = s.length - 1; u >= 0; --u) {
            const d = s[u].$filler;
            j2(d) && G0(e.ctx, d, e.chartArea)
        }
    },
    beforeDatasetDraw(e, t, i) {
        const s = t.meta.$filler;
        !j2(s) || i.drawTime !== "beforeDatasetDraw" || G0(e.ctx, s, e.chartArea)
    },
    defaults: {
        propagate: !0,
        drawTime: "beforeDatasetDraw"
    }
};
const tV = (e, t, i, s) => (typeof t == "string" ? (i = e.push(t) - 1,
s.unshift({
    index: i,
    label: t
})) : isNaN(t) && (i = null),
i);
function rV(e, t, i, s) {
    const u = e.indexOf(t);
    if (u === -1)
        return tV(e, t, i, s);
    const d = e.lastIndexOf(t);
    return u !== d ? i : u
}
const nV = (e, t) => e === null ? null : Jc(Math.round(e), 0, t);
function U2(e) {
    const t = this.getLabels();
    return e >= 0 && e < t.length ? t[e] : e
}
class iV extends rm {
    static id = "category";
    static defaults = {
        ticks: {
            callback: U2
        }
    };
    constructor(t) {
        super(t),
        this._startValue = void 0,
        this._valueRange = 0,
        this._addedLabels = []
    }
    init(t) {
        const i = this._addedLabels;
        if (i.length) {
            const s = this.getLabels();
            for (const {index: u, label: d} of i)
                s[u] === d && s.splice(u, 1);
            this._addedLabels = []
        }
        super.init(t)
    }
    parse(t, i) {
        if (li(t))
            return null;
        const s = this.getLabels();
        return i = isFinite(i) && s[i] === t ? i : rV(s, t, zn(i, t), this._addedLabels),
        nV(i, s.length - 1)
    }
    determineDataLimits() {
        const {minDefined: t, maxDefined: i} = this.getUserBounds();
        let {min: s, max: u} = this.getMinMax(!0);
        this.options.bounds === "ticks" && (t || (s = 0),
        i || (u = this.getLabels().length - 1)),
        this.min = s,
        this.max = u
    }
    buildTicks() {
        const t = this.min
          , i = this.max
          , s = this.options.offset
          , u = [];
        let d = this.getLabels();
        d = t === 0 && i === d.length - 1 ? d : d.slice(t, i + 1),
        this._valueRange = Math.max(d.length - (s ? 0 : 1), 1),
        this._startValue = this.min - (s ? .5 : 0);
        for (let f = t; f <= i; f++)
            u.push({
                value: f
            });
        return u
    }
    getLabelForValue(t) {
        return U2.call(this, t)
    }
    configure() {
        super.configure(),
        this.isHorizontal() || (this._reversePixels = !this._reversePixels)
    }
    getPixelForValue(t) {
        return typeof t != "number" && (t = this.parse(t)),
        t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
    }
    getPixelForTick(t) {
        const i = this.ticks;
        return t < 0 || t > i.length - 1 ? null : this.getPixelForValue(i[t].value)
    }
    getValueForPixel(t) {
        return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange)
    }
    getBasePixel() {
        return this.bottom
    }
}
function oV(e, t) {
    const i = []
      , {bounds: u, step: d, min: f, max: o, precision: w, count: T, maxTicks: k, maxDigits: L, includeBounds: z} = e
      , D = d || 1
      , N = k - 1
      , {min: U, max: V} = t
      , re = !li(f)
      , ie = !li(o)
      , ue = !li(T)
      , ce = (V - U) / (L + 1);
    let X = GS((V - U) / N / D) * D, me, K, be, Ee;
    if (X < 1e-14 && !re && !ie)
        return [{
            value: U
        }, {
            value: V
        }];
    Ee = Math.ceil(V / X) - Math.floor(U / X),
    Ee > N && (X = GS(Ee * X / N / D) * D),
    li(w) || (me = Math.pow(10, w),
    X = Math.ceil(X * me) / me),
    u === "ticks" ? (K = Math.floor(U / X) * X,
    be = Math.ceil(V / X) * X) : (K = U,
    be = V),
    re && ie && d && C4((o - f) / d, X / 1e3) ? (Ee = Math.round(Math.min((o - f) / X, k)),
    X = (o - f) / Ee,
    K = f,
    be = o) : ue ? (K = re ? f : K,
    be = ie ? o : be,
    Ee = T - 1,
    X = (be - K) / Ee) : (Ee = (be - K) / X,
    Ng(Ee, Math.round(Ee), X / 1e3) ? Ee = Math.round(Ee) : Ee = Math.ceil(Ee));
    const Ce = Math.max(WS(X), WS(K));
    me = Math.pow(10, li(w) ? Ce : w),
    K = Math.round(K * me) / me,
    be = Math.round(be * me) / me;
    let He = 0;
    for (re && (z && K !== f ? (i.push({
        value: f
    }),
    K < f && He++,
    Ng(Math.round((K + He * X) * me) / me, f, G2(f, ce, e)) && He++) : K < f && He++); He < Ee; ++He) {
        const ct = Math.round((K + He * X) * me) / me;
        if (ie && ct > o)
            break;
        i.push({
            value: ct
        })
    }
    return ie && z && be !== o ? i.length && Ng(i[i.length - 1].value, o, G2(o, ce, e)) ? i[i.length - 1].value = o : i.push({
        value: o
    }) : (!ie || be === o) && i.push({
        value: be
    }),
    i
}
function G2(e, t, {horizontal: i, minRotation: s}) {
    const u = Qc(s)
      , d = (i ? Math.sin(u) : Math.cos(u)) || .001
      , f = .75 * t * ("" + e).length;
    return Math.min(t / d, f)
}
class sV extends rm {
    constructor(t) {
        super(t),
        this.start = void 0,
        this.end = void 0,
        this._startValue = void 0,
        this._endValue = void 0,
        this._valueRange = 0
    }
    parse(t, i) {
        return li(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t
    }
    handleTickRangeOptions() {
        const {beginAtZero: t} = this.options
          , {minDefined: i, maxDefined: s} = this.getUserBounds();
        let {min: u, max: d} = this;
        const f = w => u = i ? u : w
          , o = w => d = s ? d : w;
        if (t) {
            const w = ru(u)
              , T = ru(d);
            w < 0 && T < 0 ? o(0) : w > 0 && T > 0 && f(0)
        }
        if (u === d) {
            let w = d === 0 ? 1 : Math.abs(d * .05);
            o(d + w),
            t || f(u - w)
        }
        this.min = u,
        this.max = d
    }
    getTickLimit() {
        const t = this.options.ticks;
        let {maxTicksLimit: i, stepSize: s} = t, u;
        return s ? (u = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1,
        u > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${u} ticks. Limiting to 1000.`),
        u = 1e3)) : (u = this.computeTickLimit(),
        i = i || 11),
        i && (u = Math.min(i, u)),
        u
    }
    computeTickLimit() {
        return Number.POSITIVE_INFINITY
    }
    buildTicks() {
        const t = this.options
          , i = t.ticks;
        let s = this.getTickLimit();
        s = Math.max(2, s);
        const u = {
            maxTicks: s,
            bounds: t.bounds,
            min: t.min,
            max: t.max,
            precision: i.precision,
            step: i.stepSize,
            count: i.count,
            maxDigits: this._maxDigits(),
            horizontal: this.isHorizontal(),
            minRotation: i.minRotation || 0,
            includeBounds: i.includeBounds !== !1
        }
          , d = this._range || this
          , f = oV(u, d);
        return t.bounds === "ticks" && T4(f, this, "value"),
        t.reverse ? (f.reverse(),
        this.start = this.max,
        this.end = this.min) : (this.start = this.min,
        this.end = this.max),
        f
    }
    configure() {
        const t = this.ticks;
        let i = this.min
          , s = this.max;
        if (super.configure(),
        this.options.offset && t.length) {
            const u = (s - i) / Math.max(t.length - 1, 1) / 2;
            i -= u,
            s += u
        }
        this._startValue = i,
        this._endValue = s,
        this._valueRange = s - i
    }
    getLabelForValue(t) {
        return kv(t, this.chart.options.locale, this.options.ticks.format)
    }
}
class aV extends sV {
    static id = "linear";
    static defaults = {
        ticks: {
            callback: $P.formatters.numeric
        }
    };
    determineDataLimits() {
        const {min: t, max: i} = this.getMinMax(!0);
        this.min = _s(t) ? t : 0,
        this.max = _s(i) ? i : 1,
        this.handleTickRangeOptions()
    }
    computeTickLimit() {
        const t = this.isHorizontal()
          , i = t ? this.width : this.height
          , s = Qc(this.options.ticks.minRotation)
          , u = (t ? Math.sin(s) : Math.cos(s)) || .001
          , d = this._resolveTickFontOptions(0);
        return Math.ceil(i / Math.min(40, d.lineHeight / u))
    }
    getPixelForValue(t) {
        return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
    }
    getValueForPixel(t) {
        return this._startValue + this.getDecimalForPixel(t) * this._valueRange
    }
}
const zv = {
    millisecond: {
        common: !0,
        size: 1,
        steps: 1e3
    },
    second: {
        common: !0,
        size: 1e3,
        steps: 60
    },
    minute: {
        common: !0,
        size: 6e4,
        steps: 60
    },
    hour: {
        common: !0,
        size: 36e5,
        steps: 24
    },
    day: {
        common: !0,
        size: 864e5,
        steps: 30
    },
    week: {
        common: !1,
        size: 6048e5,
        steps: 4
    },
    month: {
        common: !0,
        size: 2628e6,
        steps: 12
    },
    quarter: {
        common: !1,
        size: 7884e6,
        steps: 4
    },
    year: {
        common: !0,
        size: 3154e7
    }
}
  , ta = Object.keys(zv);
function W2(e, t) {
    return e - t
}
function q2(e, t) {
    if (li(t))
        return null;
    const i = e._adapter
      , {parser: s, round: u, isoWeekday: d} = e._parseOpts;
    let f = t;
    return typeof s == "function" && (f = s(f)),
    _s(f) || (f = typeof s == "string" ? i.parse(f, s) : i.parse(f)),
    f === null ? null : (u && (f = u === "week" && (qp(d) || d === !0) ? i.startOf(f, "isoWeek", d) : i.startOf(f, u)),
    +f)
}
function H2(e, t, i, s) {
    const u = ta.length;
    for (let d = ta.indexOf(e); d < u - 1; ++d) {
        const f = zv[ta[d]]
          , o = f.steps ? f.steps : Number.MAX_SAFE_INTEGER;
        if (f.common && Math.ceil((i - t) / (o * f.size)) <= s)
            return ta[d]
    }
    return ta[u - 1]
}
function lV(e, t, i, s, u) {
    for (let d = ta.length - 1; d >= ta.indexOf(i); d--) {
        const f = ta[d];
        if (zv[f].common && e._adapter.diff(u, s, f) >= t - 1)
            return f
    }
    return ta[i ? ta.indexOf(i) : 0]
}
function cV(e) {
    for (let t = ta.indexOf(e) + 1, i = ta.length; t < i; ++t)
        if (zv[ta[t]].common)
            return ta[t]
}
function Z2(e, t, i) {
    if (!i)
        e[t] = !0;
    else if (i.length) {
        const {lo: s, hi: u} = yb(i, t)
          , d = i[s] >= t ? i[s] : i[u];
        e[d] = !0
    }
}
function uV(e, t, i, s) {
    const u = e._adapter
      , d = +u.startOf(t[0].value, s)
      , f = t[t.length - 1].value;
    let o, w;
    for (o = d; o <= f; o = +u.add(o, 1, s))
        w = i[o],
        w >= 0 && (t[w].major = !0);
    return t
}
function X2(e, t, i) {
    const s = []
      , u = {}
      , d = t.length;
    let f, o;
    for (f = 0; f < d; ++f)
        o = t[f],
        u[o] = f,
        s.push({
            value: o,
            major: !1
        });
    return d === 0 || !i ? s : uV(e, s, u, i)
}
class Y2 extends rm {
    static id = "time";
    static defaults = {
        bounds: "data",
        adapters: {},
        time: {
            parser: !1,
            unit: !1,
            round: !1,
            isoWeekday: !1,
            minUnit: "millisecond",
            displayFormats: {}
        },
        ticks: {
            source: "auto",
            callback: !1,
            major: {
                enabled: !1
            }
        }
    };
    constructor(t) {
        super(t),
        this._cache = {
            data: [],
            labels: [],
            all: []
        },
        this._unit = "day",
        this._majorUnit = void 0,
        this._offsets = {},
        this._normalized = !1,
        this._parseOpts = void 0
    }
    init(t, i={}) {
        const s = t.time || (t.time = {})
          , u = this._adapter = new m$._date(t.adapters.date);
        u.init(i),
        jg(s.displayFormats, u.formats()),
        this._parseOpts = {
            parser: s.parser,
            round: s.round,
            isoWeekday: s.isoWeekday
        },
        super.init(t),
        this._normalized = i.normalized
    }
    parse(t, i) {
        return t === void 0 ? null : q2(this, t)
    }
    beforeLayout() {
        super.beforeLayout(),
        this._cache = {
            data: [],
            labels: [],
            all: []
        }
    }
    determineDataLimits() {
        const t = this.options
          , i = this._adapter
          , s = t.time.unit || "day";
        let {min: u, max: d, minDefined: f, maxDefined: o} = this.getUserBounds();
        function w(T) {
            !f && !isNaN(T.min) && (u = Math.min(u, T.min)),
            !o && !isNaN(T.max) && (d = Math.max(d, T.max))
        }
        (!f || !o) && (w(this._getLabelBounds()),
        (t.bounds !== "ticks" || t.ticks.source !== "labels") && w(this.getMinMax(!1))),
        u = _s(u) && !isNaN(u) ? u : +i.startOf(Date.now(), s),
        d = _s(d) && !isNaN(d) ? d : +i.endOf(Date.now(), s) + 1,
        this.min = Math.min(u, d - 1),
        this.max = Math.max(u + 1, d)
    }
    _getLabelBounds() {
        const t = this.getLabelTimestamps();
        let i = Number.POSITIVE_INFINITY
          , s = Number.NEGATIVE_INFINITY;
        return t.length && (i = t[0],
        s = t[t.length - 1]),
        {
            min: i,
            max: s
        }
    }
    buildTicks() {
        const t = this.options
          , i = t.time
          , s = t.ticks
          , u = s.source === "labels" ? this.getLabelTimestamps() : this._generate();
        t.bounds === "ticks" && u.length && (this.min = this._userMin || u[0],
        this.max = this._userMax || u[u.length - 1]);
        const d = this.min
          , f = this.max
          , o = R4(u, d, f);
        return this._unit = i.unit || (s.autoSkip ? H2(i.minUnit, this.min, this.max, this._getLabelCapacity(d)) : lV(this, o.length, i.minUnit, this.min, this.max)),
        this._majorUnit = !s.major.enabled || this._unit === "year" ? void 0 : cV(this._unit),
        this.initOffsets(u),
        t.reverse && o.reverse(),
        X2(this, o, this._majorUnit)
    }
    afterAutoSkip() {
        this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(t => +t.value))
    }
    initOffsets(t=[]) {
        let i = 0, s = 0, u, d;
        this.options.offset && t.length && (u = this.getDecimalForValue(t[0]),
        t.length === 1 ? i = 1 - u : i = (this.getDecimalForValue(t[1]) - u) / 2,
        d = this.getDecimalForValue(t[t.length - 1]),
        t.length === 1 ? s = d : s = (d - this.getDecimalForValue(t[t.length - 2])) / 2);
        const f = t.length < 3 ? .5 : .25;
        i = Jc(i, 0, f),
        s = Jc(s, 0, f),
        this._offsets = {
            start: i,
            end: s,
            factor: 1 / (i + 1 + s)
        }
    }
    _generate() {
        const t = this._adapter
          , i = this.min
          , s = this.max
          , u = this.options
          , d = u.time
          , f = d.unit || H2(d.minUnit, i, s, this._getLabelCapacity(i))
          , o = zn(u.ticks.stepSize, 1)
          , w = f === "week" ? d.isoWeekday : !1
          , T = qp(w) || w === !0
          , k = {};
        let L = i, z, D;
        if (T && (L = +t.startOf(L, "isoWeek", w)),
        L = +t.startOf(L, T ? "day" : f),
        t.diff(s, i, f) > 1e5 * o)
            throw new Error(i + " and " + s + " are too far apart with stepSize of " + o + " " + f);
        const N = u.ticks.source === "data" && this.getDataTimestamps();
        for (z = L,
        D = 0; z < s; z = +t.add(z, o, f),
        D++)
            Z2(k, z, N);
        return (z === s || u.bounds === "ticks" || D === 1) && Z2(k, z, N),
        Object.keys(k).sort(W2).map(U => +U)
    }
    getLabelForValue(t) {
        const i = this._adapter
          , s = this.options.time;
        return s.tooltipFormat ? i.format(t, s.tooltipFormat) : i.format(t, s.displayFormats.datetime)
    }
    format(t, i) {
        const u = this.options.time.displayFormats
          , d = this._unit
          , f = i || u[d];
        return this._adapter.format(t, f)
    }
    _tickFormatFunction(t, i, s, u) {
        const d = this.options
          , f = d.ticks.callback;
        if (f)
            return Xi(f, [t, i, s], this);
        const o = d.time.displayFormats
          , w = this._unit
          , T = this._majorUnit
          , k = w && o[w]
          , L = T && o[T]
          , z = s[i]
          , D = T && L && z && z.major;
        return this._adapter.format(t, u || (D ? L : k))
    }
    generateTickLabels(t) {
        let i, s, u;
        for (i = 0,
        s = t.length; i < s; ++i)
            u = t[i],
            u.label = this._tickFormatFunction(u.value, i, t)
    }
    getDecimalForValue(t) {
        return t === null ? NaN : (t - this.min) / (this.max - this.min)
    }
    getPixelForValue(t) {
        const i = this._offsets
          , s = this.getDecimalForValue(t);
        return this.getPixelForDecimal((i.start + s) * i.factor)
    }
    getValueForPixel(t) {
        const i = this._offsets
          , s = this.getDecimalForPixel(t) / i.factor - i.end;
        return this.min + s * (this.max - this.min)
    }
    _getLabelSize(t) {
        const i = this.options.ticks
          , s = this.ctx.measureText(t).width
          , u = Qc(this.isHorizontal() ? i.maxRotation : i.minRotation)
          , d = Math.cos(u)
          , f = Math.sin(u)
          , o = this._resolveTickFontOptions(0).size;
        return {
            w: s * d + o * f,
            h: s * f + o * d
        }
    }
    _getLabelCapacity(t) {
        const i = this.options.time
          , s = i.displayFormats
          , u = s[i.unit] || s.millisecond
          , d = this._tickFormatFunction(t, 0, X2(this, [t], this._majorUnit), u)
          , f = this._getLabelSize(d)
          , o = Math.floor(this.isHorizontal() ? this.width / f.w : this.height / f.h) - 1;
        return o > 0 ? o : 1
    }
    getDataTimestamps() {
        let t = this._cache.data || [], i, s;
        if (t.length)
            return t;
        const u = this.getMatchingVisibleMetas();
        if (this._normalized && u.length)
            return this._cache.data = u[0].controller.getAllParsedValues(this);
        for (i = 0,
        s = u.length; i < s; ++i)
            t = t.concat(u[i].controller.getAllParsedValues(this));
        return this._cache.data = this.normalize(t)
    }
    getLabelTimestamps() {
        const t = this._cache.labels || [];
        let i, s;
        if (t.length)
            return t;
        const u = this.getLabels();
        for (i = 0,
        s = u.length; i < s; ++i)
            t.push(q2(this, u[i]));
        return this._cache.labels = this._normalized ? t : this.normalize(t)
    }
    normalize(t) {
        return OP(t.sort(W2))
    }
}
function E_(e, t, i) {
    let s = 0, u = e.length - 1, d, f, o, w;
    i ? (t >= e[s].pos && t <= e[u].pos && ({lo: s, hi: u} = ff(e, "pos", t)),
    {pos: d, time: o} = e[s],
    {pos: f, time: w} = e[u]) : (t >= e[s].time && t <= e[u].time && ({lo: s, hi: u} = ff(e, "time", t)),
    {time: d, pos: o} = e[s],
    {time: f, pos: w} = e[u]);
    const T = f - d;
    return T ? o + (w - o) * (t - d) / T : o
}
class nU extends Y2 {
    static id = "timeseries";
    static defaults = Y2.defaults;
    constructor(t) {
        super(t),
        this._table = [],
        this._minPos = void 0,
        this._tableRange = void 0
    }
    initOffsets() {
        const t = this._getTimestampsForTable()
          , i = this._table = this.buildLookupTable(t);
        this._minPos = E_(i, this.min),
        this._tableRange = E_(i, this.max) - this._minPos,
        super.initOffsets(t)
    }
    buildLookupTable(t) {
        const {min: i, max: s} = this
          , u = []
          , d = [];
        let f, o, w, T, k;
        for (f = 0,
        o = t.length; f < o; ++f)
            T = t[f],
            T >= i && T <= s && u.push(T);
        if (u.length < 2)
            return [{
                time: i,
                pos: 0
            }, {
                time: s,
                pos: 1
            }];
        for (f = 0,
        o = u.length; f < o; ++f)
            k = u[f + 1],
            w = u[f - 1],
            T = u[f],
            Math.round((k + w) / 2) !== T && d.push({
                time: T,
                pos: f / (o - 1)
            });
        return d
    }
    _generate() {
        const t = this.min
          , i = this.max;
        let s = super.getDataTimestamps();
        return (!s.includes(t) || !s.length) && s.splice(0, 0, t),
        (!s.includes(i) || s.length === 1) && s.push(i),
        s.sort( (u, d) => u - d)
    }
    _getTimestampsForTable() {
        let t = this._cache.all || [];
        if (t.length)
            return t;
        const i = this.getDataTimestamps()
          , s = this.getLabelTimestamps();
        return i.length && s.length ? t = this.normalize(i.concat(s)) : t = i.length ? i : s,
        t = this._cache.all = t,
        t
    }
    getDecimalForValue(t) {
        return (E_(this._table, t) - this._minPos) / this._tableRange
    }
    getValueForPixel(t) {
        const i = this._offsets
          , s = this.getDecimalForPixel(t) / i.factor - i.end;
        return E_(this._table, s * this._tableRange + this._minPos, !0)
    }
}
var K2 = Number.isNaN || function(t) {
    return typeof t == "number" && t !== t
}
;
function hV(e, t) {
    return !!(e === t || K2(e) && K2(t))
}
function dV(e, t) {
    if (e.length !== t.length)
        return !1;
    for (var i = 0; i < e.length; i++)
        if (!hV(e[i], t[i]))
            return !1;
    return !0
}
function W0(e, t) {
    t === void 0 && (t = dV);
    var i = null;
    function s() {
        for (var u = [], d = 0; d < arguments.length; d++)
            u[d] = arguments[d];
        if (i && i.lastThis === this && t(u, i.lastArgs))
            return i.lastResult;
        var f = e.apply(this, u);
        return i = {
            lastResult: f,
            lastArgs: u,
            lastThis: this
        },
        f
    }
    return s.clear = function() {
        i = null
    }
    ,
    s
}
const fM = "label";
function Q2(e, t) {
    typeof e == "function" ? e(t) : e && (e.current = t)
}
function fV(e, t) {
    const i = e.options;
    i && t && Object.assign(i, t)
}
function pM(e, t) {
    e.labels = t
}
function mM(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fM;
    const s = [];
    e.datasets = t.map(u => {
        const d = e.datasets.find(f => f[i] === u[i]);
        return !d || !u.data || s.includes(d) ? {
            ...u
        } : (s.push(d),
        Object.assign(d, u),
        d)
    }
    )
}
function pV(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fM;
    const i = {
        labels: [],
        datasets: []
    };
    return pM(i, e.labels),
    mM(i, e.datasets, t),
    i
}
function mV(e, t) {
    return e.getElementsAtEventForMode(t.nativeEvent, "dataset", {
        intersect: !0
    }, !1)
}
function gV(e, t) {
    return e.getElementsAtEventForMode(t.nativeEvent, "nearest", {
        intersect: !0
    }, !1)
}
function yV(e, t) {
    return e.getElementsAtEventForMode(t.nativeEvent, "index", {
        intersect: !0
    }, !1)
}
function _V(e, t) {
    const {height: i=150, width: s=300, redraw: u=!1, datasetIdKey: d, type: f, data: o, options: w, plugins: T=[], fallbackContent: k, updateMode: L, ...z} = e
      , D = Pe.useRef(null)
      , N = Pe.useRef()
      , U = () => {
        D.current && (N.current = new nd(D.current,{
            type: f,
            data: pV(o, d),
            options: w && {
                ...w
            },
            plugins: T
        }),
        Q2(t, N.current))
    }
      , V = () => {
        Q2(t, null),
        N.current && (N.current.destroy(),
        N.current = null)
    }
    ;
    return Pe.useEffect( () => {
        !u && N.current && w && fV(N.current, w)
    }
    , [u, w]),
    Pe.useEffect( () => {
        !u && N.current && pM(N.current.config.data, o.labels)
    }
    , [u, o.labels]),
    Pe.useEffect( () => {
        !u && N.current && o.datasets && mM(N.current.config.data, o.datasets, d)
    }
    , [u, o.datasets]),
    Pe.useEffect( () => {
        N.current && (u ? (V(),
        setTimeout(U)) : N.current.update(L))
    }
    , [u, w, o.labels, o.datasets, L]),
    Pe.useEffect( () => {
        N.current && (V(),
        setTimeout(U))
    }
    , [f]),
    Pe.useEffect( () => (U(),
    () => V()), []),
    Ra.createElement("canvas", Object.assign({
        ref: D,
        role: "img",
        height: i,
        width: s
    }, z), k)
}
const gM = Pe.forwardRef(_V);
function id(e, t) {
    return nd.register(t),
    Pe.forwardRef( (i, s) => Ra.createElement(gM, Object.assign({}, i, {
        ref: s,
        type: e
    })))
}
const yM = id("line", u$)
  , vV = id("bar", a$)
  , xV = id("radar", f$)
  , bV = id("doughnut", JP)
  , wV = id("polarArea", h$)
  , SV = id("bubble", l$)
  , CV = id("pie", d$)
  , TV = id("scatter", p$)
  , PV = Object.freeze(Object.defineProperty({
    __proto__: null,
    Bar: vV,
    Bubble: SV,
    Chart: gM,
    Doughnut: bV,
    Line: yM,
    Pie: CV,
    PolarArea: wV,
    Radar: xV,
    Scatter: TV,
    getDatasetAtEvent: mV,
    getElementAtEvent: gV,
    getElementsAtEvent: yV
}, Symbol.toStringTag, {
    value: "Module"
}));
nd.register(aV);
nd.register(iV);
nd.register(D6);
nd.register(Av);
nd.register(eV);
class MV extends Pe.Component {
    marker = null;
    convertedChartHighlightPosition = W0( (t, i) => this.convertChartHighlightPosition(t, i));
    calculateRawElevationsAndDistance = W0(t => t.coordinates.reduce( (i, s, u, d) => {
        if (u === 0)
            i.push({
                x: 0,
                y: s[2]
            });
        else {
            const f = d[u - 1]
              , o = [f[0], f[1]]
              , w = [s[0], s[1]]
              , T = IT(o, w, {
                units: "meters"
            })
              , k = i[u - 1].x + T;
            i.push({
                x: k,
                y: s[2]
            })
        }
        return i
    }
    , []));
    calculateSmoothedElevationsAndDistance = W0(t => {
        if (t.length === 0)
            return [];
        const i = t[t.length - 1].x
          , s = Math.max(10, Math.min(50, i / 25))
          , u = []
          , d = 3
          , f = Math.ceil(i / s);
        for (let o = 0; o <= f; o++) {
            const w = o / f * i
              , T = RV(t, w, d);
            u.push({
                x: w,
                y: T
            })
        }
        return u
    }
    );
    constructor(t) {
        super(t),
        this.state = {
            LineChart: null,
            chartHighlightPosition: null
        }
    }
    componentDidMount() {
        Cj( () => Promise.resolve().then( () => PV), void 0).then(t => this.setState({
            LineChart: t.Line
        })),
        this.props.map && (this.props.map.on("mousemove", this._onMapMouseMove),
        this.props.map.on("mouseout", this._onMapMouseOut))
    }
    componentDidUpdate(t) {
        t.map !== this.props.map && (t.map && (t.map.off("mousemove", this._onMapMouseMove),
        t.map.off("mouseout", this._onMapMouseOut)),
        this.props.map && (this.props.map.on("mousemove", this._onMapMouseMove),
        this.props.map.on("mouseout", this._onMapMouseOut)))
    }
    componentWillUnmount() {
        this.props.map && (this.props.map.off("mousemove", this._onMapMouseMove),
        this.props.map.off("mouseout", this._onMapMouseOut)),
        this.clearMarker()
    }
    _onMapMouseMove = t => {
        this.setChartHighlightPosition(t.lngLat)
    }
    ;
    _onMapMouseOut = () => {
        this.setChartHighlightPosition(null)
    }
    ;
    setChartHighlightPosition = t => {
        this.setState({
            chartHighlightPosition: t
        })
    }
    ;
    onHover(t, i, s) {
        let u = i.chartArea
          , d = t.x
          , f = t.y;
        if (d === null || f === null) {
            this.clearMarker();
            return
        }
        let o = u.left
          , w = u.right;
        if (d < o || d > w) {
            this.clearMarker();
            return
        }
        if (f > u.bottom || f < u.top) {
            this.clearMarker();
            return
        }
        let T = (d - o) / (w - o) * s
          , L = Mj(this.props.elevationData.profileGeometry, T, T, {
            units: "meters"
        }).geometry;
        if (L === null) {
            this.clearMarker();
            return
        }
        const z = L.coordinates[0];
        this.markPositionOnMap(new Ea.LngLat(z[0],z[1]))
    }
    clearMarker = () => {
        this.marker !== null && (this.marker.remove(),
        this.marker = null)
    }
    ;
    markPositionOnMap = t => {
        if (!this.props.map || t === null) {
            this.clearMarker();
            return
        }
        if (this.marker === null) {
            const i = document.createElement("div");
            i.className = "chart-position-marker",
            i.style.width = "16px",
            i.style.height = "16px",
            i.style.borderRadius = "50%",
            i.style.border = "2px solid #000",
            i.style.backgroundColor = "transparent",
            this.marker = new Ea.Marker({
                element: i,
                anchor: "center"
            }).setLngLat(t).addTo(this.props.map)
        } else
            this.marker.setLngLat(t)
    }
    ;
    render() {
        const t = this.state.LineChart
          , i = this.props.feature
          , s = this.props.elevationData
          , u = i.properties.elevationProfile
          , d = this.props.unitSystem;
        if (t === null || s === null || u === null)
            return null;
        const f = this.calculateRawElevationsAndDistance(s.profileGeometry)
          , o = this.calculateSmoothedElevationsAndDistance(f)
          , T = f.length > 0 ? f[f.length - 1].x : 0
          , k = this.convertedChartHighlightPosition(this.state.chartHighlightPosition, s.profileGeometry)
          , L = {
            datasets: [{
                fill: !0,
                borderWidth: 2,
                borderColor: "rgba(0, 0, 0, 0.15)",
                tension: .3,
                pointRadius: 0,
                pointHitRadius: 5,
                pointHoverRadius: 0,
                order: 10,
                data: o.map(N => ({
                    x: N.x,
                    y: N.y
                }))
            }, ...k !== null ? [{
                fill: !1,
                borderWidth: 0,
                borderColor: "rgba(0, 0, 0, 0)",
                pointRadius: 0,
                pointHitRadius: 16,
                order: 1,
                data: [{
                    x: k,
                    y: _M(o, k)
                }]
            }] : []]
        }
          , z = [{
            id: "customPointStyle",
            afterDraw: function(N) {
                const U = N.data.datasets;
                if (!U)
                    return;
                const V = N.ctx
                  , re = 8
                  , ie = (ue, ce) => {
                    V.save(),
                    V.beginPath(),
                    V.arc(ue, ce, re, 0, Math.PI * 2),
                    V.strokeStyle = "#000",
                    V.lineWidth = 2,
                    V.stroke(),
                    V.restore()
                }
                ;
                if (N.getActiveElements().length > 0) {
                    const ue = N.getActiveElements()[0];
                    if (ue.datasetIndex === 0) {
                        const X = N.getDatasetMeta(0).data[ue.index];
                        X && ie(X.x, X.y)
                    }
                }
                if (U.length > 1) {
                    const ue = N.getDatasetMeta(1);
                    if (ue.data && ue.data.length > 0) {
                        const ce = ue.data[0];
                        ie(ce.x, ce.y),
                        ce.options.radius = 0
                    }
                }
            }
        }, {
            id: "gradient",
            beforeRender: function(N) {
                const U = N.ctx
                  , V = N.scales.x;
                if (!V || !N.data.datasets)
                    return;
                const re = N.data.datasets[0];
                if (re.backgroundColor instanceof CanvasGradient)
                    return;
                const ie = V.getPixelForValue(V.min)
                  , ue = V.getPixelForValue(V.max);
                if (Number.isNaN(ie) || Number.isNaN(ue))
                    return;
                const ce = U.createLinearGradient(ie, 0, ue, 0)
                  , X = N.data.datasets[0].data;
                re.backgroundColor = kV(i, X, ce),
                N.update()
            }
        }];
        let D = this;
        return G.jsx("div", {
            className: "height-profile",
            onMouseLeave: this.clearMarker,
            children: G.jsx(yM, {
                data: L,
                plugins: z,
                options: {
                    animation: {
                        duration: 0
                    },
                    responsive: !0,
                    maintainAspectRatio: !0,
                    elements: {
                        line: {
                            tension: .3
                        },
                        point: {
                            radius: 0
                        }
                    },
                    plugins: {
                        legend: {
                            display: !1
                        },
                        tooltip: {
                            enabled: !1
                        }
                    },
                    hover: {
                        mode: "index",
                        intersect: !1,
                        includeInvisible: !0
                    },
                    scales: {
                        x: {
                            type: "linear",
                            min: 0,
                            max: T,
                            grid: {
                                display: !0,
                                color: "rgba(0,0,0,0.05)"
                            },
                            ticks: {
                                maxRotation: 0,
                                autoSkipPadding: 20,
                                callback: N => Jp({
                                    distanceInMeters: N,
                                    unitSystem: d,
                                    forceLongestUnit: !0,
                                    withSpace: !0
                                })
                            }
                        },
                        y: {
                            type: "linear",
                            suggestedMax: Math.max(s.verticalInMeters, 100) + s.minElevationInMeters,
                            grid: {
                                display: !0,
                                color: "rgba(0,0,0,0.05)"
                            },
                            ticks: {
                                callback: N => ec(N, this.props.unitSystem)
                            }
                        }
                    },
                    onHover: function(N, U, V) {
                        D.onHover(N, V, T)
                    }
                }
            })
        })
    }
    convertChartHighlightPosition = (t, i) => {
        if (t === null)
            return null;
        const s = Wj(i, [t.lng, t.lat], {
            units: "meters"
        });
        if (s.properties.dist > 200)
            return this.clearMarker(),
            null;
        const d = s.geometry.coordinates;
        return this.markPositionOnMap(new Ea.LngLat(d[0],d[1])),
        s.properties.location
    }
}
function kV(e, t, i) {
    const s = EV(e)
      , u = e.properties.difficulty;
    if (!t || t.length < 2) {
        const o = rf(Et.getRunColor(e.properties.difficultyConvention, u), .7);
        return i.addColorStop(0, o),
        i.addColorStop(1, o),
        i
    }
    const d = t[t.length - 1].x;
    if (d === 0) {
        const o = rf(Et.getRunColor(e.properties.difficultyConvention, u), .7);
        return i.addColorStop(0, o),
        i.addColorStop(1, o),
        i
    }
    const f = [];
    for (let o = 0; o < t.length - 1; o++) {
        const w = t[o]
          , T = t[o + 1]
          , k = T.x - w.x;
        if (k <= 0)
            continue;
        const z = (w.y - T.y) / k;
        let D = u;
        const N = IV(z, s);
        N !== null && (D = N),
        f.push({
            distanceRatio: w.x / d,
            difficulty: D
        }),
        o === t.length - 2 && f.push({
            distanceRatio: 1,
            difficulty: D
        })
    }
    if (f.length > 0) {
        let o = f[0].difficulty;
        i.addColorStop(0, rf(Et.getRunColor(e.properties.difficultyConvention, o), .7));
        for (let w = 1; w < f.length; w++)
            f[w].difficulty !== o && (i.addColorStop(f[w].distanceRatio - .001, rf(Et.getRunColor(e.properties.difficultyConvention, o), .7)),
            o = f[w].difficulty,
            i.addColorStop(f[w].distanceRatio, rf(Et.getRunColor(e.properties.difficultyConvention, o), .7)));
        i.addColorStop(1, rf(Et.getRunColor(e.properties.difficultyConvention, o), .7))
    } else {
        const o = rf(Et.getRunColor(e.properties.difficultyConvention, u), .7);
        i.addColorStop(0, o),
        i.addColorStop(1, o)
    }
    return i
}
function rf(e, t) {
    const i = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(e);
    if (i === null)
        throw "Unsupported HSL input: " + e;
    return `hsl(${i[1]}, ${i[2]}%, ${i[3]}%, ${t})`
}
function EV(e) {
    return e.properties.uses.includes(Et.RunUse.Downhill) || e.properties.uses.includes(Et.RunUse.Skitour) ? {
        stops: [{
            maxSteepness: .25,
            difficulty: Et.RunDifficulty.EASY
        }, {
            maxSteepness: .4,
            difficulty: Et.RunDifficulty.INTERMEDIATE
        }, {
            maxSteepness: Number.MAX_VALUE,
            difficulty: Et.RunDifficulty.ADVANCED
        }]
    } : e.properties.uses.includes(Et.RunUse.Nordic) ? {
        stops: [{
            maxSteepness: .1,
            difficulty: Et.RunDifficulty.EASY
        }, {
            maxSteepness: .15,
            difficulty: Et.RunDifficulty.INTERMEDIATE
        }, {
            maxSteepness: Number.MAX_VALUE,
            difficulty: Et.RunDifficulty.ADVANCED
        }]
    } : {
        stops: []
    }
}
function IV(e, t) {
    const i = Math.abs(e);
    return t.stops.find(s => s.maxSteepness > i)?.difficulty || null
}
function _M(e, t) {
    let i = 0;
    for (let f = 0; f < e.length && !(e[f].x > t); f++)
        i = f;
    if (i === e.length - 1)
        return e[i].y;
    const s = e[i]
      , u = e[i + 1]
      , d = (t - s.x) / (u.x - s.x);
    return s.y + d * (u.y - s.y)
}
function RV(e, t, i=3) {
    if (e.length === 0)
        return 0;
    if (e.length === 1)
        return e[0].y;
    const s = _M(e, t);
    if (t <= e[0].x + i || t >= e[e.length - 1].x - i)
        return s;
    const u = i * 2
      , d = t - u / 2
      , f = t + u / 2;
    let o = 0
      , w = 0;
    for (let T = 0; T < e.length; T++) {
        const k = e[T];
        if (k.x >= d && k.x <= f) {
            const z = 1 / (1 + Math.abs(k.x - t));
            o += k.y * z,
            w += z
        }
    }
    return w > 0 ? o / w : s
}
const wx = zV()
  , AV = wx.getAttribute("content");
function vM(e) {
    const t = e !== null ? DV(e) : null;
    t !== null && t.length > 0 ? (document.title = t + " - OpenSkiMap.org",
    wx.setAttribute("content", `Explore a ski trail map of ${t} and learn more about the ski area.`)) : (document.title = "OpenSkiMap.org",
    wx.setAttribute("content", AV))
}
function zV() {
    return Array.from(document.getElementsByTagName("meta")).find(t => t.getAttribute("name") === "description")
}
function q0(e) {
    return e === null ? [] : [e]
}
function J2(e) {
    const t = e.flatMap(i => {
        const s = i.properties.name;
        return s !== null ? [jB(s)] : []
    }
    ).join(", ");
    return t.length > 0 ? t : null
}
function DV(e) {
    const t = e.properties;
    switch (t.type) {
    case Et.FeatureType.Lift:
        return q0(Et.getLiftNameAndType(t)).concat(q0(J2(t.skiAreas))).join(" - ");
    case Et.FeatureType.Run:
        return [xM(t).title].concat(q0(J2(t.skiAreas))).join(" - ");
    case Et.FeatureType.SkiArea:
        return t.name
    }
}
function xM(e) {
    const t = LV(e);
    return e.name ? {
        title: e.name,
        subtitle: t
    } : {
        title: t,
        subtitle: null
    }
}
function LV(e) {
    const t = e.difficulty ? vP(e.difficulty) : null
      , i = _P(e.uses, e.grooming);
    return t && i ? t + " " + i.toLowerCase() : t || i
}
const OV = e => {
    const t = e.feature
      , i = t.properties
      , s = Pe.useMemo( () => Et.getRunElevationData(t), [t])
      , {title: u, subtitle: d} = xM(e.feature.properties)
      , f = hb(i.websites);
    return G.jsxs(Mv, {
        width: e.width,
        header: G.jsx(Pv, {
            onClose: e.eventBus.hideInfo,
            breadcrumbs: {
                eventBus: e.eventBus,
                feature: e.feature
            }
        }),
        footer: f.length > 0 ? G.jsx(Jx, {
            children: f
        }) : void 0,
        children: [G.jsxs(qt, {
            gutterBottom: !0,
            variant: "h5",
            component: "h2",
            children: [i.ref && G.jsx("span", {
                style: {
                    display: "inline-block",
                    marginRight: "8px"
                },
                children: G.jsx(TP, {
                    text: i.ref,
                    color: Et.getRunColor(i.difficultyConvention, i.difficulty)
                })
            }), G.jsx("span", {
                style: {
                    verticalAlign: "middle"
                },
                children: u
            })]
        }), d && G.jsx(qt, {
            children: d
        }), G.jsx(FV, {
            feature: t
        }), i.oneway === !0 && !i.uses.includes(Et.RunUse.Downhill) ? G.jsx(lf, {
            avatar: G.jsx(t_, {
                children: G.jsx(dj, {})
            }),
            label: "One Way"
        }) : null, i.lit === !0 ? G.jsx(lf, {
            avatar: G.jsx(t_, {
                children: G.jsx(mj, {})
            }),
            label: "Night Lit"
        }) : null, i.gladed === !0 ? G.jsx(lf, {
            label: "Gladed"
        }) : null, i.patrolled === !0 ? G.jsx(lf, {
            avatar: G.jsx(t_, {
                children: G.jsx(_j, {})
            }),
            label: "Patrolled"
        }) : null, i.patrolled === !1 ? G.jsx(lf, {
            avatar: G.jsx(t_, {
                children: G.jsx(bj, {})
            }),
            label: "Not Patrolled"
        }) : null, G.jsxs(qt, {
            className: "distance-and-elevation-info",
            children: [s && s.inclinedLengthInMeters ? G.jsxs("span", {
                children: ["Distance:", " ", Jp({
                    distanceInMeters: s.inclinedLengthInMeters,
                    unitSystem: e.unitSystem
                })]
            }) : null, s && s.ascentInMeters > 1 ? G.jsxs("span", {
                children: ["Ascent:", " ", ec(s.ascentInMeters, e.unitSystem)]
            }) : null, s && s.descentInMeters > 1 ? G.jsxs("span", {
                children: ["Descent:", " ", ec(s.descentInMeters, e.unitSystem)]
            }) : null]
        }), s && (s.averagePitchInPercent !== null || s.maxPitchInPercent !== null) && G.jsxs(qt, {
            className: "distance-and-elevation-info",
            children: [s.averagePitchInPercent !== null && G.jsxs("span", {
                children: ["Average Slope: ", px(s.averagePitchInPercent)]
            }), s.maxPitchInPercent !== null && G.jsxs("span", {
                children: ["Max Slope: ", px(s.maxPitchInPercent)]
            })]
        }), i.description && G.jsx(qt, {
            children: G.jsxs("span", {
                children: ["Notes: ", i.description]
            })
        }), s !== null && G.jsx(MV, {
            feature: t,
            elevationData: s,
            map: e.map,
            unitSystem: e.unitSystem
        }), G.jsx(db, {
            sources: i.sources
        })]
    })
}
  , FV = e => {
    const t = e.feature.properties.grooming
      , i = e.feature.properties.uses.includes(Et.RunUse.Nordic);
    let s;
    switch (t) {
    case Et.RunGrooming.Classic:
        s = i ? "Classic" : "Groomed";
        break;
    case Et.RunGrooming.Skating:
        s = "Skate";
        break;
    case Et.RunGrooming.ClassicAndSkating:
        s = "Classic & Skate";
        break;
    case Et.RunGrooming.Mogul:
        s = "Moguls";
        break;
    case Et.RunGrooming.Scooter:
        s = i ? "Classic (narrow)" : "Groomed (narrow)";
        break;
    case Et.RunGrooming.Backcountry:
        s = "Ungroomed";
        break;
    default:
        return null
    }
    return G.jsx(lf, {
        label: s
    })
}
  , BV = e => {
    const [t,i] = Pe.useState(null);
    return Pe.useEffect( () => {
        (async () => {
            let u;
            try {
                u = await FB(e.id)
            } catch (d) {
                console.log(d),
                e.eventBus.hideInfo();
                return
            }
            vM(u),
            i(u),
            e.onLoadFeature(u)
        }
        )()
    }
    , [e.id]),
    G.jsxs(G.Fragment, {
        children: [t && t.properties.type == Et.FeatureType.Lift && G.jsx(cj, {
            feature: t,
            eventBus: e.eventBus,
            unitSystem: e.unitSystem,
            width: e.width
        }), t && t.properties.type == Et.FeatureType.Run && G.jsx(OV, {
            feature: t,
            map: e.map,
            eventBus: e.eventBus,
            unitSystem: e.unitSystem,
            width: e.width
        }), t && t.properties.type == Et.FeatureType.SkiArea && G.jsx(ej, {
            feature: t,
            eventBus: e.eventBus,
            unitSystem: e.unitSystem,
            width: e.width
        })]
    })
}
;
function bM(e) {
    switch (e.type) {
    case "Point":
        return e.coordinates;
    case "MultiPoint":
        return e.coordinates[0];
    case "LineString":
        return e.coordinates[0];
    case "MultiLineString":
        return e.coordinates[0][0];
    case "Polygon":
        return e.coordinates[0][0];
    case "MultiPolygon":
        return e.coordinates[0][0][0];
    case "GeometryCollection":
        return bM(e.geometries[0])
    }
}
class jV {
    _container;
    _map = null;
    _eventBus;
    _id;
    _panToPositionAfterLoad = !1;
    _root = null;
    constructor(t, i) {
        this._id = t.id,
        this._panToPositionAfterLoad = t.panToPosition === "afterLoad",
        this._eventBus = i,
        this._container = document.createElement("div"),
        this._container.className = "maplibregl-ctrl"
    }
    onAdd = t => (this._root = Wh.createRoot(this._container),
    this._map = t,
    this.render(),
    this._map.on("resize", this.render),
    this._container);
    onRemove = () => {
        this._root?.unmount(),
        this._root = null,
        this._map.off("resize", this.render);
        const t = this._container.parentNode;
        t && t.removeChild(this._container),
        this._map = null
    }
    ;
    getDefaultPosition = () => "top-left";
    render = () => {
        const t = this._map;
        t && this._root?.render(G.jsx(qh, {
            children: G.jsx(pP, {
                render: i => G.jsx(BV, {
                    id: this._id,
                    eventBus: this._eventBus,
                    width: ib(t),
                    unitSystem: i,
                    map: t,
                    onLoadFeature: s => {
                        if (this._panToPositionAfterLoad) {
                            const u = bM(s.geometry);
                            this._map?.flyTo({
                                center: [u[0], u[1]],
                                zoom: CP
                            })
                        }
                    }
                })
            })
        }))
    }
}
class NV {
    map;
    originalFilters = new Map;
    activeRules = bf();
    constructor(t) {
        this.map = t
    }
    setFilters = t => {
        const i = $V(t);
        [[this.skiAreaLayers(), i.skiAreas], [this.runLayers(), i.runs], [this.liftLayers(), i.lifts], [this.selectedLayers(), i.selected]].reduce( (d, f) => {
            const o = f[0]
              , w = f[1];
            return o.forEach(T => {
                d.set(T, Rg(w, d.get(T) || ["boolean", !0]))
            }
            ),
            d
        }
        , new Map).forEach( (d, f) => this.setFilterOverride(f, d)),
        this.activeRules = i
    }
    ;
    getVisibleSkiAreasCount = () => {
        const t = this.activeRules.skiAreas;
        if (t === "hidden")
            return 0;
        let i = null;
        t && typeof t != "string" && (i = t);
        const s = this.map.querySourceFeatures("openskimap", {
            sourceLayer: "skiareas",
            filter: i || void 0
        })
          , u = this.map.getBounds();
        return new Set(s.filter(f => f.geometry.type === "Point" && u.contains(f.geometry.coordinates)).map(f => f.properties).map(f => f.id)).size
    }
    ;
    runLayers = () => this.layers().filter(t => t["source-layer"] === "runs").map(t => t.id);
    liftLayers = () => this.layers().filter(t => t["source-layer"] === "lifts").map(t => t.id);
    skiAreaLayers = () => this.layers().filter(t => t["source-layer"] === "skiareas").map(t => t.id);
    selectedLayers = () => ["selected-run", "selected-lift"];
    layers = () => this.map.getStyle().layers || [];
    setFilterOverride = (t, i) => {
        const s = this.map.getLayer(t);
        if (!s)
            return;
        if (console.assert(s.type !== "custom", "Custom layers are not supported"),
        i === "hidden") {
            this.map.setLayoutProperty(s.id, "visibility", "none");
            return
        } else
            this.map.setLayoutProperty(s.id, "visibility", "visible");
        this.originalFilters.has(t) || this.originalFilters.set(t, s.filter || void 0);
        const u = this.originalFilters.get(t) || null;
        this.map.setFilter(t, this.finalRulesForLayer(t, u, i))
    }
    ;
    finalRulesForLayer = (t, i, s) => Array.isArray(s) && s.length == 0 ? i || null : this.selectedLayers().includes(t) || !i ? s : ["all", i, s]
}
function bf() {
    return {
        runs: ["boolean", !0],
        skiAreas: ["boolean", !0],
        lifts: ["boolean", !0],
        selected: ["boolean", !0]
    }
}
function $V(e) {
    return [VV(e), UV(e), GV(e), WV(e), qV(e)].reduce( (t, i) => ({
        runs: Rg(t.runs, i.runs),
        lifts: Rg(t.lifts, i.lifts),
        skiAreas: Rg(t.skiAreas, i.skiAreas),
        selected: Rg(t.selected, i.selected)
    }), bf())
}
function Rg(e, t) {
    return e === "hidden" || t === "hidden" ? "hidden" : !e && !t ? ["boolean", !0] : e ? t ? ["all", e, t] : e : t
}
function VV(e) {
    const t = !e.hiddenActivities.includes(Et.SkiAreaActivity.Downhill)
      , i = !e.hiddenActivities.includes(Et.SkiAreaActivity.Nordic);
    return !t && !i ? {
        skiAreas: "hidden",
        lifts: "hidden",
        runs: ["has", "other"],
        selected: ["boolean", !0]
    } : t && !i ? {
        skiAreas: ["has", "has_downhill"],
        lifts: ["boolean", !0],
        runs: ["any", ["has", "downhill"], ["has", "skitour"]],
        selected: ["boolean", !0]
    } : i && !t ? {
        skiAreas: ["has", "has_nordic"],
        lifts: "hidden",
        runs: ["has", "nordic"],
        selected: ["boolean", !0]
    } : bf()
}
function UV(e) {
    return e.minElevation ? {
        skiAreas: [">", ["get", "maxElevation"], e.minElevation],
        lifts: ["boolean", !0],
        runs: ["boolean", !0],
        selected: ["boolean", !0]
    } : bf()
}
function GV(e) {
    return e.minVertical ? {
        skiAreas: [">", ["get", "vertical"], e.minVertical],
        lifts: ["boolean", !0],
        runs: ["boolean", !0],
        selected: ["boolean", !0]
    } : bf()
}
function WV(e) {
    if (!e.minRunLength)
        return bf();
    const t = !e.hiddenActivities.includes(Et.SkiAreaActivity.Downhill)
      , i = !e.hiddenActivities.includes(Et.SkiAreaActivity.Nordic)
      , s = [];
    t && s.push([">", ["get", "downhillDistance"], e.minRunLength]),
    i && s.push([">", ["get", "nordicDistance"], e.minRunLength]);
    let u = ["boolean", !0];
    return s.length > 1 ? u = ["any", ...s] : s.length === 1 && (u = s[0]),
    {
        skiAreas: u,
        lifts: ["boolean", !0],
        runs: ["boolean", !0],
        selected: ["boolean", !0]
    }
}
function qV(e) {
    const t = bf();
    return e.selectedObjectID ? t.selected = ["any", ["==", ["get", "id"], e.selectedObjectID], ["in", e.selectedObjectID, ["get", "skiAreas"]]] : t.selected = "hidden",
    t
}
class HV {
    map;
    eventBus;
    constructor(t, i) {
        this.map = t,
        this.eventBus = i,
        t.on("styledata", () => {
            this.attachListeners()
        }
        )
    }
    attachListeners() {
        const t = new Set(["operating-downhill-nordic-ski-area-icons-1", "operating-downhill-nordic-ski-area-icons-2", "operating-downhill-ski-area-icons", "operating-nordic-ski-area-icons", "other-operating-ski-area-icons", "other-ski-area-icons", "ski-area-labels"])
          , s = (this.map.getStyle().layers || []).filter(d => d.id.indexOf("tappable") !== -1 || t.has(d.id)).map(d => d.id).reverse();
        let u = 0;
        s.forEach(d => {
            this.map.on("click", d, this._onClickItem),
            this.map.on("mouseenter", d, () => {
                u += 1,
                this.map.getCanvas().style.cursor = "pointer"
            }
            ),
            this.map.on("mouseleave", d, () => {
                u -= 1,
                u === 0 && (this.map.getCanvas().style.cursor = "")
            }
            )
        }
        )
    }
    _onClickItemUnthrottled = t => {
        this.eventBus.showInfo({
            id: t.features[0].properties.id,
            panToPosition: null
        })
    }
    ;
    _onClickItem = RT(10, this._onClickItemUnthrottled, {
        atBegin: !0
    })
}
var yg = {}, eC;
function ZV() {
    if (eC)
        return yg;
    eC = 1;
    var e = Io();
    Object.defineProperty(yg, "__esModule", {
        value: !0
    }),
    yg.default = void 0;
    var t = e(ls())
      , i = Uo();
    return yg.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "M10 18h4v-2h-4zM3 6v2h18V6zm3 7h12v-2H6z"
    }), "FilterList"),
    yg
}
var XV = ZV();
const YV = Ni(XV);
var _g = {}, tC;
function KV() {
    if (tC)
        return _g;
    tC = 1;
    var e = Io();
    Object.defineProperty(_g, "__esModule", {
        value: !0
    }),
    _g.default = void 0;
    var t = e(ls())
      , i = Uo();
    return _g.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "M3 18h18v-2H3zm0-5h18v-2H3zm0-7v2h18V6z"
    }), "Menu"),
    _g
}
var QV = KV();
const JV = Ni(QV);
var vg = {}, rC;
function e8() {
    if (rC)
        return vg;
    rC = 1;
    var e = Io();
    Object.defineProperty(vg, "__esModule", {
        value: !0
    }),
    vg.default = void 0;
    var t = e(ls())
      , i = Uo();
    return vg.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
    }), "Search"),
    vg
}
var t8 = e8();
const r8 = Ni(t8);
var I_ = {}, nC;
function n8() {
    if (nC)
        return I_;
    nC = 1,
    Object.defineProperty(I_, "__esModule", {
        value: !0
    });
    var e = iy();
    function t(i) {
        var s = i.onTriggered
          , u = i.disableClick
          , d = i.disableTouch
          , f = i.disableKeys
          , o = i.allowAnyKey
          , w = i.triggerKeys
          , T = e.useRef(null)
          , k = e.useCallback(function(D) {
            o ? s(D) : w ? w.includes(D.key) && s(D) : D.key === "Escape" && s(D)
        }, [o, w, s])
          , L = e.useCallback(function(D) {
            T && T.current && (T.current.contains(D.target) || s?.(D))
        }, [T.current, s])
          , z = e.useMemo(function() {
            return [[u, "click", L], [d, "touchstart", L], [f, "keyup", k]]
        }, [u, d, f, L, k]);
        return e.useEffect(function() {
            return z.map(function(D) {
                var N = D[0]
                  , U = D[1]
                  , V = D[2];
                N || document.addEventListener(U, V)
            }),
            function() {
                z.map(function(D) {
                    var N = D[0]
                      , U = D[1]
                      , V = D[2];
                    N || document.removeEventListener(U, V)
                })
            }
        }, [z]),
        T
    }
    return I_.useDetectClickOutside = t,
    I_
}
var i8 = n8();
const o8 = e => {
    const {width: t, eventBus: i, filtersShown: s} = e
      , [u,d] = Pe.useState({
        searchQuery: "",
        selectedIndex: 0,
        results: [],
        hideResults: !0
    })
      , f = u.results
      , o = u.hideResults
      , w = Pe.useRef();
    w.current = u;
    const T = (re, ie) => {
        let ue = [];
        const ce = re.split(",").map(X => parseFloat(X.trim())).reverse();
        ce.length === 2 && ce.every(X => !isNaN(X)) && ce[1] >= -90 && ce[1] <= 90 && ce[0] >= -180 && ce[0] <= 180 && ue.push({
            type: "add_marker",
            data: {
                type: "Point",
                coordinates: ce
            }
        }),
        ue = ue.concat(ie.map(X => ({
            type: "location",
            data: X
        }))),
        d(X => ({
            ...X,
            results: ue
        }))
    }
      , k = re => {
        fetch("https://api.openskimap.org/search?query=" + encodeURIComponent(re)).then(ie => {
            w.current?.searchQuery === re && ie.json().then(ue => {
                T(re, ue)
            }
            )
        }
        )
    }
      , L = Pe.useCallback(RT(500, k), [])
      , z = Pe.useCallback(Y_(500, k), [])
      , D = re => {
        re.keyCode == 38 ? (re.preventDefault(),
        d(ie => ({
            ...ie,
            selectedIndex: Math.max(0, u.selectedIndex - 1)
        }))) : re.keyCode == 40 && (re.preventDefault(),
        d(ie => ({
            ...ie,
            selectedIndex: Math.min(u.results.length - 1, u.selectedIndex + 1)
        })))
    }
      , N = re => {
        d(ie => {
            const ue = {
                ...ie,
                searchQuery: re
            };
            return re.length < 5 || re.endsWith(" ") ? z(re) : L(re),
            ue
        }
        )
    }
      , U = re => {
        switch (d(ie => ({
            ...ie,
            searchQuery: "",
            selectedIndex: 0,
            results: [],
            hideResults: !0
        })),
        re.type) {
        case "add_marker":
            i.addMarker(re.data);
            break;
        case "location":
            i.showInfo(l8(re));
            break
        }
    }
      , V = i8.useDetectClickOutside({
        onTriggered: () => {
            d(re => ({
                ...re,
                hideResults: !0
            }))
        }
    });
    return G.jsxs(fy, {
        style: {
            width: t
        },
        elevation: 1,
        ref: V,
        children: [G.jsxs("div", {
            style: {
                alignItems: "center",
                display: "flex"
            },
            children: [G.jsx(Lg, {
                style: {
                    padding: "10"
                },
                "aria-label": "Menu",
                onClick: i.openSidebar,
                size: "large",
                children: G.jsx(JV, {})
            }), G.jsx(FD, {
                name: "search",
                onFocus: () => {
                    d(re => ({
                        ...re,
                        hideResults: !1
                    }))
                }
                ,
                style: {
                    marginLeft: "8",
                    flex: "1"
                },
                placeholder: "Search Ski Areas, Lifts, and Runs",
                onChange: re => {
                    d(ie => ({
                        ...ie,
                        hideResults: !1
                    })),
                    N(re.target.value)
                }
                ,
                onKeyDown: re => {
                    D(re),
                    re.keyCode === 13 && f.length > u.selectedIndex && U(f[u.selectedIndex])
                }
                ,
                value: u.searchQuery
            }), G.jsx(Lg, {
                style: {
                    padding: "10"
                },
                "aria-label": "Search",
                disabled: u.searchQuery.length == 0,
                onClick: () => {
                    f.length > 0 && U(f[0])
                }
                ,
                size: "large",
                children: G.jsx(r8, {})
            }), G.jsx($p, {
                orientation: "vertical"
            }), G.jsx(Lg, {
                style: {
                    padding: "10"
                },
                color: s ? "primary" : "default",
                "aria-label": "Filters",
                onClick: i.showFilters,
                size: "large",
                children: G.jsx(YV, {})
            })]
        }), f.length > 0 && !o ? G.jsxs(Pe.Fragment, {
            children: [G.jsx($p, {}), G.jsx(s8, {
                onSelect: U,
                selectedIndex: u.selectedIndex,
                results: f
            })]
        }) : null]
    })
}
  , s8 = e => {
    let t = 0;
    return G.jsx("div", {
        style: {
            maxHeight: "calc(100dvh - 70px)",
            overflowY: "auto"
        },
        children: G.jsx(B_, {
            disablePadding: !0,
            children: e.results.map( (i, s) => G.jsx(c8, {
                onSelect: () => {
                    e.onSelect(i)
                }
                ,
                selected: e.selectedIndex === s,
                result: i
            }, a8(i))).reduce( (i, s) => [i, G.jsx($p, {}, "divider-" + t++), s])
        })
    })
}
;
function a8(e) {
    switch (e.type) {
    case "add_marker":
        return "add_marker";
    case "location":
        return "location_" + e.data.properties.id
    }
}
function l8(e) {
    const t = e.data
      , i = VB(t).geometry;
    return {
        id: e.data.properties.id,
        panToPosition: i && [i.coordinates[0], i.coordinates[1]]
    }
}
const c8 = e => G.jsx(MF, {
    onClick: e.onSelect,
    selected: e.selected,
    children: G.jsx(eh, {
        primary: u8(e.result),
        secondary: h8(e.result)
    })
});
function u8(e) {
    switch (e.type) {
    case "add_marker":
        return "Mark Location";
    case "location":
        const t = e.data.properties
          , i = t.name;
        return i || ((t.type === Et.FeatureType.SkiArea ? t.location?.localized.en.locality : null) ?? null)
    }
}
function h8(e) {
    switch (e.type) {
    case "add_marker":
        const [t,i] = e.data.coordinates
          , s = i >= 0 ? "N" : "S"
          , u = t >= 0 ? "E" : "W";
        return `Location: ${Math.abs(i)}°${s}, ${Math.abs(t)}°${u}`;
    case "location":
        const d = e.data.properties;
        return [d8(d), f8(d)].filter(p8).join(" - ")
    }
}
function d8(e) {
    switch (e.type) {
    case Et.FeatureType.SkiArea:
        return (e.activities.map(t => {
            switch (t) {
            case Et.SkiAreaActivity.Downhill:
                return "Downhill";
            case Et.SkiAreaActivity.Nordic:
                return "Nordic"
            }
        }
        ).join(" and ") + " Ski Area").trim();
    case Et.FeatureType.Run:
        return _P(e.uses, e.grooming);
    case Et.FeatureType.Lift:
        return Et.getLiftNameAndType(e) + " lift"
    }
}
function f8(e) {
    let t = [], i;
    e.type === Et.FeatureType.Lift || e.type === Et.FeatureType.Run ? (t.push(e.skiAreas.map(f => f.properties.name).join(" / ")),
    i = e.skiAreas.map(f => f.properties.location).filter(f => f != null)) : e.location ? i = [e.location] : i = [];
    const s = iC("region", i);
    s.length > 0 && t.push(s.join(" / "));
    const u = iC("country", i);
    u.length > 0 && t.push(u.join(" / "));
    const d = t.join(", ");
    return d.length > 0 ? d : null
}
function p8(e) {
    return !!e
}
function iC(e, t) {
    return [...new Set(t.map(i => i.localized.en[e]).filter(i => i != null))]
}
class m8 {
    _container;
    _root = null;
    _map = null;
    _eventBus;
    _filtersShown = !1;
    constructor(t) {
        this._eventBus = t,
        this._container = document.createElement("div"),
        this._container.className = "maplibregl-ctrl"
    }
    onAdd = t => (this._root = Wh.createRoot(this._container),
    this._map = t,
    this.render(),
    this._map.on("resize", this.render),
    this._container);
    onRemove = () => {
        this._root?.unmount(),
        this._root = null,
        this._map.off("resize", this.render);
        const t = this._container.parentNode;
        t && t.removeChild(this._container),
        this._map = null
    }
    ;
    setFiltersShown = t => {
        this._filtersShown = t,
        this.render()
    }
    ;
    render = () => {
        this._root?.render(G.jsx(qh, {
            children: G.jsx(o8, {
                eventBus: this._eventBus,
                width: ib(this._map),
                filtersShown: this._filtersShown
            })
        }))
    }
    ;
    getDefaultPosition = () => "top-left"
}
class g8 {
    canvas = null;
    gl = null;
    program = null;
    positionBuffer = null;
    texCoordBuffer = null;
    isSupported = !1;
    demSource;
    vertexShaderSource = `#version 300 es
    in vec2 a_position;
    in vec2 a_texCoord;
    out vec2 v_texCoord;
    
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
      v_texCoord = a_texCoord;
    }
  `;
    fragmentShaderSource = `#version 300 es
    precision highp float;
    
    out vec4 fragColor;
    
    uniform sampler2D u_texture;
    uniform float u_zoomLevel;
    uniform float u_latitude;
    in vec2 v_texCoord;
    
    // Color gradient for slopes (green to red based on steepness)
    vec3 getSlopeColor(float slope) {
      // Slope is in degrees (0-90)
      float normalizedSlope = clamp(slope / 45.0, 0.0, 1.0); // Normalize to 0-45 degrees for more sensitivity
      
      // More vibrant colors for better visibility
      vec3 green = vec3(0.0, 1.0, 0.0);   // Bright green for flat
      vec3 yellow = vec3(1.0, 1.0, 0.0);  // Bright yellow for moderate
      vec3 orange = vec3(1.0, 0.5, 0.0);  // Orange for steep
      vec3 red = vec3(1.0, 0.0, 0.0);     // Red for very steep
      
      vec3 color;
      if (normalizedSlope < 0.25) {
        // Green to Yellow (0-11.25 degrees)
        color = mix(green, yellow, normalizedSlope * 4.0);
      } else if (normalizedSlope < 0.5) {
        // Yellow to Orange (11.25-22.5 degrees)
        color = mix(yellow, orange, (normalizedSlope - 0.25) * 4.0);
      } else if (normalizedSlope < 0.75) {
        // Orange to Red (22.5-33.75 degrees)
        color = mix(orange, red, (normalizedSlope - 0.5) * 4.0);
      } else {
        // Deep red for extreme slopes (33.75+ degrees)
        color = red;
      }
      
      return color;
    }
    
    void main() {
      vec2 textureSize = vec2(textureSize(u_texture, 0));
      vec2 texelSize = 1.0 / textureSize;
      
      // Map output coordinates to padded texture coordinates
      // Scale and offset to map to the center portion of the padded texture
      vec2 adjustedTexCoord = v_texCoord * (textureSize - 2.0) / textureSize + 1.0 / textureSize;
      
      // Sample the center pixel - elevation is stored directly in red channel
      vec4 centerSample = texture(u_texture, adjustedTexCoord);
      
      // Check if we have valid data (DEM tiles use -10000 for no data)
      if (centerSample.r < -9999.0) {
        discard;
      }
      
      float centerHeight = centerSample.r;
      
      
      // Sample neighboring pixels for slope calculation (Sobel operator)
      float n = texture(u_texture, adjustedTexCoord + vec2(0.0, -texelSize.y)).r;
      float s = texture(u_texture, adjustedTexCoord + vec2(0.0, texelSize.y)).r;
      float e = texture(u_texture, adjustedTexCoord + vec2(texelSize.x, 0.0)).r;
      float w = texture(u_texture, adjustedTexCoord + vec2(-texelSize.x, 0.0)).r;
      float ne = texture(u_texture, adjustedTexCoord + vec2(texelSize.x, -texelSize.y)).r;
      float nw = texture(u_texture, adjustedTexCoord + vec2(-texelSize.x, -texelSize.y)).r;
      float se = texture(u_texture, adjustedTexCoord + vec2(texelSize.x, texelSize.y)).r;
      float sw = texture(u_texture, adjustedTexCoord + vec2(-texelSize.x, texelSize.y)).r;
      
      // Check if any neighboring pixels are invalid (use center height as fallback)
      if (n < -9999.0) n = centerHeight;
      if (s < -9999.0) s = centerHeight;
      if (e < -9999.0) e = centerHeight;
      if (w < -9999.0) w = centerHeight;
      if (ne < -9999.0) ne = centerHeight;
      if (nw < -9999.0) nw = centerHeight;
      if (se < -9999.0) se = centerHeight;
      if (sw < -9999.0) sw = centerHeight;
      
      // Sobel operator for gradient calculation
      float dzdx = ((ne + 2.0 * e + se) - (nw + 2.0 * w + sw)) / 8.0;
      float dzdy = ((ne + 2.0 * n + nw) - (se + 2.0 * s + sw)) / 8.0;
      
      // Calculate pixel size in meters based on zoom level and latitude
      // Formula: pixelSizeMeters = 156543.03392 * cos(latitude) / 2^zoom
      float latRad = radians(u_latitude);
      float pixelSizeMeters = 156543.03392 * cos(latRad) / pow(2.0, u_zoomLevel);
      
      // Calculate the magnitude of the gradient vector
      float gradientMagnitude = sqrt(dzdx * dzdx + dzdy * dzdy);
      
      // Calculate slope in radians, then convert to degrees
      // The slope is the arctangent of the elevation change over horizontal distance
      float slope = atan(gradientMagnitude / pixelSizeMeters);
      float slopeDegrees = degrees(slope);
      
      // Get color based on slope
      vec3 slopeColor = getSlopeColor(slopeDegrees);
      
      // Add some basic hillshading for depth perception
      vec3 normal = normalize(vec3(-dzdx, -dzdy, pixelSizeMeters));
      vec3 lightDir = normalize(vec3(0.5, 0.5, 0.8));
      float hillshade = dot(normal, lightDir);
      hillshade = clamp(hillshade, 0.3, 1.0); // Keep some ambient light
      
      // Combine slope color with hillshading
      vec3 finalColor = slopeColor * hillshade;
      
      // Full opacity to ensure visibility
      fragColor = vec4(finalColor, 1.0);
    }
  `;
    constructor(t) {
        this.canvas = document.createElement("canvas"),
        this.isSupported = this.initWebGL(this.canvas),
        this.demSource = t,
        this.isSupported || console.warn("WebGL is not supported on this device. Slope terrain rendering will not be available.")
    }
    checkSupport() {
        return this.isSupported
    }
    createShader(t, i, s) {
        const u = t.createShader(i);
        return u ? (t.shaderSource(u, s),
        t.compileShader(u),
        t.getShaderParameter(u, t.COMPILE_STATUS) ? u : (console.error("Shader compilation error:", t.getShaderInfoLog(u)),
        t.deleteShader(u),
        null)) : null
    }
    initWebGL(t) {
        this.canvas = t;
        const i = t.getContext("webgl2");
        if (!i)
            return console.error("WebGL 2 is required for slope terrain rendering"),
            !1;
        i.getExtension("EXT_color_buffer_float"),
        i.getExtension("OES_texture_float_linear"),
        this.gl = i;
        const s = this.createShader(i, i.VERTEX_SHADER, this.vertexShaderSource)
          , u = this.createShader(i, i.FRAGMENT_SHADER, this.fragmentShaderSource);
        if (!s || !u || (this.program = i.createProgram(),
        !this.program))
            return !1;
        if (i.attachShader(this.program, s),
        i.attachShader(this.program, u),
        i.linkProgram(this.program),
        !i.getProgramParameter(this.program, i.LINK_STATUS))
            return console.error("Program linking error:", i.getProgramInfoLog(this.program)),
            !1;
        if (i.validateProgram(this.program),
        !i.getProgramParameter(this.program, i.VALIDATE_STATUS))
            return console.error("Program validation error:", i.getProgramInfoLog(this.program)),
            !1;
        this.positionBuffer = i.createBuffer(),
        i.bindBuffer(i.ARRAY_BUFFER, this.positionBuffer);
        const d = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        i.bufferData(i.ARRAY_BUFFER, d, i.STATIC_DRAW),
        this.texCoordBuffer = i.createBuffer(),
        i.bindBuffer(i.ARRAY_BUFFER, this.texCoordBuffer);
        const f = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
        return i.bufferData(i.ARRAY_BUFFER, f, i.STATIC_DRAW),
        !0
    }
    processTerrainTile(t, i, s=50) {
        if (!this.isSupported)
            return null;
        const u = this.gl
          , d = this.program
          , f = this.canvas;
        if (!u || !d || !f)
            return null;
        const o = t.width - 2
          , w = t.height - 2;
        f.width = o,
        f.height = w,
        u.viewport(0, 0, o, w);
        const T = u.createTexture();
        u.bindTexture(u.TEXTURE_2D, T),
        u.texImage2D(u.TEXTURE_2D, 0, u.R32F, t.width, t.height, 0, u.RED, u.FLOAT, t.data);
        const k = u.getExtension("OES_texture_float_linear");
        u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, k ? u.LINEAR : u.NEAREST),
        u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, k ? u.LINEAR : u.NEAREST),
        u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE),
        u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE),
        u.useProgram(d);
        const L = u.getAttribLocation(d, "a_position");
        u.bindBuffer(u.ARRAY_BUFFER, this.positionBuffer),
        u.enableVertexAttribArray(L),
        u.vertexAttribPointer(L, 2, u.FLOAT, !1, 0, 0);
        const z = u.getAttribLocation(d, "a_texCoord");
        u.bindBuffer(u.ARRAY_BUFFER, this.texCoordBuffer),
        u.enableVertexAttribArray(z),
        u.vertexAttribPointer(z, 2, u.FLOAT, !1, 0, 0);
        const D = u.getUniformLocation(d, "u_texture");
        u.uniform1i(D, 0);
        const N = u.getUniformLocation(d, "u_zoomLevel");
        u.uniform1f(N, i);
        const U = u.getUniformLocation(d, "u_latitude");
        u.uniform1f(U, s),
        u.clearColor(0, 0, 0, 0),
        u.clear(u.COLOR_BUFFER_BIT),
        u.drawArrays(u.TRIANGLE_STRIP, 0, 4);
        const V = new Uint8Array(o * w * 4);
        return u.readPixels(0, 0, o, w, u.RGBA, u.UNSIGNED_BYTE, V),
        u.deleteTexture(T),
        new ImageData(new Uint8ClampedArray(V),o,w)
    }
    async getPaddedDemTile(t, i, s) {
        const u = []
          , d = [[-1, -1], [0, -1], [1, -1], [-1, 0], [0, 0], [1, 0], [-1, 1], [0, 1], [1, 1]];
        for (const [z,D] of d)
            u.push(this.demSource.getDemTile(t, i + z, s + D));
        const f = await Promise.all(u)
          , o = f[4];
        if (!o)
            return null;
        const w = o.width
          , T = w + 2
          , k = new Float32Array(T * T);
        k.fill(-1e4);
        for (let z = 0; z < w; z++)
            for (let D = 0; D < w; D++) {
                const N = z * w + D
                  , U = (z + 1) * T + (D + 1);
                k[U] = o.data[N]
            }
        const L = [[0, 1, 2], [3, 4, 5], [6, 7, 8]];
        for (let z = 0; z < 3; z++)
            for (let D = 0; D < 3; D++) {
                const N = L[z][D]
                  , U = f[N];
                if (!(!U || N === 4)) {
                    if (D === 0 && z === 1)
                        for (let V = 0; V < w; V++) {
                            const re = V * w + (w - 1)
                              , ie = (V + 1) * T + 0;
                            k[ie] = U.data[re]
                        }
                    else if (D === 2 && z === 1)
                        for (let V = 0; V < w; V++) {
                            const re = V * w + 0
                              , ie = (V + 1) * T + (T - 1);
                            k[ie] = U.data[re]
                        }
                    else if (D === 1 && z === 0)
                        for (let V = 0; V < w; V++) {
                            const re = (w - 1) * w + V
                              , ie = 0 * T + (V + 1);
                            k[ie] = U.data[re]
                        }
                    else if (D === 1 && z === 2)
                        for (let V = 0; V < w; V++) {
                            const re = 0 * w + V
                              , ie = (T - 1) * T + (V + 1);
                            k[ie] = U.data[re]
                        }
                    else if (D === 0 && z === 0) {
                        const V = (w - 1) * w + (w - 1)
                          , re = 0 * T + 0;
                        k[re] = U.data[V]
                    } else if (D === 2 && z === 0) {
                        const V = (w - 1) * w + 0
                          , re = 0 * T + (T - 1);
                        k[re] = U.data[V]
                    } else if (D === 0 && z === 2) {
                        const V = 0 * w + (w - 1)
                          , re = (T - 1) * T + 0;
                        k[re] = U.data[V]
                    } else if (D === 2 && z === 2) {
                        const V = 0 * w + 0
                          , re = (T - 1) * T + (T - 1);
                        k[re] = U.data[V]
                    }
                }
            }
        return {
            width: T,
            height: T,
            data: k
        }
    }
    registerSlopeProtocol() {
        if (!this.checkSupport()) {
            console.error("Slope terrain rendering requires WebGL 2 support");
            return
        }
        Ea.addProtocol("slope-terrain", async t => {
            const i = t.url.match(/\/(\d+)\/(\d+)\/(\d+)/);
            let s = 10
              , u = 50
              , d = 0
              , f = 0
              , o = 0;
            if (i) {
                o = parseInt(i[1], 10),
                d = parseInt(i[2], 10),
                f = parseInt(i[3], 10),
                s = o;
                const D = Math.PI - 2 * Math.PI * f / Math.pow(2, s);
                u = 180 / Math.PI * Math.atan(.5 * (Math.exp(D) - Math.exp(-D)))
            }
            const w = await this.getPaddedDemTile(o, d, f);
            if (!w) {
                const D = document.createElement("canvas");
                D.width = 512,
                D.height = 512;
                const N = D.getContext("2d");
                if (N) {
                    N.clearRect(0, 0, 512, 512);
                    const U = await new Promise(V => D.toBlob(V));
                    if (U)
                        return {
                            data: await U.arrayBuffer()
                        }
                }
                throw new Error("Failed to create empty tile")
            }
            const T = this.processTerrainTile(w, s, u);
            if (!T)
                throw new Error("WebGL processing failed");
            const k = document.createElement("canvas");
            k.width = T.width,
            k.height = T.height;
            const L = k.getContext("2d");
            if (!L)
                throw new Error("Failed to get canvas context");
            L.putImageData(T, 0, 0);
            const z = await new Promise(D => k.toBlob(D));
            if (!z)
                throw new Error("Failed to create blob");
            return {
                data: await z.arrayBuffer()
            }
        }
        )
    }
}
let y8 = class {
    map;
    eventBus;
    infoControl = null;
    filterControl;
    searchBarControl;
    markers;
    tracks = [];
    loaded = !1;
    filtersVisible = !1;
    mapScaleControl;
    interactionManager;
    filterManager;
    demSource;
    esriAttribution = null;
    attributionControl;
    currentStyle = null;
    terrainEnabled = !1;
    slopeTerrainEnabled = !1;
    slopeRenderer = null;
    constructor(t, i, s, u) {
        this.eventBus = u,
        this.map = new Ea.Map({
            container: s,
            center: t,
            zoom: i,
            hash: !0,
            attributionControl: !1
        }),
        this.markers = [],
        this.filterControl = new TB(u),
        this.searchBarControl = new m8(u),
        this.interactionManager = new HV(this.map,u),
        this.filterManager = new NV(this.map),
        this.mapScaleControl = new Ea.ScaleControl({
            maxWidth: 80
        }),
        this.map.addControl(this.searchBarControl),
        this.map.addControl(this.mapScaleControl, "bottom-left"),
        this.attributionControl = new Ea.AttributionControl({
            customAttribution: ['<a href="?legal" id="legal-attribution-link">Legal</a>']
        }),
        this.map.addControl(this.attributionControl, "bottom-right"),
        this.map.addControl(new Ea.GeolocateControl({
            positionOptions: {
                enableHighAccuracy: !0
            },
            trackUserLocation: !0
        }), "bottom-right"),
        this.map.addControl(new Ea.NavigationControl({
            showCompass: !0,
            showZoom: !1
        }), "bottom-right"),
        this.demSource = new U5.DemSource({
            url: "https://tiles.openskimap.org/dynamic/data/merged-terrain/{z}/{x}/{y}.webp",
            encoding: "mapbox",
            maxzoom: 16,
            worker: !0,
            cacheSize: 100,
            timeoutMs: 1e4
        }),
        this.demSource.setupMaplibre(hk),
        this.slopeRenderer = new g8(this.demSource),
        this.slopeRenderer?.registerSlopeProtocol(),
        this.map.getPitch() > 0 && (this.terrainEnabled = !0),
        this.map.once("load", () => {
            this.loaded = !0,
            this.esriAttribution = new G5(this.map,"https://static.arcgis.com/attribution/World_Imagery",this.attributionControl),
            this.esriAttribution.autoManage();
            const f = document.getElementById("legal-attribution-link");
            f && f.addEventListener("click", o => {
                o.preventDefault(),
                this.eventBus.openLegal()
            }
            )
        }
        ),
        this.map.on("pitchend", () => {
            const o = this.map.getPitch() > 0;
            o !== this.terrainEnabled && (this.terrainEnabled = o,
            o ? this.map.getSource("terrain") && this.map.setTerrain({
                source: "terrain"
            }) : this.map.setTerrain(null),
            this.map.getLayer("building-3d") && this.map.setLayoutProperty("building-3d", "visibility", o ? "visible" : "none"),
            this.map.getLayer("building-top") && this.map.setLayoutProperty("building-top", "visibility", o ? "none" : "visible"))
        }
        ),
        CB({
            onUnitSystemChange: f => {
                this.waitForMapLoaded( () => {
                    this.currentStyle && this.setStyle(this.currentStyle)
                }
                ),
                this.updateScaleControlUnits(f)
            }
            ,
            triggerWhenInitialized: !0
        })
    }
    updateScaleControlUnits(t) {
        this.mapScaleControl.setUnit(t)
    }
    getContourMultiplier(t) {
        return t === "imperial" ? 3.28084 : 1
    }
    getContourTextFieldExpression(t) {
        return ["concat", ["get", "ele"], t === "imperial" ? " ft" : " m"]
    }
    waitForMapLoaded = t => {
        this.loaded ? t() : this.map.once("load", t)
    }
    ;
    setInfo = t => {
        t && t.panToPosition && t.panToPosition !== "afterLoad" && this.flyTo(t.panToPosition),
        this.infoControl !== null && this.map.removeControl(this.infoControl),
        this.infoControl = t === null ? null : new jV(t,this.eventBus),
        this.infoControl !== null && this.map.addControl(this.infoControl)
    }
    ;
    flyTo = t => {
        this.map.flyTo({
            center: t,
            zoom: CP
        })
    }
    ;
    setStyle = t => {
        this.currentStyle = t,
        this.map.setStyle(z5[t], {
            transformStyle: (i, s) => {
                const u = Wp()
                  , d = T => T.endsWith("-metric") ? u === "metric" ? "visible" : "none" : T.endsWith("-imperial") ? u === "imperial" ? "visible" : "none" : T === "building-3d" ? this.terrainEnabled ? "visible" : "none" : T === "building-top" ? this.terrainEnabled ? "none" : "visible" : null
                  , f = s.layers.map(T => {
                    const k = d(T.id);
                    return k === null ? T : {
                        ...T,
                        layout: {
                            ...T.layout,
                            visibility: k
                        }
                    }
                }
                );
                let o = {
                    ...s,
                    layers: f,
                    terrain: this.terrainEnabled ? s.terrain : void 0
                };
                const w = {
                    ...o.sources
                };
                if (w.terrain && w.terrain.type === "raster-dem" && (w.terrain = {
                    ...w.terrain,
                    tiles: [this.demSource.sharedDemProtocolUrl]
                }),
                t == Yc.Terrain) {
                    const T = [this.demSource.contourProtocolUrl({
                        multiplier: this.getContourMultiplier(u),
                        thresholds: {
                            11: [200, 1e3],
                            12: [100, 500],
                            13: [10, 100]
                        },
                        overzoom: 1,
                        contourLayer: "contours",
                        elevationKey: "ele",
                        levelKey: "level"
                    })];
                    w.hillshade && w.hillshade.type === "raster-dem" && (w.hillshade = {
                        ...w.hillshade,
                        tiles: [this.demSource.sharedDemProtocolUrl]
                    }),
                    o = {
                        ...o,
                        sources: {
                            ...w,
                            contours: {
                                type: "vector",
                                tiles: T,
                                maxzoom: 16
                            }
                        },
                        layers: [...o.layers, {
                            id: "contour-lines",
                            type: "line",
                            source: "contours",
                            "source-layer": "contours",
                            paint: {
                                "line-color": "rgba(0,0,0, 10%)",
                                "line-width": ["match", ["get", "level"], 1, 1, .5]
                            }
                        }, {
                            id: "contour-labels",
                            type: "symbol",
                            source: "contours",
                            "source-layer": "contours",
                            filter: [">", ["get", "level"], 0],
                            paint: {
                                "text-halo-color": "white",
                                "text-halo-width": 1
                            },
                            layout: {
                                "symbol-spacing": 200,
                                "symbol-placement": "line",
                                "text-anchor": "center",
                                "text-size": 10,
                                "text-field": this.getContourTextFieldExpression(u),
                                "text-font": ["Noto Sans Regular"]
                            }
                        }]
                    }
                }
                if (this.slopeTerrainEnabled && this.slopeRenderer?.checkSupport()) {
                    o.sources["slope-terrain"] || (o.sources["slope-terrain"] = {
                        type: "raster",
                        tiles: [`slope-terrain://${this.demSource.sharedDemProtocolUrl}`],
                        tileSize: 512,
                        minzoom: 5,
                        maxzoom: 16
                    });
                    const T = o.layers.findIndex(L => L.id === "park" || L.id === "satellite")
                      , k = T >= 0 ? T + 1 : o.layers.length;
                    o.layers.splice(k, 0, {
                        id: "slope-terrain-overlay",
                        type: "raster",
                        source: "slope-terrain",
                        paint: {
                            "raster-opacity": .7
                        }
                    })
                }
                return this.tracks.forEach(T => {
                    const k = `track-${T.id}`
                      , L = `track-line-${T.id}`;
                    o.sources[k] = {
                        type: "geojson",
                        data: {
                            type: "Feature",
                            properties: {
                                name: T.name,
                                color: T.color
                            },
                            geometry: {
                                type: "LineString",
                                coordinates: T.coordinates
                            }
                        }
                    },
                    o.layers.push({
                        id: L,
                        type: "line",
                        source: k,
                        paint: {
                            "line-color": T.color,
                            "line-width": 3,
                            "line-opacity": .8
                        },
                        layout: {
                            "line-join": "round",
                            "line-cap": "round"
                        }
                    })
                }
                ),
                o
            }
        })
    }
    ;
    setFiltersUnthrottled = t => {
        this.waitForMapLoaded( () => {
            this.filterControl.setFilters(t),
            this.filterManager.setFilters(t),
            this.updateVisibleSkiAreasCountUnthrottled()
        }
        )
    }
    ;
    setFilters = Y_(100, this.setFiltersUnthrottled);
    setFiltersVisible = t => {
        this.waitForMapLoaded( () => {
            this.filtersVisible = t,
            this.searchBarControl.setFiltersShown(t),
            t ? (this.map.addControl(this.filterControl),
            this.map.on("render", this.updateVisibleSkiAreasCount)) : (this.map.removeControl(this.filterControl),
            this.map.off("render", this.updateVisibleSkiAreasCount)),
            this.updateVisibleSkiAreasCountUnthrottled()
        }
        )
    }
    ;
    getCenter = () => this.map.getCenter();
    getZoom = () => this.map.getZoom();
    setMarkers = t => {
        for (const i of this.markers)
            i.remove();
        this.markers = [];
        for (const i of t) {
            const s = new Ea.Marker().setLngLat([i.coordinates[0], i.coordinates[1]]).addTo(this.map);
            this.markers.push(s)
        }
    }
    ;
    updateVisibleSkiAreasCountUnthrottled = () => {
        this.filtersVisible && this.filterControl.setVisibleSkiAreasCount(this.filterManager.getVisibleSkiAreasCount())
    }
    ;
    updateVisibleSkiAreasCount = Y_(1e3, this.updateVisibleSkiAreasCountUnthrottled);
    toggleSlopeTerrainOverlay = t => {
        this.waitForMapLoaded( () => {
            const i = t !== void 0 ? t : !this.slopeTerrainEnabled;
            if (i !== this.slopeTerrainEnabled) {
                if (i && !this.slopeRenderer?.checkSupport()) {
                    console.error("Slope terrain rendering requires WebGL 2 support");
                    return
                }
                this.slopeTerrainEnabled = i,
                this.currentStyle !== null && this.setStyle(this.currentStyle)
            }
        }
        )
    }
    ;
    getSlopeTerrainEnabled = () => this.slopeTerrainEnabled;
    setTracks = t => {
        this.tracks = t,
        this.waitForMapLoaded( () => {
            this.currentStyle !== null && this.setStyle(this.currentStyle)
        }
        )
    }
    ;
    addControl = (t, i) => {
        this.map.addControl(t, i)
    }
}
  , _8 = class extends Pe.Component {
    render() {
        return G.jsxs(G.Fragment, {
            children: [G.jsx(Cv, {
                onClose: () => this.props.eventBus.closeSettings(),
                children: G.jsx(qt, {
                    variant: "h5",
                    id: "modal-title",
                    children: "Settings"
                })
            }), G.jsx("div", {
                style: {
                    minWidth: 300
                },
                children: G.jsxs(qO, {
                    children: [G.jsxs(kg, {
                        children: [" ", G.jsxs(qt, {
                            fontSize: "1.15rem",
                            color: "WindowText",
                            children: ["Unit Style", " "]
                        })]
                    }), G.jsxs(TT, {
                        value: this.props.unitSystem,
                        onChange: t => {
                            const i = t.target.value;
                            this.props.eventBus.setUnitSystem(i)
                        }
                        ,
                        children: [G.jsx(mf, {
                            value: "metric",
                            control: G.jsx(Z_, {}),
                            label: "Metric"
                        }), G.jsx(mf, {
                            value: "imperial",
                            control: G.jsx(Z_, {}),
                            label: "Imperial"
                        })]
                    })]
                })
            })]
        })
    }
}
;
const v8 = e => G.jsx(wv, {
    open: e.open,
    onClose: () => {
        e.eventBus.closeSettings()
    }
    ,
    children: G.jsx(ka, {
        sx: {
            p: 4
        },
        children: G.jsx(_8, {
            eventBus: e.eventBus,
            unitSystem: e.unitSystem
        })
    })
});
var xg = {}, oC;
function x8() {
    if (oC)
        return xg;
    oC = 1;
    var e = Io();
    Object.defineProperty(xg, "__esModule", {
        value: !0
    }),
    xg.default = void 0;
    var t = e(ls())
      , i = Uo();
    return xg.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75z"
    }), "Edit"),
    xg
}
var b8 = x8();
const w8 = Ni(b8);
var bg = {}, sC;
function S8() {
    if (sC)
        return bg;
    sC = 1;
    var e = Io();
    Object.defineProperty(bg, "__esModule", {
        value: !0
    }),
    bg.default = void 0;
    var t = e(ls())
      , i = Uo();
    return bg.default = (0,
    t.default)([(0,
    i.jsx)("path", {
        d: "m21 5-9-4-9 4v6c0 5.55 3.84 10.74 9 12 2.3-.56 4.33-1.9 5.88-3.71l-3.12-3.12c-1.94 1.29-4.58 1.07-6.29-.64-1.95-1.95-1.95-5.12 0-7.07 1.95-1.95 5.12-1.95 7.07 0 1.71 1.71 1.92 4.35.64 6.29l2.9 2.9C20.29 15.69 21 13.38 21 11z"
    }, "0"), (0,
    i.jsx)("circle", {
        cx: "12",
        cy: "12",
        r: "3"
    }, "1")], "Policy"),
    bg
}
var C8 = S8();
const T8 = Ni(C8);
var wg = {}, aC;
function P8() {
    if (aC)
        return wg;
    aC = 1;
    var e = Io();
    Object.defineProperty(wg, "__esModule", {
        value: !0
    }),
    wg.default = void 0;
    var t = e(ls())
      , i = Uo();
    return wg.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2M5 4.99h3C8 6.65 6.66 8 5 8zM5 12v-2c2.76 0 5-2.25 5-5.01h2C12 8.86 8.87 12 5 12m0 6 3.5-4.5 2.5 3.01L14.5 12l4.5 6z"
    }), "Satellite"),
    wg
}
var M8 = P8();
const k8 = Ni(M8);
var Sg = {}, lC;
function E8() {
    if (lC)
        return Sg;
    lC = 1;
    var e = Io();
    Object.defineProperty(Sg, "__esModule", {
        value: !0
    }),
    Sg.default = void 0;
    var t = e(ls())
      , i = Uo();
    return Sg.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6"
    }), "Settings"),
    Sg
}
var I8 = E8();
const R8 = Ni(I8);
var Cg = {}, cC;
function A8() {
    if (cC)
        return Cg;
    cC = 1;
    var e = Io();
    Object.defineProperty(Cg, "__esModule", {
        value: !0
    }),
    Cg.default = void 0;
    var t = e(ls())
      , i = Uo();
    return Cg.default = (0,
    t.default)((0,
    i.jsx)("path", {
        d: "m14 6-3.75 5 2.85 3.8-1.6 1.2C9.81 13.75 7 10 7 10l-6 8h22z"
    }), "Terrain"),
    Cg
}
var z8 = A8();
const D8 = Ni(z8);
class L8 extends Pe.Component {
    render = () => G.jsx($O, {
        anchor: "left",
        open: this.props.open,
        onClose: this.close,
        children: G.jsx("div", {
            tabIndex: 0,
            role: "button",
            onClick: this.close,
            onKeyDown: this.close,
            children: G.jsxs("div", {
                style: {
                    width: "256"
                },
                children: [G.jsxs(B_, {
                    children: [G.jsxs(Vh, {
                        button: !0,
                        onClick: () => {
                            this.props.eventBus.setMapStyle(Yc.Terrain)
                        }
                        ,
                        selected: this.props.selectedMapStyle === Yc.Terrain,
                        children: [G.jsx(xp, {
                            children: G.jsx(D8, {})
                        }), G.jsx(eh, {
                            primary: "Terrain"
                        })]
                    }, "terrain"), G.jsxs(Vh, {
                        button: !0,
                        onClick: () => {
                            this.props.eventBus.setMapStyle(Yc.Satellite)
                        }
                        ,
                        selected: this.props.selectedMapStyle === Yc.Satellite,
                        children: [G.jsx(xp, {
                            children: G.jsx(k8, {})
                        }), G.jsx(eh, {
                            primary: "Satellite"
                        })]
                    }, "satellite")]
                }), G.jsx($p, {}), G.jsxs(B_, {
                    children: [G.jsxs(Vh, {
                        button: !0,
                        onClick: this.props.eventBus.openSettings,
                        children: [G.jsx(xp, {
                            children: G.jsx(R8, {})
                        }), G.jsx(eh, {
                            primary: "Settings"
                        })]
                    }, "settings"), G.jsxs(Vh, {
                        button: !0,
                        onClick: this.props.eventBus.editMap,
                        children: [G.jsx(xp, {
                            children: G.jsx(w8, {})
                        }), G.jsx(eh, {
                            primary: "Edit"
                        })]
                    }, "edit"), G.jsxs(Vh, {
                        button: !0,
                        onClick: this.props.eventBus.openAboutInfo,
                        children: [G.jsx(xp, {
                            children: G.jsx(xP, {})
                        }), G.jsx(eh, {
                            primary: "About"
                        })]
                    }, "about"), G.jsxs(Vh, {
                        button: !0,
                        onClick: this.props.eventBus.openLegal,
                        children: [G.jsx(xp, {
                            children: G.jsx(T8, {})
                        }), G.jsx(eh, {
                            primary: "Credits & Legal"
                        })]
                    }, "legal")]
                }), G.jsx($p, {}), G.jsxs(B_, {
                    children: [G.jsx(Vh, {
                        button: !0,
                        onClick: M5,
                        children: G.jsx(eh, {
                            primary: "Privacy Policy"
                        })
                    }), G.jsx(Vh, {
                        button: !0,
                        onClick: k5,
                        children: G.jsx(eh, {
                            primary: "Cookie Policy"
                        })
                    })]
                })]
            })
        })
    });
    close = () => {
        this.props.eventBus.closeSidebar()
    }
}
function O8() {
    const e = localStorage.getItem("mapStyle")
      , t = e && Object.values(Yc).includes(e) ? e : Yc.Terrain
      , i = localStorage.getItem("mapStyleOverlay");
    let s = Vp.Slope;
    i === "null" || i === null ? s = null : i && Object.values(Vp).includes(i) && (s = i);
    const u = localStorage.getItem("tracks");
    let d = [];
    if (u)
        try {
            d = JSON.parse(u)
        } catch {
            d = []
        }
    return {
        sidebarOpen: !1,
        aboutInfoOpen: !1,
        legalOpen: !1,
        settingsOpen: !1,
        layersOpen: !1,
        mapFiltersOpen: !1,
        mapStyle: t,
        mapStyleOverlay: s,
        mapFilters: AT,
        info: null,
        markers: [],
        tracks: d,
        unitSystem: Wp()
    }
}
class F8 {
    _state;
    updateHandler = () => {}
    ;
    editMapHandler = null;
    constructor(t, i= () => {}
    ) {
        this._state = t,
        this.updateHandler = i
    }
    editMap = () => {
        this.editMapHandler()
    }
    ;
    openSidebar = () => {
        this.update({
            sidebarOpen: !0
        })
    }
    ;
    closeSidebar = () => {
        this.update({
            sidebarOpen: !1
        })
    }
    ;
    openAboutInfo = () => {
        this.update({
            aboutInfoOpen: !0
        })
    }
    ;
    closeAboutInfo = () => {
        this.update({
            aboutInfoOpen: !1
        })
    }
    ;
    openLegal = () => {
        this.update({
            legalOpen: !0
        })
    }
    ;
    closeLegal = () => {
        this.update({
            legalOpen: !1
        })
    }
    ;
    openSettings = () => {
        this.update({
            settingsOpen: !0
        })
    }
    ;
    closeSettings = () => {
        this.update({
            settingsOpen: !1
        })
    }
    ;
    openLayers = () => {
        this.update({
            layersOpen: !0
        })
    }
    ;
    closeLayers = () => {
        this.update({
            layersOpen: !1
        })
    }
    ;
    setMapStyle = t => {
        this.update({
            mapStyle: t
        })
    }
    ;
    setMapStyleOverlay = t => {
        this.update({
            mapStyleOverlay: t
        })
    }
    ;
    setUnitSystem = t => {
        this.update({
            unitSystem: t
        })
    }
    ;
    urlUpdate = t => {
        this.update({
            aboutInfoOpen: t.aboutInfoOpen,
            legalOpen: t.legalOpen,
            info: t.selectedObjectID ? {
                id: t.selectedObjectID,
                panToPosition: "afterLoad"
            } : null,
            mapFilters: {
                ...this._state.mapFilters,
                selectedObjectID: t.selectedObjectID
            },
            markers: t.markers
        })
    }
    ;
    showInfo = t => {
        this.update({
            info: t,
            mapFilters: {
                ...this._state.mapFilters,
                selectedObjectID: t.id
            }
        })
    }
    ;
    hideInfo = () => {
        this.update({
            info: null,
            mapFilters: {
                ...this._state.mapFilters,
                selectedObjectID: null
            }
        })
    }
    ;
    toggleActivity = t => {
        let i = this._state.mapFilters.hiddenActivities || [];
        i.includes(t) ? i = i.filter(s => s !== t) : i.push(t),
        this.update({
            mapFilters: {
                ...this._state.mapFilters,
                hiddenActivities: i
            }
        })
    }
    ;
    setMinimumElevation(t) {
        this.update({
            mapFilters: {
                ...this._state.mapFilters,
                minElevation: t
            }
        })
    }
    setMinimumVertical(t) {
        this.update({
            mapFilters: {
                ...this._state.mapFilters,
                minVertical: t
            }
        })
    }
    setMinimumRunLength(t) {
        this.update({
            mapFilters: {
                ...this._state.mapFilters,
                minRunLength: t
            }
        })
    }
    addMarker(t) {
        this.update({
            markers: [...this._state.markers, t],
            latestMarker: t
        })
    }
    addTrack = t => {
        const i = [...this._state.tracks, t];
        this.update({
            tracks: i
        })
    }
    ;
    removeTrack = t => {
        const i = this._state.tracks.filter(s => s.id !== t);
        this.update({
            tracks: i
        })
    }
    ;
    showFilters = () => {
        this.update({
            mapFiltersOpen: !0
        })
    }
    ;
    hideFilters = () => {
        this.update({
            mapFiltersOpen: !1
        })
    }
    ;
    update(t) {
        const i = this._state;
        Object.keys(t).forEach(s => {
            const u = t[s];
            i[s] !== u ? i[s] = u : delete t[s]
        }
        ),
        this.updateHandler(this._state, t)
    }
}
const wM = "%[a-f0-9]{2}"
  , uC = new RegExp("(" + wM + ")|([^%]+?)","gi")
  , hC = new RegExp("(" + wM + ")+","gi");
function Sx(e, t) {
    try {
        return [decodeURIComponent(e.join(""))]
    } catch {}
    if (e.length === 1)
        return e;
    t = t || 1;
    const i = e.slice(0, t)
      , s = e.slice(t);
    return Array.prototype.concat.call([], Sx(i), Sx(s))
}
function B8(e) {
    try {
        return decodeURIComponent(e)
    } catch {
        let t = e.match(uC) || [];
        for (let i = 1; i < t.length; i++)
            e = Sx(t, i).join(""),
            t = e.match(uC) || [];
        return e
    }
}
function j8(e) {
    const t = {
        "%FE%FF": "��",
        "%FF%FE": "��"
    };
    let i = hC.exec(e);
    for (; i; ) {
        try {
            t[i[0]] = decodeURIComponent(i[0])
        } catch {
            const u = B8(i[0]);
            u !== i[0] && (t[i[0]] = u)
        }
        i = hC.exec(e)
    }
    t["%C2"] = "�";
    const s = Object.keys(t);
    for (const u of s)
        e = e.replace(new RegExp(u,"g"), t[u]);
    return e
}
function N8(e) {
    if (typeof e != "string")
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof e + "`");
    try {
        return decodeURIComponent(e)
    } catch {
        return j8(e)
    }
}
function $8(e, t) {
    const i = {};
    if (Array.isArray(t))
        for (const s of t) {
            const u = Object.getOwnPropertyDescriptor(e, s);
            u?.enumerable && Object.defineProperty(i, s, u)
        }
    else
        for (const s of Reflect.ownKeys(e)) {
            const u = Object.getOwnPropertyDescriptor(e, s);
            if (u.enumerable) {
                const d = e[s];
                t(s, d, e) && Object.defineProperty(i, s, u)
            }
        }
    return i
}
function SM(e, t) {
    if (!(typeof e == "string" && typeof t == "string"))
        throw new TypeError("Expected the arguments to be of type `string`");
    if (e === "" || t === "")
        return [];
    const i = e.indexOf(t);
    return i === -1 ? [] : [e.slice(0, i), e.slice(i + t.length)]
}
const V8 = e => e == null
  , U8 = e => encodeURIComponent(e).replaceAll(/[!'()*]/g, t => `%${t.charCodeAt(0).toString(16).toUpperCase()}`)
  , Cx = Symbol("encodeFragmentIdentifier");
function G8(e) {
    switch (e.arrayFormat) {
    case "index":
        return t => (i, s) => {
            const u = i.length;
            return s === void 0 || e.skipNull && s === null || e.skipEmptyString && s === "" ? i : s === null ? [...i, [uo(t, e), "[", u, "]"].join("")] : [...i, [uo(t, e), "[", uo(u, e), "]=", uo(s, e)].join("")]
        }
        ;
    case "bracket":
        return t => (i, s) => s === void 0 || e.skipNull && s === null || e.skipEmptyString && s === "" ? i : s === null ? [...i, [uo(t, e), "[]"].join("")] : [...i, [uo(t, e), "[]=", uo(s, e)].join("")];
    case "colon-list-separator":
        return t => (i, s) => s === void 0 || e.skipNull && s === null || e.skipEmptyString && s === "" ? i : s === null ? [...i, [uo(t, e), ":list="].join("")] : [...i, [uo(t, e), ":list=", uo(s, e)].join("")];
    case "comma":
    case "separator":
    case "bracket-separator":
        {
            const t = e.arrayFormat === "bracket-separator" ? "[]=" : "=";
            return i => (s, u) => u === void 0 || e.skipNull && u === null || e.skipEmptyString && u === "" ? s : (u = u === null ? "" : u,
            s.length === 0 ? [[uo(i, e), t, uo(u, e)].join("")] : [[s, uo(u, e)].join(e.arrayFormatSeparator)])
        }
    default:
        return t => (i, s) => s === void 0 || e.skipNull && s === null || e.skipEmptyString && s === "" ? i : s === null ? [...i, uo(t, e)] : [...i, [uo(t, e), "=", uo(s, e)].join("")]
    }
}
function W8(e) {
    let t;
    switch (e.arrayFormat) {
    case "index":
        return (i, s, u) => {
            if (t = /\[(\d*)]$/.exec(i),
            i = i.replace(/\[\d*]$/, ""),
            !t) {
                u[i] = s;
                return
            }
            u[i] === void 0 && (u[i] = {}),
            u[i][t[1]] = s
        }
        ;
    case "bracket":
        return (i, s, u) => {
            if (t = /(\[])$/.exec(i),
            i = i.replace(/\[]$/, ""),
            !t) {
                u[i] = s;
                return
            }
            if (u[i] === void 0) {
                u[i] = [s];
                return
            }
            u[i] = [...u[i], s]
        }
        ;
    case "colon-list-separator":
        return (i, s, u) => {
            if (t = /(:list)$/.exec(i),
            i = i.replace(/:list$/, ""),
            !t) {
                u[i] = s;
                return
            }
            if (u[i] === void 0) {
                u[i] = [s];
                return
            }
            u[i] = [...u[i], s]
        }
        ;
    case "comma":
    case "separator":
        return (i, s, u) => {
            const d = typeof s == "string" && s.includes(e.arrayFormatSeparator)
              , f = typeof s == "string" && !d && nh(s, e).includes(e.arrayFormatSeparator);
            s = f ? nh(s, e) : s;
            const o = d || f ? s.split(e.arrayFormatSeparator).map(w => nh(w, e)) : s === null ? s : nh(s, e);
            u[i] = o
        }
        ;
    case "bracket-separator":
        return (i, s, u) => {
            const d = /(\[])$/.test(i);
            if (i = i.replace(/\[]$/, ""),
            !d) {
                u[i] = s && nh(s, e);
                return
            }
            const f = s === null ? [] : nh(s, e).split(e.arrayFormatSeparator);
            if (u[i] === void 0) {
                u[i] = f;
                return
            }
            u[i] = [...u[i], ...f]
        }
        ;
    default:
        return (i, s, u) => {
            if (u[i] === void 0) {
                u[i] = s;
                return
            }
            u[i] = [...[u[i]].flat(), s]
        }
    }
}
function CM(e) {
    if (typeof e != "string" || e.length !== 1)
        throw new TypeError("arrayFormatSeparator must be single character string")
}
function uo(e, t) {
    return t.encode ? t.strict ? U8(e) : encodeURIComponent(e) : e
}
function nh(e, t) {
    return t.decode ? N8(e) : e
}
function TM(e) {
    return Array.isArray(e) ? e.sort() : typeof e == "object" ? TM(Object.keys(e)).sort( (t, i) => Number(t) - Number(i)).map(t => e[t]) : e
}
function PM(e) {
    const t = e.indexOf("#");
    return t !== -1 && (e = e.slice(0, t)),
    e
}
function q8(e) {
    let t = "";
    const i = e.indexOf("#");
    return i !== -1 && (t = e.slice(i)),
    t
}
function dC(e, t, i) {
    return i === "string" && typeof e == "string" ? e : typeof i == "function" && typeof e == "string" ? i(e) : t.parseBooleans && e !== null && (e.toLowerCase() === "true" || e.toLowerCase() === "false") ? e.toLowerCase() === "true" : i === "number" && !Number.isNaN(Number(e)) && typeof e == "string" && e.trim() !== "" || t.parseNumbers && !Number.isNaN(Number(e)) && typeof e == "string" && e.trim() !== "" ? Number(e) : e
}
function kb(e) {
    e = PM(e);
    const t = e.indexOf("?");
    return t === -1 ? "" : e.slice(t + 1)
}
function Eb(e, t) {
    t = {
        decode: !0,
        sort: !0,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: !1,
        parseBooleans: !1,
        types: Object.create(null),
        ...t
    },
    CM(t.arrayFormatSeparator);
    const i = W8(t)
      , s = Object.create(null);
    if (typeof e != "string" || (e = e.trim().replace(/^[?#&]/, ""),
    !e))
        return s;
    for (const u of e.split("&")) {
        if (u === "")
            continue;
        const d = t.decode ? u.replaceAll("+", " ") : u;
        let[f,o] = SM(d, "=");
        f === void 0 && (f = d),
        o = o === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(t.arrayFormat) ? o : nh(o, t),
        i(nh(f, t), o, s)
    }
    for (const [u,d] of Object.entries(s))
        if (typeof d == "object" && d !== null && t.types[u] !== "string")
            for (const [f,o] of Object.entries(d)) {
                const w = t.types[u] ? t.types[u].replace("[]", "") : void 0;
                d[f] = dC(o, t, w)
            }
        else
            typeof d == "object" && d !== null && t.types[u] === "string" ? s[u] = Object.values(d).join(t.arrayFormatSeparator) : s[u] = dC(d, t, t.types[u]);
    return t.sort === !1 ? s : (t.sort === !0 ? Object.keys(s).sort() : Object.keys(s).sort(t.sort)).reduce( (u, d) => {
        const f = s[d];
        return u[d] = f && typeof f == "object" && !Array.isArray(f) ? TM(f) : f,
        u
    }
    , Object.create(null))
}
function MM(e, t) {
    if (!e)
        return "";
    t = {
        encode: !0,
        strict: !0,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        ...t
    },
    CM(t.arrayFormatSeparator);
    const i = f => t.skipNull && V8(e[f]) || t.skipEmptyString && e[f] === ""
      , s = G8(t)
      , u = {};
    for (const [f,o] of Object.entries(e))
        i(f) || (u[f] = o);
    const d = Object.keys(u);
    return t.sort !== !1 && d.sort(t.sort),
    d.map(f => {
        const o = e[f];
        return o === void 0 ? "" : o === null ? uo(f, t) : Array.isArray(o) ? o.length === 0 && t.arrayFormat === "bracket-separator" ? uo(f, t) + "[]" : o.reduce(s(f), []).join("&") : uo(f, t) + "=" + uo(o, t)
    }
    ).filter(f => f.length > 0).join("&")
}
function kM(e, t) {
    t = {
        decode: !0,
        ...t
    };
    let[i,s] = SM(e, "#");
    return i === void 0 && (i = e),
    {
        url: i?.split("?")?.[0] ?? "",
        query: Eb(kb(e), t),
        ...t && t.parseFragmentIdentifier && s ? {
            fragmentIdentifier: nh(s, t)
        } : {}
    }
}
function EM(e, t) {
    t = {
        encode: !0,
        strict: !0,
        [Cx]: !0,
        ...t
    };
    const i = PM(e.url).split("?")[0] || ""
      , s = kb(e.url)
      , u = {
        ...Eb(s, {
            sort: !1
        }),
        ...e.query
    };
    let d = MM(u, t);
    d &&= `?${d}`;
    let f = q8(e.url);
    if (typeof e.fragmentIdentifier == "string") {
        const o = new URL(i);
        o.hash = e.fragmentIdentifier,
        f = t[Cx] ? o.hash : `#${e.fragmentIdentifier}`
    }
    return `${i}${d}${f}`
}
function IM(e, t, i) {
    i = {
        parseFragmentIdentifier: !0,
        [Cx]: !1,
        ...i
    };
    const {url: s, query: u, fragmentIdentifier: d} = kM(e, i);
    return EM({
        url: s,
        query: $8(u, t),
        fragmentIdentifier: d
    }, i)
}
function H8(e, t, i) {
    const s = Array.isArray(t) ? u => !t.includes(u) : (u, d) => !t(u, d);
    return IM(e, s, i)
}
const RM = Object.freeze(Object.defineProperty({
    __proto__: null,
    exclude: H8,
    extract: kb,
    parse: Eb,
    parseUrl: kM,
    pick: IM,
    stringify: MM,
    stringifyUrl: EM
}, Symbol.toStringTag, {
    value: "Module"
}));
function Z8(e, t) {
    if (e === t)
        return !0;
    if (!e || !t)
        return !1;
    const i = Object.keys(e)
      , s = Object.keys(t)
      , u = i.length;
    if (s.length !== u)
        return !1;
    for (let d = 0; d < u; d++) {
        const f = i[d];
        if (e[f] !== t[f] || !Object.prototype.hasOwnProperty.call(t, f))
            return !1
    }
    return !0
}
function X8(e) {
    return JSON.stringify(e.map(t => t.coordinates))
}
function Y8(e) {
    try {
        const t = JSON.parse(e);
        if (Array.isArray(t) && t.every(K8))
            return t.map(i => ({
                type: "Point",
                coordinates: i
            }))
    } catch (t) {
        console.error("Failed to parse markers:", t)
    }
    return []
}
function K8(e) {
    return Array.isArray(e) && e.length === 2 && typeof e[0] == "number" && typeof e[1] == "number"
}
function Q8(e) {
    if (Z8(e, Tx()) || !window.history)
        return;
    const t = RM.stringify({
        about: e.aboutInfoOpen ? null : void 0,
        legal: e.legalOpen ? null : void 0,
        obj: e.selectedObjectID !== null ? e.selectedObjectID : void 0,
        markers: e.markers.length > 0 ? X8(e.markers) : void 0
    });
    window.history.pushState(e, "OpenSkiMap.org", "/" + (t.length > 0 ? "?" : "") + t + location.hash)
}
function Tx() {
    const e = RM.parseUrl(window.location.toString()).query;
    return {
        aboutInfoOpen: e.about !== void 0,
        legalOpen: e.legal !== void 0,
        selectedObjectID: e.obj !== void 0 && typeof e.obj == "string" ? e.obj : null,
        markers: e.markers !== void 0 && typeof e.markers == "string" ? Y8(e.markers) : []
    }
}
function J8() {
    const e = Wh.createRoot(document.getElementById("sidebar"))
      , t = Wh.createRoot(document.getElementById("about-modal"))
      , i = Wh.createRoot(document.getElementById("legal-modal"))
      , s = Wh.createRoot(document.getElementById("settings-modal"))
      , u = Wh.createRoot(document.getElementById("layers-modal"))
      , d = new F8(O8(),k);
    window.addEventListener("pagehide", L),
    window.addEventListener("popstate", () => {
        d.urlUpdate(Tx())
    }
    , !1),
    Ea.setRTLTextPlugin("https://unpkg.com/@mapbox/mapbox-gl-rtl-text@0.3.0/dist/mapbox-gl-rtl-text.js", !1);
    let f, o;
    localStorage["slippy.lat"] != null ? (f = [localStorage["slippy.lng"], localStorage["slippy.lat"]],
    o = Number(localStorage["slippy.zoom"])) : (f = [-100, 40],
    o = 2);
    const w = new y8(f,o,"map",d)
      , T = new I5(d);
    w.addControl(T),
    d.editMapHandler = () => {
        E5(w)
    }
    ,
    d.urlUpdate(Tx()),
    k(d._state, d._state),
    w.setTracks(d._state.tracks);
    function k(z, D) {
        if (Q8({
            aboutInfoOpen: z.aboutInfoOpen,
            legalOpen: z.legalOpen,
            selectedObjectID: z.info?.id ?? null,
            markers: z.markers
        }),
        D.mapStyle !== void 0 && (w.setStyle(z.mapStyle),
        localStorage.setItem("mapStyle", z.mapStyle)),
        D.mapStyleOverlay !== void 0 && (w.toggleSlopeTerrainOverlay(z.mapStyleOverlay === Vp.Slope),
        localStorage.setItem("mapStyleOverlay", z.mapStyleOverlay ? z.mapStyleOverlay : "null")),
        (D.sidebarOpen !== void 0 || D.mapStyle !== void 0) && e.render(G.jsx(qh, {
            children: G.jsx(L8, {
                eventBus: d,
                open: z.sidebarOpen,
                selectedMapStyle: z.mapStyle
            })
        })),
        D.aboutInfoOpen !== void 0 && t.render(G.jsx(qh, {
            children: G.jsx(P5, {
                eventBus: d,
                open: z.aboutInfoOpen
            })
        })),
        D.legalOpen !== void 0 && i.render(G.jsx(qh, {
            children: G.jsx(V5, {
                eventBus: d,
                open: z.legalOpen
            })
        })),
        (D.settingsOpen !== void 0 || D.unitSystem !== void 0) && s.render(G.jsx(qh, {
            children: G.jsx(v8, {
                eventBus: d,
                open: z.settingsOpen,
                unitSystem: z.unitSystem
            })
        })),
        (D.layersOpen !== void 0 || D.mapStyle !== void 0 || D.mapStyleOverlay !== void 0 || D.tracks !== void 0) && u.render(G.jsx(qh, {
            children: G.jsx($5, {
                eventBus: d,
                open: z.layersOpen,
                currentMapStyle: z.mapStyle,
                currentMapStyleOverlay: z.mapStyleOverlay,
                tracks: z.tracks
            })
        })),
        D.mapFiltersOpen !== void 0 && w.setFiltersVisible(D.mapFiltersOpen),
        D.info !== void 0 && (D.info === null && vM(null),
        w.setInfo(D.info)),
        D.mapFilters !== void 0 && w.setFilters(z.mapFilters),
        D.markers !== void 0 && w.setMarkers(D.markers),
        D.latestMarker !== void 0) {
            const N = D.latestMarker.coordinates;
            w.flyTo([N[0], N[1]])
        }
        D.unitSystem !== void 0 && SB(D.unitSystem),
        D.tracks !== void 0 && (localStorage.setItem("tracks", JSON.stringify(z.tracks)),
        w.setTracks(z.tracks))
    }
    function L() {
        localStorage.setItem("slippy.lat", w.getCenter().lat.toString()),
        localStorage.setItem("slippy.lng", w.getCenter().lng.toString()),
        localStorage.setItem("slippy.zoom", w.getZoom().toString())
    }
}
window.addEventListener("load", J8);
//# sourceMappingURL=index-DcDwj7pD.js.map
